<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>场景设计面试题 | 繁华流年间</title><meta name="author" content="周五打工人"><meta name="copyright" content="周五打工人"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号+姓名，而B文件存放学号+分数，要求生成文件C，存放姓名和分数。怎么实现？ hash(学号)%1000，A到a0….a1000,B到b0~b1000 学号相同的人一定hash到相同序号的小文件 加载序号相同的小文件（比如：读取a2和b2）用map储存再按姓名+分数写入C即可  秒杀系统怎么设计秒杀存在的问题 高并发、瞬间请求量极">
<meta property="og:type" content="article">
<meta property="og:title" content="场景设计面试题">
<meta property="og:url" content="http://flowtime.asia/2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="繁华流年间">
<meta property="og:description" content="有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号+姓名，而B文件存放学号+分数，要求生成文件C，存放姓名和分数。怎么实现？ hash(学号)%1000，A到a0….a1000,B到b0~b1000 学号相同的人一定hash到相同序号的小文件 加载序号相同的小文件（比如：读取a2和b2）用map储存再按姓名+分数写入C即可  秒杀系统怎么设计秒杀存在的问题 高并发、瞬间请求量极">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://flowtime.asia/img/haibian.png">
<meta property="article:published_time" content="2024-05-26T15:11:48.000Z">
<meta property="article:modified_time" content="2024-05-26T15:19:59.123Z">
<meta property="article:author" content="周五打工人">
<meta property="article:tag" content="场景设计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://flowtime.asia/img/haibian.png"><link rel="shortcut icon" href="/img/index.jpg"><link rel="canonical" href="http://flowtime.asia/2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-3578075519463317',
  enable_page_level_ads: 'true'
});</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '场景设计面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-26 23:19:59'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/transparent.css"><link rel="stylesheet" href="/css/footer.css"><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/nav.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/haibian.png')"><nav id="nav"><span id="blog-info"><a href="/" title="繁华流年间"></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">场景设计面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-05-26T15:11:48.000Z" title="发表于 2024-05-26 23:11:48">2024-05-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="场景设计面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号-姓名，而B文件存放学号-分数，要求生成文件C，存放姓名和分数。怎么实现？"><a href="#有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号-姓名，而B文件存放学号-分数，要求生成文件C，存放姓名和分数。怎么实现？" class="headerlink" title="有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号+姓名，而B文件存放学号+分数，要求生成文件C，存放姓名和分数。怎么实现？"></a>有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号+姓名，而B文件存放学号+分数，要求生成文件C，存放姓名和分数。怎么实现？</h2><ul>
<li>hash(学号)%1000，A到a0….a1000,B到b0~b1000</li>
<li>学号相同的人一定hash到相同序号的小文件</li>
<li>加载序号相同的小文件（比如：读取a2和b2）用map储存再按姓名+分数写入C即可</li>
</ul>
<h2 id="秒杀系统怎么设计"><a href="#秒杀系统怎么设计" class="headerlink" title="秒杀系统怎么设计"></a>秒杀系统怎么设计</h2><h3 id="秒杀存在的问题"><a href="#秒杀存在的问题" class="headerlink" title="秒杀存在的问题"></a>秒杀存在的问题</h3><ul>
<li>高并发、瞬间请求量极大</li>
<li>黄牛、黑客恶意请求</li>
<li>链接暴露问题</li>
<li>数据库压力问题</li>
<li>库存不足和超卖问题</li>
</ul>
<h3 id="如何解决这些问题"><a href="#如何解决这些问题" class="headerlink" title="如何解决这些问题"></a>如何解决这些问题</h3><ul>
<li>页面静态化<ul>
<li>秒杀活动的页面，大多数内容都是固定不变的，如商品名称，商品图片等等，可以对活动页面做静态化处理，减少访问服务端的请求。秒杀用户会分布在全国各地，有的在上海，有的在深圳，地域相差很远，网速也各不相同。为了让用户最快访问到活动页面，可以使用CDN（Content Delivery Network，内容分发网络）。CDN可以让用户就近获取所需内容。</li>
</ul>
</li>
<li>按钮至灰控制<ul>
<li>秒杀活动开始前，按钮一般需要置灰的。只有时间到了，才能变得可以点击。这是防止，秒杀用户在时间快到的前几秒，疯狂请求服务器，然后秒杀时间点还没到，服务器就自己挂了。</li>
</ul>
</li>
<li>服务单一职责<ul>
<li>我们都知道微服务设计思想，也就是把各个功能模块拆分，功能那个类似的放一起，再用分布式的部署方式。</li>
<li>如用户登录相关的，就设计个用户服务，订单相关的就搞个订单服务，再到礼物相关的就搞个礼物服务等等。那么，秒杀相关的业务逻辑也可以放到一起，搞个秒杀服务，单独给它搞个秒杀数据库。</li>
<li>服务单一职责有个好处：如果秒杀没抗住高并发的压力，秒杀库崩了，服务挂了，也不会影响到系统的其他服务。</li>
</ul>
</li>
<li>秒杀链接加盐<ul>
<li>链接如果明文暴露的话，会有人获取到请求Url，提前秒杀了。因此，需要给秒杀链接加盐。可以把URL动态化，如通过MD5加密算法加密随机的字符串去做url。</li>
</ul>
</li>
<li>限流<ul>
<li>一般有两种方式限流：nginx限流和redis限流。</li>
<li>为了防止某个用户请求过于频繁，我们可以对同一用户限流；</li>
<li>为了防止黄牛模拟几个用户请求，我们可以对某个IP进行限流；</li>
<li>为了防止有人使用代理，每次请求都更换IP请求，我们可以对接口进行限流。</li>
<li>为了防止瞬时过大的流量压垮系统，还可以使用阿里的Sentinel、Hystrix组件进行限流。</li>
</ul>
</li>
<li>分布式锁<ul>
<li>可以使用redis分布式锁解决超卖问题。</li>
<li>使用Redis的SET EX PX NX + 校验唯一随机值,再删除释放锁。</li>
<li>为了更严谨，一般也是用lua脚本代替。lua脚本如下：</li>
</ul>
</li>
<li>MQ异步处理<ul>
<li>如果瞬间流量特别大，可以使用消息队列削峰，异步处理。用户请求过来的时候，先放到消息队列，再拿出来消费。</li>
</ul>
</li>
<li>限流&amp;降级&amp;熔断<ul>
<li>限流，就是限制请求，防止过大的请求压垮服务器；</li>
<li>降级，就是秒杀服务有问题了，就降级处理，不要影响别的服务；</li>
<li>熔断，服务有问题就熔断，一般熔断降级是一起出现。</li>
</ul>
</li>
</ul>
<h2 id="产品上线出问题怎么定位错误"><a href="#产品上线出问题怎么定位错误" class="headerlink" title="产品上线出问题怎么定位错误"></a>产品上线出问题怎么定位错误</h2><ul>
<li>复现问题</li>
<li>top jstack</li>
</ul>
<h2 id="大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案"><a href="#大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案" class="headerlink" title="大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案"></a>大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案</h2><p>读写分离</p>
<h2 id="海量日志数据，提取出某日访问百度次数最多的那个IP。"><a href="#海量日志数据，提取出某日访问百度次数最多的那个IP。" class="headerlink" title="海量日志数据，提取出某日访问百度次数最多的那个IP。"></a>海量日志数据，提取出某日访问百度次数最多的那个IP。</h2><ul>
<li>可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址</li>
<li>对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址</li>
<li>可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；</li>
</ul>
<h2 id="给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？"><a href="#给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？" class="headerlink" title="给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？"></a>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</h2><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><ul>
<li>遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。</li>
<li>遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</li>
<li>求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</li>
</ul>
<h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p>如果允许有一定的误差，使用布隆过滤器</p>
<h2 id="一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash-x-1000分为小文件再分别加载小文件到内存中处理即可"><a href="#一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash-x-1000分为小文件再分别加载小文件到内存中处理即可" class="headerlink" title="一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash(x)%1000分为小文件再分别加载小文件到内存中处理即可"></a>一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash(x)%1000分为小文件再分别加载小文件到内存中处理即可</h2><h2 id="如何保证接口的幂等性"><a href="#如何保证接口的幂等性" class="headerlink" title="如何保证接口的幂等性"></a>如何保证接口的幂等性</h2><h3 id="什么是幂等性"><a href="#什么是幂等性" class="headerlink" title="什么是幂等性"></a>什么是幂等性</h3><p>幂等性是系统服务对外一种承诺，承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。</p>
<h3 id="什么情况下需要幂等"><a href="#什么情况下需要幂等" class="headerlink" title="什么情况下需要幂等"></a>什么情况下需要幂等</h3><p>以SQL为例：</p>
<ul>
<li>SELECT col1 FROM tab1 WHER col2&#x3D;2，无论执行多少次都不会改变状态，是天然的幂等。</li>
<li>UPDATE tab1 SET col1&#x3D;1 WHERE col2&#x3D;2，无论执行成功多少次状态都是一致的，因此也是幂等操作。</li>
<li>UPDATE tab1 SET col1&#x3D;col1+1 WHERE col2&#x3D;2，每次执行的结果都会发生变化，这种不是幂等的。</li>
<li>insert into user(userid,name) values(1,’a’) 如userid为唯一主键，即重复操作上面的业务，只会插入一条用户数据，具备幂等性。<ul>
<li>如userid不是主键，可以重复，那上面业务多次操作，数据都会新增多条，不具备幂等性。</li>
</ul>
</li>
<li>delete from user where userid&#x3D;1，多次操作，结果一样，具备幂等性</li>
</ul>
<h3 id="如何保证幂等"><a href="#如何保证幂等" class="headerlink" title="如何保证幂等"></a>如何保证幂等</h3><h4 id="1、token机制"><a href="#1、token机制" class="headerlink" title="1、token机制"></a>1、token机制</h4><ul>
<li>服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，服务器会把token保存到redis中。</li>
<li>然后调用业务接口请求时，把token携带过去，一般放在请求头部。</li>
<li>服务器判断token是否存在redis中，存在表示第一次请求，然后删除token,继续执行业务。</li>
<li>如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不被重复执行。</li>
</ul>
<p><strong>关键点 先删除token，还是后删除token。</strong></p>
<p>后删除token：如果进行业务处理成功后，删除redis中的token失败了，这样就导致了有可能会发生重复请求，因为token没有被删除。这个问题其实是数据库和缓存redis数据不一致问题，后续会写文章进行讲解。</p>
<p>先删除token：如果系统出现问题导致业务处理出现异常，业务处理没有成功，接口调用方也没有获取到明确的结果，然后进行重试，但token已经删除掉了，服务端判断token不存在，认为是重复请求，就直接返回了，无法进行业务处理了。</p>
<p>先删除token可以保证不会因为重复请求，业务数据出现问题。出现业务异常，可以让调用方配合处理一下，重新获取新的token，再次由业务调用方发起重试请求就ok了。</p>
<p><strong>token机制缺点</strong></p>
<p>业务请求每次请求，都会有额外的请求（一次获取token请求、判断token是否存在的业务）。其实真实的生产环境中，1万请求也许只会存在10个左右的请求会发生重试，为了这10个请求，我们让9990个请求都发生了额外的请求。</p>
<h4 id="2、乐观锁机制"><a href="#2、乐观锁机制" class="headerlink" title="2、乐观锁机制"></a>2、乐观锁机制</h4><ul>
<li>这种方法适合在更新的场景中，update t_goods set count &#x3D; count -1 , version &#x3D; version + 1 where good_id&#x3D;2 and version &#x3D; 1</li>
<li>根据version版本，也就是在操作库存前先获取当前商品的version版本号，然后操作的时候带上此version号。我们梳理下，我们第一次操作库存时，得到version为1，调用库存服务version变成了2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传如的version还是1，再执行上面的sql语句时，就不会执行；因为version已经变为2了，where条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。</li>
<li>乐观锁主要使用于处理读多写少的问题</li>
</ul>
<h4 id="3、唯一主键"><a href="#3、唯一主键" class="headerlink" title="3、唯一主键"></a>3、唯一主键</h4><p>这个机制是利用了数据库的主键唯一约束的特性，解决了在insert场景时幂等问题。但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。</p>
<p>如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关</p>
<h4 id="4、防重表"><a href="#4、防重表" class="headerlink" title="4、防重表"></a>4、防重表</h4><p>使用订单号orderNo做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。</p>
<h4 id="5、唯一ID"><a href="#5、唯一ID" class="headerlink" title="5、唯一ID"></a>5、唯一ID</h4><p>调用接口时，生成一个唯一id，redis将数据保存到集合中（去重），存在即处理过。</p>
<h2 id="缓存和数据库不一致问题"><a href="#缓存和数据库不一致问题" class="headerlink" title="缓存和数据库不一致问题"></a>缓存和数据库不一致问题</h2><h3 id="更新缓存和更新数据库"><a href="#更新缓存和更新数据库" class="headerlink" title="更新缓存和更新数据库"></a>更新缓存和更新数据库</h3><p>大部分观点认为，做缓存不应该是去更新缓存，而是应该删除缓存，然后由下个请求去去缓存，发现不存在后再读取数据库，写入缓存。观点引用：《分布式之数据库和缓存双写一致性方案解析》孤独烟</p>
<p>原因一：线程安全角度同时有请求A和请求B进行更新操作，那么会出现（1）线程A更新了数据库（2）线程B更新了数据库（3）线程B更新了缓存（4）线程A更新了缓存这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p>
<p>原因二：业务场景角度有如下两点：</p>
<ol>
<li>如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。</li>
<li>如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</li>
</ol>
<h3 id="删缓存和更新数据库"><a href="#删缓存和更新数据库" class="headerlink" title="删缓存和更新数据库"></a>删缓存和更新数据库</h3><h4 id="先删缓存，再更新数据库"><a href="#先删缓存，再更新数据库" class="headerlink" title="先删缓存，再更新数据库"></a>先删缓存，再更新数据库</h4><p>该方案会导致请求数据不一致同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p>
<ol>
<li>请求A进行写操作，删除缓存</li>
<li>请求B查询发现缓存不存在</li>
<li>请求B去数据库查询得到旧值</li>
<li>请求B将旧值写入缓存</li>
<li>请求A将新值写入数据库上述情况就会导致不一致的情形出现。<br>而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</li>
</ol>
<h4 id="先更新数据库，再删缓存"><a href="#先更新数据库，再删缓存" class="headerlink" title="先更新数据库，再删缓存"></a>先更新数据库，再删缓存</h4><p>这种情况不存在并发问题么？不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p>
<ol>
<li>缓存刚好失效</li>
<li>请求A查询数据库，得一个旧值</li>
<li>请求B将新值写入数据库</li>
<li>请求B删除缓存</li>
<li>请求A将查到的旧值写入缓存ok，如果发生上述情况，确实是会发生脏数据。 然而，发生这种情况的概率又有多少呢？发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。</li>
</ol>
<p>先更新数据库，再删缓存依然会有问题，不过，问题出现的可能性会因为上面说的原因，变得比较低！(补充说明：我用了“先更新数据库，再删缓存”且不设过期时间策略，会不会有问题呢？由于先缓存和更新数据库不是原子的，如果更新了数据库，程序歇逼，就没删缓存，由于没有过期策略，就永远脏数据了。)所以，如果你想实现基础的缓存数据库双写一致的逻辑，那么在大多数情况下，在不想做过多设计，增加太大工作量的情况下，请先更新数据库，再删缓存!</p>
<h3 id="数据库和缓存数据强一致怎么办"><a href="#数据库和缓存数据强一致怎么办" class="headerlink" title="数据库和缓存数据强一致怎么办"></a>数据库和缓存数据强一致怎么办</h3><p>没有办法做到绝对的一致性，这是由CAP理论决定的，缓存系统适用的场景就是非强一致性的场景，所以它属于CAP中的AP。所以，我们得委曲求全，可以去做到BASE理论中说的最终一致性。</p>
<p>大佬们给出了到达最终一致性的解决思路，主要是针对上面两种双写策略（先删缓存，再更新数据库&#x2F;先更新数据库，再删缓存）导致的脏数据问题，进行相应的处理，来保证最终一致性。</p>
<h4 id="缓存延时双删"><a href="#缓存延时双删" class="headerlink" title="缓存延时双删"></a>缓存延时双删</h4><p>步骤</p>
<ol>
<li>先删除缓存</li>
<li>再写数据库</li>
<li>休眠500毫秒（根据具体的业务时间来定）</li>
<li>再次删除缓存。</li>
</ol>
<h4 id="那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？"><a href="#那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？" class="headerlink" title="那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？"></a>那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？</h4><p>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
<h4 id="如果你用了mysql的读写分离架构怎么办？"><a href="#如果你用了mysql的读写分离架构怎么办？" class="headerlink" title="如果你用了mysql的读写分离架构怎么办？"></a>如果你用了mysql的读写分离架构怎么办？</h4><p>ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。</p>
<ol>
<li>请求A进行写操作，删除缓存</li>
<li>请求A将数据写入数据库了，</li>
<li>请求B查询缓存发现，缓存没有值</li>
<li>请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</li>
<li>请求B将旧值写入缓存</li>
<li>数据库完成主从同步，从库变为新值上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。</li>
</ol>
<h4 id="采用这种同步淘汰策略，吞吐量降低怎么办？"><a href="#采用这种同步淘汰策略，吞吐量降低怎么办？" class="headerlink" title="采用这种同步淘汰策略，吞吐量降低怎么办？"></a>采用这种同步淘汰策略，吞吐量降低怎么办？</h4><p>ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。</p>
<h4 id="删缓存失败了怎么办：重试机制"><a href="#删缓存失败了怎么办：重试机制" class="headerlink" title="删缓存失败了怎么办：重试机制"></a>删缓存失败了怎么办：重试机制</h4><p>看似问题都已经解决了，但其实，还有一个问题没有考虑到，那就是删除缓存的操作，失败了怎么办？比如延时双删的时候，第二次缓存删除失败了，那不还是没有清除脏数据吗？解决方案就是再加上一个重试机制，保证删除缓存成功</p>
<p>流程如下所示</p>
<ol>
<li>更新数据库数据；</li>
<li>缓存因为种种问题删除失败</li>
<li>将需要删除的key发送至消息队列</li>
<li>自己消费消息，获得需要删除的key</li>
<li>继续重试删除操作，直到成功然而，</li>
</ol>
<p>该方案有一个缺点，对业务线代码造成大量的侵入。</p>
<p>于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作</p>
<h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p>流程如下所示</p>
<ol>
<li>更新数据库数据</li>
<li>数据库会将操作信息写入binlog日志当中</li>
<li>订阅程序提取出所需要的数据以及key</li>
<li>另起一段非业务代码，获得该信息</li>
<li>尝试删除缓存操作，发现删除失败</li>
<li>将这些信息发送至消息队列</li>
<li>重新从消息队列中获得该数据，重试操作。</li>
</ol>
<h2 id="什么是SPI"><a href="#什么是SPI" class="headerlink" title="什么是SPI"></a>什么是SPI</h2><p>SPI 全称为 (Service Provider Interface) ，是JDK内置的一种服务提供发现机制</p>
<h3 id="SPI-实践"><a href="#SPI-实践" class="headerlink" title="SPI 实践"></a>SPI 实践</h3><p>接下来我们来如何来利用 SPI 实现刚才提到的可拔插 IOC 容器。</p>
<p>既然刚才都提到了 SPI 的本质就是面向接口编程，所以自然我们首先需要定义一个接口：</p>
<p><img src="/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/1.png" alt="SPI图"></p>
<p>其中包含了一些 Bean 容器所必须的操作：注册、获取、释放 bean。</p>
<p>为了让其他人也能实现自己的 IOC 容器，所以我们将这个接口单独放到一个 Module 中，可供他人引入实现。</p>
<p><img src="/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/2.png"></p>
<p>所以当我要实现一个单例的 IOC 容器时，我只需要新建一个 Module 然后引入刚才的模块并实现 CicadaBeanFactory 接口即可。</p>
<p>当然其中最重要的则是需要在 resources 目录下新建一个 META-INF&#x2F;services&#x2F;top.crossoverjie.cicada.base.bean.CicadaBeanFactory 文件，文件名必须得是我们之前定义接口的全限定名（SPI 规范）。<br><img src="/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/3.png"></p>
<p>其中的内容便是我们自己实现类的全限定名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top.crossoverjie.cicada.bean.ioc.CicadaIoc</span><br></pre></td></tr></table></figure>
<p>可以想象最终会通过这里的全限定名来反射创建对象。</p>
<p>只不过这个过程 Java 已经提供 API 屏蔽掉了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CicadaBeanFactory <span class="title function_">getCicadaBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    ServiceLoader&lt;CicadaBeanFactory&gt; cicadaBeanFactories = ServiceLoader.load(CicadaBeanFactory.class);</span><br><span class="line">    <span class="keyword">if</span> (cicadaBeanFactories.iterator().hasNext())&#123;</span><br><span class="line">        <span class="keyword">return</span> cicadaBeanFactories.iterator().next() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CicadaDefaultBean</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 classpath 中存在我们刚才的实现类（引入实现类的 jar 包），便可以通过 java.util.ServiceLoader 工具类来找到所有的实现类（可以有多个实现类同时存在，只不过通常我们只需要一个）。</p>
<p>一些都准备好之后，使用自然就非常简单了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.crossoverjie.opensource<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cicada-ioc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们只需要引入这个依赖便能使用它的实现，当我们想换一种实现方式时只需要更换一个依赖即可。</p>
<p>这样就做到了不修改一行代码灵活的可拔插选择 IOC 容器了。</p>
<p>SPI 的一些其他应用</p>
<p>MySQL 的驱动包也是利用 SPI 来实现自己的连接逻辑。</p>
<p><img src="/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/4.png"></p>
<p>总结来说：</p>
<ul>
<li>提供一个接口</li>
<li>在resource下新建META-INF&#x2F;services目录，在目录下新建接口的全限定名文件</li>
<li>服务方实现接口</li>
<li>调用ServiceLoad.load()</li>
</ul>
<h2 id="什么是RPC？"><a href="#什么是RPC？" class="headerlink" title="什么是RPC？"></a>什么是RPC？</h2><p>RPC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务</p>
<ol>
<li>首先客户端需要告诉服务器，需要调用的函数，这里函数和进程ID存在一个映射，客户端远程调用时，需要查一下函数，找到对应的ID，然后执行函数的代码。</li>
<li>客户端需要把本地参数传给远程函数，本地调用的过程中，直接压栈即可，但是在远程调用过程中不再同一个内存里，无法直接传递函数的参数，因此需要客户端把参数转换成字节流，传给服务端，然后服务端将字节流转换成自身能读取的格式，是一个序列化和反序列化的过程。</li>
<li>数据准备好了之后，如何进行传输？网络传输层需要把调用的ID和序列化后的参数传给服务端，然后把计算好的结果序列化传给客户端，因此TCP层即可完成上述过程，gRPC中采用的是HTTP2协议。</li>
</ol>
<p>总结一下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// Client端 </span><br><span class="line">//    Student student = Call(ServerAddr, addAge, student)</span><br><span class="line">1. 将这个调用映射为Call ID。</span><br><span class="line">2. 将Call ID，student（params）序列化，以二进制形式打包</span><br><span class="line">3. 把2中得到的数据包发送给ServerAddr，这需要使用网络传输层</span><br><span class="line">4. 等待服务器返回结果</span><br><span class="line">5. 如果服务器调用成功，那么就将结果反序列化，并赋给student，年龄更新</span><br><span class="line"></span><br><span class="line">// Server端</span><br><span class="line">1. 在本地维护一个Call ID到函数指针的映射call_id_map，可以用Map&lt;String, Method&gt; callIdMap</span><br><span class="line">2. 等待客户端请求</span><br><span class="line">3. 得到一个请求后，将其数据包反序列化，得到Call ID</span><br><span class="line">4. 通过在callIdMap中查找，得到相应的函数指针</span><br><span class="line">5. 将student（params）反序列化后，在本地调用addAge()函数，得到结果</span><br><span class="line">6. 将student结果序列化后通过网络返回给Client</span><br></pre></td></tr></table></figure>

<ul>
<li>在微服务的设计中，一个服务A如果访问另一个Module下的服务B，可以采用HTTP REST传输数据，并在两个服务之间进行序列化和反序列化操作，服务B把执行结果返回过来。</li>
<li>由于HTTP在应用层中完成，整个通信的代价较高，远程过程调用中直接基于TCP进行远程调用，数据传输在传输层TCP层完成，更适合对效率要求比较高的场景，RPC主要依赖于客户端和服务端之间建立Socket链接进行，底层实现比REST更复杂。</li>
</ul>
<h3 id="RPC-demo"><a href="#RPC-demo" class="headerlink" title="RPC demo"></a>RPC demo</h3><p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RPCClient</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getRemoteProxyObj</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; serviceInterface, <span class="keyword">final</span> InetSocketAddress addr)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.将本地的接口调用转换成JDK的动态代理，在动态代理中实现接口的远程调用</span></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(serviceInterface.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;serviceInterface&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                        <span class="type">ObjectOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                        <span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="comment">// 2.创建Socket客户端，根据指定地址连接远程服务提供者</span></span><br><span class="line">                            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>();</span><br><span class="line">                            socket.connect(addr);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 3.将远程服务调用所需的接口类、方法名、参数列表等编码后发送给服务提供者</span></span><br><span class="line">                            output = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(socket.getOutputStream());</span><br><span class="line">                            output.writeUTF(serviceInterface.getName());</span><br><span class="line">                            output.writeUTF(method.getName());</span><br><span class="line">                            output.writeObject(method.getParameterTypes());</span><br><span class="line">                            output.writeObject(args);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 4.同步阻塞等待服务器返回应答，获取应答后返回</span></span><br><span class="line">                            input = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(socket.getInputStream());</span><br><span class="line">                            <span class="keyword">return</span> input.readObject();</span><br><span class="line">                        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (socket != <span class="literal">null</span>)&#123;</span><br><span class="line">                                socket.close();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (output != <span class="literal">null</span>)&#123;</span><br><span class="line">                                output.close();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (input != <span class="literal">null</span>)&#123;</span><br><span class="line">                                input.close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceCenter</span> <span class="keyword">implements</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, Class&gt; serviceRegistry = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Class&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceCenter</span><span class="params">(<span class="type">int</span> port)</span>&#123;</span><br><span class="line">        ServiceCenter.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>();</span><br><span class="line">        server.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));</span><br><span class="line">        System.out.println(<span class="string">&quot;Server Start .....&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                executor.execute(<span class="keyword">new</span> <span class="title class_">ServiceTask</span>(server.accept()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            server.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class serviceInterface, Class impl)</span> &#123;</span><br><span class="line">        serviceRegistry.put(serviceInterface.getName(), impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isRunning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        isRunning = <span class="literal">false</span>;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ServiceTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ServiceTask</span><span class="params">(Socket client)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.client = client;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                input = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(client.getInputStream());</span><br><span class="line">                <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> input.readUTF();</span><br><span class="line">                <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> input.readUTF();</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[]) input.readObject();</span><br><span class="line">                Object[] arguments = (Object[]) input.readObject();</span><br><span class="line">                <span class="type">Class</span> <span class="variable">serviceClass</span> <span class="operator">=</span> serviceRegistry.get(serviceName);</span><br><span class="line">                <span class="keyword">if</span>(serviceClass == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(serviceName + <span class="string">&quot;not found!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> serviceClass.getMethod(methodName, parameterTypes);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(serviceClass.newInstance(), arguments);</span><br><span class="line"></span><br><span class="line">                output = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(client.getOutputStream());</span><br><span class="line">                output.writeObject(result);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(output!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        output.close();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (input != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        input.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (client != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        client.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceProducerImpl</span> <span class="keyword">implements</span> <span class="title class_">ServiceProducer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendData</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I am service producer!!!, the data is &quot;</span>+ data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RPCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Server</span> <span class="variable">serviceServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceCenter</span>(<span class="number">8088</span>);</span><br><span class="line">                    serviceServer.register(ServiceProducer.class, ServiceProducerImpl.class);</span><br><span class="line">                    serviceServer.start();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="type">ServiceProducer</span> <span class="variable">service</span> <span class="operator">=</span> RPCClient.getRemoteProxyObj(ServiceProducer.class, <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8088</span>));</span><br><span class="line">        System.out.println(service.sendData(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><h3 id="gRPC与REST"><a href="#gRPC与REST" class="headerlink" title="gRPC与REST"></a>gRPC与REST</h3><ul>
<li>REST通常以业务为导向，将业务对象上执行的操作映射到HTTP动词，格式非常简单，可以使用浏览器进行扩展和传输，通过JSON数据完成客户端和服务端之间的消息通信，直接支持请求&#x2F;响应方式的通信。不需要中间的代理，简化了系统的架构，不同系统之间只需要对JSON进行解析和序列化即可完成数据的传递。</li>
<li>但是REST也存在一些弊端，比如只支持请求&#x2F;响应这种单一的通信方式，对象和字符串之间的序列化操作也会影响消息传递速度，客户端需要通过服务发现的方式，知道服务实例的位置，在单个请求获取多个资源时存在着挑战，而且有时候很难将所有的动作都映射到HTTP动词。</li>
<li>正是因为REST面临一些问题，因此可以采用gRPC作为一种替代方案，gRPC 是一种基于二进制流的消息协议，可以采用基于Protocol Buffer的IDL定义grpc API,这是Google公司用于序列化结构化数据提供的一套语言中立的序列化机制，客户端和服务端使用HTTP&#x2F;2以Protocol Buffer格式交换二进制消息。</li>
<li>gRPC的优势是，设计复杂更新操作的API非常简单，具有高效紧凑的进程通信机制，在交换大量消息时效率高，远程过程调用和消息传递时可以采用双向的流式消息方式，同时客户端和服务端支持多种语言编写，互操作性强；不过gRPC的缺点是不方便与JavaScript集成，某些防火墙不支持该协议。</li>
<li>注册中心：当项目中有很多服务时，可以把所有的服务在启动的时候注册到一个注册中心里面，用于维护服务和服务器之间的列表，当注册中心接收到客户端请求时，去找到该服务是否远程可以调用，如果可以调用需要提供服务地址返回给客户端，客户端根据返回的地址和端口，去调用远程服务端的方法，执行完成之后将结果返回给客户端。这样在服务端加新功能的时候，客户端不需要直接感知服务端的方法，服务端将更新之后的结果在注册中心注册即可，而且当修改了服务端某些方法的时候，或者服务降级服务多机部署想实现负载均衡的时候，我们只需要更新注册中心的服务群即可。<br><img src="/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/5.png"></li>
</ul>
<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>这里使用SpringBoot+gRPC的形式实现RPC调用过程 项目结构分为三部分：client、grpc、server</p>
<h4 id="grpc"><a href="#grpc" class="headerlink" title="grpc"></a>grpc</h4><p><img src="/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/6.png"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>kr.motd.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>os-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">pluginId</span>&gt;</span>grpc-java<span class="tag">&lt;/<span class="name">pluginId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.0.2:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">protocArtifact</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:1.2.0:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">pluginArtifact</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile-custom<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建.proto文件</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;   <span class="comment">// 语法版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// stub选项</span></span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.shgx.grpc.api&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;RPCDateServiceApi&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_multiple_files = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义包名</span></span><br><span class="line"><span class="keyword">package</span> com.shgx.grpc.api;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务接口定义，服务端和客户端都要遵守该接口进行通信</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">RPCDateService</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> getDate (RPCDateRequest) <span class="keyword">returns</span> (RPCDateResponse) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义消息（请求）</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">RPCDateRequest</span> &#123;</span><br><span class="line">    <span class="type">string</span> userName = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义消息（响应）</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">RPCDateResponse</span> &#123;</span><br><span class="line">    <span class="type">string</span> serverDate = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>mvn complie</p>
<p>生成代码：<br><img src="/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/7.png"></p>
<h4 id="client"><a href="#client" class="headerlink" title="client"></a>client</h4><p><img src="/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/8.png"></p>
<p>根据gRPC中的项目配置在client和server两个Module的pom.xml添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.shgx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写GRPCClient</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GRPCClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">serverPort</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ManagedChannel</span> <span class="variable">managedChannel</span> <span class="operator">=</span> ManagedChannelBuilder.forAddress( host, serverPort ).usePlaintext().build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RPCDateServiceGrpc.<span class="type">RPCDateServiceBlockingStub</span> <span class="variable">rpcDateService</span> <span class="operator">=</span> RPCDateServiceGrpc.newBlockingStub( managedChannel );</span><br><span class="line">            <span class="type">RPCDateRequest</span> <span class="variable">rpcDateRequest</span> <span class="operator">=</span> RPCDateRequest</span><br><span class="line">                    .newBuilder()</span><br><span class="line">                    .setUserName(<span class="string">&quot;shgx&quot;</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="type">RPCDateResponse</span> <span class="variable">rpcDateResponse</span> <span class="operator">=</span> rpcDateService.getDate( rpcDateRequest );</span><br><span class="line">            System.out.println( rpcDateResponse.getServerDate() );</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            managedChannel.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><p><img src="/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/9.png"></p>
<p>按照2.2.3 client的方式添加依赖</p>
<p>创建RPCDateServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RPCDateServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">RPCDateServiceGrpc</span>.RPCDateServiceImplBase&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDate</span><span class="params">(RPCDateRequest request, StreamObserver&lt;RPCDateResponse&gt; responseObserver)</span> &#123;</span><br><span class="line">        <span class="type">RPCDateResponse</span> <span class="variable">rpcDateResponse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        Date now=<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;今天是&quot;</span>+<span class="string">&quot;yyyy年MM月dd日 E kk点mm分&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">nowTime</span> <span class="operator">=</span> simpleDateFormat.format( now );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rpcDateResponse = RPCDateResponse</span><br><span class="line">                    .newBuilder()</span><br><span class="line">                    .setServerDate( <span class="string">&quot;Welcome &quot;</span> + request.getUserName()  + <span class="string">&quot;, &quot;</span> + nowTime )</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            responseObserver.onError(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            responseObserver.onNext( rpcDateResponse );</span><br><span class="line">        &#125;</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建GRPCServer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GRPCServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> ServerBuilder.</span><br><span class="line">                forPort(port)</span><br><span class="line">                .addService( <span class="keyword">new</span> <span class="title class_">RPCDateServiceImpl</span>() )</span><br><span class="line">                .build().start();</span><br><span class="line">        System.out.println( <span class="string">&quot;grpc服务端启动成功, 端口=&quot;</span> + port );</span><br><span class="line">        server.awaitTermination();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一个优秀的RPC框架需要考虑的问题"><a href="#一个优秀的RPC框架需要考虑的问题" class="headerlink" title="一个优秀的RPC框架需要考虑的问题"></a>一个优秀的RPC框架需要考虑的问题</h2><ol>
<li><code>微服务化</code>应用都基于微服务化，实现资源调用离不开远程调用</li>
<li><code>多实例问题</code> 一个服务可能有多个实例，你在调用时，要如何获取这些实例的地址呢？— 这时候就需要一个服务注册中心，从服务注册中心获取服务的实例列表，再从中选择一个进行调用。</li>
<li><code>负载均衡</code> 选哪个调用好呢？这时候就需要负载均衡了，于是又得考虑如何实现复杂均衡</li>
<li><code>缓存</code> 总不能每次调用时都去注册中心查询实例列表吧，这样效率多低呀，于是又有了缓存，有了缓存，就要考虑缓存的更新问题</li>
<li><code>异步调用</code> 客户端总不能每次调用完都干等着服务端返回数据吧,于是就要支持异步调用;<ul>
<li>Future实现</li>
</ul>
</li>
<li><code>版本控制</code> 服务端的接口修改了，老的接口还有人在用，怎么办？总不能让他们都改了吧？这就需要版本控制了；</li>
<li><code>线程池</code> 服务端总不能每次接到请求都马上启动一个线程去处理吧？于是就需要线程池；</li>
<li><code>未处理完的请求</code> 服务端关闭时，还没处理完的请求怎么办？是直接结束呢，还是等全部请求处理完再关闭呢？</li>
</ol>
<h2 id="什么是DDD？"><a href="#什么是DDD？" class="headerlink" title="什么是DDD？"></a>什么是DDD？</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>要说DDD，不得不先看看MVC，我相信基本上99%的java开发读者，不管你是计科专业出身还是跨专业，初学spring或者springboot的时候，接触到的代码分层都是MVC<br>这说明了MVC有它自身独有的优势：</p>
<ul>
<li>开发人员可以只关注整个结构中的其中某一层；</li>
<li>可以很容易的用新的实现来替换原有层次的实现；</li>
<li>可以降低层与层之间的依赖；</li>
<li>有利于标准化；</li>
<li>利于各层逻辑的复用。</li>
</ul>
<p>但是真实情况是这样吗？随着你系统功能迭代，业务逻辑越来越复杂之后。MVC三层中，V层作为数据载体，C层作为逻辑路由都是很薄的一层，大量的代码都堆积在了M层（模型层）。一个service的类，动辄几百上千行，大的甚至几万行，逻辑嵌套复杂，主业务逻辑不清晰。service做的稍微轻量化一点的，代码就像是胶水，把数据库执行逻辑与控制返回给前端的逻辑胶在一起，主次不清晰。<br>一看你的工程，类啊，代码量啊都不少，你甚至不知道如何入手去修改“屎山”一样的代码。</p>
<h3 id="那么DDD为什么可以去解决以上的问题呢？"><a href="#那么DDD为什么可以去解决以上的问题呢？" class="headerlink" title="那么DDD为什么可以去解决以上的问题呢？"></a>那么DDD为什么可以去解决以上的问题呢？</h3><p>DDD核心思想是什么呢？解耦！让业务不是像炒大锅饭一样混在一起，而是一道道工序复杂的美食，都有他们自己独立的做法。</p>
<p>DDD的价值观里面，任何业务都是某个业务领域模型的职责体现。A领域只会去做A领域的事情，A领域想去修改B领域，需要找中介（防腐层）去对B领域完成操作。我想完成一个很长的业务逻辑动作，在划分好业务边界之后，交给业务服务的编排者（应用服务）去组织业务模型（聚合）完成逻辑。</p>
<p>这样，每个服务（领域）只会做自己业务边界内的事情，最小细粒度的去定义需求的实现。原先空空的贫血模型摇身一变变成了充血模型。原理冗长的service里面类似到处set，get值这种与业务逻辑无关的数据载体包装代码，都会被去除，进到应用服务层，你的代码就是你的业务逻辑。逻辑清晰，可维护性高！</p>
<h3 id="什么样的系统适配DDD"><a href="#什么样的系统适配DDD" class="headerlink" title="什么样的系统适配DDD"></a>什么样的系统适配DDD</h3><p>中小规模的系统，本身业务体量小，功能单一，选择mvc架构无疑是最好的。 项目化交付的系统，研发周期短，一天到晚按照甲方的需求定制功能。</p>
<p>中大规模系统，产品化模式，业务可持续迭代，可预见的业务逻辑复杂性的系统。</p>
<h3 id="DDD的代码怎么做"><a href="#DDD的代码怎么做" class="headerlink" title="DDD的代码怎么做"></a>DDD的代码怎么做</h3><p>&#x2F;&#x2F; TODO</p>
<h2 id="Java实现生产者消费者"><a href="#Java实现生产者消费者" class="headerlink" title="Java实现生产者消费者"></a>Java实现生产者消费者</h2><h3 id="wait-和notify-方法的实现"><a href="#wait-和notify-方法的实现" class="headerlink" title="wait()和notify()方法的实现"></a>wait()和notify()方法的实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">FULL</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="string">&quot;lock&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test1</span> <span class="variable">test1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test1.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test1.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test1.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test1.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test1.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test1.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test1.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test1.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count == FULL) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            LOCK.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class="line">                    LOCK.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            LOCK.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class="line">                    LOCK.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可重入锁ReentrantLock的实现"><a href="#可重入锁ReentrantLock的实现" class="headerlink" title="可重入锁ReentrantLock的实现"></a>可重入锁ReentrantLock的实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">FULL</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//创建一个锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//创建两个条件变量，一个为缓冲区非满，一个为缓冲区非空</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test2</span> <span class="variable">test2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test2.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test2.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test2.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test2.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test2.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test2.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test2.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test2.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取锁</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count == FULL) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            notFull.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class="line">                    <span class="comment">//唤醒消费者</span></span><br><span class="line">                    notEmpty.signal();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放锁</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            notEmpty.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class="line">                    notFull.signal();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="阻塞队列BlockingQueue的实现"><a href="#阻塞队列BlockingQueue的实现" class="headerlink" title="阻塞队列BlockingQueue的实现"></a>阻塞队列BlockingQueue的实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//创建一个阻塞队列</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">BlockingQueue</span> <span class="variable">blockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test3</span> <span class="variable">test3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test3</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test3.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test3.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test3.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test3.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test3.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test3.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test3.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test3.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    blockingQueue.put(<span class="number">1</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    blockingQueue.take();</span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="信号量Semaphore的实现"><a href="#信号量Semaphore的实现" class="headerlink" title="信号量Semaphore的实现"></a>信号量Semaphore的实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//创建三个信号量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">notFull</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">notEmpty</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test4</span> <span class="variable">test4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test4</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test4.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test4.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test4.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test4.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test4.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test4.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test4.<span class="keyword">new</span> <span class="title class_">Producer</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test4.<span class="keyword">new</span> <span class="title class_">Consumer</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    notFull.acquire();</span><br><span class="line">                    mutex.acquire();</span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mutex.release();</span><br><span class="line">                    notEmpty.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    notEmpty.acquire();</span><br><span class="line">                    mutex.acquire();</span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mutex.release();</span><br><span class="line">                    notFull.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Java实现BlockQueue"><a href="#Java实现BlockQueue" class="headerlink" title="Java实现BlockQueue"></a>Java实现BlockQueue</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueue</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有界队列内部固定长度，因此可以用数组实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列的头和尾下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列目前的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elements = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (size == elements.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            elements[tail] = e;</span><br><span class="line">            <span class="keyword">if</span> (++tail == elements.length) &#123;</span><br><span class="line">                tail = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            size++;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            e = (E) elements[head];</span><br><span class="line">            elements[head] = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (++head == elements.length)</span><br><span class="line">                head = <span class="number">0</span>;</span><br><span class="line">            size--;</span><br><span class="line">            notFull.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解决哈希冲突的方法"><a href="#解决哈希冲突的方法" class="headerlink" title="解决哈希冲突的方法"></a>解决哈希冲突的方法</h2><h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><p>从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。</p>
<p>在开放定址法中解决冲突的方法有：线行探查法、平方探查法、双散列函数探查法。</p>
<p>开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。</p>
<h4 id="线行探查法"><a href="#线行探查法" class="headerlink" title="线行探查法"></a>线行探查法</h4><p>线行探查法是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。</p>
<p>可以参考csdn上flash对该方法的演示：<br><a target="_blank" rel="noopener" href="http://student.zjzk.cn/course_ware/data_structure/web/flash/cz/kfdzh.swf">http://student.zjzk.cn/course_ware/data_structure/web/flash/cz/kfdzh.swf</a></p>
<h4 id="平方探查法"><a href="#平方探查法" class="headerlink" title="平方探查法"></a>平方探查法</h4><p>平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²…直到找到空闲单元。</p>
<p>在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。</p>
<h4 id="双散列函数探查法"><a href="#双散列函数探查法" class="headerlink" title="双散列函数探查法"></a>双散列函数探查法</h4><p>这种方法使用两个散列函数hl和h2。其中hl和前面的h一样，以关键字为自变量，产生一个0至m—l之间的数作为散列地址；h2也以关键字为自变量，产生一个l至m—1之间的、并和m互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)，探查序列的步长值是固定值l；对于平方探查法，探查序列的步长值是探查次数i的两倍减l；对于双散列函数探查法，其探查序列的步长值是同一关键字的另一散列函数的值。</p>
<h3 id="链地址法（拉链法）"><a href="#链地址法（拉链法）" class="headerlink" title="链地址法（拉链法）"></a>链地址法（拉链法）</h3><p>链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。</p>
<p>如下一组数字,(32、40、36、53、16、46、71、27、42、24、49、64)哈希表长度为13，哈希函数为H(key)&#x3D;key%13,则链表法结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>       </span><br><span class="line"><span class="number">1</span>  -&gt; <span class="number">40</span> -&gt; <span class="number">27</span> -&gt; <span class="number">53</span> </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span>  -&gt; <span class="number">16</span> -&gt; <span class="number">42</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span>  -&gt; <span class="number">32</span> -&gt; <span class="number">71</span></span><br><span class="line"><span class="number">7</span>  -&gt; <span class="number">46</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> -&gt; <span class="number">36</span> -&gt; <span class="number">49</span></span><br><span class="line"><span class="number">11</span> -&gt; <span class="number">24</span></span><br><span class="line"><span class="number">12</span> -&gt; <span class="number">64</span></span><br></pre></td></tr></table></figure>
<p>注：在java中，链接地址法也是HashMap解决哈希冲突的方法之一，jdk1.7完全采用单链表来存储同义词，jdk1.8则采用了一种混合模式，对于链表长度大于8的，会转换为红黑树存储。</p>
<h3 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h3><p>就是同时构造多个不同的哈希函数：</p>
<p>Hi &#x3D; RHi(key)   i&#x3D; 1,2,3 … k;</p>
<p>当H1 &#x3D; RH1(key)  发生冲突时，再用H2 &#x3D; RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。</p>
<h3 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h3><p>将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>
<h2 id="排行榜设计"><a href="#排行榜设计" class="headerlink" title="排行榜设计"></a>排行榜设计</h2><h3 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a>基于数据库</h3><p>基于MySQL，order by</p>
<p>缺点：</p>
<ul>
<li>速度慢</li>
</ul>
<h3 id="基于Redis"><a href="#基于Redis" class="headerlink" title="基于Redis"></a>基于Redis</h3><p>主要考察sort set 也就是zset</p>
<p>zadd添加数据后，zrevrange获取排序后的排名</p>
<h3 id="类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样"><a href="#类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样" class="headerlink" title="类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样"></a>类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样</h3><p>key的设计比较重要，比如aa用户和bb用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zadd step:aa 1000 小明</span><br><span class="line">zadd step:bb 1000 小明</span><br></pre></td></tr></table></figure>

<p>同理时间也可以通过key的设计解决</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zadd step:aa:20210929 1000 小明</span><br><span class="line">zadd step:aa:20210929 1000 小明</span><br></pre></td></tr></table></figure>

<p>但是上述设计会导致每个用户都有一个排行榜，存储的数据巨大，其实可以考虑只在用户查询时通过好友关系去生成</p>
<p>那朋友圈排行榜的：微信头像、点赞数 怎么获取呢</p>
<ul>
<li>可以使用hmset hash储存对象，需要时通过zset储存的key去查询即可</li>
</ul>
<h3 id="最近七天排行榜怎么弄"><a href="#最近七天排行榜怎么弄" class="headerlink" title="最近七天排行榜怎么弄"></a>最近七天排行榜怎么弄</h3><p>前面我们说的都是每日排行榜。</p>
<p>假设面试官要求我们提供一个最近七天、上一周、上一月、上个季度、这一年排行榜啥的，又该怎么搞呢？</p>
<p>其实这还是在考察你对于 Redis 有序集合 API 的掌握程度。</p>
<p>也就是这个 API：</p>
<ul>
<li>zinterstore&#x2F;zunionstore destination numkeys key [key …] [weights weight [weight …]] [aggregate sum|min|max] 获取交集&#x2F;并集<ul>
<li>zinterstore&#x2F;zunionstore其实就是交集&#x2F;并集</li>
<li>destination 将交集&#x2F;并集的结果保存到这个键中</li>
<li>numkeys 需要做交集&#x2F;并集的集合的个数</li>
<li>key [key …] 具体参与交集&#x2F;并集的集合</li>
<li>weights weight [weight …] 每个参与计算的集合的权重。在做交集&#x2F;并集计算时，每个集合中的 member 会把自己的 score 乘以这个权重，默认为 1。</li>
<li>aggregate sum|min|max 对于各个集合中的相同元素是 sum(求和)、min(取最小值)还是max(取最大值)，默认为 sum。</li>
</ul>
</li>
</ul>
<p>比如现在有一些数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zadd sport:ranking:why:20210222 43243 why 2341 mx 8764 les 42321 skr</span><br><span class="line">zadd sport:ranking:why:20210223 57632 why 24354 mx 4231 les 43512 skr 5341 jay</span><br><span class="line">zadd sport:ranking:why:20210224 10026 why 12344 mx 54312 les 34531 skr 43512 jay</span><br><span class="line">zadd sport:ranking:why:20210225 54312 why 32451 mx 23412 les 21341 skr 56321 jay</span><br><span class="line">zadd sport:ranking:why:20210226 3212 why 63421 mx 53652 les 45621 skr 5723 jay</span><br><span class="line">zadd sport:ranking:why:20210227 5462 why 10158 mx 30169 les 48858 skr 66079 jay</span><br><span class="line">zadd sport:ranking:why:20210228 43553 why 4451 mx 7431 les 9563 skr 8232 jay</span><br></pre></td></tr></table></figure>
<p><img src="/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/10.png"></p>
<p>现在我们要求出最近 7 天的排行榜，就用下面这行命令，命令有点复杂，但是对着命令格式看，还是很清晰的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zunionstore sport:ranking:why:last_seven_day 7 sport:ranking:why:20210222 sport:ranking:why:20210223 sport:ranking:why:20210224 sport:ranking:why:20210225 sport:ranking:why:20210226 sport:ranking:why:20210227 sport:ranking:why:20210228 weights 1 1 1 1 1 1 1 aggregate sum</span><br></pre></td></tr></table></figure>
<p><img src="/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/11.png"></p>
<p>上面用的是并集，如果我们的要求是对最近 7 天，每天都上传运动数据的人进行排序，就用交集来算。</p>
<p>命令和上面的一致，只是把 zunionstore 修改为 zinterstore 即可。</p>
<p>另外为了有对比，合并之后的队列名称也修改一下，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zinterstore sport:ranking:why:last_seven_day_zinterstore 7 sport:ranking:why:20210222 sport:ranking:why:20210223 sport:ranking:why:20210224 sport:ranking:why:20210225 sport:ranking:why:20210226 sport:ranking:why:20210227 sport:ranking:why:20210228 weights 1 1 1 1 1 1 1 aggregate sum</span><br></pre></td></tr></table></figure>
<p><img src="/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/12.png"></p>
<p>知道最近 7 天的做法了，我们又有每一天数据，上一周、上一月、上个季度、这一年排行榜啥的不都是这个套路吗</p>
<h3 id="亿级用户排行榜"><a href="#亿级用户排行榜" class="headerlink" title="亿级用户排行榜"></a>亿级用户排行榜</h3><h4 id="按段位分桶"><a href="#按段位分桶" class="headerlink" title="按段位分桶"></a>按段位分桶</h4><p>由于数据量比较大，所以需要类似于分成一个个小文件的思想去统计每一部分的数据</p>
<p>比如游戏里的段位，统计国服前100，可以把王者、大师、砖石、铂金、黄金、白银、青铜 分为不同的桶，每个分段的人在不同的桶里(假设还是用zset存储用户的段位)<br>那计算全服排名即可先计算在某个段位桶的排名x,再获取这个段位桶前的所有桶的大小y1,y2…yn，排名就计算出来了x+y1+y2….yn</p>
<h5 id="计算top100"><a href="#计算top100" class="headerlink" title="计算top100"></a>计算top100</h5><p>分桶后，直接在段位最大的桶里计算top100即可</p>
<h4 id="按积分分桶"><a href="#按积分分桶" class="headerlink" title="按积分分桶"></a>按积分分桶</h4><p>[0-5000] [5001-10000] …..[10000000-x]</p>
<p>这种可能会出现热点问题，比如处于0-5000区间的人会非常多（可能很多人都是没有打排位）用户的落点其实并不是均匀的，那就需要通过其他预测算法去预估每个区间的人数了</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://flowtime.asia">周五打工人</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://flowtime.asia/2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/">http://flowtime.asia/2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://flowtime.asia" target="_blank">繁华流年间</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/">场景设计</a></div><div class="post_share"><div class="social-share" data-image="/img/haibian.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/" title="百亿流量红包系统"><img class="cover" src="/img/hubian.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">百亿流量红包系统</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Springcloud最热点面试题"><img class="cover" src="/img/hubian.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Springcloud最热点面试题</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Livere</span><span id="switch-btn"></span><span class="second-comment">Twikoo</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTg1OS8zNjMyMQ=="></div></div><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/nav.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">周五打工人</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">无论你是追求知识的急先锋，还是对生活感悟充满好奇，亦或是渴望找到属于自己情感共鸣的灵魂，本博客都将竭诚欢迎你的加入。共同书写属于自己的精彩篇章。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89A%E3%80%81B%E4%B8%A4%E4%B8%AA%E5%A4%A7%E6%96%87%E4%BB%B6%EF%BC%8C%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6%E5%87%A0%E5%8D%81G%EF%BC%8C%E8%80%8C%E5%86%85%E5%AD%98%E5%8F%AA%E6%9C%894G%EF%BC%8C%E5%85%B6%E4%B8%ADA%E6%96%87%E4%BB%B6%E5%AD%98%E6%94%BE%E5%AD%A6%E5%8F%B7-%E5%A7%93%E5%90%8D%EF%BC%8C%E8%80%8CB%E6%96%87%E4%BB%B6%E5%AD%98%E6%94%BE%E5%AD%A6%E5%8F%B7-%E5%88%86%E6%95%B0%EF%BC%8C%E8%A6%81%E6%B1%82%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6C%EF%BC%8C%E5%AD%98%E6%94%BE%E5%A7%93%E5%90%8D%E5%92%8C%E5%88%86%E6%95%B0%E3%80%82%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号+姓名，而B文件存放学号+分数，要求生成文件C，存放姓名和分数。怎么实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.</span> <span class="toc-text">秒杀系统怎么设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">秒杀存在的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">如何解决这些问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A7%E5%93%81%E4%B8%8A%E7%BA%BF%E5%87%BA%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E5%AE%9A%E4%BD%8D%E9%94%99%E8%AF%AF"><span class="toc-number">3.</span> <span class="toc-text">产品上线出问题怎么定位错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E9%87%8F%E5%B9%B6%E5%8F%91%E6%9F%A5%E8%AF%A2%E7%94%A8%E6%88%B7%E5%95%86%E5%93%81%E4%BF%A1%E6%81%AF%EF%BC%8CMySQL%E5%8E%8B%E5%8A%9B%E5%A4%A7%E6%9F%A5%E8%AF%A2%E6%85%A2%EF%BC%8C%E4%BF%9D%E8%AF%81%E9%80%9F%E5%BA%A6%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-number">4.</span> <span class="toc-text">大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%B7%E9%87%8F%E6%97%A5%E5%BF%97%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%8F%90%E5%8F%96%E5%87%BA%E6%9F%90%E6%97%A5%E8%AE%BF%E9%97%AE%E7%99%BE%E5%BA%A6%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E9%82%A3%E4%B8%AAIP%E3%80%82"><span class="toc-number">5.</span> <span class="toc-text">海量日志数据，提取出某日访问百度次数最多的那个IP。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%99%E5%AE%9Aa%E3%80%81b%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%8C%E5%90%84%E5%AD%98%E6%94%BE50%E4%BA%BF%E4%B8%AAurl%EF%BC%8C%E6%AF%8F%E4%B8%AAurl%E5%90%84%E5%8D%A064%E5%AD%97%E8%8A%82%EF%BC%8C%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6%E6%98%AF4G%EF%BC%8C%E8%AE%A9%E4%BD%A0%E6%89%BE%E5%87%BAa%E3%80%81b%E6%96%87%E4%BB%B6%E5%85%B1%E5%90%8C%E7%9A%84url%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%881"><span class="toc-number">6.1.</span> <span class="toc-text">方案1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%882"><span class="toc-number">6.2.</span> <span class="toc-text">方案2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E8%80%8C%E9%9C%80%E8%A6%81%E5%88%86%E6%9E%90%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%88%E5%BE%88%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98%E9%83%BD%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%88%86%E6%B2%BB%E7%9A%84%E6%80%9D%E6%83%B3%EF%BC%8C%E5%B0%86%E6%95%B0%E6%8D%AEhash-x-1000%E5%88%86%E4%B8%BA%E5%B0%8F%E6%96%87%E4%BB%B6%E5%86%8D%E5%88%86%E5%88%AB%E5%8A%A0%E8%BD%BD%E5%B0%8F%E6%96%87%E4%BB%B6%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD%E5%A4%84%E7%90%86%E5%8D%B3%E5%8F%AF"><span class="toc-number">7.</span> <span class="toc-text">一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash(x)%1000分为小文件再分别加载小文件到内存中处理即可</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">8.</span> <span class="toc-text">如何保证接口的幂等性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">8.1.</span> <span class="toc-text">什么是幂等性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E5%B9%82%E7%AD%89"><span class="toc-number">8.2.</span> <span class="toc-text">什么情况下需要幂等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89"><span class="toc-number">8.3.</span> <span class="toc-text">如何保证幂等</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81token%E6%9C%BA%E5%88%B6"><span class="toc-number">8.3.1.</span> <span class="toc-text">1、token机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">8.3.2.</span> <span class="toc-text">2、乐观锁机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%94%AF%E4%B8%80%E4%B8%BB%E9%94%AE"><span class="toc-number">8.3.3.</span> <span class="toc-text">3、唯一主键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E9%98%B2%E9%87%8D%E8%A1%A8"><span class="toc-number">8.3.4.</span> <span class="toc-text">4、防重表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%94%AF%E4%B8%80ID"><span class="toc-number">8.3.5.</span> <span class="toc-text">5、唯一ID</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98"><span class="toc-number">9.</span> <span class="toc-text">缓存和数据库不一致问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%E5%92%8C%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">9.1.</span> <span class="toc-text">更新缓存和更新数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E7%BC%93%E5%AD%98%E5%92%8C%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">9.2.</span> <span class="toc-text">删缓存和更新数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%88%A0%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">9.2.1.</span> <span class="toc-text">先删缓存，再更新数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E5%88%A0%E7%BC%93%E5%AD%98"><span class="toc-number">9.2.2.</span> <span class="toc-text">先更新数据库，再删缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">9.3.</span> <span class="toc-text">数据库和缓存数据强一致怎么办</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0"><span class="toc-number">9.3.1.</span> <span class="toc-text">缓存延时双删</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E4%B9%88%EF%BC%8C%E8%BF%99%E4%B8%AA%E4%BC%91%E7%9C%A0500%E6%AF%AB%E7%A7%92%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%E7%9A%84%EF%BC%8C%E5%85%B7%E4%BD%93%E8%AF%A5%E4%BC%91%E7%9C%A0%E5%A4%9A%E4%B9%85%E5%91%A2%EF%BC%9F"><span class="toc-number">9.3.2.</span> <span class="toc-text">那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%94%A8%E4%BA%86mysql%E7%9A%84%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">9.3.3.</span> <span class="toc-text">如果你用了mysql的读写分离架构怎么办？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E8%BF%99%E7%A7%8D%E5%90%8C%E6%AD%A5%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%8C%E5%90%9E%E5%90%90%E9%87%8F%E9%99%8D%E4%BD%8E%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">9.3.4.</span> <span class="toc-text">采用这种同步淘汰策略，吞吐量降低怎么办？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E7%BC%93%E5%AD%98%E5%A4%B1%E8%B4%A5%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9A%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">9.3.5.</span> <span class="toc-text">删缓存失败了怎么办：重试机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binlog"><span class="toc-number">9.3.6.</span> <span class="toc-text">binlog</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSPI"><span class="toc-number">10.</span> <span class="toc-text">什么是SPI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI-%E5%AE%9E%E8%B7%B5"><span class="toc-number">10.1.</span> <span class="toc-text">SPI 实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">什么是RPC？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC-demo"><span class="toc-number">11.1.</span> <span class="toc-text">RPC demo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gRPC"><span class="toc-number">12.</span> <span class="toc-text">gRPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gRPC%E4%B8%8EREST"><span class="toc-number">12.1.</span> <span class="toc-text">gRPC与REST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#demo"><span class="toc-number">12.2.</span> <span class="toc-text">demo</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#grpc"><span class="toc-number">12.2.1.</span> <span class="toc-text">grpc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#client"><span class="toc-number">12.2.2.</span> <span class="toc-text">client</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#server"><span class="toc-number">12.2.3.</span> <span class="toc-text">server</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E4%BC%98%E7%A7%80%E7%9A%84RPC%E6%A1%86%E6%9E%B6%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">13.</span> <span class="toc-text">一个优秀的RPC框架需要考虑的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDDD%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">什么是DDD？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC"><span class="toc-number">14.1.</span> <span class="toc-text">MVC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%A3%E4%B9%88DDD%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%8E%BB%E8%A7%A3%E5%86%B3%E4%BB%A5%E4%B8%8A%E7%9A%84%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F"><span class="toc-number">14.2.</span> <span class="toc-text">那么DDD为什么可以去解决以上的问题呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E7%B3%BB%E7%BB%9F%E9%80%82%E9%85%8DDDD"><span class="toc-number">14.3.</span> <span class="toc-text">什么样的系统适配DDD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DDD%E7%9A%84%E4%BB%A3%E7%A0%81%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-number">14.4.</span> <span class="toc-text">DDD的代码怎么做</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">15.</span> <span class="toc-text">Java实现生产者消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-%E5%92%8Cnotify-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.1.</span> <span class="toc-text">wait()和notify()方法的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.2.</span> <span class="toc-text">可重入锁ReentrantLock的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.2.1.</span> <span class="toc-text">阻塞队列BlockingQueue的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.2.2.</span> <span class="toc-text">信号量Semaphore的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AE%9E%E7%8E%B0BlockQueue"><span class="toc-number">16.</span> <span class="toc-text">Java实现BlockQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">17.</span> <span class="toc-text">解决哈希冲突的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="toc-number">17.1.</span> <span class="toc-text">开放定址法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E8%A1%8C%E6%8E%A2%E6%9F%A5%E6%B3%95"><span class="toc-number">17.1.1.</span> <span class="toc-text">线行探查法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%9F%A5%E6%B3%95"><span class="toc-number">17.1.2.</span> <span class="toc-text">平方探查法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E6%8E%A2%E6%9F%A5%E6%B3%95"><span class="toc-number">17.1.3.</span> <span class="toc-text">双散列函数探查法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95%EF%BC%88%E6%8B%89%E9%93%BE%E6%B3%95%EF%BC%89"><span class="toc-number">17.2.</span> <span class="toc-text">链地址法（拉链法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E5%93%88%E5%B8%8C%E6%B3%95"><span class="toc-number">17.3.</span> <span class="toc-text">再哈希法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%85%AC%E5%85%B1%E6%BA%A2%E5%87%BA%E5%8C%BA"><span class="toc-number">17.4.</span> <span class="toc-text">建立公共溢出区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E8%A1%8C%E6%A6%9C%E8%AE%BE%E8%AE%A1"><span class="toc-number">18.</span> <span class="toc-text">排行榜设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">18.1.</span> <span class="toc-text">基于数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis"><span class="toc-number">18.2.</span> <span class="toc-text">基于Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%BC%BC%E4%BA%8E%E5%BE%AE%E4%BF%A1%E8%AE%A1%E6%95%B0%E6%A6%9C%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E7%9C%8B%E5%88%B0%E7%9A%84%E6%9C%8B%E5%8F%8B%E5%9C%88%E7%9A%84%E6%8E%92%E8%A1%8C%E6%A6%9C%E4%B8%8D%E4%B8%80%E6%A0%B7"><span class="toc-number">18.3.</span> <span class="toc-text">类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E4%B8%83%E5%A4%A9%E6%8E%92%E8%A1%8C%E6%A6%9C%E6%80%8E%E4%B9%88%E5%BC%84"><span class="toc-number">18.4.</span> <span class="toc-text">最近七天排行榜怎么弄</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%BF%E7%BA%A7%E7%94%A8%E6%88%B7%E6%8E%92%E8%A1%8C%E6%A6%9C"><span class="toc-number">18.5.</span> <span class="toc-text">亿级用户排行榜</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E6%AE%B5%E4%BD%8D%E5%88%86%E6%A1%B6"><span class="toc-number">18.5.1.</span> <span class="toc-text">按段位分桶</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97top100"><span class="toc-number">18.5.1.1.</span> <span class="toc-text">计算top100</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E7%A7%AF%E5%88%86%E5%88%86%E6%A1%B6"><span class="toc-number">18.5.2.</span> <span class="toc-text">按积分分桶</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/06/02/%E7%BB%9F%E8%AE%A1%E5%85%A8%E5%9B%BD%E9%87%8D%E5%90%8D%E6%9C%80%E5%A4%9A%E7%9A%84%E5%89%8D100%E4%B8%AA/" title="统计全国重名最多的前100个"><img src="/img/liushui.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="统计全国重名最多的前100个"/></a><div class="content"><a class="title" href="/2024/06/02/%E7%BB%9F%E8%AE%A1%E5%85%A8%E5%9B%BD%E9%87%8D%E5%90%8D%E6%9C%80%E5%A4%9A%E7%9A%84%E5%89%8D100%E4%B8%AA/" title="统计全国重名最多的前100个">统计全国重名最多的前100个</a><time datetime="2024-06-02T09:16:17.000Z" title="发表于 2024-06-02 17:16:17">2024-06-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/" title="Edge浏览器中使用免费的ChatGPT"><img src="/img/liushui.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Edge浏览器中使用免费的ChatGPT"/></a><div class="content"><a class="title" href="/2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/" title="Edge浏览器中使用免费的ChatGPT">Edge浏览器中使用免费的ChatGPT</a><time datetime="2024-06-01T04:20:56.000Z" title="发表于 2024-06-01 12:20:56">2024-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/" title="百亿流量红包系统"><img src="/img/hubian.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="百亿流量红包系统"/></a><div class="content"><a class="title" href="/2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/" title="百亿流量红包系统">百亿流量红包系统</a><time datetime="2024-05-28T12:40:48.000Z" title="发表于 2024-05-28 20:40:48">2024-05-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/" title="场景设计面试题"><img src="/img/haibian.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="场景设计面试题"/></a><div class="content"><a class="title" href="/2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/" title="场景设计面试题">场景设计面试题</a><time datetime="2024-05-26T15:11:48.000Z" title="发表于 2024-05-26 23:11:48">2024-05-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Springcloud最热点面试题"><img src="/img/hubian.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Springcloud最热点面试题"/></a><div class="content"><a class="title" href="/2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Springcloud最热点面试题">Springcloud最热点面试题</a><time datetime="2024-05-26T14:57:29.000Z" title="发表于 2024-05-26 22:57:29">2024-05-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By 周五打工人</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Livere' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://mywaline-7unwzwfdi-motors-projects-a4d09e71.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://mywaline-7unwzwfdi-motors-projects-a4d09e71.vercel.app/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Livere' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>