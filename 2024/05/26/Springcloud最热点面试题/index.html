<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Springcloud最热点面试题 | 繁华流年间</title><meta name="author" content="周五打工人"><meta name="copyright" content="周五打工人"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。 Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot">
<meta property="og:type" content="article">
<meta property="og:title" content="Springcloud最热点面试题">
<meta property="og:url" content="http://flowtime.asia/2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="繁华流年间">
<meta property="og:description" content="Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。 Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://flowtime.asia/img/haibian.png">
<meta property="article:published_time" content="2024-05-26T14:57:29.000Z">
<meta property="article:modified_time" content="2024-05-26T15:05:33.395Z">
<meta property="article:author" content="周五打工人">
<meta property="article:tag" content="springcloud">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://flowtime.asia/img/haibian.png"><link rel="shortcut icon" href="/img/index.jpg"><link rel="canonical" href="http://flowtime.asia/2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-3578075519463317',
  enable_page_level_ads: 'true'
});</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Springcloud最热点面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-26 23:05:33'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/transparent.css"><link rel="stylesheet" href="/css/footer.css"><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/nav.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/haibian.png')"><nav id="nav"><span id="blog-info"><a href="/" title="繁华流年间"></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Springcloud最热点面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-05-26T14:57:29.000Z" title="发表于 2024-05-26 22:57:29">2024-05-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Springcloud最热点面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p>
<p>Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>
<h2 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h2><h3 id="eureka"><a href="#eureka" class="headerlink" title="eureka"></a>eureka</h3><p>服务治理组件，包括服务端的注册中心和客户端的服务发现机制；</p>
<h3 id="consul"><a href="#consul" class="headerlink" title="consul"></a>consul</h3><p>基于Hashicorp Consul的服务治理组件。</p>
<h2 id="服务负载与均衡"><a href="#服务负载与均衡" class="headerlink" title="服务负载与均衡"></a>服务负载与均衡</h2><h3 id="ribbon"><a href="#ribbon" class="headerlink" title="ribbon"></a>ribbon</h3><p>负载均衡的服务调用组件，具有多种负载均衡调用策略；</p>
<h3 id="loadbalancer"><a href="#loadbalancer" class="headerlink" title="loadbalancer"></a>loadbalancer</h3><h2 id="服务负载与调用"><a href="#服务负载与调用" class="headerlink" title="服务负载与调用"></a>服务负载与调用</h2><h3 id="feign"><a href="#feign" class="headerlink" title="feign"></a>feign</h3><p>基于Ribbon和Hystrix的声明式服务调用组件；</p>
<h3 id="openFeign"><a href="#openFeign" class="headerlink" title="openFeign"></a>openFeign</h3><p>基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。</p>
<h2 id="服务熔断与降级"><a href="#服务熔断与降级" class="headerlink" title="服务熔断与降级"></a>服务熔断与降级</h2><h3 id="hystrix"><a href="#hystrix" class="headerlink" title="hystrix"></a>hystrix</h3><p>服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；</p>
<h3 id="resilience4j"><a href="#resilience4j" class="headerlink" title="resilience4j"></a>resilience4j</h3><h2 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h2><h3 id="zuul"><a href="#zuul" class="headerlink" title="zuul"></a>zuul</h3><p>API网关组件，对请求提供路由及过滤功能。</p>
<h3 id="zuul2"><a href="#zuul2" class="headerlink" title="zuul2"></a>zuul2</h3><h3 id="getway"><a href="#getway" class="headerlink" title="getway"></a>getway</h3><p>API网关组件，对请求提供路由及过滤功能。</p>
<h2 id="服务分布式配置"><a href="#服务分布式配置" class="headerlink" title="服务分布式配置"></a>服务分布式配置</h2><h3 id="springcloud-config"><a href="#springcloud-config" class="headerlink" title="springcloud config"></a>springcloud config</h3><p>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</p>
<h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><h3 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h3><p>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。</p>
<h1 id="springcloudAlibaba"><a href="#springcloudAlibaba" class="headerlink" title="springcloudAlibaba"></a>springcloudAlibaba</h1><h2 id="Nacos-1"><a href="#Nacos-1" class="headerlink" title="Nacos"></a>Nacos</h2><p>Nacos 是一个开源的分布式系统服务发现、配置管理和服务管理平台。它主要包含以下功能：</p>
<p>服务发现与注册：Nacos 可以管理服务的注册和发现，支持 DNS 和 HTTP&#x2F;RESTful 方式。<br>配置管理：Nacos 可以动态管理配置，支持多种数据类型和版本控制。<br>服务管理：Nacos 可以对服务进行健康检查、流量管理、负载均衡等。</p>
<h3 id="服务发现与注册"><a href="#服务发现与注册" class="headerlink" title="服务发现与注册"></a>服务发现与注册</h3><p>Nacos 实现服务发现和注册的核心代码位于 nacos&#x2F;naming 目录下，包括以下文件：</p>
<ul>
<li>naming-common&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;api&#x2F;naming: 定义了服务发现和注册的 API 接口和数据模型。</li>
<li>naming-core&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;naming: 实现了服务发现和注册的核心逻辑。</li>
<li>naming-impl&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;naming: 实现了服务发现和注册的具体实现。</li>
</ul>
<p>下面简单介绍一下 Nacos 的服务发现和注册的实现流程。</p>
<h4 id="服务注册流程"><a href="#服务注册流程" class="headerlink" title="服务注册流程"></a>服务注册流程</h4><p>服务提供者向 Nacos 注册服务时，会调用 NamingService.registerInstance() 方法，该方法会做以下几件事情：</p>
<ol>
<li>将服务实例的元数据封装为 Instance 对象，包括服务名、IP、端口号、健康状态、元数据等。</li>
<li>将 Instance 对象转换为 InstanceEntity 对象，包含了实例 ID 和实例元数据的 JSON 字符串。</li>
<li>将 InstanceEntity 对象存储到 Nacos 中，可以存储到内存中或者持久化到磁盘中。</li>
</ol>
<h4 id="服务发现流程"><a href="#服务发现流程" class="headerlink" title="服务发现流程"></a>服务发现流程</h4><p>服务消费者向 Nacos 发现服务时，会调用 NamingService.getAllInstances() 或 NamingService.selectInstances() 方法，该方法会做以下几件事情：</p>
<ol>
<li>从 Nacos 中获取服务实例的元数据，包括服务名、IP、端口号、健康状态、元数据等。</li>
<li>将元数据封装为 Instance 对象，存储到本地缓存中。</li>
<li>根据负载均衡算法选择一个服务实例处理请求，可以选择轮询、随机、权重等算法。</li>
</ol>
<p>服务发现和注册的核心逻辑在 naming-core 目录下的 com.alibaba.nacos.naming 包中实现，主要包括以下类：</p>
<ul>
<li>com.alibaba.nacos.naming.core.InstancesManager: 维护服务实例的元数据和状态信息。</li>
<li>com.alibaba.nacos.naming.core.Cluster: 维护一个服务的所有实例信息和负载均衡策略。</li>
<li>com.alibaba.nacos.naming.core.InstanceOperator: 实现了服务实例的注册、注销和更新操作。</li>
<li>com.alibaba.nacos.naming.core.DomainsManager: 维护多个服务的信息，包括服务名、集群名、命名空间等。</li>
</ul>
<p>服务发现和注册的具体实现在 naming-impl 目录下的 com.alibaba.nacos.naming 包中，主要包括以下类：</p>
<ul>
<li>com.alibaba.nacos.naming.push.PushService: 实现了服务实例的推送功能。</li>
<li>com.alibaba.nacos.naming.healthcheck.HealthCheckProcessor: 实现了服务实例的健康检查功能。</li>
<li>com.alibaba.nacos.naming.misc.GlobalConfig: 存储了一些全局配置，例如默认权重值、心跳间隔</li>
</ul>
<h3 id="配置动态刷新"><a href="#配置动态刷新" class="headerlink" title="配置动态刷新"></a>配置动态刷新</h3><p>从远端服务器获取变更数据的主要模式有两种：推（push）和拉（pull）。Push 模式简单来说就是服务端主动将数据变更信息推送给客户端，这种模式优点是时效性好，服务端数据发生变更可以立马通知到客户端，但这种模式需要服务端维持与客户端的心跳连接，会增加服务端实现的复杂度，服务端也需要占用更多的资源来维持与客户端的连接。</p>
<p>而 Pull 模式则是客户端主动去服务器请求数据，例如，每间隔10ms就向服务端发起请求获取数据。显而易见pull模式存在时效性问题。请求的间隔也不太好设置，间隔太短，对服务器请求压力过大。间隔时间过长，那么必然会造成时效性很差。而且如果配置长时间不更新，并且存在大量的客户端就会产生大量无效的pull请求。</p>
<p>Nacos 没有采用上述的两种模式，而是采用了长轮询方式结合了推和拉的优点：</p>
<p><img src="/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/1.png" alt="动态刷新图"></p>
<p>长轮询也是轮询，因此 Nacos 客户端会默认每10ms向服务端发起请求，当客户端请求服务端时会在请求头上携带长轮询的超时时间，默认是30s。而服务端接收到该请求时会hang住请求，为了防止客户端超时会在请求头携带的超时时间上减去500ms，因此默认会hang住请求29.5s。在这期间如果服务端发生了配置变更会产生相应的事件，监听到该事件后，会响应对应的客户端。这样一来客户端不会频繁发起轮询请求，而服务端也不需要维持与客户端的心跳，兼备了时效性和复杂度。</p>
<p><img src="/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/2.png" alt="长轮询图"></p>
<blockquote>
<p>1.4版本nacos使用Http短连接+长轮询的方式，客户端发起http请求，服务端hold住请求，当配置变更时响应客户端，超时时间30s。<br>2.0版本nacos用gRPC长连接代替了http短连接长轮询。配置同步采用推拉结合的方式。</p>
</blockquote>
<h4 id="Nacos-Config-长轮询源码剖析"><a href="#Nacos-Config-长轮询源码剖析" class="headerlink" title="Nacos Config 长轮询源码剖析"></a>Nacos Config 长轮询源码剖析</h4><p>首先，打开 com.alibaba.cloud.nacos.NacosConfigBootstrapConfiguration 这个类，从类名也可以看出该类是Nacos Config的启动配置类，是Nacos Config自动装配的入口。在该类中的 nacosConfigManager 方法实例化了一个 NacosConfigManager 对象，并注册到容器中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> NacosConfigManager <span class="title function_">nacosConfigManager</span><span class="params">(</span></span><br><span class="line"><span class="params">		NacosConfigProperties nacosConfigProperties)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NacosConfigManager</span>(nacosConfigProperties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 NacosConfigManager 的构造器中调用了 createConfigService 方法，这是一个静态方法用来创建 ConfigService 对象的单例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Compatible with old design,It will be perfected in the future.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> ConfigService <span class="title function_">createConfigService</span><span class="params">(</span></span><br><span class="line"><span class="params">		NacosConfigProperties nacosConfigProperties)</span> &#123;</span><br><span class="line">    <span class="comment">// 双重检查锁模式的单例</span></span><br><span class="line">	<span class="keyword">if</span> (Objects.isNull(service)) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (NacosConfigManager.class) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (Objects.isNull(service)) &#123;</span><br><span class="line">					service = NacosFactory.createConfigService(</span><br><span class="line">							nacosConfigProperties.assembleConfigServiceProperties());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">				log.error(e.getMessage());</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NacosConnectionFailureException</span>(</span><br><span class="line">						nacosConfigProperties.getServerAddr(), e.getMessage(), e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConfigService 的具体实现是 NacosConfigService，在该类的构造器中主要初始化了 HttpAgent 和 ClientWorker 对象。ClientWorker 的构造器中则初始化了几个线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ClientWorker</span><span class="params">(<span class="keyword">final</span> HttpAgent agent, <span class="keyword">final</span> ConfigFilterChainManager configFilterChainManager,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> Properties properties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.agent = agent;</span><br><span class="line">    <span class="built_in">this</span>.configFilterChainManager = configFilterChainManager;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Initialize the timeout parameter</span></span><br><span class="line">    init(properties);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建具有定时执行功能的单线程池，用于定时执行 checkConfigInfo 方法</span></span><br><span class="line">    <span class="built_in">this</span>.executor = Executors.newScheduledThreadPool(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">            t.setName(<span class="string">&quot;com.alibaba.nacos.client.Worker.&quot;</span> + agent.getName());</span><br><span class="line">            t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建具有定时执行功能的且线程数与cpu核数相对应的线程池，用于根据需要动态刷新的配置文件执行 LongPollingRunnable，因此长轮询任务是可以有多个并行的</span></span><br><span class="line">    <span class="built_in">this</span>.executorService = Executors</span><br><span class="line">            .newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                    t.setName(<span class="string">&quot;com.alibaba.nacos.client.Worker.longPolling.&quot;</span> + agent.getName());</span><br><span class="line">                    t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 每10ms执行一次 checkConfigInfo 方法</span></span><br><span class="line">    <span class="built_in">this</span>.executor.scheduleWithFixedDelay(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                checkConfigInfo();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;[&quot;</span> + agent.getName() + <span class="string">&quot;] [sub-check] rotate check error&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1L</span>, <span class="number">10L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">    <span class="comment">// 长轮询的超时时间，默认为30秒，此参数会被放到请求头中带到服务端，服务端会根据该参数去做长轮询的hold</span></span><br><span class="line">    timeout = Math.max(ConvertUtils.toInt(properties.getProperty(PropertyKeyConst.CONFIG_LONG_POLL_TIMEOUT),</span><br><span class="line">            Constants.CONFIG_LONG_POLL_TIMEOUT), Constants.MIN_CONFIG_LONG_POLL_TIMEOUT);</span><br><span class="line">    </span><br><span class="line">    taskPenaltyTime = ConvertUtils</span><br><span class="line">            .toInt(properties.getProperty(PropertyKeyConst.CONFIG_RETRY_TIME), Constants.CONFIG_RETRY_TIME);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">this</span>.enableRemoteSyncConfig = Boolean</span><br><span class="line">            .parseBoolean(properties.getProperty(PropertyKeyConst.ENABLE_REMOTE_SYNC_CONFIG));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check config info.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkConfigInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Dispatch taskes.</span></span><br><span class="line">    <span class="comment">// 获取需要监听的文件数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">listenerSize</span> <span class="operator">=</span> cacheMap.size();</span><br><span class="line">    <span class="comment">// Round up the longingTaskCount.</span></span><br><span class="line">    <span class="comment">// 默认一个 LongPollingRunnable 可以处理监听3k个配置文件的变化，超过3k个才会创建新的 LongPollingRunnable</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">longingTaskCount</span> <span class="operator">=</span> (<span class="type">int</span>) Math.ceil(listenerSize / ParamUtil.getPerTaskConfigSize());</span><br><span class="line">    <span class="keyword">if</span> (longingTaskCount &gt; currentLongingTaskCount) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) currentLongingTaskCount; i &lt; longingTaskCount; i++) &#123;</span><br><span class="line">            <span class="comment">// The task list is no order.So it maybe has issues when changing.</span></span><br><span class="line">            executorService.execute(<span class="keyword">new</span> <span class="title class_">LongPollingRunnable</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        currentLongingTaskCount = longingTaskCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LongPollingRunnable 类主要用于检查本地配置，以及长轮询地去服务端获取变更配置的 dataid 和 group，其代码位于 com.alibaba.nacos.client.config.impl.ClientWorker 类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LongPollingRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> taskId;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LongPollingRunnable</span><span class="params">(<span class="type">int</span> taskId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskId = taskId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;CacheData&gt; cacheDatas = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;CacheData&gt;();</span><br><span class="line">        List&lt;String&gt; inInitializingCacheList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// check failover config</span></span><br><span class="line">            <span class="comment">// 遍历本地缓存的配置</span></span><br><span class="line">            <span class="keyword">for</span> (CacheData cacheData : cacheMap.values()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cacheData.getTaskId() == taskId) &#123;</span><br><span class="line">                    cacheDatas.add(cacheData);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 检查本地配置</span></span><br><span class="line">                        checkLocalConfig(cacheData);</span><br><span class="line">                        <span class="keyword">if</span> (cacheData.isUseLocalConfigInfo()) &#123;</span><br><span class="line">                            cacheData.checkListenerMd5();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        LOGGER.error(<span class="string">&quot;get local config info error&quot;</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// check server config</span></span><br><span class="line">            <span class="comment">// 通过长轮询检查服务端配置</span></span><br><span class="line">            List&lt;String&gt; changedGroupKeys = checkUpdateDataIds(cacheDatas, inInitializingCacheList);</span><br><span class="line">            <span class="keyword">if</span> (!CollectionUtils.isEmpty(changedGroupKeys)) &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;get changedGroupKeys:&quot;</span> + changedGroupKeys);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (String groupKey : changedGroupKeys) &#123;</span><br><span class="line">                String[] key = GroupKey.parseKey(groupKey);</span><br><span class="line">                <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> key[<span class="number">0</span>];</span><br><span class="line">                <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> key[<span class="number">1</span>];</span><br><span class="line">                <span class="type">String</span> <span class="variable">tenant</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (key.length == <span class="number">3</span>) &#123;</span><br><span class="line">                    tenant = key[<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String[] ct = getServerConfig(dataId, group, tenant, <span class="number">3000L</span>);</span><br><span class="line">                    <span class="type">CacheData</span> <span class="variable">cache</span> <span class="operator">=</span> cacheMap.get(GroupKey.getKeyTenant(dataId, group, tenant));</span><br><span class="line">                    cache.setContent(ct[<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">null</span> != ct[<span class="number">1</span>]) &#123;</span><br><span class="line">                        cache.setType(ct[<span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    LOGGER.info(<span class="string">&quot;[&#123;&#125;] [data-received] dataId=&#123;&#125;, group=&#123;&#125;, tenant=&#123;&#125;, md5=&#123;&#125;, content=&#123;&#125;, type=&#123;&#125;&quot;</span>,</span><br><span class="line">                            agent.getName(), dataId, group, tenant, cache.getMd5(),</span><br><span class="line">                            ContentUtils.truncateContent(ct[<span class="number">0</span>]), ct[<span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException ioe) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String</span><br><span class="line">                            .format(<span class="string">&quot;[%s] [get-update] get changed config exception. dataId=%s, group=%s, tenant=%s&quot;</span>,</span><br><span class="line">                                    agent.getName(), dataId, group, tenant);</span><br><span class="line">                    LOGGER.error(message, ioe);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (CacheData cacheData : cacheDatas) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cacheData.isInitializing() || inInitializingCacheList</span><br><span class="line">                        .contains(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant))) &#123;</span><br><span class="line">                    cacheData.checkListenerMd5();</span><br><span class="line">                    cacheData.setInitializing(<span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            inInitializingCacheList.clear();</span><br><span class="line">            </span><br><span class="line">            executorService.execute(<span class="built_in">this</span>);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// If the rotation training task is abnormal, the next execution time of the task will be punished</span></span><br><span class="line">            LOGGER.error(<span class="string">&quot;longPolling error : &quot;</span>, e);</span><br><span class="line">            executorService.schedule(<span class="built_in">this</span>, taskPenaltyTime, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面有个 checkUpdateDataIds 方法，用于获取发生变更了的配置文件的dataId列表，它同样位于 ClientWorker 内。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fetch the dataId list from server.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cacheDatas              CacheDatas for config infomations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inInitializingCacheList initial cache lists.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String include dataId and group (ps: it maybe null).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception Exception.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;String&gt; <span class="title function_">checkUpdateDataIds</span><span class="params">(List&lt;CacheData&gt; cacheDatas, List&lt;String&gt; inInitializingCacheList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 拼接出配置文件的唯一标识</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (CacheData cacheData : cacheDatas) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cacheData.isUseLocalConfigInfo()) &#123;</span><br><span class="line">            sb.append(cacheData.dataId).append(WORD_SEPARATOR);</span><br><span class="line">            sb.append(cacheData.group).append(WORD_SEPARATOR);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(cacheData.tenant)) &#123;</span><br><span class="line">                sb.append(cacheData.getMd5()).append(LINE_SEPARATOR);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(cacheData.getMd5()).append(WORD_SEPARATOR);</span><br><span class="line">                sb.append(cacheData.getTenant()).append(LINE_SEPARATOR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cacheData.isInitializing()) &#123;</span><br><span class="line">                <span class="comment">// It updates when cacheData occours in cacheMap by first time.</span></span><br><span class="line">                inInitializingCacheList</span><br><span class="line">                        .add(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isInitializingCacheList</span> <span class="operator">=</span> !inInitializingCacheList.isEmpty();</span><br><span class="line">    <span class="keyword">return</span> checkUpdateConfigStr(sb.toString(), isInitializingCacheList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fetch the updated dataId list from server.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> probeUpdateString       updated attribute string value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> isInitializingCacheList initial cache lists.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The updated dataId list(ps: it maybe null).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException Exception.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;String&gt; <span class="title function_">checkUpdateConfigStr</span><span class="params">(String probeUpdateString, <span class="type">boolean</span> isInitializingCacheList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    </span><br><span class="line">    Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">2</span>);</span><br><span class="line">    params.put(Constants.PROBE_MODIFY_REQUEST, probeUpdateString);</span><br><span class="line">    Map&lt;String, String&gt; headers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 长轮询的超时时间</span></span><br><span class="line">    headers.put(<span class="string">&quot;Long-Pulling-Timeout&quot;</span>, <span class="string">&quot;&quot;</span> + timeout);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// told server do not hang me up if new initializing cacheData added in</span></span><br><span class="line">    <span class="keyword">if</span> (isInitializingCacheList) &#123;</span><br><span class="line">        headers.put(<span class="string">&quot;Long-Pulling-Timeout-No-Hangup&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(probeUpdateString)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// In order to prevent the server from handling the delay of the client&#x27;s long task,</span></span><br><span class="line">        <span class="comment">// increase the client&#x27;s read timeout to avoid this problem.</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">readTimeoutMs</span> <span class="operator">=</span> timeout + (<span class="type">long</span>) Math.round(timeout &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 向服务端发起一个http请求，该请求在服务端配置没有变更的情况下默认会hang住30s</span></span><br><span class="line">        HttpRestResult&lt;String&gt; result = agent</span><br><span class="line">                .httpPost(Constants.CONFIG_CONTROLLER_PATH + <span class="string">&quot;/listener&quot;</span>, headers, params, agent.getEncode(),</span><br><span class="line">                        readTimeoutMs);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (result.ok()) &#123;</span><br><span class="line">            setHealthServer(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 响应状态是成功则解析响应体得到 dataId、group、tenant 等信息并返回</span></span><br><span class="line">            <span class="keyword">return</span> parseUpdateDataIdResponse(result.getData());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setHealthServer(<span class="literal">false</span>);</span><br><span class="line">            LOGGER.error(<span class="string">&quot;[&#123;&#125;] [check-update] get changed dataId error, code: &#123;&#125;&quot;</span>, agent.getName(),</span><br><span class="line">                    result.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        setHealthServer(<span class="literal">false</span>);</span><br><span class="line">        LOGGER.error(<span class="string">&quot;[&quot;</span> + agent.getName() + <span class="string">&quot;] [check-update] get changed dataId exception&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端对 listener 接口的请求会进入到服务端的 com.alibaba.nacos.config.server.controller.ConfigController#listener 方法进行处理，该方法主要是调用了 com.alibaba.nacos.config.server.controller.ConfigServletInner#doPollingConfig 方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 轮询接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doPollingConfig</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                              Map&lt;String, String&gt; clientMd5Map, <span class="type">int</span> probeRequestSize)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果支持长轮询则进入长轮询的流程</span></span><br><span class="line">    <span class="keyword">if</span> (LongPollingService.isSupportLongPolling(request)) &#123;</span><br><span class="line">        longPollingService.addLongPollingClient(request, response, clientMd5Map, probeRequestSize);</span><br><span class="line">        <span class="keyword">return</span> HttpServletResponse.SC_OK + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// else 兼容短轮询逻辑</span></span><br><span class="line">    List&lt;String&gt; changedGroups = MD5Util.compareMd5(request, response, clientMd5Map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 兼容短轮询result</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">oldResult</span> <span class="operator">=</span> MD5Util.compareMd5OldResult(changedGroups);</span><br><span class="line">    <span class="type">String</span> <span class="variable">newResult</span> <span class="operator">=</span> MD5Util.compareMd5ResultString(changedGroups);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> request.getHeader(Constants.CLIENT_VERSION_HEADER);</span><br><span class="line">    <span class="keyword">if</span> (version == <span class="literal">null</span>) &#123;</span><br><span class="line">        version = <span class="string">&quot;2.0.0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">versionNum</span> <span class="operator">=</span> Protocol.getVersionNumber(version);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.0.4版本以前, 返回值放入header中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (versionNum &lt; START_LONGPOLLING_VERSION_NUM) &#123;</span><br><span class="line">        response.addHeader(Constants.PROBE_MODIFY_RESPONSE, oldResult);</span><br><span class="line">        response.addHeader(Constants.PROBE_MODIFY_RESPONSE_NEW, newResult);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        request.setAttribute(<span class="string">&quot;content&quot;</span>, newResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用缓存</span></span><br><span class="line">    response.setHeader(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">    response.setDateHeader(<span class="string">&quot;Expires&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache,no-store&quot;</span>);</span><br><span class="line">    response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">    <span class="keyword">return</span> HttpServletResponse.SC_OK + <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们主要关注上面的 com.alibaba.nacos.config.server.service.LongPollingService#addLongPollingClient 长轮询流程的方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLongPollingClient</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp, Map&lt;String, String&gt; clientMd5Map,</span></span><br><span class="line"><span class="params">                                 <span class="type">int</span> probeRequestSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> req.getHeader(LongPollingService.LONG_POLLING_HEADER);</span><br><span class="line">    <span class="type">String</span> <span class="variable">noHangUpFlag</span> <span class="operator">=</span> req.getHeader(LongPollingService.LONG_POLLING_NO_HANG_UP_HEADER);</span><br><span class="line">    <span class="type">String</span> <span class="variable">appName</span> <span class="operator">=</span> req.getHeader(RequestUtil.CLIENT_APPNAME_HEADER);</span><br><span class="line">    <span class="type">String</span> <span class="variable">tag</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;Vipserver-Tag&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">delayTime</span> <span class="operator">=</span> SwitchService.getSwitchInteger(SwitchService.FIXED_DELAY_TIME, <span class="number">500</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提前500ms返回响应，为避免客户端超时 <span class="doctag">@qiaoyi</span>.dingqy 2013.10.22改动  add delay time for LoadBalance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">timeout</span> <span class="operator">=</span> Math.max(<span class="number">10000</span>, Long.parseLong(str) - delayTime);</span><br><span class="line">    <span class="keyword">if</span> (isFixedPolling()) &#123;</span><br><span class="line">        timeout = Math.max(<span class="number">10000</span>, getFixedPollingInterval());</span><br><span class="line">        <span class="comment">// do nothing but set fix polling timeout</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        List&lt;String&gt; changedGroups = MD5Util.compareMd5(req, rsp, clientMd5Map);</span><br><span class="line">        <span class="keyword">if</span> (changedGroups.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            generateResponse(req, rsp, changedGroups);</span><br><span class="line">            LogUtil.clientLog.info(<span class="string">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class="line">                System.currentTimeMillis() - start, <span class="string">&quot;instant&quot;</span>, RequestUtil.getRemoteIp(req), <span class="string">&quot;polling&quot;</span>,</span><br><span class="line">                clientMd5Map.size(), probeRequestSize, changedGroups.size());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (noHangUpFlag != <span class="literal">null</span> &amp;&amp; noHangUpFlag.equalsIgnoreCase(TRUE_STR)) &#123;</span><br><span class="line">            LogUtil.clientLog.info(<span class="string">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>, System.currentTimeMillis() - start, <span class="string">&quot;nohangup&quot;</span>,</span><br><span class="line">                RequestUtil.getRemoteIp(req), <span class="string">&quot;polling&quot;</span>, clientMd5Map.size(), probeRequestSize,</span><br><span class="line">                changedGroups.size());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> RequestUtil.getRemoteIp(req);</span><br><span class="line">    <span class="comment">// 一定要由HTTP线程调用，否则离开后容器会立即发送响应</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AsyncContext</span> <span class="variable">asyncContext</span> <span class="operator">=</span> req.startAsync();</span><br><span class="line">    <span class="comment">// AsyncContext.setTimeout()的超时时间不准，所以只能自己控制</span></span><br><span class="line">    asyncContext.setTimeout(<span class="number">0L</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在 ClientLongPolling 的 run 方法会将 ClientLongPolling 实例（携带了本次请求的相关信息）放入 allSubs 中，然后会在29.5s后再执行另一个 Runnable，该 Runnable 用于等待29.5s后依旧没有相应的配置变更时对客户端进行响应，并将相应的 ClientLongPolling 实例从 allSubs 中移出</span></span><br><span class="line">    scheduler.execute(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClientLongPolling</span>(asyncContext, clientMd5Map, ip, probeRequestSize, timeout, appName, tag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 LongPollingService 实现了 AbstractEventListener，也就是说能接收事件通知，在其 com.alibaba.nacos.config.server.service.LongPollingService#onEvent 方法中可以看到，它关注的是 LocalDataChangeEvent 事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFixedPolling()) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> LocalDataChangeEvent) &#123;</span><br><span class="line">            <span class="type">LocalDataChangeEvent</span> <span class="variable">evt</span> <span class="operator">=</span> (LocalDataChangeEvent)event;</span><br><span class="line">            scheduler.execute(<span class="keyword">new</span> <span class="title class_">DataChangeTask</span>(evt.groupKey, evt.isBeta, evt.betaIps));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在nacos上修改配置后就会产生 LocalDataChangeEvent 事件，此时 LongPollingService 也就能监听到，当收到该事件时就会遍历 allSubs，找到匹配的请求并将 groupKey 返回给客户端。具体代码在 DataChangeTask 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataChangeTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ConfigService.getContentBetaMd5(groupKey);</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;ClientLongPolling&gt; iter = allSubs.iterator(); iter.hasNext(); ) &#123;</span><br><span class="line">                <span class="type">ClientLongPolling</span> <span class="variable">clientSub</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                <span class="keyword">if</span> (clientSub.clientMd5Map.containsKey(groupKey)) &#123;</span><br><span class="line">                    <span class="comment">// 如果beta发布且不在beta列表直接跳过</span></span><br><span class="line">                    <span class="keyword">if</span> (isBeta &amp;&amp; !betaIps.contains(clientSub.ip)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果tag发布且不在tag列表直接跳过</span></span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotBlank(tag) &amp;&amp; !tag.equals(clientSub.tag)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    getRetainIps().put(clientSub.ip, System.currentTimeMillis());</span><br><span class="line">                    iter.remove(); <span class="comment">// 删除订阅关系</span></span><br><span class="line">                    LogUtil.clientLog.info(<span class="string">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class="line">                        (System.currentTimeMillis() - changeTime),</span><br><span class="line">                        <span class="string">&quot;in-advance&quot;</span>,</span><br><span class="line">                        RequestUtil.getRemoteIp((HttpServletRequest)clientSub.asyncContext.getRequest()),</span><br><span class="line">                        <span class="string">&quot;polling&quot;</span>,</span><br><span class="line">                        clientSub.clientMd5Map.size(), clientSub.probeRequestSize, groupKey);</span><br><span class="line">                    clientSub.sendResponse(Arrays.asList(groupKey));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            LogUtil.defaultLog.error(<span class="string">&quot;data change error:&quot;</span> + t.getMessage(), t.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DataChangeTask(String groupKey) &#123;</span><br><span class="line">        <span class="built_in">this</span>(groupKey, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DataChangeTask(String groupKey, <span class="type">boolean</span> isBeta, List&lt;String&gt; betaIps) &#123;</span><br><span class="line">        <span class="built_in">this</span>(groupKey, isBeta, betaIps, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DataChangeTask(String groupKey, <span class="type">boolean</span> isBeta, List&lt;String&gt; betaIps, String tag) &#123;</span><br><span class="line">        <span class="built_in">this</span>.groupKey = groupKey;</span><br><span class="line">        <span class="built_in">this</span>.isBeta = isBeta;</span><br><span class="line">        <span class="built_in">this</span>.betaIps = betaIps;</span><br><span class="line">        <span class="built_in">this</span>.tag = tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String groupKey;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">changeTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> isBeta;</span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; betaIps;</span><br><span class="line">    <span class="keyword">final</span> String tag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当客户端收到变更的dataid+group后，就会去服务端获取最新的配置数据，并更新本地数据 cacheData，然后发送数据变更事件，整个流程结束。</p>
<ul>
<li>获取服务端最新配置数据的方法：com.alibaba.nacos.client.config.impl.ClientWorker#getServerConfig</li>
<li>发送数据变更事件的方法：com.alibaba.nacos.client.config.impl.CacheData#checkListenerMd5</li>
</ul>
<h2 id="Sentienl"><a href="#Sentienl" class="headerlink" title="Sentienl"></a>Sentienl</h2><p>Sentinel是阿里巴巴开源的一款流量控制和熔断降级框架，主要用于微服务架构中服务的流量控制和熔断降级。其限流实现原理主要分为两个部分：</p>
<blockquote>
<p>统计信息收集</p>
</blockquote>
<p>Sentinel会在运行过程中对服务的各种统计信息进行收集，包括请求的响应时间、请求通过的QPS（每秒查询率）、线程池队列大小等指标。这些指标通过定义的规则进行分析，判断当前请求是否超过了设定的阈值。</p>
<blockquote>
<p>阈值判断</p>
</blockquote>
<p>Sentinel根据收集到的统计信息，通过定义的规则对请求进行判断。规则中包括以下几个要素：</p>
<p>资源名：对哪个资源进行限流<br>流控模式：直接拒绝或者匀速通过<br>流控阈值：单位时间内允许通过的请求个数<br>统计时间窗口：多长时间内统计一次流量，单位秒<br>降级处理：当请求超过阈值时的处理策略，如直接拒绝、返回默认值等<br>Sentinel会根据以上规则进行限流，当请求超过阈值时，根据设置的降级处理策略进行处理，比如直接拒绝请求、返回默认值等。同时，Sentinel还可以进行自适应的流控，根据实际情况调整阈值，保证服务的可用性和稳定性。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="Slot-插槽"><a href="#Slot-插槽" class="headerlink" title="Slot 插槽"></a>Slot 插槽</h4><p>在 Sentinel 里面，所有的资源都对应一个资源名称（resourceName），每次资源调用都会创建一个 Entry 对象。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 SphU API 显式创建。Entry 创建的时候，同时也会创建一系列功能插槽（slot chain），这些插槽有不同的职责，例如:</p>
<ul>
<li>NodeSelectorSlot 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</li>
<li>ClusterBuilderSlot 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；</li>
<li>StatisticSlot 则用于记录、统计不同纬度的 runtime 指标监控信息；</li>
<li>FlowSlot 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；</li>
<li>AuthoritySlot 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li>
<li>DegradeSlot 则通过统计信息以及预设的规则，来做熔断降级；</li>
<li>SystemSlot 则通过系统的状态，例如 load1 等，来控制总的入口流量；</li>
</ul>
<p>Sentinel 提供了插槽接口 ProcessorSlot，其中提供了方法 enrty 处理进入请求 和 exit 处理请求结束操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProcessorSlot</span>&lt;T&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Entrance of this slot.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context         current &#123;<span class="doctag">@link</span> Context&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resourceWrapper current resource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param           generics parameter, usually is a &#123;<span class="doctag">@link</span> com.alibaba.csp.sentinel.node.Node&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count           tokens needed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prioritized     whether the entry is prioritized</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args            parameters of the original call</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable blocked exception or unexpected error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, T param, <span class="type">int</span> count, <span class="type">boolean</span> prioritized,</span></span><br><span class="line"><span class="params">               Object... args)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Means finish of &#123;<span class="doctag">@link</span> #entry(Context, ResourceWrapper, Object, int, boolean, Object...)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context         current &#123;<span class="doctag">@link</span> Context&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resourceWrapper current resource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj             relevant object (e.g. Node)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count           tokens needed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prioritized     whether the entry is prioritized</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args            parameters of the original call</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable blocked exception or unexpected error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fireEntry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, Object obj, <span class="type">int</span> count, <span class="type">boolean</span> prioritized,</span></span><br><span class="line"><span class="params">                   Object... args)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exit of this slot.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context         current &#123;<span class="doctag">@link</span> Context&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resourceWrapper current resource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count           tokens needed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args            parameters of the original call</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(Context context, ResourceWrapper resourceWrapper, <span class="type">int</span> count, Object... args)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Means finish of &#123;<span class="doctag">@link</span> #exit(Context, ResourceWrapper, int, Object...)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context         current &#123;<span class="doctag">@link</span> Context&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resourceWrapper current resource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count           tokens needed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args            parameters of the original call</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fireExit</span><span class="params">(Context context, ResourceWrapper resourceWrapper, <span class="type">int</span> count, Object... args)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总体的框架如下:</p>
<p><img src="/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/3.png" alt="结构图"></p>
<p>Sentinel 将 SlotChainBuilder 作为 SPI 接口进行扩展，使得 Slot Chain 具备了扩展的能力。您可以自行加入自定义的 slot 并编排 slot 间的顺序，从而可以给 Sentinel 添加自定义的功能。</p>
<p><img src="/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/4.png" alt="Sentinel图"></p>
<h4 id="RuleManager-规则管理器"><a href="#RuleManager-规则管理器" class="headerlink" title="RuleManager 规则管理器"></a>RuleManager 规则管理器</h4><p>每个 Slot 插槽背后都对应着一个 RuleManager 的实现类，简单理解就是每个 Slot 有一套规则，规则验证处理由对应的 RuleManager 来进行处理。</p>
<p>流量控制：FlowSolt 对应 FlowRuleManager</p>
<p>降级控制：DegradeSlot  对应 DegradeRuleManager</p>
<p>权限控制：AuthoritySlot 对应 AuthorityRuleManager</p>
<p>系统规则控制： SystemSlot 对应 SystemRuleManager</p>
<h4 id="降级控制实现原理"><a href="#降级控制实现原理" class="headerlink" title="降级控制实现原理"></a>降级控制实现原理</h4><ol>
<li>新增资源配置降级规则，目前对于降级策有如下三种：</li>
</ol>
<p>RT：平均响应时间 (DEGRADE_GRADE_RT)：当 1s 内持续进入 5 个请求，对应时刻的平均响应时间（秒级）均超过阈值（count，以 ms 为单位），那么在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt&#x3D;xxx 来配置。</p>
<p><img src="/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/5.png" alt="平均响应图"></p>
<p>异常比例：当资源的每秒请求量 &gt;&#x3D; 5，并且每秒异常总数占通过量的比值超过阈值（DegradeRule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</p>
<p><img src="/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/6.png" alt="异常比例图"></p>
<p>异常数：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。</p>
<p><img src="/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/7.png" alt="异常数图"></p>
<p>限流结果信息</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Blocked by Sentinel (flow limiting)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实现逻辑</li>
</ol>
<p>在之前我们已经提及 Sentinel 是通过 slot 链来实现的，对于降级功能其提供了 DegradeSlot，实现源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DegradeSlot</span> <span class="keyword">extends</span> <span class="title class_">AbstractLinkedProcessorSlot</span>&lt;DefaultNode&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="type">int</span> count, <span class="type">boolean</span> prioritized, Object... args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        DegradeRuleManager.checkDegrade(resourceWrapper, context, node, count);</span><br><span class="line">        fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(Context context, ResourceWrapper resourceWrapper, <span class="type">int</span> count, Object... args)</span> &#123;</span><br><span class="line">        fireExit(context, resourceWrapper, count, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面代码我们可以了解到，限流规则的实现是在 DegradeRuleManager 的checkDegrade中来处理的，限流可以-配置多个规则，依次按照规则来处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkDegrade</span><span class="params">(ResourceWrapper resource, Context context, DefaultNode node, <span class="type">int</span> count)</span></span><br><span class="line">        <span class="keyword">throws</span> BlockException &#123;</span><br><span class="line"> </span><br><span class="line">        Set&lt;DegradeRule&gt; rules = degradeRules.get(resource.getName());</span><br><span class="line">        <span class="keyword">if</span> (rules == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (DegradeRule rule : rules) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!rule.passCheck(context, node, count)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DegradeException</span>(rule.getLimitApp(), rule);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在 DegradeRule 的 passCheck 方法中我们可以看到可以根据 RT、异常数和异常比例来进行熔断降级处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">passCheck</span><span class="params">(Context context, DefaultNode node, <span class="type">int</span> acquireCount, Object... args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cut.get()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="type">ClusterNode</span> <span class="variable">clusterNode</span> <span class="operator">=</span> ClusterBuilderSlot.getClusterNode(<span class="built_in">this</span>.getResource());</span><br><span class="line">        <span class="keyword">if</span> (clusterNode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// 请求处理时间</span></span><br><span class="line">        <span class="keyword">if</span> (grade == RuleConstant.DEGRADE_GRADE_RT) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">rt</span> <span class="operator">=</span> clusterNode.avgRt();</span><br><span class="line">            <span class="keyword">if</span> (rt &lt; <span class="built_in">this</span>.count) &#123;</span><br><span class="line">                passCount.set(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Sentinel will degrade the service only if count exceeds.</span></span><br><span class="line">            <span class="keyword">if</span> (passCount.incrementAndGet() &lt; rtSlowRequestAmount) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO) &#123;</span><br><span class="line">			<span class="comment">//异常比例</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">exception</span> <span class="operator">=</span> clusterNode.exceptionQps();</span><br><span class="line">            <span class="type">double</span> <span class="variable">success</span> <span class="operator">=</span> clusterNode.successQps();</span><br><span class="line">            <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> clusterNode.totalQps();</span><br><span class="line">            <span class="comment">// If total amount is less than minRequestAmount, the request will pass.</span></span><br><span class="line">            <span class="keyword">if</span> (total &lt; minRequestAmount) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// In the same aligned statistic time window,</span></span><br><span class="line">            <span class="comment">// &quot;success&quot; (aka. completed count) = exception count + non-exception count (realSuccess)</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">realSuccess</span> <span class="operator">=</span> success - exception;</span><br><span class="line">            <span class="keyword">if</span> (realSuccess &lt;= <span class="number">0</span> &amp;&amp; exception &lt; minRequestAmount) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (exception / success &lt; count) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT) &#123;</span><br><span class="line">			<span class="comment">//异常数</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">exception</span> <span class="operator">=</span> clusterNode.totalException();</span><br><span class="line">            <span class="keyword">if</span> (exception &lt; count) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (cut.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="type">ResetTask</span> <span class="variable">resetTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResetTask</span>(<span class="built_in">this</span>);</span><br><span class="line">            pool.schedule(resetTask, timeWindow, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="流量控制实现原理"><a href="#流量控制实现原理" class="headerlink" title="流量控制实现原理"></a>流量控制实现原理</h4><p>接下来我们了解学习一下 Sentinel 是如何实现流量控制的</p>
<p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。</p>
<p>FlowSlot 会根据预设的规则，结合前面 NodeSelectorSlot、ClusterNodeBuilderSlot、StatisticSlot 统计出来的实时信息进行流量控制。</p>
<p>限流的直接表现是在执行 Entry nodeA &#x3D; SphU.entry(resourceName) 的时候抛出 FlowException 异常。FlowException 是 BlockException 的子类，您可以捕捉 BlockException 来自定义被限流之后的处理逻辑。</p>
<p>同一个资源可以创建多条限流规则。FlowSlot 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。</p>
<p>一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：</p>
<ul>
<li>resource：资源名，即限流规则的作用对象</li>
<li>count: 限流阈值</li>
<li>grade: 限流阈值类型（QPS 或并发线程数）</li>
<li>limitApp: 流控针对的调用来源，若为 default 则不区分调用来源</li>
<li>strategy: 调用关系限流策略</li>
<li>controlBehavior: 流量控制效果（直接拒绝、Warm Up、匀速排队）</li>
</ul>
<p>流控-QPS配置</p>
<p><img src="/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/8.png" alt="QPS配置图"></p>
<p>流控-线程数配置</p>
<p><img src="/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/9.png" alt="流控图"></p>
<h5 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h5><p>Sentinel 提供了 FlowSlot 用来进行流量控制，流量规则的最终实现在 FlowRuleChecker 的 checkFlow 中实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlowSlot</span> <span class="keyword">extends</span> <span class="title class_">AbstractLinkedProcessorSlot</span>&lt;DefaultNode&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FlowRuleChecker checker;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FlowSlot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">FlowRuleChecker</span>());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Package-private for test.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> checker flow rule checker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6.1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FlowSlot(FlowRuleChecker checker) &#123;</span><br><span class="line">        AssertUtil.notNull(checker, <span class="string">&quot;flow checker should not be null&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.checker = checker;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="type">int</span> count,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> prioritized, Object... args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        checkFlow(resourceWrapper, context, node, count, prioritized);</span><br><span class="line"> </span><br><span class="line">        fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">checkFlow</span><span class="params">(ResourceWrapper resource, Context context, DefaultNode node, <span class="type">int</span> count, <span class="type">boolean</span> prioritized)</span></span><br><span class="line">        <span class="keyword">throws</span> BlockException &#123;</span><br><span class="line">        checker.checkFlow(ruleProvider, resource, context, node, count, prioritized);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(Context context, ResourceWrapper resourceWrapper, <span class="type">int</span> count, Object... args)</span> &#123;</span><br><span class="line">        fireExit(context, resourceWrapper, count, args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;String, Collection&lt;FlowRule&gt;&gt; ruleProvider = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Collection&lt;FlowRule&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Collection&lt;FlowRule&gt; <span class="title function_">apply</span><span class="params">(String resource)</span> &#123;</span><br><span class="line">            <span class="comment">// Flow rule map should not be null.</span></span><br><span class="line">            Map&lt;String, List&lt;FlowRule&gt;&gt; flowRules = FlowRuleManager.getFlowRuleMap();</span><br><span class="line">            <span class="keyword">return</span> flowRules.get(resource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 checkFlow 中会依次获取我们配置的流控规则，然后依次进行流控判断处理，如果被流控则抛出异常 FlowException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFlow</span><span class="params">(Function&lt;String, Collection&lt;FlowRule&gt;&gt; ruleProvider, ResourceWrapper resource,</span></span><br><span class="line"><span class="params">                          Context context, DefaultNode node, <span class="type">int</span> count, <span class="type">boolean</span> prioritized)</span> <span class="keyword">throws</span> BlockException &#123;</span><br><span class="line">        <span class="keyword">if</span> (ruleProvider == <span class="literal">null</span> || resource == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Collection&lt;FlowRule&gt; rules = ruleProvider.apply(resource.getName());</span><br><span class="line">        <span class="keyword">if</span> (rules != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (FlowRule rule : rules) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!canPassCheck(rule, context, node, count, prioritized)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FlowException</span>(rule.getLimitApp(), rule);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在 canPassCheck 中会判断是集群限流还是本地限流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPassCheck</span><span class="params">(<span class="comment">/*@NonNull*/</span> FlowRule rule, Context context, DefaultNode node, <span class="type">int</span> acquireCount,</span></span><br><span class="line"><span class="params">                                                    <span class="type">boolean</span> prioritized)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">limitApp</span> <span class="operator">=</span> rule.getLimitApp();</span><br><span class="line">        <span class="keyword">if</span> (limitApp == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (rule.isClusterMode()) &#123;</span><br><span class="line">            <span class="keyword">return</span> passClusterCheck(rule, context, node, acquireCount, prioritized);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> passLocalCheck(rule, context, node, acquireCount, prioritized);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果是本地限流则获取节点信息，然后根据流控规则进行流控判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">passLocalCheck</span><span class="params">(FlowRule rule, Context context, DefaultNode node, <span class="type">int</span> acquireCount,</span></span><br><span class="line"><span class="params">                                          <span class="type">boolean</span> prioritized)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">selectedNode</span> <span class="operator">=</span> selectNodeByRequesterAndStrategy(rule, context, node);</span><br><span class="line">        <span class="keyword">if</span> (selectedNode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> rule.getRater().canPass(selectedNode, acquireCount, prioritized);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当 QPS 超过某个阈值的时候，则采取措施进行流量控制。流量控制的手段包括以下几种：直接拒绝、Warm Up、匀速排队。对应 FlowRule 中的 controlBehavior 字段。</p>
<p>直接拒绝（RuleConstant.CONTROL_BEHAVIOR_DEFAULT）方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。具体的例子参见 FlowQpsDemo。</p>
<p>Warm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）方式，即预热&#x2F;冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。详细文档可以参考 流量控制 - Warm Up 文档</p>
<p>目前 Sentinel 对于流量控制提供了如下几种方式：</p>
<ul>
<li>直接拒绝（DefaultController）：支持抛出异常<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPass</span><span class="params">(Node node, <span class="type">int</span> acquireCount, <span class="type">boolean</span> prioritized)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">curCount</span> <span class="operator">=</span> avgUsedTokens(node);</span><br><span class="line">    <span class="keyword">if</span> (curCount + acquireCount &gt; count) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prioritized &amp;&amp; grade == RuleConstant.FLOW_GRADE_QPS) &#123;</span><br><span class="line">            <span class="type">long</span> currentTime;</span><br><span class="line">            <span class="type">long</span> waitInMs;</span><br><span class="line">            currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">            waitInMs = node.tryOccupyNext(currentTime, acquireCount, count);</span><br><span class="line">            <span class="keyword">if</span> (waitInMs &lt; OccupyTimeoutProperty.getOccupyTimeout()) &#123;</span><br><span class="line">                node.addWaitingRequest(currentTime + waitInMs, acquireCount);</span><br><span class="line">                node.addOccupiedPass(acquireCount);</span><br><span class="line">                sleep(waitInMs);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// PriorityWaitException indicates that the request will pass after waiting for &#123;@link @waitInMs&#125;.</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PriorityWaitException</span>(waitInMs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>匀速排队（RateLimiterController）：判断等待时间，如果等待时间过长也是会限流，并且使用 Thread.sleep 如果配置不正确可能会导致线程过多。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPass</span><span class="params">(Node node, <span class="type">int</span> acquireCount, <span class="type">boolean</span> prioritized)</span> &#123;</span><br><span class="line">        <span class="comment">// Pass when acquire count is less or equal than 0.</span></span><br><span class="line">        <span class="keyword">if</span> (acquireCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Reject when count is less or equal than 0.</span></span><br><span class="line">        <span class="comment">// Otherwise,the costTime will be max of long and waitTime will overflow in some cases.</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> TimeUtil.currentTimeMillis();</span><br><span class="line">        <span class="comment">// Calculate the interval between every two requests.</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">costTime</span> <span class="operator">=</span> Math.round(<span class="number">1.0</span> * (acquireCount) / count * <span class="number">1000</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Expected pass time of this request.</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">expectedTime</span> <span class="operator">=</span> costTime + latestPassedTime.get();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (expectedTime &lt;= currentTime) &#123;</span><br><span class="line">            <span class="comment">// Contention may exist here, but it&#x27;s okay.</span></span><br><span class="line">            latestPassedTime.set(currentTime);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Calculate the time to wait.</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">oldTime</span> <span class="operator">=</span> latestPassedTime.addAndGet(costTime);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    waitTime = oldTime - TimeUtil.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class="line">                        latestPassedTime.addAndGet(-costTime);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// in race condition waitTime may &lt;= 0</span></span><br><span class="line">                    <span class="keyword">if</span> (waitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Thread.sleep(waitTime);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>Warm Up（WarmUpController 和 WarmUpRateLimiterController）：预热启动<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPass</span><span class="params">(Node node, <span class="type">int</span> acquireCount, <span class="type">boolean</span> prioritized)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">passQps</span> <span class="operator">=</span> (<span class="type">long</span>) node.passQps();</span><br><span class="line"> </span><br><span class="line">    <span class="type">long</span> <span class="variable">previousQps</span> <span class="operator">=</span> (<span class="type">long</span>) node.previousPassQps();</span><br><span class="line">    syncToken(previousQps);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 开始计算它的斜率</span></span><br><span class="line">    <span class="comment">// 如果进入了警戒线，开始调整他的qps</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">restToken</span> <span class="operator">=</span> storedTokens.get();</span><br><span class="line">    <span class="keyword">if</span> (restToken &gt;= warningToken) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">aboveToken</span> <span class="operator">=</span> restToken - warningToken;</span><br><span class="line">        <span class="comment">// 消耗的速度要比warning快，但是要比慢</span></span><br><span class="line">        <span class="comment">// current interval = restToken*slope+1/count</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">warningQps</span> <span class="operator">=</span> Math.nextUp(<span class="number">1.0</span> / (aboveToken * slope + <span class="number">1.0</span> / count));</span><br><span class="line">        <span class="keyword">if</span> (passQps + acquireCount &lt;= warningQps) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (passQps + acquireCount &lt;= count) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://flowtime.asia">周五打工人</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://flowtime.asia/2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/">http://flowtime.asia/2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://flowtime.asia" target="_blank">繁华流年间</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/springcloud/">springcloud</a></div><div class="post_share"><div class="social-share" data-image="/img/haibian.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/" title="场景设计面试题"><img class="cover" src="/img/haibian.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">场景设计面试题</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/26/Springmvc%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Springmvc最热点面试题"><img class="cover" src="/img/liushui.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Springmvc最热点面试题</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/nav.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">周五打工人</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">无论你是追求知识的急先锋，还是对生活感悟充满好奇，亦或是渴望找到属于自己情感共鸣的灵魂，本博客都将竭诚欢迎你的加入。共同书写属于自己的精彩篇章。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">服务注册与发现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#eureka"><span class="toc-number">1.1.</span> <span class="toc-text">eureka</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#consul"><span class="toc-number">1.2.</span> <span class="toc-text">consul</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E8%B4%9F%E8%BD%BD%E4%B8%8E%E5%9D%87%E8%A1%A1"><span class="toc-number">2.</span> <span class="toc-text">服务负载与均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ribbon"><span class="toc-number">2.1.</span> <span class="toc-text">ribbon</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loadbalancer"><span class="toc-number">2.2.</span> <span class="toc-text">loadbalancer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E8%B4%9F%E8%BD%BD%E4%B8%8E%E8%B0%83%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">服务负载与调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#feign"><span class="toc-number">3.1.</span> <span class="toc-text">feign</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#openFeign"><span class="toc-number">3.2.</span> <span class="toc-text">openFeign</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E4%B8%8E%E9%99%8D%E7%BA%A7"><span class="toc-number">4.</span> <span class="toc-text">服务熔断与降级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hystrix"><span class="toc-number">4.1.</span> <span class="toc-text">hystrix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resilience4j"><span class="toc-number">4.2.</span> <span class="toc-text">resilience4j</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3"><span class="toc-number">5.</span> <span class="toc-text">服务网关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#zuul"><span class="toc-number">5.1.</span> <span class="toc-text">zuul</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zuul2"><span class="toc-number">5.2.</span> <span class="toc-text">zuul2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getway"><span class="toc-number">5.3.</span> <span class="toc-text">getway</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE"><span class="toc-number">6.</span> <span class="toc-text">服务分布式配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#springcloud-config"><span class="toc-number">6.1.</span> <span class="toc-text">springcloud config</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nacos"><span class="toc-number">6.2.</span> <span class="toc-text">Nacos</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF"><span class="toc-number">7.</span> <span class="toc-text">总线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Cloud-Bus"><span class="toc-number">7.1.</span> <span class="toc-text">Spring Cloud Bus</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#springcloudAlibaba"><span class="toc-number"></span> <span class="toc-text">springcloudAlibaba</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Nacos-1"><span class="toc-number">1.</span> <span class="toc-text">Nacos</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E6%B3%A8%E5%86%8C"><span class="toc-number">1.1.</span> <span class="toc-text">服务发现与注册</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">服务注册流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">服务发现流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0"><span class="toc-number">1.2.</span> <span class="toc-text">配置动态刷新</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Nacos-Config-%E9%95%BF%E8%BD%AE%E8%AF%A2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">Nacos Config 长轮询源码剖析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sentienl"><span class="toc-number">2.</span> <span class="toc-text">Sentienl</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Slot-%E6%8F%92%E6%A7%BD"><span class="toc-number">2.1.1.</span> <span class="toc-text">Slot 插槽</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RuleManager-%E8%A7%84%E5%88%99%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">RuleManager 规则管理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%8D%E7%BA%A7%E6%8E%A7%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.3.</span> <span class="toc-text">降级控制实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.4.</span> <span class="toc-text">流量控制实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">实现流程</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/02/28/%E7%A7%92%E6%9D%80%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/" title="秒杀的分布式事务如何设计"><img src="/img/liushui.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="秒杀的分布式事务如何设计"/></a><div class="content"><a class="title" href="/2025/02/28/%E7%A7%92%E6%9D%80%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/" title="秒杀的分布式事务如何设计">秒杀的分布式事务如何设计</a><time datetime="2025-02-28T02:33:34.000Z" title="发表于 2025-02-28 10:33:34">2025-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/27/%E6%9C%80%E6%96%B0Seata%E9%9B%86%E6%88%90%E4%BA%86RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AFyyds/" title="最新Seata集成了RocketMQ事务消息yyds"><img src="/img/haibian.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="最新Seata集成了RocketMQ事务消息yyds"/></a><div class="content"><a class="title" href="/2025/02/27/%E6%9C%80%E6%96%B0Seata%E9%9B%86%E6%88%90%E4%BA%86RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AFyyds/" title="最新Seata集成了RocketMQ事务消息yyds">最新Seata集成了RocketMQ事务消息yyds</a><time datetime="2025-02-27T03:03:11.000Z" title="发表于 2025-02-27 11:03:11">2025-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/27/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-Nacos%E6%9C%80%E5%85%A8%E8%AF%A6%E8%A7%A3/" title="从入门到精通 Nacos最全详解"><img src="/img/haibian.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从入门到精通 Nacos最全详解"/></a><div class="content"><a class="title" href="/2025/02/27/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-Nacos%E6%9C%80%E5%85%A8%E8%AF%A6%E8%A7%A3/" title="从入门到精通 Nacos最全详解">从入门到精通 Nacos最全详解</a><time datetime="2025-02-27T02:27:12.000Z" title="发表于 2025-02-27 10:27:12">2025-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/24/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-Sentinel/" title="从入门到精通 Sentinel"><img src="/img/liushui.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从入门到精通 Sentinel"/></a><div class="content"><a class="title" href="/2025/02/24/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-Sentinel/" title="从入门到精通 Sentinel">从入门到精通 Sentinel</a><time datetime="2025-02-24T07:48:28.000Z" title="发表于 2025-02-24 15:48:28">2025-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/24/redis-%E9%94%81%E7%9A%845%E4%B8%AA%E5%A4%A7%E5%9D%91%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%EF%BC%9F/" title="redis 锁的5个大坑，如何规避？"><img src="/img/liushui.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis 锁的5个大坑，如何规避？"/></a><div class="content"><a class="title" href="/2025/02/24/redis-%E9%94%81%E7%9A%845%E4%B8%AA%E5%A4%A7%E5%9D%91%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%EF%BC%9F/" title="redis 锁的5个大坑，如何规避？">redis 锁的5个大坑，如何规避？</a><time datetime="2025-02-24T02:42:01.000Z" title="发表于 2025-02-24 10:42:01">2025-02-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 周五打工人</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://mywaline-7unwzwfdi-motors-projects-a4d09e71.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://mywaline-7unwzwfdi-motors-projects-a4d09e71.vercel.app/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>