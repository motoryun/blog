---
title: Mysql 有几级缓存？ 每一级缓存，具体是什么？
date: 2025-03-03 21:10:35
tags: Mysql
categories: 面试
---


在 MySQL 数据库中，查询执行计划（MySQL Execution Plan）是决定查询性能的关键因素。

一个好的执行计划（MySQL Execution Plan）能够让查询高效地运行，减少资源的消耗和响应时间。

一、MySQL缓存机制概述
-------------

MySQL的缓存机制主要分为两种：一级缓存和二级缓存。

**一级缓存**

也称为InnoDB缓存，是MySQL的一种存储引擎（InnoDB）提供的缓存机制。它主要用于存储数据和索引，提高数据访问速度。

**二级缓存**：

也称为查询缓存（Query Cache），是MySQL服务器内部的缓存机制，用于存储SELECT查询的结果。当相同的查询再次执行时，可以直接从缓存中获取结果，而无需再次查询数据库。

二、MySQL 整体架构
------------

Mysql的架构 ，整体是分为服务层、引擎层和文件系统层，其架构图如下所示：

![](./2025/03/03/Mysql-有几级缓存？-每一级缓存，具体是什么？/img.png)

MySQL Server 服务层（Service Layer）解析 SQL 语句、优化查询以及执行操作的，分别有三个关键组件完成：

*   **解析器（Parser）**

*   **优化器（Optimizer）**

*   **执行器（Executor）**。


每个组件在查询执行的过程中扮演不同的角色，下面分别介绍这三者的作用：

#### 1\. 解析器（Parser）

解析器是 SQL 查询执行的第一步，它的职责是将用户发送的 SQL 语句解析为数据库能够理解的内部结构。

*   **SQL 词法分析**：解析器首先对 SQL 语句进行词法分析，将 SQL 语句分割成多个“单词”或“标记”，如表名、列名、关键字等。

*   **语法分析**：接着，解析器会根据 SQL 语法规则生成对应的解析树（Parse Tree），用来描述 SQL 语句的逻辑结构。这个过程检查 SQL 语句的语法是否正确。

*   **语义分析**：确认 SQL 语句中涉及的数据库对象是否存在（比如表名、字段名是否有效），并且检查权限。


解析完成后，生成一个中间表示结构，交由下一步进行处理。

#### 2\. 优化器（Optimizer）

优化器负责选择最优的执行计划，使查询能够以最高效的方式运行。

*   **逻辑优化**：优化器会对 SQL 语句进行逻辑优化，比如 SQL 语句重写、消除冗余操作、合并重复条件、重新排列 WHERE 子句中的条件等。

*   **物理优化**：在物理优化阶段，优化器会选择最优的访问路径和执行顺序。例如，它会决定使用哪种索引（如果有多个索引可选），是否做全表扫描，如何连接多张表（选择嵌套循环、哈希连接或排序合并连接等）。

*   **成本估算**：优化器会基于数据库的统计信息（例如表的大小、索引的选择性等）来估算不同执行计划的成本，选择代价最低的执行方案。


经过优化后，优化器会生成一个查询执行计划，并交给执行器处理。

#### 3\. 执行器（Executor）

执行器的任务是按照优化器生成的执行计划，逐步执行查询，访问数据并返回结果。

*   **权限检查**：在执行之前，执行器会首先检查用户是否有权限执行相应的操作。如果没有权限，则返回错误信息。

*   **执行执行计划**：执行器根据生成的执行计划，依次调用存储引擎的接口来执行具体的操作。例如，如果是查询操作，执行器会调用存储引擎来读取相应的数据；如果是插入操作，执行器则会调用存储引擎来插入数据。

*   **结果返回**：执行器根据查询的结果，将数据以合适的格式返回给客户端。如果涉及多个步骤（如 JOIN 操作），执行器会协调各个步骤的执行，并组合最终的结果集。


#### 三个核心组件之间的交互流程

1.  **解析器**：SQL 语句转换为解析树。

2.  **优化器**：生成最优的执行计划。

3.  **执行器**：根据计划调用存储引擎执行操作并返回结果。


这三个组件相互协作，完成从接收到 SQL 查询到返回结果的整个过程。

三：一条完成的sql查询语句 执行流程 ，如下所示：
--------------------------

![](./2025/03/03/Mysql-有几级缓存？-每一级缓存，具体是什么？/img_1.png)

一条完整的SQL查询语句从执行到返回结果的流程涉及到多个组件和步骤，其中可能包括缓存的使用。以下是执行流程的一般概述，以及可能用到的缓存：

1.  **客户端请求**：

    客户端（如应用程序）向MySQL服务器发送SQL查询请求。

2.  **解析器**：

    MySQL服务器接收到SQL查询后，首先由解析器进行解析，检查SQL语句的语法是否正确。

3.  **优化器**：

    解析完成后，优化器会根据查询语句和数据库的元数据（如表结构、索引等）生成一个或多个执行计划。

4.  **权限检查**：

    服务器检查执行该查询的用户是否有相应的权限。

5.  **缓存查询**：

    在某些情况下，如果查询可以被缓存，服务器会检查一级缓存（如InnoDB缓冲池）和/或二级缓存（如果启用了查询缓存）。

    **二级缓存（查询缓存，MySQL 8.0之前）**：如果查询缓存启用，服务器会检查查询缓存中是否有该查询的结果。如果有，直接返回缓存结果。

6.  **执行器**：

    如果查询没有在缓存中找到，执行器会根据优化器生成的执行计划执行查询。

    执行过程中，可能会涉及到数据的读取和写入操作，此时二级缓存（InnoDB缓冲池）会更新。

    **一级缓存（InnoDB缓冲池）**：如果查询涉及到的数据或索引页已经在缓冲池中，可以直接使用，无需访问磁盘。

    **Buffer Pool** 中，如下图所示：

7. ![](./2025/03/03/Mysql-有几级缓存？-每一级缓存，具体是什么？/img_2.png)

7.  **返回结果**：

    查询执行完成后，结果集被返回给客户端。

8.  **更新缓存**：

    对于写操作（如INSERT、UPDATE、DELETE），相关的缓存（一级缓存和查询缓存）需要被更新或失效，以保持数据的一致性。

9.  **日志记录**：

    服务器会记录查询的日志信息，如慢查询日志，用于后续的性能分析。

10.  **关闭连接**：

查询完成后，客户端可以选择关闭与MySQL服务器的连接，或者保持连接以便于后续的查询。


需要注意的是，从MySQL 8.0开始，查询缓存已经被移除，因此在使用MySQL 8.0及更高版本时，不会使用到查询缓存。

此外，二级缓存（如InnoDB缓冲池）的使用是自动的，由InnoDB存储引擎管理，不需要用户干预。用户可以通过调整缓冲池的大小和其他相关参数来优化其性能。

四：MySQL 8.0 版本为何移出了二级缓存（Query Cache）?
-------------------------------------

MySQL 8.0 版本中已经完全移除了查询缓存（Query Cache）功能。在早期的MySQL版本中，查询缓存是一个用于存储SELECT查询结果的内存区域，以提高重复查询的性能。然而，由于查询缓存在某些情况下会导致性能问题，特别是在高并发和写密集型的应用场景中，查询缓存可能会频繁失效，导致缓存命中率低，反而增加了性能开销。

因此，MySQL 8.0及更高版本推荐使用其他缓存策略，比如：

1.  **应用层缓存**：在应用代码中实现缓存逻辑，使用如Redis、Memcached等缓存系统。

2.  **持久化存储引擎缓存**：利用InnoDB的缓冲池来缓存数据和索引。

3.  **其他存储引擎**：如果需要查询缓存的功能，可以考虑使用支持查询缓存的存储引擎，如MyISAM（但MyISAM不支持事务）。


MySQL 8.0通过优化存储引擎和索引管理，以及提供更好的性能调优工具和特性，来提高查询性能，而不是依赖于查询缓存。

五：MySQL 8.0 版本前的二级缓存配置
----------------------

##### 可以通过下面的步骤，进行二级缓存配置

| **步骤** | **描述** | **代码** |
| --- | --- | --- |
|1|启用查询缓存|`SET GLOBAL query_cache_type = 1;`|
| 2| 设置查询缓存大小| `SET GLOBAL query_cache_size = 64 * 1024 * 1024;`|
| 3| 执行查询| `SELECT * FROM table_name;`|

##### 代码解释

*   `SET GLOBAL query_cache_type = 1;`：启用查询缓存，1表示ON。

*   `SET GLOBAL query_cache_size = 64 * 1024 * 1024;`：设置查询缓存的大小，这里设置为64MB。

*   `SELECT * FROM table_name;`：执行查询，如果查询缓存中存在相同的查询，将直接从缓存中获取结果。


六：使用应用层的缓存作为 外置缓存
-----------------

需要注意的是，MySQL 8.0版本中已经移除了查询缓存（Query Cache），因为其在某些情况下会导致性能问题，比如在高并发写入的场景下，查询缓存可能会频繁失效，导致缓存命中率低，反而增加了性能开销。

MySQL 8.0推荐使用其他缓存策略，比如使用应用层的缓存（如Redis、Memcached）作为 外置缓存，加速热点数据的访问。

对于需要缓存的场景，可以考虑以下几种替代方案：

*   **应用层缓存**：在应用代码中实现缓存逻辑，使用如Redis、Memcached等缓存系统。

*   **本地缓存**：对与热点数据，可以是用本地缓存对数据进行cache。
    

