<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      
        <title>Springcloud最热点面试题</title>
      
      <link href="/2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p><p>Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><h2 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h2><h3 id="eureka"><a href="#eureka" class="headerlink" title="eureka"></a>eureka</h3><p>服务治理组件，包括服务端的注册中心和客户端的服务发现机制；</p><h3 id="consul"><a href="#consul" class="headerlink" title="consul"></a>consul</h3><p>基于Hashicorp Consul的服务治理组件。</p><h2 id="服务负载与均衡"><a href="#服务负载与均衡" class="headerlink" title="服务负载与均衡"></a>服务负载与均衡</h2><h3 id="ribbon"><a href="#ribbon" class="headerlink" title="ribbon"></a>ribbon</h3><p>负载均衡的服务调用组件，具有多种负载均衡调用策略；</p><h3 id="loadbalancer"><a href="#loadbalancer" class="headerlink" title="loadbalancer"></a>loadbalancer</h3><h2 id="服务负载与调用"><a href="#服务负载与调用" class="headerlink" title="服务负载与调用"></a>服务负载与调用</h2><h3 id="feign"><a href="#feign" class="headerlink" title="feign"></a>feign</h3><p>基于Ribbon和Hystrix的声明式服务调用组件；</p><h3 id="openFeign"><a href="#openFeign" class="headerlink" title="openFeign"></a>openFeign</h3><p>基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。</p><h2 id="服务熔断与降级"><a href="#服务熔断与降级" class="headerlink" title="服务熔断与降级"></a>服务熔断与降级</h2><h3 id="hystrix"><a href="#hystrix" class="headerlink" title="hystrix"></a>hystrix</h3><p>服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；</p><h3 id="resilience4j"><a href="#resilience4j" class="headerlink" title="resilience4j"></a>resilience4j</h3><h2 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h2><h3 id="zuul"><a href="#zuul" class="headerlink" title="zuul"></a>zuul</h3><p>API网关组件，对请求提供路由及过滤功能。</p><h3 id="zuul2"><a href="#zuul2" class="headerlink" title="zuul2"></a>zuul2</h3><h3 id="getway"><a href="#getway" class="headerlink" title="getway"></a>getway</h3><p>API网关组件，对请求提供路由及过滤功能。</p><h2 id="服务分布式配置"><a href="#服务分布式配置" class="headerlink" title="服务分布式配置"></a>服务分布式配置</h2><h3 id="springcloud-config"><a href="#springcloud-config" class="headerlink" title="springcloud config"></a>springcloud config</h3><p>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</p><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><h3 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h3><p>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。</p><h1 id="springcloudAlibaba"><a href="#springcloudAlibaba" class="headerlink" title="springcloudAlibaba"></a>springcloudAlibaba</h1><h2 id="Nacos-1"><a href="#Nacos-1" class="headerlink" title="Nacos"></a>Nacos</h2><p>Nacos 是一个开源的分布式系统服务发现、配置管理和服务管理平台。它主要包含以下功能：</p><p>服务发现与注册：Nacos 可以管理服务的注册和发现，支持 DNS 和 HTTP&#x2F;RESTful 方式。<br>配置管理：Nacos 可以动态管理配置，支持多种数据类型和版本控制。<br>服务管理：Nacos 可以对服务进行健康检查、流量管理、负载均衡等。</p><h3 id="服务发现与注册"><a href="#服务发现与注册" class="headerlink" title="服务发现与注册"></a>服务发现与注册</h3><p>Nacos 实现服务发现和注册的核心代码位于 nacos&#x2F;naming 目录下，包括以下文件：</p><ul><li>naming-common&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;api&#x2F;naming: 定义了服务发现和注册的 API 接口和数据模型。</li><li>naming-core&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;naming: 实现了服务发现和注册的核心逻辑。</li><li>naming-impl&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;naming: 实现了服务发现和注册的具体实现。</li></ul><p>下面简单介绍一下 Nacos 的服务发现和注册的实现流程。</p><h4 id="服务注册流程"><a href="#服务注册流程" class="headerlink" title="服务注册流程"></a>服务注册流程</h4><p>服务提供者向 Nacos 注册服务时，会调用 NamingService.registerInstance() 方法，该方法会做以下几件事情：</p><ol><li>将服务实例的元数据封装为 Instance 对象，包括服务名、IP、端口号、健康状态、元数据等。</li><li>将 Instance 对象转换为 InstanceEntity 对象，包含了实例 ID 和实例元数据的 JSON 字符串。</li><li>将 InstanceEntity 对象存储到 Nacos 中，可以存储到内存中或者持久化到磁盘中。</li></ol><h4 id="服务发现流程"><a href="#服务发现流程" class="headerlink" title="服务发现流程"></a>服务发现流程</h4><p>服务消费者向 Nacos 发现服务时，会调用 NamingService.getAllInstances() 或 NamingService.selectInstances() 方法，该方法会做以下几件事情：</p><ol><li>从 Nacos 中获取服务实例的元数据，包括服务名、IP、端口号、健康状态、元数据等。</li><li>将元数据封装为 Instance 对象，存储到本地缓存中。</li><li>根据负载均衡算法选择一个服务实例处理请求，可以选择轮询、随机、权重等算法。</li></ol><p>服务发现和注册的核心逻辑在 naming-core 目录下的 com.alibaba.nacos.naming 包中实现，主要包括以下类：</p><ul><li>com.alibaba.nacos.naming.core.InstancesManager: 维护服务实例的元数据和状态信息。</li><li>com.alibaba.nacos.naming.core.Cluster: 维护一个服务的所有实例信息和负载均衡策略。</li><li>com.alibaba.nacos.naming.core.InstanceOperator: 实现了服务实例的注册、注销和更新操作。</li><li>com.alibaba.nacos.naming.core.DomainsManager: 维护多个服务的信息，包括服务名、集群名、命名空间等。</li></ul><p>服务发现和注册的具体实现在 naming-impl 目录下的 com.alibaba.nacos.naming 包中，主要包括以下类：</p><ul><li>com.alibaba.nacos.naming.push.PushService: 实现了服务实例的推送功能。</li><li>com.alibaba.nacos.naming.healthcheck.HealthCheckProcessor: 实现了服务实例的健康检查功能。</li><li>com.alibaba.nacos.naming.misc.GlobalConfig: 存储了一些全局配置，例如默认权重值、心跳间隔</li></ul><h3 id="配置动态刷新"><a href="#配置动态刷新" class="headerlink" title="配置动态刷新"></a>配置动态刷新</h3><p>从远端服务器获取变更数据的主要模式有两种：推（push）和拉（pull）。Push 模式简单来说就是服务端主动将数据变更信息推送给客户端，这种模式优点是时效性好，服务端数据发生变更可以立马通知到客户端，但这种模式需要服务端维持与客户端的心跳连接，会增加服务端实现的复杂度，服务端也需要占用更多的资源来维持与客户端的连接。</p><p>而 Pull 模式则是客户端主动去服务器请求数据，例如，每间隔10ms就向服务端发起请求获取数据。显而易见pull模式存在时效性问题。请求的间隔也不太好设置，间隔太短，对服务器请求压力过大。间隔时间过长，那么必然会造成时效性很差。而且如果配置长时间不更新，并且存在大量的客户端就会产生大量无效的pull请求。</p><p>Nacos 没有采用上述的两种模式，而是采用了长轮询方式结合了推和拉的优点：</p><p><img src="/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/1.png" alt="动态刷新图"></p><p>长轮询也是轮询，因此 Nacos 客户端会默认每10ms向服务端发起请求，当客户端请求服务端时会在请求头上携带长轮询的超时时间，默认是30s。而服务端接收到该请求时会hang住请求，为了防止客户端超时会在请求头携带的超时时间上减去500ms，因此默认会hang住请求29.5s。在这期间如果服务端发生了配置变更会产生相应的事件，监听到该事件后，会响应对应的客户端。这样一来客户端不会频繁发起轮询请求，而服务端也不需要维持与客户端的心跳，兼备了时效性和复杂度。</p><p><img src="/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/2.png" alt="长轮询图"></p><blockquote><p>1.4版本nacos使用Http短连接+长轮询的方式，客户端发起http请求，服务端hold住请求，当配置变更时响应客户端，超时时间30s。<br>2.0版本nacos用gRPC长连接代替了http短连接长轮询。配置同步采用推拉结合的方式。</p></blockquote><h4 id="Nacos-Config-长轮询源码剖析"><a href="#Nacos-Config-长轮询源码剖析" class="headerlink" title="Nacos Config 长轮询源码剖析"></a>Nacos Config 长轮询源码剖析</h4><p>首先，打开 com.alibaba.cloud.nacos.NacosConfigBootstrapConfiguration 这个类，从类名也可以看出该类是Nacos Config的启动配置类，是Nacos Config自动装配的入口。在该类中的 nacosConfigManager 方法实例化了一个 NacosConfigManager 对象，并注册到容器中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> NacosConfigManager <span class="title function_">nacosConfigManager</span><span class="params">(</span></span><br><span class="line"><span class="params">NacosConfigProperties nacosConfigProperties)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NacosConfigManager</span>(nacosConfigProperties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 NacosConfigManager 的构造器中调用了 createConfigService 方法，这是一个静态方法用来创建 ConfigService 对象的单例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Compatible with old design,It will be perfected in the future.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> ConfigService <span class="title function_">createConfigService</span><span class="params">(</span></span><br><span class="line"><span class="params">NacosConfigProperties nacosConfigProperties)</span> &#123;</span><br><span class="line">    <span class="comment">// 双重检查锁模式的单例</span></span><br><span class="line"><span class="keyword">if</span> (Objects.isNull(service)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (NacosConfigManager.class) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (Objects.isNull(service)) &#123;</span><br><span class="line">service = NacosFactory.createConfigService(</span><br><span class="line">nacosConfigProperties.assembleConfigServiceProperties());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">log.error(e.getMessage());</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NacosConnectionFailureException</span>(</span><br><span class="line">nacosConfigProperties.getServerAddr(), e.getMessage(), e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConfigService 的具体实现是 NacosConfigService，在该类的构造器中主要初始化了 HttpAgent 和 ClientWorker 对象。ClientWorker 的构造器中则初始化了几个线程池：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ClientWorker</span><span class="params">(<span class="keyword">final</span> HttpAgent agent, <span class="keyword">final</span> ConfigFilterChainManager configFilterChainManager,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> Properties properties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.agent = agent;</span><br><span class="line">    <span class="built_in">this</span>.configFilterChainManager = configFilterChainManager;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Initialize the timeout parameter</span></span><br><span class="line">    init(properties);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建具有定时执行功能的单线程池，用于定时执行 checkConfigInfo 方法</span></span><br><span class="line">    <span class="built_in">this</span>.executor = Executors.newScheduledThreadPool(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">            t.setName(<span class="string">&quot;com.alibaba.nacos.client.Worker.&quot;</span> + agent.getName());</span><br><span class="line">            t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建具有定时执行功能的且线程数与cpu核数相对应的线程池，用于根据需要动态刷新的配置文件执行 LongPollingRunnable，因此长轮询任务是可以有多个并行的</span></span><br><span class="line">    <span class="built_in">this</span>.executorService = Executors</span><br><span class="line">            .newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                    t.setName(<span class="string">&quot;com.alibaba.nacos.client.Worker.longPolling.&quot;</span> + agent.getName());</span><br><span class="line">                    t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 每10ms执行一次 checkConfigInfo 方法</span></span><br><span class="line">    <span class="built_in">this</span>.executor.scheduleWithFixedDelay(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                checkConfigInfo();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;[&quot;</span> + agent.getName() + <span class="string">&quot;] [sub-check] rotate check error&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1L</span>, <span class="number">10L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">    <span class="comment">// 长轮询的超时时间，默认为30秒，此参数会被放到请求头中带到服务端，服务端会根据该参数去做长轮询的hold</span></span><br><span class="line">    timeout = Math.max(ConvertUtils.toInt(properties.getProperty(PropertyKeyConst.CONFIG_LONG_POLL_TIMEOUT),</span><br><span class="line">            Constants.CONFIG_LONG_POLL_TIMEOUT), Constants.MIN_CONFIG_LONG_POLL_TIMEOUT);</span><br><span class="line">    </span><br><span class="line">    taskPenaltyTime = ConvertUtils</span><br><span class="line">            .toInt(properties.getProperty(PropertyKeyConst.CONFIG_RETRY_TIME), Constants.CONFIG_RETRY_TIME);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">this</span>.enableRemoteSyncConfig = Boolean</span><br><span class="line">            .parseBoolean(properties.getProperty(PropertyKeyConst.ENABLE_REMOTE_SYNC_CONFIG));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check config info.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkConfigInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Dispatch taskes.</span></span><br><span class="line">    <span class="comment">// 获取需要监听的文件数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">listenerSize</span> <span class="operator">=</span> cacheMap.size();</span><br><span class="line">    <span class="comment">// Round up the longingTaskCount.</span></span><br><span class="line">    <span class="comment">// 默认一个 LongPollingRunnable 可以处理监听3k个配置文件的变化，超过3k个才会创建新的 LongPollingRunnable</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">longingTaskCount</span> <span class="operator">=</span> (<span class="type">int</span>) Math.ceil(listenerSize / ParamUtil.getPerTaskConfigSize());</span><br><span class="line">    <span class="keyword">if</span> (longingTaskCount &gt; currentLongingTaskCount) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) currentLongingTaskCount; i &lt; longingTaskCount; i++) &#123;</span><br><span class="line">            <span class="comment">// The task list is no order.So it maybe has issues when changing.</span></span><br><span class="line">            executorService.execute(<span class="keyword">new</span> <span class="title class_">LongPollingRunnable</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        currentLongingTaskCount = longingTaskCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LongPollingRunnable 类主要用于检查本地配置，以及长轮询地去服务端获取变更配置的 dataid 和 group，其代码位于 com.alibaba.nacos.client.config.impl.ClientWorker 类，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LongPollingRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> taskId;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LongPollingRunnable</span><span class="params">(<span class="type">int</span> taskId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskId = taskId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;CacheData&gt; cacheDatas = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;CacheData&gt;();</span><br><span class="line">        List&lt;String&gt; inInitializingCacheList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// check failover config</span></span><br><span class="line">            <span class="comment">// 遍历本地缓存的配置</span></span><br><span class="line">            <span class="keyword">for</span> (CacheData cacheData : cacheMap.values()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cacheData.getTaskId() == taskId) &#123;</span><br><span class="line">                    cacheDatas.add(cacheData);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 检查本地配置</span></span><br><span class="line">                        checkLocalConfig(cacheData);</span><br><span class="line">                        <span class="keyword">if</span> (cacheData.isUseLocalConfigInfo()) &#123;</span><br><span class="line">                            cacheData.checkListenerMd5();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        LOGGER.error(<span class="string">&quot;get local config info error&quot;</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// check server config</span></span><br><span class="line">            <span class="comment">// 通过长轮询检查服务端配置</span></span><br><span class="line">            List&lt;String&gt; changedGroupKeys = checkUpdateDataIds(cacheDatas, inInitializingCacheList);</span><br><span class="line">            <span class="keyword">if</span> (!CollectionUtils.isEmpty(changedGroupKeys)) &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;get changedGroupKeys:&quot;</span> + changedGroupKeys);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (String groupKey : changedGroupKeys) &#123;</span><br><span class="line">                String[] key = GroupKey.parseKey(groupKey);</span><br><span class="line">                <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> key[<span class="number">0</span>];</span><br><span class="line">                <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> key[<span class="number">1</span>];</span><br><span class="line">                <span class="type">String</span> <span class="variable">tenant</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (key.length == <span class="number">3</span>) &#123;</span><br><span class="line">                    tenant = key[<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String[] ct = getServerConfig(dataId, group, tenant, <span class="number">3000L</span>);</span><br><span class="line">                    <span class="type">CacheData</span> <span class="variable">cache</span> <span class="operator">=</span> cacheMap.get(GroupKey.getKeyTenant(dataId, group, tenant));</span><br><span class="line">                    cache.setContent(ct[<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">null</span> != ct[<span class="number">1</span>]) &#123;</span><br><span class="line">                        cache.setType(ct[<span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    LOGGER.info(<span class="string">&quot;[&#123;&#125;] [data-received] dataId=&#123;&#125;, group=&#123;&#125;, tenant=&#123;&#125;, md5=&#123;&#125;, content=&#123;&#125;, type=&#123;&#125;&quot;</span>,</span><br><span class="line">                            agent.getName(), dataId, group, tenant, cache.getMd5(),</span><br><span class="line">                            ContentUtils.truncateContent(ct[<span class="number">0</span>]), ct[<span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException ioe) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String</span><br><span class="line">                            .format(<span class="string">&quot;[%s] [get-update] get changed config exception. dataId=%s, group=%s, tenant=%s&quot;</span>,</span><br><span class="line">                                    agent.getName(), dataId, group, tenant);</span><br><span class="line">                    LOGGER.error(message, ioe);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (CacheData cacheData : cacheDatas) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cacheData.isInitializing() || inInitializingCacheList</span><br><span class="line">                        .contains(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant))) &#123;</span><br><span class="line">                    cacheData.checkListenerMd5();</span><br><span class="line">                    cacheData.setInitializing(<span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            inInitializingCacheList.clear();</span><br><span class="line">            </span><br><span class="line">            executorService.execute(<span class="built_in">this</span>);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// If the rotation training task is abnormal, the next execution time of the task will be punished</span></span><br><span class="line">            LOGGER.error(<span class="string">&quot;longPolling error : &quot;</span>, e);</span><br><span class="line">            executorService.schedule(<span class="built_in">this</span>, taskPenaltyTime, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面有个 checkUpdateDataIds 方法，用于获取发生变更了的配置文件的dataId列表，它同样位于 ClientWorker 内。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fetch the dataId list from server.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cacheDatas              CacheDatas for config infomations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inInitializingCacheList initial cache lists.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String include dataId and group (ps: it maybe null).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception Exception.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;String&gt; <span class="title function_">checkUpdateDataIds</span><span class="params">(List&lt;CacheData&gt; cacheDatas, List&lt;String&gt; inInitializingCacheList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 拼接出配置文件的唯一标识</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (CacheData cacheData : cacheDatas) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cacheData.isUseLocalConfigInfo()) &#123;</span><br><span class="line">            sb.append(cacheData.dataId).append(WORD_SEPARATOR);</span><br><span class="line">            sb.append(cacheData.group).append(WORD_SEPARATOR);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(cacheData.tenant)) &#123;</span><br><span class="line">                sb.append(cacheData.getMd5()).append(LINE_SEPARATOR);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(cacheData.getMd5()).append(WORD_SEPARATOR);</span><br><span class="line">                sb.append(cacheData.getTenant()).append(LINE_SEPARATOR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cacheData.isInitializing()) &#123;</span><br><span class="line">                <span class="comment">// It updates when cacheData occours in cacheMap by first time.</span></span><br><span class="line">                inInitializingCacheList</span><br><span class="line">                        .add(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isInitializingCacheList</span> <span class="operator">=</span> !inInitializingCacheList.isEmpty();</span><br><span class="line">    <span class="keyword">return</span> checkUpdateConfigStr(sb.toString(), isInitializingCacheList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fetch the updated dataId list from server.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> probeUpdateString       updated attribute string value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> isInitializingCacheList initial cache lists.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The updated dataId list(ps: it maybe null).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException Exception.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;String&gt; <span class="title function_">checkUpdateConfigStr</span><span class="params">(String probeUpdateString, <span class="type">boolean</span> isInitializingCacheList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    </span><br><span class="line">    Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">2</span>);</span><br><span class="line">    params.put(Constants.PROBE_MODIFY_REQUEST, probeUpdateString);</span><br><span class="line">    Map&lt;String, String&gt; headers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 长轮询的超时时间</span></span><br><span class="line">    headers.put(<span class="string">&quot;Long-Pulling-Timeout&quot;</span>, <span class="string">&quot;&quot;</span> + timeout);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// told server do not hang me up if new initializing cacheData added in</span></span><br><span class="line">    <span class="keyword">if</span> (isInitializingCacheList) &#123;</span><br><span class="line">        headers.put(<span class="string">&quot;Long-Pulling-Timeout-No-Hangup&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(probeUpdateString)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// In order to prevent the server from handling the delay of the client&#x27;s long task,</span></span><br><span class="line">        <span class="comment">// increase the client&#x27;s read timeout to avoid this problem.</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">readTimeoutMs</span> <span class="operator">=</span> timeout + (<span class="type">long</span>) Math.round(timeout &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 向服务端发起一个http请求，该请求在服务端配置没有变更的情况下默认会hang住30s</span></span><br><span class="line">        HttpRestResult&lt;String&gt; result = agent</span><br><span class="line">                .httpPost(Constants.CONFIG_CONTROLLER_PATH + <span class="string">&quot;/listener&quot;</span>, headers, params, agent.getEncode(),</span><br><span class="line">                        readTimeoutMs);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (result.ok()) &#123;</span><br><span class="line">            setHealthServer(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 响应状态是成功则解析响应体得到 dataId、group、tenant 等信息并返回</span></span><br><span class="line">            <span class="keyword">return</span> parseUpdateDataIdResponse(result.getData());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setHealthServer(<span class="literal">false</span>);</span><br><span class="line">            LOGGER.error(<span class="string">&quot;[&#123;&#125;] [check-update] get changed dataId error, code: &#123;&#125;&quot;</span>, agent.getName(),</span><br><span class="line">                    result.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        setHealthServer(<span class="literal">false</span>);</span><br><span class="line">        LOGGER.error(<span class="string">&quot;[&quot;</span> + agent.getName() + <span class="string">&quot;] [check-update] get changed dataId exception&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端对 listener 接口的请求会进入到服务端的 com.alibaba.nacos.config.server.controller.ConfigController#listener 方法进行处理，该方法主要是调用了 com.alibaba.nacos.config.server.controller.ConfigServletInner#doPollingConfig 方法。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 轮询接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doPollingConfig</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                              Map&lt;String, String&gt; clientMd5Map, <span class="type">int</span> probeRequestSize)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果支持长轮询则进入长轮询的流程</span></span><br><span class="line">    <span class="keyword">if</span> (LongPollingService.isSupportLongPolling(request)) &#123;</span><br><span class="line">        longPollingService.addLongPollingClient(request, response, clientMd5Map, probeRequestSize);</span><br><span class="line">        <span class="keyword">return</span> HttpServletResponse.SC_OK + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// else 兼容短轮询逻辑</span></span><br><span class="line">    List&lt;String&gt; changedGroups = MD5Util.compareMd5(request, response, clientMd5Map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 兼容短轮询result</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">oldResult</span> <span class="operator">=</span> MD5Util.compareMd5OldResult(changedGroups);</span><br><span class="line">    <span class="type">String</span> <span class="variable">newResult</span> <span class="operator">=</span> MD5Util.compareMd5ResultString(changedGroups);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> request.getHeader(Constants.CLIENT_VERSION_HEADER);</span><br><span class="line">    <span class="keyword">if</span> (version == <span class="literal">null</span>) &#123;</span><br><span class="line">        version = <span class="string">&quot;2.0.0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">versionNum</span> <span class="operator">=</span> Protocol.getVersionNumber(version);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.0.4版本以前, 返回值放入header中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (versionNum &lt; START_LONGPOLLING_VERSION_NUM) &#123;</span><br><span class="line">        response.addHeader(Constants.PROBE_MODIFY_RESPONSE, oldResult);</span><br><span class="line">        response.addHeader(Constants.PROBE_MODIFY_RESPONSE_NEW, newResult);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        request.setAttribute(<span class="string">&quot;content&quot;</span>, newResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用缓存</span></span><br><span class="line">    response.setHeader(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">    response.setDateHeader(<span class="string">&quot;Expires&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache,no-store&quot;</span>);</span><br><span class="line">    response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">    <span class="keyword">return</span> HttpServletResponse.SC_OK + <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们主要关注上面的 com.alibaba.nacos.config.server.service.LongPollingService#addLongPollingClient 长轮询流程的方法。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLongPollingClient</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp, Map&lt;String, String&gt; clientMd5Map,</span></span><br><span class="line"><span class="params">                                 <span class="type">int</span> probeRequestSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> req.getHeader(LongPollingService.LONG_POLLING_HEADER);</span><br><span class="line">    <span class="type">String</span> <span class="variable">noHangUpFlag</span> <span class="operator">=</span> req.getHeader(LongPollingService.LONG_POLLING_NO_HANG_UP_HEADER);</span><br><span class="line">    <span class="type">String</span> <span class="variable">appName</span> <span class="operator">=</span> req.getHeader(RequestUtil.CLIENT_APPNAME_HEADER);</span><br><span class="line">    <span class="type">String</span> <span class="variable">tag</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;Vipserver-Tag&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">delayTime</span> <span class="operator">=</span> SwitchService.getSwitchInteger(SwitchService.FIXED_DELAY_TIME, <span class="number">500</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提前500ms返回响应，为避免客户端超时 <span class="doctag">@qiaoyi</span>.dingqy 2013.10.22改动  add delay time for LoadBalance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">timeout</span> <span class="operator">=</span> Math.max(<span class="number">10000</span>, Long.parseLong(str) - delayTime);</span><br><span class="line">    <span class="keyword">if</span> (isFixedPolling()) &#123;</span><br><span class="line">        timeout = Math.max(<span class="number">10000</span>, getFixedPollingInterval());</span><br><span class="line">        <span class="comment">// do nothing but set fix polling timeout</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        List&lt;String&gt; changedGroups = MD5Util.compareMd5(req, rsp, clientMd5Map);</span><br><span class="line">        <span class="keyword">if</span> (changedGroups.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            generateResponse(req, rsp, changedGroups);</span><br><span class="line">            LogUtil.clientLog.info(<span class="string">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class="line">                System.currentTimeMillis() - start, <span class="string">&quot;instant&quot;</span>, RequestUtil.getRemoteIp(req), <span class="string">&quot;polling&quot;</span>,</span><br><span class="line">                clientMd5Map.size(), probeRequestSize, changedGroups.size());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (noHangUpFlag != <span class="literal">null</span> &amp;&amp; noHangUpFlag.equalsIgnoreCase(TRUE_STR)) &#123;</span><br><span class="line">            LogUtil.clientLog.info(<span class="string">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>, System.currentTimeMillis() - start, <span class="string">&quot;nohangup&quot;</span>,</span><br><span class="line">                RequestUtil.getRemoteIp(req), <span class="string">&quot;polling&quot;</span>, clientMd5Map.size(), probeRequestSize,</span><br><span class="line">                changedGroups.size());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> RequestUtil.getRemoteIp(req);</span><br><span class="line">    <span class="comment">// 一定要由HTTP线程调用，否则离开后容器会立即发送响应</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AsyncContext</span> <span class="variable">asyncContext</span> <span class="operator">=</span> req.startAsync();</span><br><span class="line">    <span class="comment">// AsyncContext.setTimeout()的超时时间不准，所以只能自己控制</span></span><br><span class="line">    asyncContext.setTimeout(<span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ClientLongPolling 的 run 方法会将 ClientLongPolling 实例（携带了本次请求的相关信息）放入 allSubs 中，然后会在29.5s后再执行另一个 Runnable，该 Runnable 用于等待29.5s后依旧没有相应的配置变更时对客户端进行响应，并将相应的 ClientLongPolling 实例从 allSubs 中移出</span></span><br><span class="line">    scheduler.execute(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClientLongPolling</span>(asyncContext, clientMd5Map, ip, probeRequestSize, timeout, appName, tag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 LongPollingService 实现了 AbstractEventListener，也就是说能接收事件通知，在其 com.alibaba.nacos.config.server.service.LongPollingService#onEvent 方法中可以看到，它关注的是 LocalDataChangeEvent 事件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFixedPolling()) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> LocalDataChangeEvent) &#123;</span><br><span class="line">            <span class="type">LocalDataChangeEvent</span> <span class="variable">evt</span> <span class="operator">=</span> (LocalDataChangeEvent)event;</span><br><span class="line">            scheduler.execute(<span class="keyword">new</span> <span class="title class_">DataChangeTask</span>(evt.groupKey, evt.isBeta, evt.betaIps));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在nacos上修改配置后就会产生 LocalDataChangeEvent 事件，此时 LongPollingService 也就能监听到，当收到该事件时就会遍历 allSubs，找到匹配的请求并将 groupKey 返回给客户端。具体代码在 DataChangeTask 中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataChangeTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ConfigService.getContentBetaMd5(groupKey);</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;ClientLongPolling&gt; iter = allSubs.iterator(); iter.hasNext(); ) &#123;</span><br><span class="line">                <span class="type">ClientLongPolling</span> <span class="variable">clientSub</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                <span class="keyword">if</span> (clientSub.clientMd5Map.containsKey(groupKey)) &#123;</span><br><span class="line">                    <span class="comment">// 如果beta发布且不在beta列表直接跳过</span></span><br><span class="line">                    <span class="keyword">if</span> (isBeta &amp;&amp; !betaIps.contains(clientSub.ip)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果tag发布且不在tag列表直接跳过</span></span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotBlank(tag) &amp;&amp; !tag.equals(clientSub.tag)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    getRetainIps().put(clientSub.ip, System.currentTimeMillis());</span><br><span class="line">                    iter.remove(); <span class="comment">// 删除订阅关系</span></span><br><span class="line">                    LogUtil.clientLog.info(<span class="string">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class="line">                        (System.currentTimeMillis() - changeTime),</span><br><span class="line">                        <span class="string">&quot;in-advance&quot;</span>,</span><br><span class="line">                        RequestUtil.getRemoteIp((HttpServletRequest)clientSub.asyncContext.getRequest()),</span><br><span class="line">                        <span class="string">&quot;polling&quot;</span>,</span><br><span class="line">                        clientSub.clientMd5Map.size(), clientSub.probeRequestSize, groupKey);</span><br><span class="line">                    clientSub.sendResponse(Arrays.asList(groupKey));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            LogUtil.defaultLog.error(<span class="string">&quot;data change error:&quot;</span> + t.getMessage(), t.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DataChangeTask(String groupKey) &#123;</span><br><span class="line">        <span class="built_in">this</span>(groupKey, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DataChangeTask(String groupKey, <span class="type">boolean</span> isBeta, List&lt;String&gt; betaIps) &#123;</span><br><span class="line">        <span class="built_in">this</span>(groupKey, isBeta, betaIps, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DataChangeTask(String groupKey, <span class="type">boolean</span> isBeta, List&lt;String&gt; betaIps, String tag) &#123;</span><br><span class="line">        <span class="built_in">this</span>.groupKey = groupKey;</span><br><span class="line">        <span class="built_in">this</span>.isBeta = isBeta;</span><br><span class="line">        <span class="built_in">this</span>.betaIps = betaIps;</span><br><span class="line">        <span class="built_in">this</span>.tag = tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String groupKey;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">changeTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> isBeta;</span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; betaIps;</span><br><span class="line">    <span class="keyword">final</span> String tag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当客户端收到变更的dataid+group后，就会去服务端获取最新的配置数据，并更新本地数据 cacheData，然后发送数据变更事件，整个流程结束。</p><ul><li>获取服务端最新配置数据的方法：com.alibaba.nacos.client.config.impl.ClientWorker#getServerConfig</li><li>发送数据变更事件的方法：com.alibaba.nacos.client.config.impl.CacheData#checkListenerMd5</li></ul><h2 id="Sentienl"><a href="#Sentienl" class="headerlink" title="Sentienl"></a>Sentienl</h2><p>Sentinel是阿里巴巴开源的一款流量控制和熔断降级框架，主要用于微服务架构中服务的流量控制和熔断降级。其限流实现原理主要分为两个部分：</p><blockquote><p>统计信息收集</p></blockquote><p>Sentinel会在运行过程中对服务的各种统计信息进行收集，包括请求的响应时间、请求通过的QPS（每秒查询率）、线程池队列大小等指标。这些指标通过定义的规则进行分析，判断当前请求是否超过了设定的阈值。</p><blockquote><p>阈值判断</p></blockquote><p>Sentinel根据收集到的统计信息，通过定义的规则对请求进行判断。规则中包括以下几个要素：</p><p>资源名：对哪个资源进行限流<br>流控模式：直接拒绝或者匀速通过<br>流控阈值：单位时间内允许通过的请求个数<br>统计时间窗口：多长时间内统计一次流量，单位秒<br>降级处理：当请求超过阈值时的处理策略，如直接拒绝、返回默认值等<br>Sentinel会根据以上规则进行限流，当请求超过阈值时，根据设置的降级处理策略进行处理，比如直接拒绝请求、返回默认值等。同时，Sentinel还可以进行自适应的流控，根据实际情况调整阈值，保证服务的可用性和稳定性。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="Slot-插槽"><a href="#Slot-插槽" class="headerlink" title="Slot 插槽"></a>Slot 插槽</h4><p>在 Sentinel 里面，所有的资源都对应一个资源名称（resourceName），每次资源调用都会创建一个 Entry 对象。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 SphU API 显式创建。Entry 创建的时候，同时也会创建一系列功能插槽（slot chain），这些插槽有不同的职责，例如:</p><ul><li>NodeSelectorSlot 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</li><li>ClusterBuilderSlot 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；</li><li>StatisticSlot 则用于记录、统计不同纬度的 runtime 指标监控信息；</li><li>FlowSlot 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；</li><li>AuthoritySlot 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li><li>DegradeSlot 则通过统计信息以及预设的规则，来做熔断降级；</li><li>SystemSlot 则通过系统的状态，例如 load1 等，来控制总的入口流量；</li></ul><p>Sentinel 提供了插槽接口 ProcessorSlot，其中提供了方法 enrty 处理进入请求 和 exit 处理请求结束操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProcessorSlot</span>&lt;T&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Entrance of this slot.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context         current &#123;<span class="doctag">@link</span> Context&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resourceWrapper current resource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param           generics parameter, usually is a &#123;<span class="doctag">@link</span> com.alibaba.csp.sentinel.node.Node&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count           tokens needed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prioritized     whether the entry is prioritized</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args            parameters of the original call</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable blocked exception or unexpected error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, T param, <span class="type">int</span> count, <span class="type">boolean</span> prioritized,</span></span><br><span class="line"><span class="params">               Object... args)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Means finish of &#123;<span class="doctag">@link</span> #entry(Context, ResourceWrapper, Object, int, boolean, Object...)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context         current &#123;<span class="doctag">@link</span> Context&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resourceWrapper current resource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj             relevant object (e.g. Node)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count           tokens needed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prioritized     whether the entry is prioritized</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args            parameters of the original call</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable blocked exception or unexpected error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fireEntry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, Object obj, <span class="type">int</span> count, <span class="type">boolean</span> prioritized,</span></span><br><span class="line"><span class="params">                   Object... args)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exit of this slot.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context         current &#123;<span class="doctag">@link</span> Context&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resourceWrapper current resource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count           tokens needed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args            parameters of the original call</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(Context context, ResourceWrapper resourceWrapper, <span class="type">int</span> count, Object... args)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Means finish of &#123;<span class="doctag">@link</span> #exit(Context, ResourceWrapper, int, Object...)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context         current &#123;<span class="doctag">@link</span> Context&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resourceWrapper current resource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count           tokens needed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args            parameters of the original call</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fireExit</span><span class="params">(Context context, ResourceWrapper resourceWrapper, <span class="type">int</span> count, Object... args)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体的框架如下:</p><p><img src="/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/3.png" alt="结构图"></p><p>Sentinel 将 SlotChainBuilder 作为 SPI 接口进行扩展，使得 Slot Chain 具备了扩展的能力。您可以自行加入自定义的 slot 并编排 slot 间的顺序，从而可以给 Sentinel 添加自定义的功能。</p><p><img src="/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/4.png" alt="Sentinel图"></p><h4 id="RuleManager-规则管理器"><a href="#RuleManager-规则管理器" class="headerlink" title="RuleManager 规则管理器"></a>RuleManager 规则管理器</h4><p>每个 Slot 插槽背后都对应着一个 RuleManager 的实现类，简单理解就是每个 Slot 有一套规则，规则验证处理由对应的 RuleManager 来进行处理。</p><p>流量控制：FlowSolt 对应 FlowRuleManager</p><p>降级控制：DegradeSlot  对应 DegradeRuleManager</p><p>权限控制：AuthoritySlot 对应 AuthorityRuleManager</p><p>系统规则控制： SystemSlot 对应 SystemRuleManager</p><h4 id="降级控制实现原理"><a href="#降级控制实现原理" class="headerlink" title="降级控制实现原理"></a>降级控制实现原理</h4><ol><li>新增资源配置降级规则，目前对于降级策有如下三种：</li></ol><p>RT：平均响应时间 (DEGRADE_GRADE_RT)：当 1s 内持续进入 5 个请求，对应时刻的平均响应时间（秒级）均超过阈值（count，以 ms 为单位），那么在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt&#x3D;xxx 来配置。</p><p><img src="/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/5.png" alt="平均响应图"></p><p>异常比例：当资源的每秒请求量 &gt;&#x3D; 5，并且每秒异常总数占通过量的比值超过阈值（DegradeRule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</p><p><img src="/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/6.png" alt="异常比例图"></p><p>异常数：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。</p><p><img src="/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/7.png" alt="异常数图"></p><p>限流结果信息</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Blocked by Sentinel (flow limiting)</span><br></pre></td></tr></table></figure><ol start="2"><li>实现逻辑</li></ol><p>在之前我们已经提及 Sentinel 是通过 slot 链来实现的，对于降级功能其提供了 DegradeSlot，实现源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DegradeSlot</span> <span class="keyword">extends</span> <span class="title class_">AbstractLinkedProcessorSlot</span>&lt;DefaultNode&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="type">int</span> count, <span class="type">boolean</span> prioritized, Object... args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        DegradeRuleManager.checkDegrade(resourceWrapper, context, node, count);</span><br><span class="line">        fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(Context context, ResourceWrapper resourceWrapper, <span class="type">int</span> count, Object... args)</span> &#123;</span><br><span class="line">        fireExit(context, resourceWrapper, count, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码我们可以了解到，限流规则的实现是在 DegradeRuleManager 的checkDegrade中来处理的，限流可以-配置多个规则，依次按照规则来处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkDegrade</span><span class="params">(ResourceWrapper resource, Context context, DefaultNode node, <span class="type">int</span> count)</span></span><br><span class="line">        <span class="keyword">throws</span> BlockException &#123;</span><br><span class="line"> </span><br><span class="line">        Set&lt;DegradeRule&gt; rules = degradeRules.get(resource.getName());</span><br><span class="line">        <span class="keyword">if</span> (rules == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (DegradeRule rule : rules) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!rule.passCheck(context, node, count)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DegradeException</span>(rule.getLimitApp(), rule);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在 DegradeRule 的 passCheck 方法中我们可以看到可以根据 RT、异常数和异常比例来进行熔断降级处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">passCheck</span><span class="params">(Context context, DefaultNode node, <span class="type">int</span> acquireCount, Object... args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cut.get()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="type">ClusterNode</span> <span class="variable">clusterNode</span> <span class="operator">=</span> ClusterBuilderSlot.getClusterNode(<span class="built_in">this</span>.getResource());</span><br><span class="line">        <span class="keyword">if</span> (clusterNode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 请求处理时间</span></span><br><span class="line">        <span class="keyword">if</span> (grade == RuleConstant.DEGRADE_GRADE_RT) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">rt</span> <span class="operator">=</span> clusterNode.avgRt();</span><br><span class="line">            <span class="keyword">if</span> (rt &lt; <span class="built_in">this</span>.count) &#123;</span><br><span class="line">                passCount.set(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Sentinel will degrade the service only if count exceeds.</span></span><br><span class="line">            <span class="keyword">if</span> (passCount.incrementAndGet() &lt; rtSlowRequestAmount) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO) &#123;</span><br><span class="line"><span class="comment">//异常比例</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">exception</span> <span class="operator">=</span> clusterNode.exceptionQps();</span><br><span class="line">            <span class="type">double</span> <span class="variable">success</span> <span class="operator">=</span> clusterNode.successQps();</span><br><span class="line">            <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> clusterNode.totalQps();</span><br><span class="line">            <span class="comment">// If total amount is less than minRequestAmount, the request will pass.</span></span><br><span class="line">            <span class="keyword">if</span> (total &lt; minRequestAmount) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// In the same aligned statistic time window,</span></span><br><span class="line">            <span class="comment">// &quot;success&quot; (aka. completed count) = exception count + non-exception count (realSuccess)</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">realSuccess</span> <span class="operator">=</span> success - exception;</span><br><span class="line">            <span class="keyword">if</span> (realSuccess &lt;= <span class="number">0</span> &amp;&amp; exception &lt; minRequestAmount) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (exception / success &lt; count) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT) &#123;</span><br><span class="line"><span class="comment">//异常数</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">exception</span> <span class="operator">=</span> clusterNode.totalException();</span><br><span class="line">            <span class="keyword">if</span> (exception &lt; count) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (cut.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="type">ResetTask</span> <span class="variable">resetTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResetTask</span>(<span class="built_in">this</span>);</span><br><span class="line">            pool.schedule(resetTask, timeWindow, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="流量控制实现原理"><a href="#流量控制实现原理" class="headerlink" title="流量控制实现原理"></a>流量控制实现原理</h4><p>接下来我们了解学习一下 Sentinel 是如何实现流量控制的</p><p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。</p><p>FlowSlot 会根据预设的规则，结合前面 NodeSelectorSlot、ClusterNodeBuilderSlot、StatisticSlot 统计出来的实时信息进行流量控制。</p><p>限流的直接表现是在执行 Entry nodeA &#x3D; SphU.entry(resourceName) 的时候抛出 FlowException 异常。FlowException 是 BlockException 的子类，您可以捕捉 BlockException 来自定义被限流之后的处理逻辑。</p><p>同一个资源可以创建多条限流规则。FlowSlot 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。</p><p>一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：</p><ul><li>resource：资源名，即限流规则的作用对象</li><li>count: 限流阈值</li><li>grade: 限流阈值类型（QPS 或并发线程数）</li><li>limitApp: 流控针对的调用来源，若为 default 则不区分调用来源</li><li>strategy: 调用关系限流策略</li><li>controlBehavior: 流量控制效果（直接拒绝、Warm Up、匀速排队）</li></ul><p>流控-QPS配置</p><p><img src="/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/8.png" alt="QPS配置图"></p><p>流控-线程数配置</p><p><img src="/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/9.png" alt="流控图"></p><h5 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h5><p>Sentinel 提供了 FlowSlot 用来进行流量控制，流量规则的最终实现在 FlowRuleChecker 的 checkFlow 中实现的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlowSlot</span> <span class="keyword">extends</span> <span class="title class_">AbstractLinkedProcessorSlot</span>&lt;DefaultNode&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FlowRuleChecker checker;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FlowSlot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">FlowRuleChecker</span>());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Package-private for test.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> checker flow rule checker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6.1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FlowSlot(FlowRuleChecker checker) &#123;</span><br><span class="line">        AssertUtil.notNull(checker, <span class="string">&quot;flow checker should not be null&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.checker = checker;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="type">int</span> count,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> prioritized, Object... args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        checkFlow(resourceWrapper, context, node, count, prioritized);</span><br><span class="line"> </span><br><span class="line">        fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">checkFlow</span><span class="params">(ResourceWrapper resource, Context context, DefaultNode node, <span class="type">int</span> count, <span class="type">boolean</span> prioritized)</span></span><br><span class="line">        <span class="keyword">throws</span> BlockException &#123;</span><br><span class="line">        checker.checkFlow(ruleProvider, resource, context, node, count, prioritized);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(Context context, ResourceWrapper resourceWrapper, <span class="type">int</span> count, Object... args)</span> &#123;</span><br><span class="line">        fireExit(context, resourceWrapper, count, args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;String, Collection&lt;FlowRule&gt;&gt; ruleProvider = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Collection&lt;FlowRule&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Collection&lt;FlowRule&gt; <span class="title function_">apply</span><span class="params">(String resource)</span> &#123;</span><br><span class="line">            <span class="comment">// Flow rule map should not be null.</span></span><br><span class="line">            Map&lt;String, List&lt;FlowRule&gt;&gt; flowRules = FlowRuleManager.getFlowRuleMap();</span><br><span class="line">            <span class="keyword">return</span> flowRules.get(resource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 checkFlow 中会依次获取我们配置的流控规则，然后依次进行流控判断处理，如果被流控则抛出异常 FlowException</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFlow</span><span class="params">(Function&lt;String, Collection&lt;FlowRule&gt;&gt; ruleProvider, ResourceWrapper resource,</span></span><br><span class="line"><span class="params">                          Context context, DefaultNode node, <span class="type">int</span> count, <span class="type">boolean</span> prioritized)</span> <span class="keyword">throws</span> BlockException &#123;</span><br><span class="line">        <span class="keyword">if</span> (ruleProvider == <span class="literal">null</span> || resource == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Collection&lt;FlowRule&gt; rules = ruleProvider.apply(resource.getName());</span><br><span class="line">        <span class="keyword">if</span> (rules != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (FlowRule rule : rules) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!canPassCheck(rule, context, node, count, prioritized)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FlowException</span>(rule.getLimitApp(), rule);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在 canPassCheck 中会判断是集群限流还是本地限流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPassCheck</span><span class="params">(<span class="comment">/*@NonNull*/</span> FlowRule rule, Context context, DefaultNode node, <span class="type">int</span> acquireCount,</span></span><br><span class="line"><span class="params">                                                    <span class="type">boolean</span> prioritized)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">limitApp</span> <span class="operator">=</span> rule.getLimitApp();</span><br><span class="line">        <span class="keyword">if</span> (limitApp == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (rule.isClusterMode()) &#123;</span><br><span class="line">            <span class="keyword">return</span> passClusterCheck(rule, context, node, acquireCount, prioritized);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> passLocalCheck(rule, context, node, acquireCount, prioritized);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果是本地限流则获取节点信息，然后根据流控规则进行流控判断</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">passLocalCheck</span><span class="params">(FlowRule rule, Context context, DefaultNode node, <span class="type">int</span> acquireCount,</span></span><br><span class="line"><span class="params">                                          <span class="type">boolean</span> prioritized)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">selectedNode</span> <span class="operator">=</span> selectNodeByRequesterAndStrategy(rule, context, node);</span><br><span class="line">        <span class="keyword">if</span> (selectedNode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> rule.getRater().canPass(selectedNode, acquireCount, prioritized);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当 QPS 超过某个阈值的时候，则采取措施进行流量控制。流量控制的手段包括以下几种：直接拒绝、Warm Up、匀速排队。对应 FlowRule 中的 controlBehavior 字段。</p><p>直接拒绝（RuleConstant.CONTROL_BEHAVIOR_DEFAULT）方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。具体的例子参见 FlowQpsDemo。</p><p>Warm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）方式，即预热&#x2F;冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。详细文档可以参考 流量控制 - Warm Up 文档</p><p>目前 Sentinel 对于流量控制提供了如下几种方式：</p><ul><li>直接拒绝（DefaultController）：支持抛出异常<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPass</span><span class="params">(Node node, <span class="type">int</span> acquireCount, <span class="type">boolean</span> prioritized)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">curCount</span> <span class="operator">=</span> avgUsedTokens(node);</span><br><span class="line">    <span class="keyword">if</span> (curCount + acquireCount &gt; count) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prioritized &amp;&amp; grade == RuleConstant.FLOW_GRADE_QPS) &#123;</span><br><span class="line">            <span class="type">long</span> currentTime;</span><br><span class="line">            <span class="type">long</span> waitInMs;</span><br><span class="line">            currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">            waitInMs = node.tryOccupyNext(currentTime, acquireCount, count);</span><br><span class="line">            <span class="keyword">if</span> (waitInMs &lt; OccupyTimeoutProperty.getOccupyTimeout()) &#123;</span><br><span class="line">                node.addWaitingRequest(currentTime + waitInMs, acquireCount);</span><br><span class="line">                node.addOccupiedPass(acquireCount);</span><br><span class="line">                sleep(waitInMs);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// PriorityWaitException indicates that the request will pass after waiting for &#123;@link @waitInMs&#125;.</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PriorityWaitException</span>(waitInMs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>匀速排队（RateLimiterController）：判断等待时间，如果等待时间过长也是会限流，并且使用 Thread.sleep 如果配置不正确可能会导致线程过多。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPass</span><span class="params">(Node node, <span class="type">int</span> acquireCount, <span class="type">boolean</span> prioritized)</span> &#123;</span><br><span class="line">        <span class="comment">// Pass when acquire count is less or equal than 0.</span></span><br><span class="line">        <span class="keyword">if</span> (acquireCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Reject when count is less or equal than 0.</span></span><br><span class="line">        <span class="comment">// Otherwise,the costTime will be max of long and waitTime will overflow in some cases.</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> TimeUtil.currentTimeMillis();</span><br><span class="line">        <span class="comment">// Calculate the interval between every two requests.</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">costTime</span> <span class="operator">=</span> Math.round(<span class="number">1.0</span> * (acquireCount) / count * <span class="number">1000</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Expected pass time of this request.</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">expectedTime</span> <span class="operator">=</span> costTime + latestPassedTime.get();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (expectedTime &lt;= currentTime) &#123;</span><br><span class="line">            <span class="comment">// Contention may exist here, but it&#x27;s okay.</span></span><br><span class="line">            latestPassedTime.set(currentTime);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Calculate the time to wait.</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">oldTime</span> <span class="operator">=</span> latestPassedTime.addAndGet(costTime);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    waitTime = oldTime - TimeUtil.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class="line">                        latestPassedTime.addAndGet(-costTime);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// in race condition waitTime may &lt;= 0</span></span><br><span class="line">                    <span class="keyword">if</span> (waitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Thread.sleep(waitTime);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>Warm Up（WarmUpController 和 WarmUpRateLimiterController）：预热启动<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPass</span><span class="params">(Node node, <span class="type">int</span> acquireCount, <span class="type">boolean</span> prioritized)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">passQps</span> <span class="operator">=</span> (<span class="type">long</span>) node.passQps();</span><br><span class="line"> </span><br><span class="line">    <span class="type">long</span> <span class="variable">previousQps</span> <span class="operator">=</span> (<span class="type">long</span>) node.previousPassQps();</span><br><span class="line">    syncToken(previousQps);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 开始计算它的斜率</span></span><br><span class="line">    <span class="comment">// 如果进入了警戒线，开始调整他的qps</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">restToken</span> <span class="operator">=</span> storedTokens.get();</span><br><span class="line">    <span class="keyword">if</span> (restToken &gt;= warningToken) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">aboveToken</span> <span class="operator">=</span> restToken - warningToken;</span><br><span class="line">        <span class="comment">// 消耗的速度要比warning快，但是要比慢</span></span><br><span class="line">        <span class="comment">// current interval = restToken*slope+1/count</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">warningQps</span> <span class="operator">=</span> Math.nextUp(<span class="number">1.0</span> / (aboveToken * slope + <span class="number">1.0</span> / count));</span><br><span class="line">        <span class="keyword">if</span> (passQps + acquireCount &lt;= warningQps) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (passQps + acquireCount &lt;= count) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>Springmvc最热点面试题</title>
      
      <link href="/2024/05/26/Springmvc%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2024/05/26/Springmvc%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><img src="/./2024/05/26/Springmvc%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/1.png" alt="流程图"></p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><ol><li><strong>用户发送请求至前端控制器DispatcherServlet</strong><ol><li>DispatcherServlet：前端控制器。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性,系统扩展性提高。由框架实现</li><li>doService doDispatch(request, response);</li></ol></li><li><strong>DispatcherServlet收到请求调用处理器映射器HandlerMapping</strong><ol><li>HandlerMapping：处理器映射器。HandlerMapping负责根据用户请求的url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，根据一定的规则去查找,例如：xml配置方式，实现接口方式，注解方式等。由框架实现</li></ol></li><li><strong>处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet</strong></li><li><strong>DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作</strong><ol><li>Handler：处理器。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</li><li>将http报文转换为对象<ol><li>HttpMessageConverter接口<ol><li><code>canRead</code> http-&gt;object</li><li><code>canWrite</code> 对象的序列化输出</li></ol></li><li>HttpMessageConverter有很多的实现类，根据HTTP协议的Accept和Content-Type属性，以及参数数据类型来判别使用哪一种HttpMessageConverter</li></ol></li></ol></li><li><strong>执行处理器Handler(Controller，也叫页面控制器)</strong></li><li><strong>Handler执行完成返回ModelAndView</strong></li><li><strong>HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet</strong><ol><li>HandlAdapter：处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。由框架实现。</li></ol></li><li><strong>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</strong><ol><li>ModelAndView是springmvc的封装对象，将model和view封装在一起</li></ol></li><li><strong>ViewReslover解析后返回具体View</strong><ol><li>ViewResolver：视图解析器。ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户</li></ol></li><li><strong>DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）</strong><ol><li>View:是springmvc的封装对象，是一个接口, springmvc框架提供了很多的View视图类型，包括：jspview，pdfview,jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</li></ol></li><li><strong>DispatcherServlet响应用户</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springmvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>Springboot最热点面试题</title>
      
      <link href="/2024/05/26/Springboot%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2024/05/26/Springboot%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="springboot启动流程"><a href="#springboot启动流程" class="headerlink" title="springboot启动流程"></a>springboot启动流程</h2><h3 id="启动类上注解：-SpringBootApplication"><a href="#启动类上注解：-SpringBootApplication" class="headerlink" title="启动类上注解：@SpringBootApplication"></a>启动类上注解：@SpringBootApplication</h3><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><p>根据Javadoc可知，该注解作用就是将当前的类作为一个JavaConfig，然后触发注解@EnableAutoConfiguration和@ComponentScan的处理，本质上与@Configuration注解没有区别</p><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><p>@EnableAutoConfiguration:实现自动装配的核心注解</p><ul><li>@AutoConfigurationPackage<ul><li>注册当前启动类的根 package</li><li>注册 org.springframework.boot.autoconfigure.AutoConfigurationPackages 的 BeanDefinition</li></ul></li><li>@Import(AutoConfigurationImportSelector.class)<ul><li>自动装配核心功能的实现实际是通过 AutoConfigurationImportSelector(加载自动装配类)类</li><li>AutoConfigurationImportSelector 类实现了 ImportSelector接口<ul><li>实现了这个接口中的 selectImports方法<ul><li>方法实现 重要的getAutoConfigurationEntry()方法<ol><li>判断自动装配是否打开，默认是true可以通过application.yml设置</li><li>获取@EnableAutoConfiguration里的exclude和excludeName内容以便排除</li><li>获取需要自动装配的所有配置类，读取META-INF&#x2F;spring.factories druid 数据库连接池的 Spring Boot Starter 就创建了META-INF&#x2F;spring.factories文件</li><li>筛选满足@ConditionalOnXXX注解的类，生效才会被加载</li></ol></li><li>该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</li></ul></li></ul></li></ul></li></ul><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>扫描的 Spring 对应的组件，如 @Componet，@Repository</p><ul><li>我们可以通过 basePackages 等属性来细粒度的定制 @ComponentScan 自动扫描的范围，如果不指定，则默认Spring框架实现会从声明 @ComponentScan 所在类的package进行扫描，所以 SpringBoot 的启动类最好是放在根package下，我们自定义的类就放在对应的子package下，这样就可以不指定 basePackages</li></ul><h3 id="启动类中的main方法：org-springframework-boot-SpringApplication-run-java-lang-Class-java-lang-String…"><a href="#启动类中的main方法：org-springframework-boot-SpringApplication-run-java-lang-Class-java-lang-String…" class="headerlink" title="启动类中的main方法：org.springframework.boot.SpringApplication#run(java.lang.Class&lt;?&gt;, java.lang.String…)"></a>启动类中的main方法：org.springframework.boot.SpringApplication#run(java.lang.Class&lt;?&gt;, java.lang.String…)</h3><ul><li>从spring.factories配置文件中加载EventPublishingRunListener对象，该对象拥有SimpleApplicationEventMulticaster属性，即在SpringBoot启动过程的不同阶段用来发射内置的生命周期事件;<ul><li>spring-bean包下META-INF&#x2F;spring.factories</li></ul></li><li>准备环境变量，包括系统变量，环境变量，命令行参数，默认变量，servlet相关配置变量，随机值以及配置文件（比如application.properties）等;<ul><li>而后就会去创建Environment——这个时候会去加载application配置文件</li></ul></li><li>控制台打印SpringBoot的bannner标志；</li><li>根据不同类型环境创建不同类型的applicationcontext容器，因为这里是servlet环境，所以创建的是AnnotationConfigServletWebServerApplicationContext容器对象；</li><li>从spring.factories配置文件中加载FailureAnalyzers对象,用来报告SpringBoot启动过程中的异常；</li><li>为刚创建的容器对象做一些初始化工作，准备一些容器属性值等，对ApplicationContext应用一些相关的后置处理和调用各个ApplicationContextInitializer的初始化方法来执行一些初始化逻辑等；</li><li>刷新容器，这一步至关重要。比如调用bean factory的后置处理器，注册BeanPostProcessor后置处理器，初始化事件广播器且广播事件，初始化剩下的单例bean和SpringBoot创建内嵌的Tomcat服务器等等重要且复杂的逻辑都在这里实现，主要步骤可见代码的注释，关于这里的逻辑会在以后的spring源码分析专题详细分析；<ul><li>&#x2F;&#x2F; 1）在context刷新前做一些准备工作，比如初始化一些属性设置，属性合法性校验和保存容器中的一些早期事件等；</li><li>&#x2F;&#x2F; 2）让子类刷新其内部bean factory,注意SpringBoot和Spring启动的情况执行逻辑不一样</li><li>&#x2F;&#x2F; 3）对bean factory进行配置，比如配置bean factory的类加载器，后置处理器等</li><li>&#x2F;&#x2F; 4）完成bean factory的准备工作后，此时执行一些后置处理逻辑，子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置<ul><li>&#x2F;&#x2F; 在这一步，所有的bean definitions将会被加载，但此时bean还不会被实例化</li></ul></li><li>&#x2F;&#x2F; 5）执行BeanFactoryPostProcessor的方法即调用bean factory的后置处理器：<ul><li>&#x2F;&#x2F; BeanDefinitionRegistryPostProcessor（触发时机：bean定义注册之前）和BeanFactoryPostProcessor（触发时机：bean定义注册之后bean实例化之前）</li></ul></li><li>&#x2F;&#x2F; 6）注册bean的后置处理器BeanPostProcessor，注意不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的</li><li>&#x2F;&#x2F; 7）初始化国际化MessageSource相关的组件，比如消息绑定，消息解析等</li><li>&#x2F;&#x2F; 8）初始化事件广播器，如果bean factory没有包含事件广播器，那么new一个SimpleApplicationEventMulticaster广播器对象并注册到bean factory中</li><li>&#x2F;&#x2F; 9）AbstractApplicationContext定义了一个模板方法onRefresh，留给子类覆写，比如ServletWebServerApplicationContext覆写了该方法来创建内嵌的tomcat容器</li><li>&#x2F;&#x2F; 10）注册实现了ApplicationListener接口的监听器，之前已经有了事件广播器，此时就可以派发一些early application events</li><li>&#x2F;&#x2F; 11）完成容器bean factory的初始化，并初始化所有剩余的单例bean。这一步非常重要，一些bean postprocessor会在这里调用。</li><li>&#x2F;&#x2F; 12）完成容器的刷新工作，并且调用生命周期处理器的onRefresh()方法，并且发布ContextRefreshedEvent事件</li></ul></li><li>执行刷新容器后的后置处理逻辑，注意这里为空方法；</li><li>调用ApplicationRunner和CommandLineRunner的run方法，我们实现这两个接口可以在spring容器启动后需要的一些东西比如加载一些业务数据等;</li><li>报告启动异常，即若启动过程中抛出异常，此时用FailureAnalyzers来报告异常;</li><li>最终返回容器对象，这里调用方法没有声明对象来接收。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   SpringApplication.run(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[<span class="number">0</span>], args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;</span><br><span class="line">   <span class="comment">// 新建SpringApplication对象，再调用run方法</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(primarySources).run(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">   <span class="comment">// stopWatch用于统计run启动过程时长</span></span><br><span class="line">   <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">   <span class="comment">// 开始计时</span></span><br><span class="line">   stopWatch.start();</span><br><span class="line">   <span class="comment">// 创建ConfigurableApplicationContext对象</span></span><br><span class="line">   <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">// exceptionReporters集合用来存储SpringApplication启动过程的异常，SpringBootExceptionReporter且通过spring.factories方式来加载</span></span><br><span class="line">   Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">// 配置headless属性</span></span><br><span class="line">   configureHeadlessProperty();</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从spring.factories配置文件中加载到EventPublishingRunListener对象并赋值给SpringApplicationRunListeners</span></span><br><span class="line"><span class="comment">    * # Run Listeners</span></span><br><span class="line"><span class="comment">    * org.springframework.boot.SpringApplicationRunListener=\</span></span><br><span class="line"><span class="comment">    * org.springframework.boot.context.event.EventPublishingRunListener</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line">   <span class="comment">// 启动SpringApplicationRunListeners监听</span></span><br><span class="line">   listeners.starting();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建ApplicationArguments对象，封装了args参数</span></span><br><span class="line">      <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">      <span class="comment">// 备配置参数有app.properties，外部配置参数比如jvm启动参数等</span></span><br><span class="line">      <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">      <span class="comment">// 配置spring.beaninfo.ignore属性</span></span><br><span class="line">      configureIgnoreBeanInfo(environment);</span><br><span class="line">      <span class="comment">// 打印springboot的bannner</span></span><br><span class="line">      <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment);</span><br><span class="line">      <span class="comment">// 根据不同类型创建不同类型的spring applicationcontext容器</span></span><br><span class="line">      context = createApplicationContext();</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 异常报告</span></span><br><span class="line"><span class="comment">       * 从spring.factories配置文件中加载exceptionReporters，其中ConfigurableApplicationContext.class作为FailureAnalyzers构造方法的参数</span></span><br><span class="line"><span class="comment">       * # Error Reporters</span></span><br><span class="line"><span class="comment">       * org.springframework.boot.SpringBootExceptionReporter=\</span></span><br><span class="line"><span class="comment">       * org.springframework.boot.diagnostics.FailureAnalyzers</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">      <span class="comment">// 准备容器事项：调用各个ApplicationContextInitializer的initialize方法</span></span><br><span class="line">      <span class="comment">// 和触发SpringApplicationRunListeners的contextPrepared及contextLoaded方法等</span></span><br><span class="line">      prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">      <span class="comment">// 刷新容器，这一步至关重要</span></span><br><span class="line">      refreshContext(context);</span><br><span class="line">      <span class="comment">// 执行刷新容器后的后置处理逻辑，注意这里为空方法</span></span><br><span class="line">      afterRefresh(context, applicationArguments);</span><br><span class="line">      <span class="comment">// 停止stopWatch计时</span></span><br><span class="line">      stopWatch.stop();</span><br><span class="line">      <span class="comment">// 打印springboot的启动时常</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 触发SpringApplicationRunListener的started方法，通知spring容器已经启动</span></span><br><span class="line">      listeners.started(context);</span><br><span class="line">      <span class="comment">// 调用ApplicationRunner和CommandLineRunner的run方法，实现spring容器启动后需要做的一些东西</span></span><br><span class="line">      callRunners(context, applicationArguments);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 若上面的方法抛出异常，将异常添加到exceptionReporters集合中，并抛出 IllegalStateException 异常。</span></span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 当容器刷新完毕等，触发SpringApplicationRunListeners数组的running方法</span></span><br><span class="line">      listeners.running(context);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="comment">// 若上面的方法抛出异常，将异常添加到exceptionReporters集合中，并抛出 IllegalStateException 异常。</span></span><br><span class="line">      handleRunFailure(context, ex, exceptionReporters, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="怎么让Spring把Body变成一个对象"><a href="#怎么让Spring把Body变成一个对象" class="headerlink" title="怎么让Spring把Body变成一个对象"></a>怎么让Spring把Body变成一个对象</h2><ul><li>@RequestBody注解原理</li><li>详细看springmvc的处理流程</li></ul><h2 id="SpringBoot的starter实现原理是什么？"><a href="#SpringBoot的starter实现原理是什么？" class="headerlink" title="SpringBoot的starter实现原理是什么？"></a>SpringBoot的starter实现原理是什么？</h2><p>原理就是因为在@EnableAutoConfiguration注解，会自动的扫描jar包下的META-INF&#x2F;spring.factories文件的配置类，写在这里面的类都是需要被自动加载的</p><p>将configuration类中定义的bean加入spring到容器中。就相当于加载之前我们自己配置组件的xml文件。而现在SpringBoot自己定义了一个默认的值，然后直接加载进入了Spring容器。</p><p>SpringBoot提供的自动配置依赖模块都以spring-boot-starter-为命名前缀，并且这些依赖都在org.springframework.boot下。 所有的spring-boot-starter都有约定俗成的默认配置，但允许调整这些配置调整默认的行为。</p><h2 id="spring-和springboot的区别"><a href="#spring-和springboot的区别" class="headerlink" title="spring 和springboot的区别"></a>spring 和springboot的区别</h2><p>Spring Boot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，为更快，更高效的开发生态系统铺平了道路。</p><p>Spring Boot中的一些特征：</p><ul><li>创建独立的Spring应用。</li><li>嵌入式Tomcat、Jetty、 Undertow容器（无需部署war文件）。</li><li>提供的starters 简化构建配置</li><li>尽可能自动配置spring应用。</li><li>提供生产指标,例如指标、健壮检查和外部化配置</li><li>完全没有代码生成和XML配置要求</li></ul><p>Maven依赖</p><p>首先，让我们看一下使用Spring创建Web应用程序所需的最小依赖项</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>与Spring不同，Spring Boot只需要一个依赖项来启动和运行Web应用程序：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在进行构建期间，所有其他依赖项将自动添加到项目中。</p><p>另一个很好的例子就是测试库。我们通常使用Spring Test，JUnit，Hamcrest和Mockito库。在Spring项目中，我们应该将所有这些库添加为依赖项。但是在Spring Boot中，我们只需要添加spring-boot-starter-test依赖项来自动包含这些库。</p><p>spring在运行前需要使用xml文件做很多配置，而springboot帮我们实现了这些配置的自动加载，基于注解和简单的yml配置即可</p><p>spring的web程序还是打包为war然后再Tomcat里运行，而springboot内嵌了Tomcat直接打成可运行的jar</p><h2 id="Spring-Boot-可执行-Jar-包运行原理"><a href="#Spring-Boot-可执行-Jar-包运行原理" class="headerlink" title="Spring Boot 可执行 Jar 包运行原理"></a>Spring Boot 可执行 Jar 包运行原理</h2><p>Spring Boot 有一个很方便的功能就是可以将应用打成可执行的 Jar。那么大家有没想过这个 Jar 是怎么运行起来的呢？本篇博客就来介绍下 Spring Boot 可执行 Jar 包的运行原理。</p><h3 id="打可执行-Jar-包"><a href="#打可执行-Jar-包" class="headerlink" title="打可执行 Jar 包"></a>打可执行 Jar 包</h3><p>将 Spring Boot 应用打成可执行 Jar包很容易，只需要在 pom 中加上一个 Spring Boot 提供的插件，然后在执行mvn package即可</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行完mvn package后，我们会在 target 目录下看到两个 jar 文件。myproject-0.0.1-SNAPSHOT.jar 和 myproject-0.0.1-SNAPSHOT.jar.original。第一个 jar 文件就是我们应用的可执行 jar 包，第二个 Jar 文件是应用原始的 jar 包。</p><h3 id="可执行-Jar-包内部结构"><a href="#可执行-Jar-包内部结构" class="headerlink" title="可执行 Jar 包内部结构"></a>可执行 Jar 包内部结构</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">可执行 jar 目录结构</span><br><span class="line">├─BOOT-INF</span><br><span class="line">│  ├─classes</span><br><span class="line">│  └─lib</span><br><span class="line">├─META-INF</span><br><span class="line">│  ├─maven</span><br><span class="line">│  ├─app.properties</span><br><span class="line">│  ├─MANIFEST.MF      </span><br><span class="line">└─org</span><br><span class="line">    └─springframework</span><br><span class="line">        └─boot</span><br><span class="line">            └─loader</span><br><span class="line">                ├─archive</span><br><span class="line">                ├─data</span><br><span class="line">                ├─jar</span><br><span class="line">                └─util</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们先来重点关注两个地方：META-INF 下面的 Jar 包描述文件和 BOOT-INF 这个目录。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Manifest-Version</span>: <span class="string">1.0</span></span><br><span class="line"><span class="attr">Archiver-Version</span>: <span class="string">Plexus Archiver</span></span><br><span class="line"><span class="attr">Built-By</span>: <span class="string">xxxx</span></span><br><span class="line"><span class="attr">Start-Class</span>: <span class="string">com.xxxx.AppServer</span></span><br><span class="line"><span class="attr">Spring-Boot-Classes</span>: <span class="string">BOOT-INF/classes/</span></span><br><span class="line"><span class="attr">Spring-Boot-Lib</span>: <span class="string">BOOT-INF/lib/</span></span><br><span class="line"><span class="attr">Spring-Boot-Version</span>: <span class="string">2.1.6.RELEASE</span></span><br><span class="line"><span class="attr">Created-By</span>: <span class="string">Apache Maven 3.3.9</span></span><br><span class="line"><span class="attr">Build-Jdk</span>: <span class="string">1.8.0_73</span></span><br><span class="line"><span class="attr">Main-Class</span>: <span class="string">org.springframework.boot.loader.JarLauncher</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面我们看到一个熟悉的配置Main-Class: org.springframework.boot.loader.JarLauncher。我们大概能猜到这个类是整个系统的入口。</p><p>再看下 BOOT-INF 这个目录下面，我们会发现里面是我们项目打出来的 class 文件和项目依赖的 Jar 包。看到这里，你可能已经猜到 Spring Boot 是怎么启动项目的了。</p><h3 id="JarLauncher"><a href="#JarLauncher" class="headerlink" title="JarLauncher"></a>JarLauncher</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JarLauncher</span> <span class="keyword">extends</span> <span class="title class_">ExecutableArchiveLauncher</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BOOT_INF_CLASSES</span> <span class="operator">=</span> <span class="string">&quot;BOOT-INF/classes/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BOOT_INF_LIB</span> <span class="operator">=</span> <span class="string">&quot;BOOT-INF/lib/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">JarLauncher</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">JarLauncher</span><span class="params">(Archive archive)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(archive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isNestedArchive</span><span class="params">(Archive.Entry entry)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line"><span class="keyword">return</span> entry.getName().equals(BOOT_INF_CLASSES);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> entry.getName().startsWith(BOOT_INF_LIB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//项目入口，重点在launch这个方法中</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">JarLauncher</span>().launch(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//launch方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">launch</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    JarFile.registerUrlProtocolHandler();</span><br><span class="line">    <span class="comment">//创建LaunchedURLClassLoader。如果根类加载器和扩展类加载器没有加载到某个类的话，就会通过LaunchedURLClassLoader这个加载器来加载类。这个加载器会从Boot-INF下面的class目录和lib目录下加载类。</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> createClassLoader(getClassPathArchives());</span><br><span class="line">    <span class="comment">//这个方法会读取jar描述文件中的Start-Class属性，然后通过反射调用到这个类的main方法。</span></span><br><span class="line">    launch(args, getMainClass(), classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简单总结</p><ul><li>Spring Boot 可执行 Jar 包的入口点是 JarLauncher 的 main 方法；</li><li>这个方法的执行逻辑是先创建一个 LaunchedURLClassLoader，这个加载器加载类的逻辑是：先判断根类加载器和扩展类加载器能否加载到某个类，如果都加载不到就从 Boot-INF 下面的 class 和 lib 目录下去加载；</li><li>读取Start-Class属性，通过反射机制调用启动类的 main 方法，这样就顺利调用到我们开发的 Spring Boot 主启动类的 main 方法了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>Spring最热点面试题</title>
      
      <link href="/2024/05/26/Spring%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2024/05/26/Spring%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="/./2024/05/26/Spring%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/1.png" alt="结构图"></p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="Core-Container"><a href="#Core-Container" class="headerlink" title="Core Container"></a>Core Container</h3><p>核心容器(Core Container)</p><ul><li><code>spring-beans</code> 该模块是依赖注入IoC与DI的最基本实现</li><li><code>spring-core</code> 该模块是Bean工厂与bean的装配</li><li><code>spring-context</code> 该模块构架于核心模块之上，它扩展了 BeanFactory，为它添加了 Bean 生命周期控制、框架事件体系以及资源加载透明化等功能。ApplicationContext 是该模块的核心接口，它的超类是<br>BeanFactory。与BeanFactory 不同，ApplicationContext 容器实例化后会自动对所有的单实例 Bean 进行实例化与依赖关系的装配，使之处于待用状态</li><li><code>spring-context-indexer</code> 该模块是 Spring 的类管理组件和 Classpath 扫描</li><li><code>spring-context-support</code> 该模块是对 Spring IOC 容器的扩展支持，以及 IOC 子容器</li><li><code>spring-expression</code> 该模块是Spring表达式语言块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等</li></ul><h3 id="Data-Access-Integration"><a href="#Data-Access-Integration" class="headerlink" title="Data Access&#x2F;Integration"></a>Data Access&#x2F;Integration</h3><p>数据访问&#x2F;集成</p><ul><li><code>spring-jdbc</code> 该模块提供了 JDBC抽象层，它消除了冗长的 JDBC 编码和对数据库供应商特定错误代码的解析</li><li><code>spring-tx</code> 该模块支持编程式事务和声明式事务，可用于实现了特定接口的类和所有的 POJO 对象。编程式事务需要自己写beginTransaction()、commit()、rollback()<br>等事务管理方法，声明式事务是通过注解或配置由 spring 自动处理，编程式事务粒度更细</li><li><code>spring-orm</code> 该模块提供了对流行的对象关系映射 API的集成，包括 JPA、JDO 和 Hibernate 等。通过此模块可以让这些 ORM 框架和 spring 的其它功能整合，比如前面提及的事务管理</li><li><code>spring-oxm</code> 该模块提供了对 OXM 实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等</li><li><code>spring-jms</code> 该模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了 spring-messaging 模块</li></ul><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p>网络部分</p><ul><li><code>spring-web</code> 该模块为 Spring 提供了最基础 Web 支持，主要建立于核心容器之上，通过 Servlet 或者 Listeners 来初始化 IOC 容器，也包含一些与 Web 相关的支持</li><li><code>spring-webmvc</code> 该模块众所周知是一个的 Web-Servlet 模块，实现了 Spring MVC（model-view-Controller）的 Web 应用</li><li><code>spring-websocket</code> 该模块主要是与 Web 前端的全双工通讯的协议</li><li><code>spring-webflux</code> 该模块是一个新的非堵塞函数式 Reactive Web 框架，可以用来建立异步的，非阻塞，事件驱动的服务，并且扩展性非常好。</li></ul><h3 id="面向切面编程-AOP和Aspects"><a href="#面向切面编程-AOP和Aspects" class="headerlink" title="面向切面编程(AOP和Aspects)"></a>面向切面编程(AOP和Aspects)</h3><ul><li><code>spring-aop</code> 该模块是Spring的另一个核心模块，是 AOP 主要的实现模块</li><li><code>spring-aspects</code> 该模块提供了对 AspectJ 的集成，主要是为 Spring AOP提供多种 AOP 实现方法，如前置方法后置方法等</li></ul><h3 id="设备-Instrumentation"><a href="#设备-Instrumentation" class="headerlink" title="设备(Instrumentation)"></a>设备(Instrumentation)</h3><ul><li><code>spring-instrument</code> 该模块是基于JAVA SE 中的”java.lang.instrument”进行设计的，应该算是 AOP的一个支援模块，主要作用是在 JVM<br>启用时，生成一个代理类，程序员通过代理类在运行时修改类的字节，从而改变一个类的功能，实现 AOP 的功能</li></ul><h3 id="消息-Messaging"><a href="#消息-Messaging" class="headerlink" title="消息(Messaging)"></a>消息(Messaging)</h3><ul><li><code>spring-messaging</code> 是从 Spring4 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用</li></ul><h3 id="测试-Test"><a href="#测试-Test" class="headerlink" title="测试(Test)"></a>测试(Test)</h3><ul><li><code>spring-test</code> 主要为测试提供支持的，通过 JUnit 和 TestNG 组件支持单元测试和集成测试。它提供了一致性地加载和缓存 Spring 上下文，也提供了用于单独测试代码的模拟对象（mock object）</li></ul><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="IOC是什么？"><a href="#IOC是什么？" class="headerlink" title="IOC是什么？"></a>IOC是什么？</h3><p>控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p><p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p><h3 id="使用IOC的好处"><a href="#使用IOC的好处" class="headerlink" title="使用IOC的好处"></a>使用IOC的好处</h3><ul><li>不用自己组装，拿来就用。</li><li>享受单例的好处，效率高，不浪费空间</li><li>便于单元测试，方便切换mock组件</li><li>便于进行AOP操作，对于使用者是透明的</li><li>统一配置，便于修改</li></ul><h2 id="BeanFactory-和-ApplicationContext有什么区别"><a href="#BeanFactory-和-ApplicationContext有什么区别" class="headerlink" title="BeanFactory 和 ApplicationContext有什么区别"></a>BeanFactory 和 ApplicationContext有什么区别</h2><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p><p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p><ul><li>继承MessageSource，因此支持国际化。</li><li>统一的资源文件访问方式。</li><li>提供在监听器中注册bean的事件。</li><li>同时加载多个配置文件。</li><li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li></ul><h3 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h3><p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())<br>，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p><p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。<br>ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p><p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p><h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><p>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p><h3 id="注册方式"><a href="#注册方式" class="headerlink" title="注册方式"></a>注册方式</h3><p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p><h3 id="Spring-IoC的初始化过程"><a href="#Spring-IoC的初始化过程" class="headerlink" title="Spring IoC的初始化过程"></a>Spring IoC的初始化过程</h3><h4 id="IOC粗略总结"><a href="#IOC粗略总结" class="headerlink" title="IOC粗略总结"></a>IOC粗略总结</h4><ol><li>首先入口是xml或者注解或者其他形式，要实现beanDefinationReader接口，然后 读取的时候，会将他们解析为bean的定义信息；</li><li>beanFactory在加载bean信息实例化（底层用的反射）之前，spring加了一个接口beanFactoryPostProcessor,用作扩展用。</li><li>beanFactory内部实例化bean之后，在要初始化bean对象之前，增加了一个一系列aware接口，将他的容器，以及工厂都暴露出来供使用者做扩展用。</li><li>经过一些列容器以及容器对象的注入之后，在初始化之前，spring又增加了一个接口 beanPostProcessor,该接口是可以作用于所有创建的bean,在初始化前后，均能通过重写该接口获取bean对象进行定制操作。</li><li>经过实现初始化接口完成初始化功能。</li><li>经过实现销毁接口disposableBean结束其生命。</li></ol><h4 id="重要的组件"><a href="#重要的组件" class="headerlink" title="重要的组件"></a>重要的组件</h4><ul><li><code>BeanDefinition</code> 描述bean的属性的接口，例如bean的scope是单例还是多例，构造方法，有哪些property value，依赖等，相当于对这个bean的一份身份描述<ul><li><h2 id="Bean配置-–-BeanDefinition-–-Bean对象"><a href="#Bean配置-–-BeanDefinition-–-Bean对象" class="headerlink" title="Bean配置 –&gt; BeanDefinition –&gt; Bean对象"></a>Bean配置 –&gt; BeanDefinition –&gt; Bean对象</h2>懒加载情况下，refresh只是把BeanDefinition注册到BeanFactory中，而不是把Bean注册到BeanFactory中。在调用上下文的getBean的时候才会去根据BeanDefinition生成具体的bean对象</li></ul></li><li><code>BeanDefinitionMap</code></li><li><code>BeanFactory</code><ul><li>spring的基础bean容器</li><li>相当于存放所有bean的容器</li></ul></li><li><code>ApplicationContext</code><ul><li>BeanFactory 的子接口，在 BeanFactory 的基础上构建，是相对比较高级的 IoC 容器实现。包含 BeanFactory<br>的所有功能，还提供了其他高级的特性，比如：事件发布、国际化信息支持、统一资源加载策略等。正常情况下，我们都是使用的 ApplicationContext</li><li>相当于丰富了beanfactory的功能，这里理解为上下文就好</li></ul></li><li><code>FactoryBean</code></li></ul><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>首先抛开其他组件的启动，我们只需要引入spring-context就可以启动一个容器了</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而在springboot出来之前最常见的加载bean的方式是读取配置文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        ApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:applicationfile.xml&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里ApplicationContext是一个接口，主要的实现类有：</p><ul><li>ClassPathXmlApplicationContext 需要一个 xml 配置文件在系统中的路径</li><li>FileSystemXmlApplicationContext 需要一个 xml 配置文件在系统中的路径</li><li>AnnotationConfigApplicationContext 基于注解，大势所趋</li></ul><p>下面的分析都基于 ClassPathXmlApplicationContext 进行分析，因为比较好理解点</p><p>在 resources 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml就可以了,对应的类实现一个：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.javadoop.example.MessageServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>main</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 用我们的配置文件来启动一个 ApplicationContext</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:application.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;context 启动成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式</span></span><br><span class="line">        <span class="type">MessageService</span> <span class="variable">messageService</span> <span class="operator">=</span> context.getBean(MessageService.class);</span><br><span class="line">        <span class="comment">// 这句将输出: hello world</span></span><br><span class="line">        System.out.println(messageService.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中的refresh()方法是启动加载整个容器的关键方法</p><p>方法在springboot容器启动时也会加载,方法为</p><ul><li>org.springframework.boot.SpringApplication#run</li><li>org.springframework.boot.SpringApplication#refreshContext</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span><span class="keyword">throws</span> BeansException,IllegalStateException&#123;</span><br><span class="line">    <span class="comment">// 1. 首先是一个synchronized加锁，当然要加锁，不然你先调一次refresh()然后这次还没处理完又调一次，就会乱套了；</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor)&#123;</span><br><span class="line">        <span class="comment">// 2. 这个方法是做准备工作的，记录容器的启动时间、标记“已启动”状态、处理配置文件中的占位符，可以点进去看看，这里就不多说了。</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 这个就很重要了，这一步是把配置文件解析成一个个Bean，并且注册到BeanFactory中，注意这里只是注册进去，并没有初始化。先继续往下看，等会展开这个方法详细解读</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory=obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 这个方法的作用是：设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean，这里都是spring里面的特殊处理，然后继续往下看</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 5. 方法是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化，具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类，来完成一些其他的操作。</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 6. 接下来是这个方法是调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法；</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 7. 然后这个方法注册 BeanPostProcessor 的实现类，和上面的BeanFactoryPostProcessor 是有区别的，这个方法调用的其实是PostProcessorRegistrationDelegate类的registerBeanPostProcessors方法；</span></span><br><span class="line">            <span class="comment">// 这个类里面有个内部类BeanPostProcessorChecker，BeanPostProcessorChecker里面有两个方法postProcessBeforeInitialization和postProcessAfterInitialization，这两个方法分别在 Bean 初始化之前和初始化之后得到执行。</span></span><br><span class="line">            <span class="comment">// 然后回到refresh()方法中继续往下看</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 8. 方法是初始化当前 ApplicationContext 的 MessageSource，国际化处理，继续往下</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 9. 方法初始化当前 ApplicationContext 的事件广播器继续往下</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 10. 方法初始化一些特殊的 Bean（在初始化 singleton beans 之前）；继续往下</span></span><br><span class="line">            onRefresh();</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 11. 方法注册事件监听器，监听器需要实现 ApplicationListener 接口；继续往下</span></span><br><span class="line">            registerListeners();</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 12. 重点到了 初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 13. 方法是最后一步，广播事件，ApplicationContext 初始化完成</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(BeansException ex)&#123;</span><br><span class="line">            <span class="keyword">if</span>(logger.isWarnEnabled())&#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span>+<span class="string">&quot;cancelling refresh attempt: &quot;</span>+ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-bean的生命周期"><a href="#Spring-bean的生命周期" class="headerlink" title="Spring bean的生命周期"></a>Spring bean的生命周期</h3><p>Spring Bean的生命周期分为四个阶段和多个扩展点。扩展点又可以分为影响多个Bean和影响单个Bean。整理如下：</p><p>四个阶段</p><ul><li>实例化 Instantiation</li><li>属性赋值 Populate</li><li>初始化 Initialization</li><li>销毁 Destruction</li></ul><p>多个扩展点</p><ul><li>影响多个Bean<ul><li>BeanPostProcessor(作用于初始化阶段的前后)</li><li>InstantiationAwareBeanPostProcessor(作用于实例化阶段的前后)</li></ul></li><li>影响单个Bean<ul><li>Aware(Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源)<ul><li>Aware Group1<ul><li>BeanNameAware</li><li>BeanClassLoaderAware</li><li>BeanFactoryAware</li></ul></li><li>Aware Group2<ul><li>EnvironmentAware</li><li>EmbeddedValueResolverAware(实现该接口能够获取Spring EL解析器，用户的自定义注解需要支持spel表达式的时候可以使用)</li><li>ApplicationContextAware(ResourceLoaderAware\ApplicationEventPublisherAware\MessageSourceAware)</li></ul></li></ul></li><li>生命周期(实例化和属性赋值都是Spring帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段)<ul><li>InitializingBean</li><li>DisposableBean</li></ul></li></ul></li></ul><h3 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h3><p>Spring Bean 中所说的作用域，在配置文件中即是“scope”</p><p>在面向对象程序设计中作用域一般指对象或变量之间的可见范围。</p><p>而在Spring容器中是指其创建的Bean对象相对于其他Bean对象的请求可见范围。</p><p>在Spring 容器当中，一共提供了5种作用域类型，在配置文件中，通过属性scope来设置bean的作用域范围</p><h4 id="singleton"><a href="#singleton" class="headerlink" title="singleton"></a>singleton</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userInfo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.lovepi.UserInfo&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当Bean的作用域为singleton的时候,Spring容器中只会存在一个共享的Bean实例，所有对Bean的请求只要id与bean的定义相匹配，则只会返回bean的同一实例。单一实例会被存储在单例缓存中，为Spring的缺省作用域。</p><h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userInfo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.lovepi.UserInfo&quot;</span> <span class="attr">scope</span>=<span class="string">&quot; prototype &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每次对该Bean请求的时候，Spring IoC都会创建一个新的作用域。</p><p>对于有状态的Bean应该使用prototype，对于无状态的Bean则使用singleton</p><h4 id="request"><a href="#request" class="headerlink" title="request"></a>request</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userInfo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.lovepi.UserInfo&quot;</span> <span class="attr">scope</span>=<span class="string">&quot; request &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Request作用域针对的是每次的Http请求，Spring容器会根据相关的Bean的</p><p>定义来创建一个全新的Bean实例。而且该Bean只在当前request内是有效的。</p><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userInfo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.lovepi.UserInfo&quot;</span> <span class="attr">scope</span>=<span class="string">&quot; session &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>针对http session起作用，Spring容器会根据该Bean的定义来创建一个全新的Bean的实例。而且该Bean只在当前http session内是有效的。</p><h4 id="global-session"><a href="#global-session" class="headerlink" title="global session"></a>global session</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userInfo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.lovepi.UserInfo&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;globalSession&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类似标准的http session作用域，不过仅仅在基于portlet的web应用当中才有意义。Portlet规范定义了全局的Session的概念。他被所有构成某个portlet外部应用中的各种不同的portlet所共享。在global<br>session作用域中所定义的bean被限定于全局的portlet session的生命周期范围之内。</p><h3 id="循环依赖问题"><a href="#循环依赖问题" class="headerlink" title="循环依赖问题"></a>循环依赖问题</h3><h4 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h4><p>Spring 解决循环依赖的核心就是提前暴露对象，而提前暴露的对象就是放置于第二级缓存中。下表是三级缓存的说明：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>singletonObjects</td><td>一级缓存，存放完整的 Bean。</td></tr><tr><td>earlySingletonObjects</td><td>二级缓存，存放提前暴露的Bean，Bean 是不完整的，未完成属性注入和执行 init 方法。</td></tr><tr><td>singletonFactories</td><td>三级缓存，存放的是 Bean 工厂，主要是生产 Bean，存放到二级缓存中。</td></tr></tbody></table><p>所有被Spring 管理的 Bean，最终都会存放在 singletonObjects 中，这里面存放的 Bean 是经历了所有生命周期的（除了销毁的生命周期），完整的，可以给用户使用的。</p><p>earlySingletonObjects 存放的是已经被实例化，但是还没有注入属性和执行 init 方法的 Bean。</p><p>singletonFactories 存放的是生产 Bean 的工厂。</p><p>Bean 都已经实例化了，为什么还需要一个生产 Bean 的工厂呢？这里实际上是跟 AOP 有关，如果项目中不需要为 Bean 进行代理，那么这个 Bean 工厂就会直接返回一开始实例化的对象，如果需要使用 AOP 进行代理，那么这个工厂就会发挥重要的作用了，这也是本文需要重点关注的问题之一。</p><h4 id="解决循环依赖"><a href="#解决循环依赖" class="headerlink" title="解决循环依赖"></a>解决循环依赖</h4><p>Spring 是如何通过上面介绍的三级缓存来解决循环依赖的呢？这里只用 A，B 形成的循环依赖来举例：</p><ol><li>实例化 A，此时 A 还未完成属性填充和初始化方法（@PostConstruct）的执行，A 只是一个半成品。</li><li>为 A 创建一个 Bean 工厂，并放入到  singletonFactories 中。</li><li>发现 A 需要注入 B 对象，但是一级、二级、三级缓存均为发现对象 B。</li><li>实例化 B，此时 B 还未完成属性填充和初始化方法（@PostConstruct）的执行，B 只是一个半成品。</li><li>为 B 创建一个 Bean 工厂，并放入到  singletonFactories 中。</li><li>发现 B 需要注入 A 对象，此时在一级、二级未发现对象 A，但是在三级缓存中发现了对象 A，从三级缓存中得到对象 A，并将对象 A 放入二级缓存中，同时删除三级缓存中的对象 A。（注意，此时的 A 还是一个半成品，并没有完成属性填充和执行初始化方法）</li><li>将对象 A 注入到对象 B 中。</li><li>对象 B 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 B。（此时对象 B 已经是一个成品）</li><li>对象 A 得到对象 B，将对象 B 注入到对象 A 中。（对象 A 得到的是一个完整的对象 B）</li><li>对象 A 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 A。</li></ol><h2 id="Spring框架中的单例bean是否线程安全"><a href="#Spring框架中的单例bean是否线程安全" class="headerlink" title="Spring框架中的单例bean是否线程安全"></a>Spring框架中的单例bean是否线程安全</h2><p>Spring框架中的单例bean是线程安全的吗？它是如何处理线程并发问题的?</p><p>不是，Spring框架中的单例bean不是线程安全的。</p><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。实际上大部分 spring bean 是无状态的（比如 dao 类），在某种程度上来说 bean 也是安全的，但如果 bean<br>有状态的话（比如 view model ）就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了， 保证线程安全了。</p><ul><li>有状态就是有数据存储功能。</li><li>无状态就是不会保存数据。</li></ul><p>Spring如何处理线程并发问题?</p><p>一般只有无状态的Bean才可以在多线程下共享，大部分是无状态的Bean。当存有状态的Bean的时候，spring一般是使用ThreadLocal进行处理，解决线程安全问题。</p><p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。<br>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，所以没有相同变量的访问冲突问题。所以在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p><p>AOP(Aspect-Oriented Programming)<br>，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</p><h3 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h3><p>原理是在IOC过程中，创建bean实例时，最后都会对bean进行处理来实现增强，对于AOP来说就是创建代理类</p><ul><li>底层是动态代理技术<ul><li>JDK动态代理(基于接口)</li><li>CGLib动态代理(基于类)</li><li>在Spring AOP中，如果使用的是单例，推荐使用CGLib代理</li></ul></li></ul><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>(一）实现原理</p><p>JDK的动态代理是基于反射实现。JDK通过反射，生成一个代理类，这个代理类实现了原来那个类的全部接口，并对接口中定义的所有方法进行了代理。当我们通过代理对象执行原来那个类的方法时，代理类底层会通过反射机制，回调我们实现的InvocationHandler接口的invoke方法。并且这个代理类是Proxy类的子类（记住这个结论，后面测试要用）。这就是JDK动态代理大致的实现方式。</p><p>（二）优点</p><p>JDK动态代理是JDK原生的，不需要任何依赖即可使用；</p><p>通过反射机制生成代理类的速度要比CGLib操作字节码生成代理类的速度更快；</p><p>（三）缺点</p><p>如果要使用JDK动态代理，被代理的类必须实现了接口，否则无法代理；</p><p>JDK动态代理无法为没有在接口中定义的方法实现代理，假设我们有一个实现了接口的类，我们为它的一个不属于接口中的方法配置了切面，Spring仍然会使用JDK的动态代理，但是由于配置了切面的方法不属于接口，为这个方法配置的切面将不会被织入。</p><p>JDK动态代理执行代理方法时，需要通过反射机制进行回调，此时方法执行的效率比较低；</p><h3 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h3><p>（一）实现原理</p><p>CGLib实现动态代理的原理是，底层采用了ASM字节码生成框架，直接对需要代理的类的字节码进行操作，生成这个类的一个子类，并重写了类的所有可以重写的方法，在重写的过程中，将我们定义的额外的逻辑（简单理解为Spring中的切面）织入到方法中，对方法进行了增强。而通过字节码操作生成的代理类，和我们自己编写并编译后的类没有太大区别。</p><p>（二）优点</p><p>使用CGLib代理的类，不需要实现接口，因为CGLib生成的代理类是直接继承自需要被代理的类；</p><p>CGLib生成的代理类是原来那个类的子类，这就意味着这个代理类可以为原来那个类中，所有能够被子类重写的方法进行代理；</p><p>CGLib生成的代理类，和我们自己编写并编译的类没有太大区别，对方法的调用和直接调用普通类的方式一致，所以CGLib执行代理方法的效率要高于JDK的动态代理；</p><p>（三）缺点</p><p>由于CGLib的代理类使用的是继承，这也就意味着如果需要被代理的类是一个final类，则无法使用CGLib代理；</p><p>由于CGLib实现代理方法的方式是重写父类的方法，所以无法对final方法，或者private方法进行代理，因为子类无法重写这些方法；</p><p>CGLib生成代理类的方式是通过操作字节码，这种方式生成代理类的速度要比JDK通过反射生成代理类的速度更慢；</p><h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><h4 id="连接点-Join-point"><a href="#连接点-Join-point" class="headerlink" title="连接点(Join point)"></a>连接点(Join point)</h4><p>能够被拦截的地方</p><h4 id="切点-Poincut"><a href="#切点-Poincut" class="headerlink" title="切点(Poincut)"></a>切点(Poincut)</h4><p>具体定位的连接点</p><h4 id="增强-通知-Advice"><a href="#增强-通知-Advice" class="headerlink" title="增强&#x2F;通知(Advice)"></a>增强&#x2F;通知(Advice)</h4><p>表示添加到切点的一段逻辑代码，并定位连接点的方位信息</p><h4 id="织入-Weaving"><a href="#织入-Weaving" class="headerlink" title="织入(Weaving)"></a>织入(Weaving)</h4><p>将增强&#x2F;通知添加到目标类的具体连接点上的过程。</p><h4 id="引入-引介-Introduction"><a href="#引入-引介-Introduction" class="headerlink" title="引入&#x2F;引介(Introduction)"></a>引入&#x2F;引介(Introduction)</h4><p>允许我们向现有的类添加新方法或属性。是一种特殊的增强！</p><h4 id="切面-Aspect"><a href="#切面-Aspect" class="headerlink" title="切面(Aspect)"></a>切面(Aspect)</h4><p>切面由切点和增强&#x2F;通知组成，它既包括了横切逻辑的定义、也包括了连接点的定义</p><h3 id="Spring对AOP的支持"><a href="#Spring对AOP的支持" class="headerlink" title="Spring对AOP的支持"></a>Spring对AOP的支持</h3><ul><li>基于代理的经典SpringAOP：需要实现接口，手动创建代理</li><li>纯POJO切面：使用XML配置，aop命名空间</li><li>@AspectJ注解驱动的切面：使用注解的方式，这是最简洁和最方便的！</li></ul><h2 id="怎么定义一个注解"><a href="#怎么定义一个注解" class="headerlink" title="怎么定义一个注解"></a>怎么定义一个注解</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h3><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>java.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：</p><ul><li>@Documented – 注解是否将包含在JavaDoc中</li><li>@Retention – 什么时候使用该注解</li><li>@Target – 注解用于什么地方</li><li>@Inherited – 是否允许子类继承该注解</li></ul><h5 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h5><p>定义该注解的生命周期</p><ul><li>RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。</li><li>RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式</li><li>RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</li></ul><h5 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h5><p>表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType 参数包括</p><ul><li>ElementType.CONSTRUCTOR: 用于描述构造器</li><li>ElementType.FIELD: 成员变量、对象、属性（包括enum实例）</li><li>ElementType.LOCAL_VARIABLE: 用于描述局部变量</li><li>ElementType.METHOD: 用于描述方法</li><li>ElementType.PACKAGE: 用于描述包</li><li>ElementType.PARAMETER: 用于描述参数</li><li>ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明</li></ul><h5 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h5><p>一个简单的Annotations 标记注解，表示是否将注解信息添加在java文档中。</p><h5 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h5><p>定义该注释和子类的关系</p><p>@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class<br>的子类。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>自定义一个检查是否登录的注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CheckLogin &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckLoginAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* *..controller..*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> signature.getMethod();</span><br><span class="line">        <span class="type">CheckLogin</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getAnnotation(CheckLogin.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (annotation == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取类上注解</span></span><br><span class="line">            annotation = joinPoint.getTarget().getClass().getAnnotation(CheckLogin.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (annotation != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取到请求的属性</span></span><br><span class="line">            <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span></span><br><span class="line">                    (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">            <span class="comment">//获取到请求对象</span></span><br><span class="line">            <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();</span><br><span class="line">            <span class="type">String</span> <span class="variable">ssoToken</span> <span class="operator">=</span> HttpUtil.getSsoToken(request);</span><br><span class="line">            <span class="keyword">if</span> (ssoToken != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">loginUserTokenKey</span> <span class="operator">=</span> AuthRedisKeyUtil.getLoginUserTokenKey(ssoToken);</span><br><span class="line">                <span class="keyword">if</span> (redisTemplate.hasKey(loginUserTokenKey)) &#123;</span><br><span class="line">                    <span class="comment">//通过</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LoginException</span>(<span class="string">&quot;登录已过期&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalRequestException</span>(<span class="string">&quot;非法请求&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CheckLogin</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/query&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JSONObject <span class="title function_">queryRegulation</span><span class="params">(Integer pageNum, Integer pageSize)</span> &#123;</span><br><span class="line">        <span class="comment">//....业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="Spring-支持两种方式的事务管理"><a href="#Spring-支持两种方式的事务管理" class="headerlink" title="Spring 支持两种方式的事务管理"></a>Spring 支持两种方式的事务管理</h3><h4 id="1、编程式事务管理"><a href="#1、编程式事务管理" class="headerlink" title="1、编程式事务管理"></a>1、编程式事务管理</h4><ul><li>TransactionTemplate</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span>&#123;</span><br><span class="line">    transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">//...业务代码</span></span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    status.setRollbackOnly();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TransactionManager</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction2</span><span class="params">()</span>&#123;</span><br><span class="line">        TransactionStatus status=transactionManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//...业务代码</span></span><br><span class="line">            transactionManager.commit(status);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            transactionManager.rollback(status);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、注解"><a href="#2、注解" class="headerlink" title="2、注解"></a>2、注解</h4><ul><li>@Transactional</li></ul><h3 id="事务的传播性-Propagation"><a href="#事务的传播性-Propagation" class="headerlink" title="事务的传播性 Propagation"></a>事务的传播性 Propagation</h3><p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p><p>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p><p>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p><p>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p><p>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><p>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p><p>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p><h3 id="spring事务失效的场景"><a href="#spring事务失效的场景" class="headerlink" title="spring事务失效的场景"></a>spring事务失效的场景</h3><ol><li><p>非被Spring管理的Bean上的事务： 如果你在一个非被Spring容器管理的Bean（例如通过new关键字直接创建的对象）上使用事务注解，事务将不会生效。Spring的事务管理是基于AOP（面向切面编程）实现的，因此只能在由Spring容器管理的Bean上起作用。</p></li><li><p>未捕获的异常： 如果在事务内发生未捕获的运行时异常，事务将回滚。但是，如果异常被捕获并在方法内处理，事务可能不会回滚。确保在事务边界内处理异常或者允许异常传播到事务管理器以便正确回滚。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transactionalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// some code that may throw an exception</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// handle the exception (not recommended within a transaction)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>嵌套事务问题： Spring事务支持嵌套事务，但是嵌套事务的行为取决于底层事务管理器的支持。如果使用的事务管理器不支持嵌套事务，嵌套事务可能会被忽略，导致事务行为不一致。</p></li><li><p>方法调用问题： Spring事务是通过AOP实现的，它依赖于代理对象来拦截方法调用并处理事务。如果你在同一个类内部调用一个带有事务注解的方法，事务可能不会起作用，因为代理对象无法拦截内部方法的调用。确保事务注解生效，要么调用方法是通过代理对象，要么通过self-invocation，例如通过this关键字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        innerMethod(); <span class="comment">// Transactional annotation may not work here</span></span><br><span class="line">        <span class="built_in">this</span>.innerMethod(); <span class="comment">// Transactional annotation should work here</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some transactional logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>异步方法问题： 如果使用了异步方法（通过@Async注解），事务可能会失效。在异步方法内，事务上下文可能无法正确传播，导致事务不起作用。要在异步方法中使用事务，可以使用TransactionContext传播方式。</p></li></ol><h2 id="spring使用的设计模式"><a href="#spring使用的设计模式" class="headerlink" title="spring使用的设计模式"></a>spring使用的设计模式</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p><strong>实现方式：</strong></p><p>BeanFactory。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</p><p><strong>实现原理：</strong></p><p>bean容器的启动阶段：</p><p>读取bean的xml配置文件,将bean元素分别转换成一个BeanDefinition对象。<br>然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个ConcurrentHashMap中。<br>将BeanDefinition注册到了beanFactory之后，在这里Spring为我们提供了一个扩展的切口，允许我们通过实现接口BeanFactoryPostProcessor<br>在此处来插入我们定义的代码。典型的例子就是：PropertyPlaceholderConfigurer，我们一般在配置数据库的dataSource时使用到的占位符的值，就是它注入进去的。</p><p>容器中bean的实例化阶段：</p><p>实例化阶段主要是通过反射或者CGLIB对bean进行实例化，在这个阶段Spring又给我们暴露了很多的扩展点：</p><p>各种的Aware接口 ，比如 BeanFactoryAware，对于实现了这些Aware接口的bean，在实例化bean时Spring会帮我们注入对应的BeanFactory的实例。 BeanPostProcessor接口<br>，实现了BeanPostProcessor接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 InitializingBean接口<br>，实现了InitializingBean接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 DisposableBean接口<br>，实现了DisposableBean接口的bean，在该bean死亡时Spring会帮我们调用接口中的方法。</p><p><strong>设计意义：</strong></p><p>松耦合。<br>可以将原来硬编码的依赖，通过Spring这个beanFactory这个工厂来注入依赖，也就是说原来只有依赖方和被依赖方，现在我们引入了第三方——spring这个beanFactory，由它来解决bean之间的依赖问题，达到了松耦合的效果.</p><p>bean的额外处理。 通过Spring接口的暴露，在实例化bean的阶段我们可以进行一些额外的处理，这些额外的处理只需要让bean实现对应的接口即可，那么spring就会在bean的生命周期调用我们实现的接口来处理该bean。[非常重要]</p><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p><strong>实现方式：</strong></p><p>FactoryBean接口。</p><p><strong>实现原理：</strong></p><p>实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()<br>方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>Spring依赖注入Bean实例默认是单例的。</p><p>Spring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><strong>实现方式：</strong></p><p>SpringMVC中的适配器HandlerAdatper。</p><p><strong>实现原理：</strong></p><p>HandlerAdatper根据Handler规则执行不同的Handler。</p><p><strong>实现过程：</strong></p><p>DispatcherServlet根据HandlerMapping返回的handler，向HandlerAdatper发起请求，处理Handler。</p><p>HandlerAdapter根据规则找到对应的Handler并让其执行，执行完毕后Handler会向HandlerAdapter返回一个ModelAndView，最后由HandlerAdapter向DispatchServelet返回一个ModelAndView。</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p><strong>实现方式：</strong></p><p>Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p><p><strong>实质：</strong></p><p>动态地给一个对象添加一些额外的职责。</p><p>就增加功能来说，Decorator模式相比生成子类更为灵活。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>实现方式：</strong></p><p>AOP底层，就是动态代理模式的实现。</p><p><strong>动态代理：</strong></p><p>在内存中构建的，不需要手动编写代理类</p><h2 id="spring中properties和yml的加载顺序"><a href="#spring中properties和yml的加载顺序" class="headerlink" title="spring中properties和yml的加载顺序"></a>spring中properties和yml的加载顺序</h2><p>相同内容properties和yml的加载顺序是properties优先</p><h2 id="使用-Autowired注解自动装配的过程是怎样的？"><a href="#使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="使用@Autowired注解自动装配的过程是怎样的？"></a>使用@Autowired注解自动装配的过程是怎样的？</h2><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config &#x2F;&gt;。</p><p>在启动spring<br>IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p><ul><li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li><li>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</li><li>如果上述查找的结果为空，那么会抛出异常。解决方法是，使用required&#x3D;false。</li></ul><h2 id="Autowired和-Resource之间的区别"><a href="#Autowired和-Resource之间的区别" class="headerlink" title="@Autowired和@Resource之间的区别"></a>@Autowired和@Resource之间的区别</h2><p>@Autowired可用于：构造函数、成员变量、Setter方法</p><p>@Autowired和@Resource之间的区别</p><ul><li>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</li><li>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</li></ul><h2 id="Spring中BeanFactory与FactoryBean的区别"><a href="#Spring中BeanFactory与FactoryBean的区别" class="headerlink" title="Spring中BeanFactory与FactoryBean的区别"></a>Spring中BeanFactory与FactoryBean的区别</h2><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>BeanFactory是一个接口，它是Spring中工厂的顶层规范，是SpringIoc容器的核心接口，它定义了getBean()、containsBean()等管理Bean的通用方法。Spring的容器都是它的具体实现如：</p><ul><li>DefaultListableBeanFactory</li><li>XmlBeanFactory</li><li>ApplicationContext</li></ul><p>这些实现类又从不同的维度分别有不同的扩展。</p><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>首先它是一个Bean，但又不仅仅是一个Bean。它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式。它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。</p><p>FactoryBean表现的是一个工厂的职责。 即一个Bean A如果实现了FactoryBean接口，那么A就变成了一个工厂，根据A的名称获取到的实际上是工厂调用getObject()<br>返回的对象，而不是A本身，如果要获取工厂A自身的实例，那么需要在名称前面加上’&amp;’符号。</p><ul><li>getObject(‘name’)返回工厂中的实例</li><li>getObject(‘&amp;name’)返回工厂本身的实例</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>写代码神器</title>
      
      <link href="/2024/05/26/%E5%86%99%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8/"/>
      <url>/2024/05/26/%E5%86%99%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>Cursor是一个基于人工智能的编程辅助工具，它可以帮助你快速地生成、修改、优化和测试代码。Cursor使用了最先进的自然语言处理技术，能够理解你的编程意图和需求，并根据你的上下文和目标，生成符合你期望的代码。Cursor不仅可以生成代码，还可以检测和修复代码中的错误，提高代码的质量和效率。Cursor还可以根据你的代码生成相应的文档、注释和测试用例，让你的编程过程更加轻松和高效。</p><p><img src="/./2024/05/26/%E5%86%99%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8/1.png" alt="首页"></p><p>Cursor的用途和优势</p><p>Cursor可以应用于多种编程场景和语言，无论你是一个新手还是一个专家，Cursor都可以为你提供强大的编程支持。Cursor的主要用途和优势有：</p><p>代码生成：Cursor可以根据你的自然语言描述或者部分代码，生成完整的代码片段或者函数。你可以使用Cursor来快速实现你的编程想法，或者填补你的代码空缺。Cursor支持多种编程语言，如Python, Java, C++, JavaScript等，你可以根据你的需要选择合适的语言。</p><p>代码修改：Cursor可以根据你的修改意图和需求，对你的代码进行修改和优化。你可以使用Cursor来修改你的代码逻辑、参数、变量名等，或者对你的代码进行重构、简化和美化。Cursor可以保证修改后的代码的正确性和一致性，避免引入新的错误。</p><p>代码测试：Cursor可以根据你的代码，生成相应的测试用例和测试代码。你可以使用Cursor来测试你的代码的功能、性能、安全性等，或者对你的代码进行覆盖率、静态分析等检查。Cursor可以帮助你提高你的代码的可靠性和稳定性，发现和解决潜在的问题。</p><p>代码文档：Cursor可以根据你的代码，生成相应的文档和注释。你可以使用Cursor来生成你的代码的说明、用法、参数、返回值等，或者对你的代码添加有意义的注释。Cursor可以帮助你提高你的代码的可读性和可维护性，方便你和他人理解和使用你的代码。</p><p><img src="/./2024/05/26/%E5%86%99%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8/2.png" alt="编辑页"></p><p>Cursor的使用方法</p><p>Cursor的使用方法非常简单和方便，你只需要在你的编程环境中安装Cursor的插件，然后就可以通过自然语言或者部分代码来引导Cursor为你生成、修改、测试或者文档化你的代码。Cursor的使用方法如下：</p><p>代码生成：你可以在你的代码编辑器中输入你的自然语言描述或者部分代码，然后按下Ctrl+Enter键，Cursor就会为你生成相应的代码。例如，你可以输入“定义一个Python函数，计算两个数的最大公约数”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的代码：</p><p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p><p>def gcd(a, b):</p><h1 id="使用辗转相除法计算两个数的最大公约数"><a href="#使用辗转相除法计算两个数的最大公约数" class="headerlink" title="使用辗转相除法计算两个数的最大公约数"></a>使用辗转相除法计算两个数的最大公约数</h1><p>while b !&#x3D; 0:<br>a, b &#x3D; b, a % b<br>return a<br>代码修改：你可以在你的代码编辑器中选中你想要修改的代码，然后输入你的修改意图或者需求，然后按下Ctrl+Enter键，Cursor就会为你修改相应的代码。例如，你可以选中上面的代码，然后输入“使用递归的方式实现”，然后按下Ctrl+Enter键，Cursor就会为你修改如下的代码：</p><p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p><p>def gcd(a, b):</p><h1 id="使用递归的方式计算两个数的最大公约数"><a href="#使用递归的方式计算两个数的最大公约数" class="headerlink" title="使用递归的方式计算两个数的最大公约数"></a>使用递归的方式计算两个数的最大公约数</h1><p>if b &#x3D;&#x3D; 0:<br>return a<br>else:<br>return gcd(b, a % b)<br>代码测试：你可以在你的代码编辑器中选中你想要测试的代码，然后输入你的测试目标或者条件，然后按下Ctrl+Enter键，Cursor就会为你生成相应的测试用例和测试代码。例如，你可以选中上面的代码，然后输入“测试函数的正确性和性能”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的测试用例和测试代码：</p><p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p><p>import unittest<br>import timeit</p><p>class TestGcd(unittest.TestCase):</p><h1 id="测试gcd函数的正确性和性能"><a href="#测试gcd函数的正确性和性能" class="headerlink" title="测试gcd函数的正确性和性能"></a>测试gcd函数的正确性和性能</h1><p>def test_correctness(self):</p><h1 id="测试gcd函数的正确性"><a href="#测试gcd函数的正确性" class="headerlink" title="测试gcd函数的正确性"></a>测试gcd函数的正确性</h1><p>self.assertEqual(gcd(12, 18), 6)<br>self.assertEqual(gcd(24, 36), 12)<br>self.assertEqual(gcd(17, 23), 1)</p><p>def test_performance(self):</p><h1 id="测试gcd函数的性能"><a href="#测试gcd函数的性能" class="headerlink" title="测试gcd函数的性能"></a>测试gcd函数的性能</h1><p>t &#x3D; timeit.timeit(“gcd(123456789, 987654321)”, setup&#x3D;”from <strong>main</strong> import gcd”, number&#x3D;1000)<br>print(f”Average time for 1000 calls: {t&#x2F;1000:.6f} seconds”)</p><p>if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>unittest.main()<br>代码文档：你可以在你的代码编辑器中选中你想要文档化的代码，然后输入你的文档目的或者格式，然后按下Ctrl+Enter键，Cursor就会为你生成相应的文档和注释。例如，你可以选中上面的代码，然后输入“生成Markdown格式的文档”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的文档和注释：</p><p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p><h1 id="gcd函数"><a href="#gcd函数" class="headerlink" title="gcd函数"></a>gcd函数</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>gcd函数用于计算两个数的最大公约数。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>a: 第一个数，必须是整数。</li><li>b: 第二个数，必须是整数。</li></ul><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回两个数的最大公约数，是一个整数。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>gcd(<span class="number">12</span>, <span class="number">18</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gcd(<span class="number">24</span>, <span class="number">36</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gcd(<span class="number">17</span>, <span class="number">23</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>gcd函数使用了递归的方式实现，如果两个数较大，可能会导致栈溢出的风险。可以考虑使用循环的方式改进。</p><p>Cursor的优势和特点</p><p>Cursor的优势和特点有：</p><ul><li>基于人工智能：Cursor使用了最先进的自然语言处理技术，能够理解你的编程意图和需求，并根据你的上下文和目标，生成符合你期望的代码。Cursor不仅可以生成代码，还可以检测和修复代码中的错误，提高代码的质量和效率。Cursor还可以根据你的代码生成相应的文档、注释和测试用例，让你的编程过程更加轻松和高效。</li><li>基于文本：Cursor使用了基于文本的交互方式，你只需要通过自然语言或者部分代码来引导Cursor为你生成、修改、测试或者文档化你的代码。你不需要学习任何复杂的语法或者命令，只需要用你熟悉的语言来表达你的编程想法和需求，Cursor就可以为你完成你的编程任务。</li><li>基于插件：Cursor使用了基于插件的集成方式，你只需要在你的编程环境中安装Cursor的插件，然后就可以在你的代码编辑器中直接使用Cursor的功能。你不需要切换到任何其他的平台或者工具，只需要在你的代码编辑器中按下Ctrl+Enter键，Cursor就可以为你生成、修改、测试或者文档化你的代码。</li></ul><p><img src="/./2024/05/26/%E5%86%99%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8/2.png" alt="搜索页"></p><p>Cursor的未来展望</p><p>Cursor是一个基于人工智能的编程辅助工具，它可以帮助你快速地生成、修改、优化和测试代码。Cursor使用了最先进的自然语言</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发神器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>Hello World</title>
      
      <link href="/2024/05/20/hello-world/"/>
      <url>/2024/05/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
