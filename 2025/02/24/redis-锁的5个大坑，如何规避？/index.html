<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>redis 锁的5个大坑，如何规避？ | 繁华流年间</title><meta name="author" content="周五打工人"><meta name="copyright" content="周五打工人"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="redis 锁的5个大坑，如何规避？分布式锁 使用场景和主要类型分布式锁 的使用场景Redis 分布式锁在多种场景下都非常有用，特别是在需要确保分布式系统中不同进程或线程对共享资源进行互斥访问的情况下。以下是一些常见的使用场景：  秒杀抢购或优惠券领取：在电商平台中，当进行秒杀或领取优惠券时，需要确保同一时间只有一个用户能够成功操作，以避免超卖或重复领取的问题。  订单处理：在分布式部署的电商系统">
<meta property="og:type" content="article">
<meta property="og:title" content="redis 锁的5个大坑，如何规避？">
<meta property="og:url" content="http://flowtime.asia/2025/02/24/redis-%E9%94%81%E7%9A%845%E4%B8%AA%E5%A4%A7%E5%9D%91%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%EF%BC%9F/index.html">
<meta property="og:site_name" content="繁华流年间">
<meta property="og:description" content="redis 锁的5个大坑，如何规避？分布式锁 使用场景和主要类型分布式锁 的使用场景Redis 分布式锁在多种场景下都非常有用，特别是在需要确保分布式系统中不同进程或线程对共享资源进行互斥访问的情况下。以下是一些常见的使用场景：  秒杀抢购或优惠券领取：在电商平台中，当进行秒杀或领取优惠券时，需要确保同一时间只有一个用户能够成功操作，以避免超卖或重复领取的问题。  订单处理：在分布式部署的电商系统">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://flowtime.asia/img/liushui.png">
<meta property="article:published_time" content="2025-02-24T02:42:01.000Z">
<meta property="article:modified_time" content="2025-02-24T03:04:14.772Z">
<meta property="article:author" content="周五打工人">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://flowtime.asia/img/liushui.png"><link rel="shortcut icon" href="/img/index.jpg"><link rel="canonical" href="http://flowtime.asia/2025/02/24/redis-%E9%94%81%E7%9A%845%E4%B8%AA%E5%A4%A7%E5%9D%91%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%EF%BC%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-3578075519463317',
  enable_page_level_ads: 'true'
});</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'redis 锁的5个大坑，如何规避？',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-02-24 11:04:14'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/transparent.css"><link rel="stylesheet" href="/css/footer.css"><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/nav.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/liushui.png')"><nav id="nav"><span id="blog-info"><a href="/" title="繁华流年间"></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">redis 锁的5个大坑，如何规避？</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-02-24T02:42:01.000Z" title="发表于 2025-02-24 10:42:01">2025-02-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">架构设计</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="redis 锁的5个大坑，如何规避？"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="redis-锁的5个大坑，如何规避？"><a href="#redis-锁的5个大坑，如何规避？" class="headerlink" title="redis 锁的5个大坑，如何规避？"></a>redis 锁的5个大坑，如何规避？</h1><h2 id="分布式锁-使用场景和主要类型"><a href="#分布式锁-使用场景和主要类型" class="headerlink" title="分布式锁 使用场景和主要类型"></a>分布式锁 使用场景和主要类型</h2><h3 id="分布式锁-的使用场景"><a href="#分布式锁-的使用场景" class="headerlink" title="分布式锁 的使用场景"></a>分布式锁 的使用场景</h3><p>Redis 分布式锁在多种场景下都非常有用，特别是在需要确保分布式系统中不同进程或线程对共享资源进行互斥访问的情况下。以下是一些常见的使用场景：</p>
<ol>
<li><p><strong>秒杀抢购或优惠券领取</strong>：在电商平台中，当进行秒杀或领取优惠券时，需要确保同一时间只有一个用户能够成功操作，以避免超卖或重复领取的问题。</p>
</li>
<li><p><strong>订单处理</strong>：在分布式部署的电商系统中，用户下单前需要获取分布式锁，检查库存，确保库存足够后才允许下单，然后释放锁。</p>
</li>
<li><p><strong>实时统计</strong>：在需要统计在线用户数、PV、UV等实时数据时，可以使用分布式锁来避免并发冲突，确保数据的一致性。</p>
</li>
<li><p><strong>任务调度</strong>：在分布式系统中，如果需要执行任务调度，并且任务之间需要互斥执行，可以使用分布式锁来保证同一时间只有一个任务在运行。</p>
</li>
<li><p><strong>分布式爬虫</strong>：对于需要对同一网站进行抓取的分布式爬虫系统，可以使用分布式锁来避免多个爬虫同时抓取同一资源，导致IP被封或资源过载。</p>
</li>
<li><p><strong>消息队列幂等性</strong>：在使用 消息队列时，分布式锁可以用于确保消息不会被重复处理, 实现 幂等性。</p>
</li>
</ol>
<h4 id="先看本地锁："><a href="#先看本地锁：" class="headerlink" title="先看本地锁："></a>先看本地锁：</h4><p>在单体的应用开发场景中，在多线程的环境下，涉及并发同步的时候，为了保证一个代码块在同一时间只能由一个线程访问， 一般可以使用synchronized语法和ReetrantLock去保证，这实际上是本地锁的方式。</p>
<p>也就是说，在同一个JVM内部，大家往往采用synchronized或者Lock的方式来解决多线程间的安全问题。但在分布式集群工作的开发场景中，在JVM之间，那么就需要一种更加高级的锁机制，来处理种跨JVM进程之间的线程安全问题.</p>
<h4 id="再看分布式锁"><a href="#再看分布式锁" class="headerlink" title="再看分布式锁"></a>再看分布式锁</h4><p>总之， 分布式场景， 可以使用分布式锁，它是控制分布式系统之间<strong>互斥访问共享资源</strong>的一种方式。</p>
<p>比如说在一个分布式系统中，多台机器上部署了多个服务，当客户端一个用户发起一个数据插入请求时，如果没有分布式锁机制保证，那么那多台机器上的多个服务可能进行并发插入操作，导致数据重复插入，对于某些不允许有多余数据的业务来说，这就会造成问题。而分布式锁机制就是为了解决类似这类问题，保证多个服务之间互斥的访问共享资源，如果一个服务抢占了分布式锁，其他服务没获取到锁，就不进行后续操作。</p>
<p>大致意思如下图所示（不一定准确）：</p>
<p><img src="/./2025/02/24/redis-%E9%94%81%E7%9A%845%E4%B8%AA%E5%A4%A7%E5%9D%91%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%EF%BC%9F/1.png"></p>
<h3 id="什么是分布式锁？"><a href="#什么是分布式锁？" class="headerlink" title="什么是分布式锁？"></a>什么是分布式锁？</h3><p><strong>何为分布式锁？</strong></p>
<ul>
<li><p>当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。</p>
</li>
<li><p>用一个状态值表示锁，对锁的占用和释放通过状态值来标识。</p>
</li>
</ul>
<p><strong>分布式锁的条件：</strong></p>
<ul>
<li><p>互斥性。在任意时刻，只有一个客户端能持有锁。</p>
</li>
<li><p>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</p>
</li>
<li><p>具有容错性。只要大部分的 Redis 节点正常运行，客户端就可以加锁和解锁。</p>
</li>
<li><p>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</p>
</li>
</ul>
<p><strong>分布式锁的实现：</strong></p>
<p>分布式锁的实现由很多种，文件锁、数据库、redis等等，比较多；分布式锁常见的多种实现方式：</p>
<ol>
<li><p>数据库悲观锁、</p>
</li>
<li><p>数据库乐观锁；</p>
</li>
<li><p>基于Redis的分布式锁；</p>
</li>
<li><p>基于ZooKeeper的分布式锁。</p>
</li>
</ol>
<p>在实践中，还是redis做分布式锁性能会高一些</p>
<h3 id="常见分布式锁方案对比"><a href="#常见分布式锁方案对比" class="headerlink" title="常见分布式锁方案对比"></a>常见分布式锁方案对比</h3><table>
<thead>
<tr>
<th>分类</th>
<th>方案</th>
<th>实现原理</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>基于数据库</td>
<td>基于mysql 表唯一索引</td>
<td>1.表增加唯一索引 2.加锁：执行insert语句，若报错，则表明加锁失败 3.解锁：执行delete语句</td>
<td>完全利用DB现有能力，实现简单</td>
<td>1.锁无超时自动失效机制，有死锁风险 2.不支持锁重入，不支持阻塞等待 3.操作数据库开销大，性能不高</td>
</tr>
<tr>
<td>基于MongoDB findAndModify原子操作</td>
<td>1.加锁：执行findAndModify原子命令查找document，若不存在则新增 2.解锁：删除document</td>
<td>实现也很容易，较基于MySQL唯一索引的方案，性能要好很多</td>
<td>1.大部分公司数据库用MySQL，可能缺乏相应的MongoDB运维、开发人员 2.锁无超时自动失效机制</td>
<td></td>
</tr>
<tr>
<td>基于分布式协调系统</td>
<td>基于ZooKeeper</td>
<td>1.加锁：在&#x2F;lock目录下创建临时有序节点，判断创建的节点序号是否最小。若是，则表示获取到锁；否，则则watch &#x2F;lock目录下序号比自身小的前一个节点 2.解锁：删除节点</td>
<td>1.由zk保障系统高可用 2.Curator框架已原生支持系列分布式锁命令，使用简单</td>
<td>需单独维护一套zk集群，维保成本高</td>
</tr>
<tr>
<td>基于redis 命令的分布式锁</td>
<td>基于redis命令</td>
<td>1. 加锁：执行setnx，若成功再执行expire添加过期时间 2. 解锁：执行delete命令</td>
<td>实现简单，相比数据库和分布式系统的实现，该方案最轻，性能最好</td>
<td>1.setnx和expire分2步执行，非原子操作；若setnx执行成功，但expire执行失败，就可能出现死锁 2.delete命令存在误删除非当前线程持有的锁的可能 3.不支持阻塞等待、不可重入</td>
</tr>
<tr>
<td>基于redis Lua脚本能力（Redission分布式锁）</td>
<td>1. 加锁：执行SET lock_name random_value EX seconds NX 命令 2. 解锁：执行Lua脚本，释放锁时验证random_value – ARGV[1]为random_value, KEYS[1]为lock_nameif redis.call(“get”, KEYS[1]) &#x3D;&#x3D; ARGV[1] then return redis.call(“del”,KEYS[1])else return 0end</td>
<td>同上；实现逻辑上也更严谨，除了单点问题，生产环境采用用这种方案，问题也不大。</td>
<td>不支持锁重入，不支持阻塞等待</td>
<td></td>
</tr>
</tbody></table>
<p>实际上，大家业务场景中，用的还是 redis 锁。</p>
<p>在用redis 锁的过程中， 遇到过 的 5大深坑，大家看看， 你遇到 了吗？</p>
<h2 id="redis-分布式锁-5大深坑"><a href="#redis-分布式锁-5大深坑" class="headerlink" title="redis 分布式锁 5大深坑"></a>redis 分布式锁 5大深坑</h2><p>曾经，做O2O电商引流业务，要频繁的对商品库存进行扣减，为避免并发造成库存 超买超卖 等问题，采用 <code>redis</code> 分布式锁加以控制。</p>
<p>一路踩坑 ， 惨不忍睹 ， 经验深刻</p>
<h2 id="之一：-原子性-之深坑"><a href="#之一：-原子性-之深坑" class="headerlink" title="之一： 原子性 之深坑"></a>之一： 原子性 之深坑</h2><p>使用redis的分布式锁，最早的版本，用的是<code>setNx</code>命令。</p>
<p><code>SETNX</code>（SET if Not eXists）命令用于设置一个键值对，但只有在键不存在的情况下。</p>
<p>因为它涉及到两个步骤：检查键是否存在和设置键。</p>
<p>如果多个进程或线程同时检查键是否存在，并且都发现键不存在，那么它们都可能会认为自己获得了锁。</p>
<p>以下是使用<code>SETNX</code>和Jedis实现一个非原子性Redis分布式锁的基本步骤：</p>
<ol>
<li><p><strong>尝试获取锁</strong>： 使用<code>SETNX</code>命令尝试设置锁。如果返回值是1，表示获取锁成功；如果返回值是0，表示锁已经被其他进程或线程获取。</p>
</li>
<li><p><strong>设置过期时间</strong>： 为了确保锁最终会被释放，即使获取锁的进程或线程崩溃，也需要为锁设置一个过期时间。</p>
</li>
<li><p><strong>执行业务逻辑</strong>： 在获取锁之后，执行需要同步的业务逻辑。</p>
</li>
<li><p><strong>释放锁</strong>： 完成业务逻辑后，使用<code>DEL</code>命令删除锁。</p>
</li>
</ol>
<p>以下是最早的版本，用的是<code>setNx</code> 分布式锁的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import redis.clients.jedis.Jedis;  </span><br><span class="line">  </span><br><span class="line">public class RedisDistributedLock &#123;  </span><br><span class="line">    private static final String LOCK\_SUCCESS = &quot;OK&quot;;  </span><br><span class="line">    private Jedis jedis = null;  </span><br><span class="line">    private String lockKey;  </span><br><span class="line">    private String lockValue = UUID.randomUUID().toString();  </span><br><span class="line">  </span><br><span class="line">    public RedisDistributedLock(Jedis jedis, String lockKey) &#123;  </span><br><span class="line">        this.jedis = jedis;  </span><br><span class="line">        this.lockKey = lockKey;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public boolean tryLock(int expireTime) &#123;  </span><br><span class="line">        // 尝试获取锁  </span><br><span class="line">        String result = jedis.setnx(lockKey, lockValue);  </span><br><span class="line">        if (LOCK\_SUCCESS.equals(result)) &#123;  </span><br><span class="line">            // 设置过期时间  </span><br><span class="line">            jedis.expire(lockKey, expireTime);  </span><br><span class="line">            return true;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return false;  </span><br><span class="line">    &#125;  </span><br><span class="line">    /\*\*  </span><br><span class="line">     \* 释放锁  </span><br><span class="line">     \*/  </span><br><span class="line">    public void unlock() &#123;  </span><br><span class="line">        // 检查锁是否由当前进程或线程持有  </span><br><span class="line">        if (lockValue.equals(jedis.get(lockKey))) &#123;  </span><br><span class="line">            // 删除锁  </span><br><span class="line">            jedis.del(lockKey);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>早期忽略了上面的原子性， 导致 有的场景， 加了锁没啥用。</strong></p>
<p>为什么呢？</p>
<ul>
<li><p>上述代码中的 <code>lock</code>方法并不是原子性的，因为它涉及到两个步骤： 因为它涉及到<code>SETNX</code>和<code>EXPIRE</code>两个命令。</p>
</li>
<li><p>上述代码中的<code>unlock</code>方法并不是原子性的，因为它涉及到两个步骤：获取锁的值和删除锁。</p>
</li>
</ul>
<p>如何解决 lock`方法的原子性问题？答案是:</p>
<ul>
<li><p>可以使用带<code>NX</code>和<code>EX</code>选项版本的 SET`命令</p>
</li>
<li><p>或者使用lua脚本。</p>
</li>
</ul>
<p>如何解决 unlock方法的原子性问题？答案是:</p>
<ul>
<li>使用lua脚本。</li>
</ul>
<p>其实 Redisson等分布式锁框架，就是使用 lua脚本实现。</p>
<p>不过，我们有的时候 不一定使用分布式锁框架，就像早期的版本一样， 喜欢自己造轮子。</p>
<p>下面，就是的第二个版本， 具备了 加锁和解锁 原子性的版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">package com.crazymaker.springcloud.standard.lock;  </span><br><span class="line">  </span><br><span class="line">@Slf4j  </span><br><span class="line">@Data  </span><br><span class="line">@AllArgsConstructor  </span><br><span class="line">public class JedisLock &#123;  </span><br><span class="line">  </span><br><span class="line">    private  RedisTemplate redisTemplate;  </span><br><span class="line">  </span><br><span class="line">    private static final String LOCK\_SUCCESS = &quot;OK&quot;;  </span><br><span class="line">    private static final String SET\_IF\_NOT\_EXIST = &quot;NX&quot;;  </span><br><span class="line">    private static final String SET\_WITH\_EXPIRE\_TIME = &quot;PX&quot;;  </span><br><span class="line">  </span><br><span class="line">    /\*\*  </span><br><span class="line">     \* 尝试获取分布式锁  </span><br><span class="line">     \* @param jedis Redis客户端  </span><br><span class="line">     \* @param lockKey 锁  </span><br><span class="line">     \* @param requestId 请求标识  </span><br><span class="line">     \* @param expireTime 超期时间  </span><br><span class="line">     \* @return 是否获取成功  </span><br><span class="line">     \*/  </span><br><span class="line">    public static   boolean tryLock(Jedis jedis, String lockKey, String requestId, int expireTime) &#123;  </span><br><span class="line">  </span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET\_IF\_NOT\_EXIST, SET\_WITH\_EXPIRE\_TIME, expireTime);  </span><br><span class="line">  </span><br><span class="line">        if (LOCK\_SUCCESS.equals(result)) &#123;  </span><br><span class="line">            return true;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return false;  </span><br><span class="line">    &#125;  </span><br><span class="line">        </span><br><span class="line">       public void unlock(Jedis jedis, String lockKey,  String requestId) &#123;  </span><br><span class="line">        // 释放锁的逻辑需要确保原子性，这里只是一个简单示例  </span><br><span class="line">        // 实际上，这里应该使用Lua脚本来确保删除操作的原子性  </span><br><span class="line">        String script =  </span><br><span class="line">                &quot;if redis.call(&#x27;get&#x27;, KEYS\[1\]) == ARGV\[1\] then &quot; +  </span><br><span class="line">                &quot;return redis.call(&#x27;del&#x27;, KEYS\[1\]) &quot; +  </span><br><span class="line">                &quot;else &quot; +  </span><br><span class="line">                &quot;return 0 &quot; +  </span><br><span class="line">                &quot;end&quot;;  </span><br><span class="line">        jedis.eval(script, 1, lockKey, requestId);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>上面的加锁原子性，是通过使用带</strong><strong><code>NX</code>和<code>EX</code>选项版本的 SET 命令解决。</strong></p>
<p><strong>上面的解锁原子性，是通过lua脚本解决。</strong></p>
<p>特别说说， <code>Jedis.set</code> 方法是 Jedis 客户端用来设置 Redis 中的键值对的方法，基本对应到 redis 的set命令， 版本有很多。</p>
<p>Jedis.set个方法有多个重载版本，以不同的方式设置键值对，例如设置键的过期时间等。</p>
<p>以下是 <code>Jedis.set</code> 方法的一些常见使用方式：</p>
<ol>
<li><p><code>String set(String key, String value)</code>：将键值对设置到 Redis 中，如果键已经存在，则覆盖之前的值。返回 “OK” 表示操作成功。</p>
</li>
<li><p><code>String set(String key, String value, String nxxx)</code>：</p>
<p>这个版本允许 指定一个条件，<code>nxxx</code> 可以是 <code>NX</code>（Not Exist）或 <code>XX</code>（eXist），分别表示只有当键不存在或已经存在时才设置值。</p>
</li>
<li><p><code>String set(String key, String value, String nxxx, String expx, int time)</code>：</p>
<p>这个版本允许 设置键的过期时间，<code>expx</code> 可以是 <code>EX</code>（秒）或 <code>PX</code>（毫秒），<code>time</code> 是过期时间的值。</p>
</li>
</ol>
<p>在源码层面，<code>Jedis.set</code> 方法的实现会将相应的命令发送到 Redis 服务器。例如，不带过期时间的 <code>set</code> 操作会发送 <code>SET</code> 命令，而带有过期时间的 <code>set</code> 操作会发送 <code>SET</code> 命令加上 <code>EX</code> 或 <code>PX</code> 选项。</p>
<p>上面最后的 <code>set</code>命令，是一个原子性的版本， 该命令可以指定多个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">String result = jedis.set(lockKey, requestId, &quot;NX&quot;, &quot;PX&quot;, expireTime);  </span><br><span class="line">if (&quot;OK&quot;.equals(result))   </span><br><span class="line">&#123;     </span><br><span class="line">    return true;  </span><br><span class="line">&#125;  </span><br><span class="line">return false;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中的参数介绍如下：</p>
<ul>
<li><p><code>lockKey</code>：锁的标识</p>
</li>
<li><p><code>requestId</code>：请求id</p>
</li>
<li><p><code>NX</code>：只在键不存在时，才对键进行设置操作。</p>
</li>
<li><p><code>PX</code>：设置键的过期时间为 millisecond 毫秒。</p>
</li>
<li><p><code>expireTime</code>：过期时间</p>
</li>
</ul>
<p>这个 <code>set</code>命令是原子操作，加锁和设置超时时间，一个命令就能轻松搞定。</p>
<p>一看源码，就能发现，其实  <code>Jedis.set</code> 方法的不同参数，可以对应到 Redis 的SET命令的命令选项。</p>
<p>Redis 的 <code>SET</code> 命令用于将给定的键（key）与值（value）关联。Redis 的<code>SET</code> 命令的基本格式和命令选项如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">SET key value  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此外，<code>SET</code> 命令还支持一些选项，以提供更多的控制功能，例如设置键的过期时间、仅在键不存在时设置值等。以下是 <code>SET</code> 命令的一些常用选项：</p>
<ol>
<li><p><strong>NX</strong>：仅当键不存在时，才对键进行设置操作。相当于 “SET if Not eXists”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">SET key value NX  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>XX</strong>：仅当键已经存在时，才对键进行设置操作。相当于 “SET if eXists”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">SET key value XX  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>EX</strong>：设置键的过期时间，单位为秒。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">SET key value EX seconds  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>PX</strong>：设置键的过期时间，单位为毫秒。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">SET key value PX milliseconds  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>EXAT</strong>：设置键的过期时间，精确到某个时间点（Unix时间戳）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">SET key value EXAT timestamp  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>PXAT</strong>：设置键的过期时间，精确到某个时间点（Unix时间戳），单位为毫秒。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">SET key value PXAT milliseconds-timestamp  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>KEEPTTL</strong>：设置键的值，但保持键的原始过期时间不变。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">SET key value KEEPTTL  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>GET</strong>：设置键的值，并返回旧的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">SET key value GET  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些选项可以组合使用。</p>
<p>例如， 想设置一个键的值，并设置其过期时间为10秒，同时仅当键不存在时才进行设置，你可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">SET key value NX EX 10  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>SET</code> 命令返回的结果通常是 “OK”，表示操作成功。如果使用了 <code>GET</code> 选项，<code>SET</code> 命令将返回旧的值。</p>
<p>在实际应用中，这些选项使得 <code>SET</code> 命令非常灵活，可以用于实现各种复杂的逻辑，如分布式锁、缓存控制等场景。</p>
<h2 id="之二：连接耗尽-之深坑"><a href="#之二：连接耗尽-之深坑" class="headerlink" title="之二：连接耗尽 之深坑"></a>之二：连接耗尽 之深坑</h2><p>早期的版本， 没有正确的被释放， 大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class LockDemo &#123;  </span><br><span class="line">    public static void main(String\[\] args) &#123;  </span><br><span class="line">        JedisPool jedisPool = new JedisPool(&quot;localhost&quot;, 6379);  </span><br><span class="line">        JedisLock lock = new JedisLock(jedisPool, &quot;myLock&quot;);  </span><br><span class="line">  </span><br><span class="line">       if (lock.tryLock(10)) &#123; // 尝试获取锁，锁的过期时间为10秒  </span><br><span class="line">                </span><br><span class="line">             // 执行业务逻辑  </span><br><span class="line">              System.out.println(&quot;Lock acquired, executing business logic&quot;);  </span><br><span class="line">                   </span><br><span class="line">             lock.unlock(); // 执行完业务，释放锁  </span><br><span class="line">             System.out.println(&quot;Lock released&quot;);  </span><br><span class="line">               </span><br><span class="line">         &#125; else &#123;  </span><br><span class="line">              System.out.println(&quot;Failed to acquire lock&quot;);  </span><br><span class="line">         &#125;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上边代码中，如果业务代码异常，或者JVM在执行业务代码的时候重启，就会导致 未及时释放锁，导致其它线程会一直尝试获取锁阻塞，</p>
<p>导致连接耗尽：用<code>Jedis</code>客户端会报如下的错误信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>redis线程池 已经没有空闲线程来处理客户端命令。</p>
<p>要解决这个问题，就需要及时的释放锁，并且过期的时间，不能设置太长。</p>
<p>改进的版本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class LockDemo &#123;  </span><br><span class="line">    public static void main(String\[\] args) &#123;  </span><br><span class="line">        JedisPool jedisPool = new JedisPool(&quot;localhost&quot;, 6379);  </span><br><span class="line">        JedisLock lock = new JedisLock(jedisPool, &quot;myLock&quot;);  </span><br><span class="line">  </span><br><span class="line">        try &#123;  </span><br><span class="line">            if (lock.tryLock(10)) &#123; // 尝试获取锁，锁的过期时间为10秒  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    // 执行业务逻辑  </span><br><span class="line">                    System.out.println(&quot;Lock acquired, executing business logic&quot;);  </span><br><span class="line">                    Thread.sleep(5000); // 模拟业务逻辑执行时间  </span><br><span class="line">                &#125; finally &#123;  </span><br><span class="line">                    lock.unlock(); // 释放锁  </span><br><span class="line">                    System.out.println(&quot;Lock released&quot;);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                System.out.println(&quot;Failed to acquire lock&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; finally &#123;  </span><br><span class="line">            jedisPool.close();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p><strong>锁的过期时间</strong>：在 <code>tryLock</code> 方法中设置了锁的过期时间，这是为了防止持有锁的进程崩溃，从而导致锁永远无法释放。但是也不能太长，设置在 30s内为适宜。</p>
</li>
<li><p><strong>锁的安全性</strong>：在 <code>unlock</code> 方法中，我们使用 Lua 脚本来确保检查和删除操作的原子性，这是为了防止错误地释放其他进程持有的锁。</p>
</li>
<li><p><strong>连接池资源管理</strong>：在示例中，关闭了连接，确保 Jedis 连接在使用后被正确关闭，避免资源泄露。</p>
</li>
</ul>
<p>所以，加锁后，如果不及时释放锁，会有很多问题。</p>
<p>分布式锁更合理的用法是：</p>
<ol>
<li><p>手动加锁</p>
</li>
<li><p>业务操作</p>
</li>
<li><p>手动释放锁</p>
</li>
<li><p>如果手动释放锁失败了，则达到超时时间，redis会自动释放锁。</p>
</li>
</ol>
<p>大致流程图如下：</p>
<p><img src="/./2025/02/24/redis-%E9%94%81%E7%9A%845%E4%B8%AA%E5%A4%A7%E5%9D%91%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%EF%BC%9F/2.png"></p>
<h2 id="之三：锁过期-的深坑"><a href="#之三：锁过期-的深坑" class="headerlink" title="之三：锁过期 的深坑"></a>之三：锁过期 的深坑</h2><p>下面有一个简单的使用锁， 实现并发操作文件的例子，锁的时间 10秒：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">  //写数据到文件  </span><br><span class="line">function writeData(filename, data) &#123;  </span><br><span class="line">    boolean locked = lock.tryLock(10, TimeUnit.SECONDS);  </span><br><span class="line">    if (!locked) &#123;  </span><br><span class="line">        throw &#x27;Failed to acquire lock&#x27;;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    try &#123;  </span><br><span class="line">        //将数据写到文件  </span><br><span class="line">        var file = storage.readFile(filename);  </span><br><span class="line">        var updated = updateContents(file, data);  </span><br><span class="line">        storage.writeFile(filename, updated);  </span><br><span class="line">    &#125; finally &#123;  </span><br><span class="line">        lock.unlock();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题是：</p>
<ul>
<li><p>如果在写文件过程中，发生了 fullGC，并且其时间跨度较长， 超过了10秒，</p>
</li>
<li><p>那么，由于锁的有效期就是 10s，这时候任务没有执行完成，分布式锁就自动过期了。</p>
</li>
</ul>
<p>在此过程中，client2 抢到锁，写了文件。</p>
<p>回到 client1： client1 的fullGC完成后，也继续写文件，<strong>注意，此时client1 的并没有占用锁</strong>，此时写入会导致文件数据错乱，发生线程安全问题。</p>
<p>fullGC STW导致，导致了的锁过期问题。 整个流程，打造具体如下图所示：</p>
<p><img src="/./2025/02/24/redis-%E9%94%81%E7%9A%845%E4%B8%AA%E5%A4%A7%E5%9D%91%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%EF%BC%9F/3.png"></p>
<h3 id="锁过期问题-的解决方案"><a href="#锁过期问题-的解决方案" class="headerlink" title="锁过期问题 的解决方案"></a>锁过期问题 的解决方案</h3><p>锁过期问题,大概的解决方案 有2种：</p>
<p>1： 模拟CAS乐观锁的方式，增加版本号</p>
<p>2：<strong>watch dog自动延期机制</strong></p>
<h3 id="方式一：模拟CAS乐观锁的方式，增加版本号"><a href="#方式一：模拟CAS乐观锁的方式，增加版本号" class="headerlink" title="方式一：模拟CAS乐观锁的方式，增加版本号"></a>方式一：模拟CAS乐观锁的方式，增加版本号</h3><p><strong>1： 模拟CAS乐观锁的方式，增加版本号（如下图中的token）</strong></p>
<p>CAS乐观锁 的方法也很简单：</p>
<p>在每次写操作时加入一个 token。 token 可以是一个递增的数字（lock service 可以做到），每次有 client 申请锁就递增一次。比如：</p>
<ul>
<li><p>client1 的token 是33</p>
</li>
<li><p>client2 的token 是34</p>
</li>
</ul>
<p>紧接着 client1 活过来之后尝试写入数据，自身 token 33 比 34 小，因此client1 的写入操作被拒绝了。</p>
<p><img src="/./2025/02/24/redis-%E9%94%81%E7%9A%845%E4%B8%AA%E5%A4%A7%E5%9D%91%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%EF%BC%9F/4.png"></p>
<p>此方案如果要实现，需要调整业务逻辑与之配合，所以会入侵代码。</p>
<h3 id="方式二：watch-dog自动延期机制"><a href="#方式二：watch-dog自动延期机制" class="headerlink" title="方式二：watch dog自动延期机制"></a>方式二：watch dog自动延期机制</h3><p>客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？</p>
<p>简单！</p>
<p>只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，<strong>他是一个后台线程，会每隔10秒检查一下</strong>，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。</p>
<blockquote>
<p>redission，采用的就是这种方案， 此方案不会入侵业务代码。</p>
</blockquote>
<p>watch dog看门狗 的作用是在锁没有过期之前，不断的延长锁的有效期。</p>
<p>默认情况下，锁的过期时间是 30 秒，看门狗的续期时间是 10 秒，</p>
<p>也可以通过修改 Config.lockWatchdogTimeout 来指定。</p>
<p>Redission 就是 使用 看门狗的机制。建议大家不用自己实现，直接使用Redission。</p>
<p><strong>当然，作为高级开发或者架构师， 锁过期的 原理还是要懂的。</strong></p>
<p><code>redisson</code>的解决锁过期的源码，大致如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">@Slf4j  </span><br><span class="line">@Service  </span><br><span class="line">public class RedisDistributionLockPlus &#123;  </span><br><span class="line">   </span><br><span class="line">    /\*\*  </span><br><span class="line">     \* 加锁超时时间，单位毫秒， 即：加锁时间内执行完操作，如果未完成会有并发现象  </span><br><span class="line">     \*/  </span><br><span class="line">    private static final long DEFAULT\_LOCK\_TIMEOUT = 30;  </span><br><span class="line">   </span><br><span class="line">    private static final long TIME\_SECONDS\_FIVE = 5 ;  </span><br><span class="line">   </span><br><span class="line">    /\*\*  </span><br><span class="line">     \* 每个key的过期时间 &#123;@link LockContent&#125;  </span><br><span class="line">     \*/  </span><br><span class="line">    private Map&lt;String, LockContent&gt; lockContentMap = new ConcurrentHashMap&lt;&gt;(512);  </span><br><span class="line">   </span><br><span class="line">    /\*\*  </span><br><span class="line">     \* redis执行成功的返回  </span><br><span class="line">     \*/  </span><br><span class="line">    private static final Long EXEC\_SUCCESS = 1L;  </span><br><span class="line">   </span><br><span class="line">    /\*\*  </span><br><span class="line">     \* 获取锁lua脚本， k1：获锁key, k2：续约耗时key, arg1:requestId，arg2：超时时间  </span><br><span class="line">     \*/  </span><br><span class="line">    private static final String LOCK\_SCRIPT = &quot;if redis.call(&#x27;exists&#x27;, KEYS\[2\]) == 1 then ARGV\[2\] = math.floor(redis.call(&#x27;get&#x27;, KEYS\[2\]) + 10) end &quot; +  </span><br><span class="line">            &quot;if redis.call(&#x27;exists&#x27;, KEYS\[1\]) == 0 then &quot; +  </span><br><span class="line">               &quot;local t = redis.call(&#x27;set&#x27;, KEYS\[1\], ARGV\[1\], &#x27;EX&#x27;, ARGV\[2\]) &quot; +  </span><br><span class="line">               &quot;for k, v in pairs(t) do &quot; +  </span><br><span class="line">                 &quot;if v == &#x27;OK&#x27; then return tonumber(ARGV\[2\]) end &quot; +  </span><br><span class="line">               &quot;end &quot; +  </span><br><span class="line">            &quot;return 0 end&quot;;  </span><br><span class="line">   </span><br><span class="line">    /\*\*  </span><br><span class="line">     \* 释放锁lua脚本, k1：获锁key, k2：续约耗时key, arg1:requestId，arg2：业务耗时 arg3: 业务开始设置的timeout  </span><br><span class="line">     \*/  </span><br><span class="line">    private static final String UNLOCK\_SCRIPT = &quot;if redis.call(&#x27;get&#x27;, KEYS\[1\]) == ARGV\[1\] then &quot; +  </span><br><span class="line">            &quot;local ctime = tonumber(ARGV\[2\]) &quot; +  </span><br><span class="line">            &quot;local biz\_timeout = tonumber(ARGV\[3\]) &quot; +  </span><br><span class="line">            &quot;if ctime &gt; 0 then  &quot; +  </span><br><span class="line">               &quot;if redis.call(&#x27;exists&#x27;, KEYS\[2\]) == 1 then &quot; +  </span><br><span class="line">                   &quot;local avg\_time = redis.call(&#x27;get&#x27;, KEYS\[2\]) &quot; +  </span><br><span class="line">                   &quot;avg\_time = (tonumber(avg\_time) \* 8 + ctime \* 2)/10 &quot; +  </span><br><span class="line">                   &quot;if avg\_time &gt;= biz\_timeout - 5 then redis.call(&#x27;set&#x27;, KEYS\[2\], avg\_time, &#x27;EX&#x27;, 24\*60\*60) &quot; +  </span><br><span class="line">                   &quot;else redis.call(&#x27;del&#x27;, KEYS\[2\]) end &quot; +  </span><br><span class="line">               &quot;elseif ctime &gt; biz\_timeout -5 then redis.call(&#x27;set&#x27;, KEYS\[2\], ARGV\[2\], &#x27;EX&#x27;, 24\*60\*60) end &quot; +  </span><br><span class="line">            &quot;end &quot; +  </span><br><span class="line">            &quot;return redis.call(&#x27;del&#x27;, KEYS\[1\]) &quot; +  </span><br><span class="line">            &quot;else return 0 end&quot;;  </span><br><span class="line">    /\*\*  </span><br><span class="line">     \* 续约lua脚本  </span><br><span class="line">     \*/  </span><br><span class="line">    private static final String RENEW\_SCRIPT = &quot;if redis.call(&#x27;get&#x27;, KEYS\[1\]) == ARGV\[1\] then return redis.call(&#x27;expire&#x27;, KEYS\[1\], ARGV\[2\]) else return 0 end&quot;;  </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    private final StringRedisTemplate redisTemplate;  </span><br><span class="line">   </span><br><span class="line">    public RedisDistributionLockPlus(StringRedisTemplate redisTemplate) &#123;  </span><br><span class="line">        this.redisTemplate = redisTemplate;  </span><br><span class="line">        ScheduleTask task = new ScheduleTask(this, lockContentMap);  </span><br><span class="line">        // 启动定时任务  </span><br><span class="line">        ScheduleExecutor.schedule(task, 1, 1, TimeUnit.SECONDS);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    /\*\*  </span><br><span class="line">     \* 加锁  </span><br><span class="line">     \* 取到锁加锁，取不到锁一直等待知道获得锁  </span><br><span class="line">     \*  </span><br><span class="line">     \* @param lockKey  </span><br><span class="line">     \* @param requestId 全局唯一  </span><br><span class="line">     \* @param expire   锁过期时间, 单位秒  </span><br><span class="line">     \* @return  </span><br><span class="line">     \*/  </span><br><span class="line">    public boolean lock(String lockKey, String requestId, long expire) &#123;  </span><br><span class="line">        log.info(&quot;开始执行加锁, lockKey =&#123;&#125;, requestId=&#123;&#125;&quot;, lockKey, requestId);  </span><br><span class="line">        for (; ; ) &#123;  </span><br><span class="line">            // 判断是否已经有线程持有锁，减少redis的压力  </span><br><span class="line">            LockContent lockContentOld = lockContentMap.get(lockKey);  </span><br><span class="line">            boolean unLocked = null == lockContentOld;  </span><br><span class="line">            // 如果没有被锁，就获取锁  </span><br><span class="line">            if (unLocked) &#123;  </span><br><span class="line">                long startTime = System.currentTimeMillis();  </span><br><span class="line">                // 计算超时时间  </span><br><span class="line">                long bizExpire = expire == 0L ? DEFAULT\_LOCK\_TIMEOUT : expire;  </span><br><span class="line">                String lockKeyRenew = lockKey + &quot;\_renew&quot;;  </span><br><span class="line">   </span><br><span class="line">                RedisScript&lt;Long&gt; script = RedisScript.of(LOCK\_SCRIPT, Long.class);  </span><br><span class="line">                List&lt;String&gt; keys = new ArrayList&lt;&gt;();  </span><br><span class="line">                keys.add(lockKey);  </span><br><span class="line">                keys.add(lockKeyRenew);  </span><br><span class="line">                Long lockExpire = redisTemplate.execute(script, keys, requestId, Long.toString(bizExpire));  </span><br><span class="line">                if (null != lockExpire &amp;&amp; lockExpire &gt; 0) &#123;  </span><br><span class="line">                    // 将锁放入map  </span><br><span class="line">                    LockContent lockContent = new LockContent();  </span><br><span class="line">                    lockContent.setStartTime(startTime);  </span><br><span class="line">                    lockContent.setLockExpire(lockExpire);  </span><br><span class="line">                    lockContent.setExpireTime(startTime + lockExpire \* 1000);  </span><br><span class="line">                    lockContent.setRequestId(requestId);  </span><br><span class="line">                    lockContent.setThread(Thread.currentThread());  </span><br><span class="line">                    lockContent.setBizExpire(bizExpire);  </span><br><span class="line">                    lockContent.setLockCount(1);  </span><br><span class="line">                    lockContentMap.put(lockKey, lockContent);  </span><br><span class="line">                    log.info(&quot;加锁成功, lockKey =&#123;&#125;, requestId=&#123;&#125;&quot;, lockKey, requestId);  </span><br><span class="line">                    return true;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            // 重复获取锁，在线程池中由于线程复用，线程相等并不能确定是该线程的锁  </span><br><span class="line">            if (Thread.currentThread() == lockContentOld.getThread()  </span><br><span class="line">                      &amp;&amp; requestId.equals(lockContentOld.getRequestId()))&#123;  </span><br><span class="line">                // 计数 +1  </span><br><span class="line">                lockContentOld.setLockCount(lockContentOld.getLockCount()+1);  </span><br><span class="line">                return true;  </span><br><span class="line">            &#125;  </span><br><span class="line">   </span><br><span class="line">            // 如果被锁或获取锁失败，则等待100毫秒  </span><br><span class="line">            try &#123;  </span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(100);  </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                // 这里用lombok 有问题  </span><br><span class="line">                log.error(&quot;获取redis 锁失败, lockKey =&#123;&#125;, requestId=&#123;&#125;&quot;, lockKey, requestId, e);  </span><br><span class="line">                return false;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    /\*\*  </span><br><span class="line">     \* 解锁  </span><br><span class="line">     \*  </span><br><span class="line">     \* @param lockKey  </span><br><span class="line">     \* @param lockValue  </span><br><span class="line">     \*/  </span><br><span class="line">    public boolean unlock(String lockKey, String lockValue) &#123;  </span><br><span class="line">        String lockKeyRenew = lockKey + &quot;\_renew&quot;;  </span><br><span class="line">        LockContent lockContent = lockContentMap.get(lockKey);  </span><br><span class="line">   </span><br><span class="line">        long consumeTime;  </span><br><span class="line">        if (null == lockContent) &#123;  </span><br><span class="line">            consumeTime = 0L;  </span><br><span class="line">        &#125; else if (lockValue.equals(lockContent.getRequestId())) &#123;  </span><br><span class="line">            int lockCount = lockContent.getLockCount();  </span><br><span class="line">            // 每次释放锁， 计数 -1，减到0时删除redis上的key  </span><br><span class="line">            if (--lockCount &gt; 0) &#123;  </span><br><span class="line">                lockContent.setLockCount(lockCount);  </span><br><span class="line">                return false;  </span><br><span class="line">            &#125;  </span><br><span class="line">            consumeTime = (System.currentTimeMillis() - lockContent.getStartTime()) / 1000;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            log.info(&quot;释放锁失败，不是自己的锁。&quot;);  </span><br><span class="line">            return false;  </span><br><span class="line">        &#125;  </span><br><span class="line">   </span><br><span class="line">        // 删除已完成key，先删除本地缓存，减少redis压力, 分布式锁，只有一个，所以这里不加锁  </span><br><span class="line">        lockContentMap.remove(lockKey);  </span><br><span class="line">   </span><br><span class="line">        RedisScript&lt;Long&gt; script = RedisScript.of(UNLOCK\_SCRIPT, Long.class);  </span><br><span class="line">        List&lt;String&gt; keys = new ArrayList&lt;&gt;();  </span><br><span class="line">        keys.add(lockKey);  </span><br><span class="line">        keys.add(lockKeyRenew);  </span><br><span class="line">   </span><br><span class="line">        Long result = redisTemplate.execute(script, keys, lockValue, Long.toString(consumeTime),  </span><br><span class="line">                Long.toString(lockContent.getBizExpire()));  </span><br><span class="line">        return EXEC\_SUCCESS.equals(result);  </span><br><span class="line">   </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    /\*\*  </span><br><span class="line">     \* 续约  </span><br><span class="line">     \*  </span><br><span class="line">     \* @param lockKey  </span><br><span class="line">     \* @param lockContent  </span><br><span class="line">     \* @return true:续约成功，false:续约失败（1、续约期间执行完成，锁被释放 2、不是自己的锁，3、续约期间锁过期了（未解决））  </span><br><span class="line">     \*/  </span><br><span class="line">    public boolean renew(String lockKey, LockContent lockContent) &#123;  </span><br><span class="line">   </span><br><span class="line">        // 检测执行业务线程的状态  </span><br><span class="line">        Thread.State state = lockContent.getThread().getState();  </span><br><span class="line">        if (Thread.State.TERMINATED == state) &#123;  </span><br><span class="line">            log.info(&quot;执行业务的线程已终止,不再续约 lockKey =&#123;&#125;, lockContent=&#123;&#125;&quot;, lockKey, lockContent);  </span><br><span class="line">            return false;  </span><br><span class="line">        &#125;  </span><br><span class="line">   </span><br><span class="line">        String requestId = lockContent.getRequestId();  </span><br><span class="line">        long timeOut = (lockContent.getExpireTime() - lockContent.getStartTime()) / 1000;  </span><br><span class="line">   </span><br><span class="line">        RedisScript&lt;Long&gt; script = RedisScript.of(RENEW\_SCRIPT, Long.class);  </span><br><span class="line">        List&lt;String&gt; keys = new ArrayList&lt;&gt;();  </span><br><span class="line">        keys.add(lockKey);  </span><br><span class="line">   </span><br><span class="line">        Long result = redisTemplate.execute(script, keys, requestId, Long.toString(timeOut));  </span><br><span class="line">        log.info(&quot;续约结果，True成功，False失败 lockKey =&#123;&#125;, result=&#123;&#125;&quot;, lockKey, EXEC\_SUCCESS.equals(result));  </span><br><span class="line">        return EXEC\_SUCCESS.equals(result);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    static class ScheduleExecutor &#123;  </span><br><span class="line">   </span><br><span class="line">        public static void schedule(ScheduleTask task, long initialDelay, long period, TimeUnit unit) &#123;  </span><br><span class="line">            long delay = unit.toMillis(initialDelay);  </span><br><span class="line">            long period\_ = unit.toMillis(period);  </span><br><span class="line">            // 定时执行  </span><br><span class="line">            new Timer(&quot;Lock-Renew-Task&quot;).schedule(task, delay, period\_);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    static class ScheduleTask extends TimerTask &#123;  </span><br><span class="line">   </span><br><span class="line">        private final RedisDistributionLockPlus redisDistributionLock;  </span><br><span class="line">        private final Map&lt;String, LockContent&gt; lockContentMap;  </span><br><span class="line">   </span><br><span class="line">        public ScheduleTask(RedisDistributionLockPlus redisDistributionLock, Map&lt;String, LockContent&gt; lockContentMap) &#123;  </span><br><span class="line">            this.redisDistributionLock = redisDistributionLock;  </span><br><span class="line">            this.lockContentMap = lockContentMap;  </span><br><span class="line">        &#125;  </span><br><span class="line">   </span><br><span class="line">        @Override  </span><br><span class="line">        public void run() &#123;  </span><br><span class="line">            if (lockContentMap.isEmpty()) &#123;  </span><br><span class="line">                return;  </span><br><span class="line">            &#125;  </span><br><span class="line">            Set&lt;Map.Entry&lt;String, LockContent&gt;&gt; entries = lockContentMap.entrySet();  </span><br><span class="line">            for (Map.Entry&lt;String, LockContent&gt; entry : entries) &#123;  </span><br><span class="line">                String lockKey = entry.getKey();  </span><br><span class="line">                LockContent lockContent = entry.getValue();  </span><br><span class="line">                long expireTime = lockContent.getExpireTime();  </span><br><span class="line">                // 减少线程池中任务数量  </span><br><span class="line">                if ((expireTime - System.currentTimeMillis())/ 1000 &lt; TIME\_SECONDS\_FIVE) &#123;  </span><br><span class="line">                    //线程池异步续约  </span><br><span class="line">                    ThreadPool.submit(() -&gt; &#123;  </span><br><span class="line">                        boolean renew = redisDistributionLock.renew(lockKey, lockContent);  </span><br><span class="line">                        if (renew) &#123;  </span><br><span class="line">                            long expireTimeNew = lockContent.getStartTime() + (expireTime - lockContent.getStartTime()) \* 2 - TIME\_SECONDS\_FIVE \* 1000;  </span><br><span class="line">                            lockContent.setExpireTime(expireTimeNew);  </span><br><span class="line">                        &#125; else &#123;  </span><br><span class="line">                            // 续约失败，说明已经执行完 OR redis 出现问题  </span><br><span class="line">                            lockContentMap.remove(lockKey);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过源码，可以发现：</p>
<p>Redission <code>加锁</code>、<code>解锁</code>、<code>续约</code>都是客户端把一些复杂的业务逻辑，通过封装在<code>Lua</code>脚本中发送给<code>redis</code>，保证这段复杂业务逻辑执行的<code>原子性</code></p>
<p>有关  <strong>锁过期</strong> 的系统化、体系化的 介绍， 请参见的 专题文章（建议大家看10遍）：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzkxNzIyMTM1NQ==&mid=2247503521&idx=1&sn=e2f71881eb3abd52d484213089262ebc&scene=21#wechat_redirect"><strong>史上最全： Redis锁如何续期 ？Redis锁超时，任务没完怎么办？</strong></a></p>
<h2 id="之四：锁失效-的深坑"><a href="#之四：锁失效-的深坑" class="headerlink" title="之四：锁失效 的深坑"></a>之四：锁失效 的深坑</h2><p>redis高可用最常见的方案就是主从复制（master-slave），这种模式也给redis分布式锁挖了一坑。</p>
<p>redis cluster集群环境下，假如现在A客户端想要加锁，它会根据路由规则选择一台master节点写入key mylock，在加锁成功后，master节点会把key异步复制给对应的slave节点。</p>
<p>在Redis主从架构中，写入的，都是 master Redis实例，master 主实例会向 slave 从实例同步key。</p>
<p>一个业务线程 通过向主Redis实例中写入 key-value 来实现加分布式锁，加锁后开始执行业务代码。</p>
<p>一般情况下：如果主master Redis实例挂掉了，会选举出一个从Redis实例成为主的。这是redis 集群的故障转移机制。</p>
<p>但是，如果刚刚加锁的key还没有来得及同步到slave Redis中，新选出的主Redis实例中就没有这个key，这个时候业务线程B就能加锁来获取分布式锁，导致锁失效了。</p>
<p>线程B 加锁成功，也执行业务代码了。</p>
<p>B客户端在新的master节点上加锁成功，而A客户端也以为自己还是成功加了锁的。</p>
<p>此时就会导致同一时间内多个客户端对一个分布式锁完成了加锁，导致各种脏数据的产生。</p>
<p>而这个时候A还没有执行结束，所以就会出现并发安全问题，这就是Redis主从架构下的分布式锁失效问题</p>
<p>本质上，Redis 分布式锁的高可用，有两个层面的解决方案：</p>
<p>Redis 分布式锁的Server端高可用方案, 就是通过配置， 保证Server 尽量可能少的数据丢失。</p>
<p>在redis的配置文件中有两个参数我们可以设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">min-slaves-to-write 1  </span><br><span class="line">min-slaves-max-lag 10  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>min-slaves-to-write默认情况下是0，min-slaves-max-lag默认情况下是10。</p>
<p>Redis 分布式锁的Server端高可用方案, 就是使用红锁。</p>
<p>在 Java 中，可以使用 Redisson 框架来实现 RedLock。RedissonRedLock 实际上是基于 RedissonMultiLock 实现的，从继承关系可以看出这一点。</p>
<p>Redisson 提供了 RedissonMultiLock 类，它可以同时管理多个锁，并保证操作的原子性。</p>
<p>以下是 Redisson 中 RedLock 的简单使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">RedissonClient redisson = // 初始化 Redisson 客户端  </span><br><span class="line">RLock lock1 = redisson.getLock(&quot;lock1&quot;);  </span><br><span class="line">RLock lock2 = redisson.getLock(&quot;lock2&quot;);  </span><br><span class="line">RLock lock3 = redisson.getLock(&quot;lock3&quot;);  </span><br><span class="line">  </span><br><span class="line">RedissonMultiLock multiLock = new RedissonMultiLock(lock1, lock2, lock3);  </span><br><span class="line">try &#123;  </span><br><span class="line">   if (multiLock.tryLock()) &#123;  </span><br><span class="line">       // 成功获取锁，执行业务逻辑  </span><br><span class="line">   &#125; else &#123;  </span><br><span class="line">       // 获取锁失败  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125; finally &#123;  </span><br><span class="line">   multiLock.unlock(); // 释放锁  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过以上机制，RedLock 在分布式环境下提供了一种较为可靠的锁方案，能够应对部分节点故障，并保持锁服务的可用性和安全性。</p>
<p>RedLock 具备以下主要特性：</p>
<ul>
<li><p>互斥性：在任何时间，只有一个客户端可以获得锁，确保了资源的互斥访问。</p>
</li>
<li><p>避免死锁：通过为锁设置一个较短的过期时间，即使客户端在获得锁后由于网络故障等原因未能按时释放锁，锁也会因为过期而自动释放，避免了死锁的发生。</p>
</li>
<li><p>容错性：即使一部分 Redis 节点宕机，只要大多数节点（即过半数以上的节点）仍在线，RedLock 算法就能继续提供服务，并确保锁的正确性。</p>
</li>
</ul>
<p>有关  <strong>锁失效</strong> 的系统化、体系化的 介绍， 请参见的 专题文章（建议大家看10遍）：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzkxNzIyMTM1NQ==&mid=2247503611&idx=1&sn=3cf05137d843f87757f3b7a3c76dbd7b&scene=21#wechat_redirect"><strong>史上最全：Redis分布式 锁失效了，怎么办？</strong></a></p>
<h2 id="之五：锁分段-的深坑"><a href="#之五：锁分段-的深坑" class="headerlink" title="之五：锁分段 的深坑"></a>之五：锁分段 的深坑</h2><p>此外，为了减小锁的粒度，比较常见的做法是将大锁：分段。</p>
<p>java中`ConcurrentHashMap ，就是将数据分为16段，每一段都有单独的锁，并且处于不同锁段的数据互不干扰，以此来提升锁的性能。</p>
<p>由于秒杀场景的分布式锁，实际上是为了防止超卖， 和库存是强相关的。</p>
<p>所以，可以结合库存，把秒杀的分布式锁 提升性能。</p>
<p>第一步： 把redis 的分段方式进行演进，就是将库存分段分为100段，每一段都有单独的锁，并且处于不同锁段的数据互不干扰，以此来提升锁的性能。。</p>
<p>第二步：使用hash取模法，把用户路由到某一个分段，如果分段里边的库存耗光了，就去访问剩余的总库存。</p>
<p>具体来说，现在的库存中有2000个商品，用户可以秒杀。为了防止出现超卖的情况，通常情况下，可以对库存加锁。如果有1W的用户竞争同一把锁，显然系统吞吐量会非常低。</p>
<p>为了提升系统性能，我们可以将库存分段，比如：分为100段，这样每段就有20个商品可以参与秒杀。</p>
<p>在秒杀的过程中，先把用户id获取hash值，然后除以100取模。</p>
<p>模为1的用户访问第1段库存，模为2的用户访问第2段库存，模为3的用户访问第3段库存，后面以此类推，到最后模为100的用户访问第100段库存。</p>
<p><img src="/./2025/02/24/redis-%E9%94%81%E7%9A%845%E4%B8%AA%E5%A4%A7%E5%9D%91%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%EF%BC%9F/5.png"></p>
<p>上面的这个 方案还有一个不足：</p>
<ul>
<li>可能 其他slot槽位 还有 库存， 但是 用户请求 路由到 对应的分片槽位 没有库存， 导致 扣减库存失败</li>
</ul>
<h3 id="解决办法是：在使用hash取模基础上，可以使用动态库存迁移，减少库存消耗不均和无效重试"><a href="#解决办法是：在使用hash取模基础上，可以使用动态库存迁移，减少库存消耗不均和无效重试" class="headerlink" title="解决办法是：在使用hash取模基础上，可以使用动态库存迁移，减少库存消耗不均和无效重试"></a>解决办法是：在使用hash取模基础上，可以使用动态库存迁移，减少库存消耗不均和无效重试</h3><p>所以，可以结合库存，把秒杀的分布式锁进行改进。</p>
<p>第一步： 把redis 的分段方式进行演进，额外增加一个总库存分段锁，用于分配存储剩余的总库存。采用多批次少量分配的思路，通过定时任务，从总库存向分段库存中迁移库存。</p>
<p>第二步：使用hash取模法，把用户路由到某一个分段，如果分段里边的库存耗光了，就去访问剩余的总库存。</p>
<h3 id="库存动态迁移"><a href="#库存动态迁移" class="headerlink" title="库存动态迁移"></a>库存动态迁移</h3><p>为了防止分段多库存耗光，大家都去抢占总库存锁。</p>
<p>采用多批次少量分配的思路，通过定时任务，从总库存向分段库存中迁移库存。</p>
<p>至此， hash取模法的分段锁设计方案，已经完美实现。</p>
<p>并且社群中，已经有小伙伴在生产上完成落地。 以上方案，也是在给他一对一改简历的时候，分享给的。</p>
<p>当然，如果大家简历挖掘不出来亮点，也可以找挖掘， 保证简历金光闪闪、改天换地。</p>
<p>如此一来，在多线程环境中，可以大大的减少锁的冲突。</p>
<p>以前多个线程只能同时竞争1把锁，尤其在秒杀的场景中，竞争太激烈了，简直可以用惨绝人寰来形容，其后果是导致绝大数线程在锁等待。</p>
<p>redis 锁，是一个非常常见的高并发面试题，很多面试官也非常熟悉，上来就让面试者讲讲 redis 锁。</p>
<p>珍藏此文， 帮大家 吊打面试官。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://flowtime.asia">周五打工人</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://flowtime.asia/2025/02/24/redis-%E9%94%81%E7%9A%845%E4%B8%AA%E5%A4%A7%E5%9D%91%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%EF%BC%9F/">http://flowtime.asia/2025/02/24/redis-%E9%94%81%E7%9A%845%E4%B8%AA%E5%A4%A7%E5%9D%91%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%EF%BC%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://flowtime.asia" target="_blank">繁华流年间</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="/img/liushui.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/02/24/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-Sentinel/" title="从入门到精通 Sentinel"><img class="cover" src="/img/liushui.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">从入门到精通 Sentinel</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/28/IDEA%E4%B8%ADGit-Reset%E9%80%89%E9%A1%B9%E8%AF%B4%E6%98%8E/" title="IDEA中Git Reset选项说明"><img class="cover" src="/img/hubian.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">IDEA中Git Reset选项说明</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/08/11/Redis-%E6%9D%80%E7%96%AF%E4%BA%86%E3%80%82%E3%80%82%E3%80%82/" title="Redis 杀疯了。。。"><img class="cover" src="/img/hubian.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-11</div><div class="title">Redis 杀疯了。。。</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/nav.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">周五打工人</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">无论你是追求知识的急先锋，还是对生活感悟充满好奇，亦或是渴望找到属于自己情感共鸣的灵魂，本博客都将竭诚欢迎你的加入。共同书写属于自己的精彩篇章。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E9%94%81%E7%9A%845%E4%B8%AA%E5%A4%A7%E5%9D%91%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">redis 锁的5个大坑，如何规避？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E4%B8%BB%E8%A6%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">分布式锁 使用场景和主要类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">分布式锁 的使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E7%9C%8B%E6%9C%AC%E5%9C%B0%E9%94%81%EF%BC%9A"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">先看本地锁：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%8D%E7%9C%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">再看分布式锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">什么是分布式锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.3.</span> <span class="toc-text">常见分布式锁方案对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-5%E5%A4%A7%E6%B7%B1%E5%9D%91"><span class="toc-number">1.2.</span> <span class="toc-text">redis 分布式锁 5大深坑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%8B%E4%B8%80%EF%BC%9A-%E5%8E%9F%E5%AD%90%E6%80%A7-%E4%B9%8B%E6%B7%B1%E5%9D%91"><span class="toc-number">1.3.</span> <span class="toc-text">之一： 原子性 之深坑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%8B%E4%BA%8C%EF%BC%9A%E8%BF%9E%E6%8E%A5%E8%80%97%E5%B0%BD-%E4%B9%8B%E6%B7%B1%E5%9D%91"><span class="toc-number">1.4.</span> <span class="toc-text">之二：连接耗尽 之深坑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.4.1.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%8B%E4%B8%89%EF%BC%9A%E9%94%81%E8%BF%87%E6%9C%9F-%E7%9A%84%E6%B7%B1%E5%9D%91"><span class="toc-number">1.5.</span> <span class="toc-text">之三：锁过期 的深坑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.5.1.</span> <span class="toc-text">锁过期问题 的解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E6%A8%A1%E6%8B%9FCAS%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%A2%9E%E5%8A%A0%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number">1.5.2.</span> <span class="toc-text">方式一：模拟CAS乐观锁的方式，增加版本号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9Awatch-dog%E8%87%AA%E5%8A%A8%E5%BB%B6%E6%9C%9F%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.3.</span> <span class="toc-text">方式二：watch dog自动延期机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%8B%E5%9B%9B%EF%BC%9A%E9%94%81%E5%A4%B1%E6%95%88-%E7%9A%84%E6%B7%B1%E5%9D%91"><span class="toc-number">1.6.</span> <span class="toc-text">之四：锁失效 的深坑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%8B%E4%BA%94%EF%BC%9A%E9%94%81%E5%88%86%E6%AE%B5-%E7%9A%84%E6%B7%B1%E5%9D%91"><span class="toc-number">1.7.</span> <span class="toc-text">之五：锁分段 的深坑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E6%98%AF%EF%BC%9A%E5%9C%A8%E4%BD%BF%E7%94%A8hash%E5%8F%96%E6%A8%A1%E5%9F%BA%E7%A1%80%E4%B8%8A%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%BA%93%E5%AD%98%E8%BF%81%E7%A7%BB%EF%BC%8C%E5%87%8F%E5%B0%91%E5%BA%93%E5%AD%98%E6%B6%88%E8%80%97%E4%B8%8D%E5%9D%87%E5%92%8C%E6%97%A0%E6%95%88%E9%87%8D%E8%AF%95"><span class="toc-number">1.7.1.</span> <span class="toc-text">解决办法是：在使用hash取模基础上，可以使用动态库存迁移，减少库存消耗不均和无效重试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%AD%98%E5%8A%A8%E6%80%81%E8%BF%81%E7%A7%BB"><span class="toc-number">1.7.2.</span> <span class="toc-text">库存动态迁移</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/02/27/%E6%9C%80%E6%96%B0Seata%E9%9B%86%E6%88%90%E4%BA%86RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AFyyds/" title="最新Seata集成了RocketMQ事务消息yyds"><img src="/img/haibian.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="最新Seata集成了RocketMQ事务消息yyds"/></a><div class="content"><a class="title" href="/2025/02/27/%E6%9C%80%E6%96%B0Seata%E9%9B%86%E6%88%90%E4%BA%86RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AFyyds/" title="最新Seata集成了RocketMQ事务消息yyds">最新Seata集成了RocketMQ事务消息yyds</a><time datetime="2025-02-27T03:03:11.000Z" title="发表于 2025-02-27 11:03:11">2025-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/27/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-Nacos%E6%9C%80%E5%85%A8%E8%AF%A6%E8%A7%A3/" title="从入门到精通 Nacos最全详解"><img src="/img/hubian.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从入门到精通 Nacos最全详解"/></a><div class="content"><a class="title" href="/2025/02/27/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-Nacos%E6%9C%80%E5%85%A8%E8%AF%A6%E8%A7%A3/" title="从入门到精通 Nacos最全详解">从入门到精通 Nacos最全详解</a><time datetime="2025-02-27T02:27:12.000Z" title="发表于 2025-02-27 10:27:12">2025-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/24/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-Sentinel/" title="从入门到精通 Sentinel"><img src="/img/liushui.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从入门到精通 Sentinel"/></a><div class="content"><a class="title" href="/2025/02/24/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-Sentinel/" title="从入门到精通 Sentinel">从入门到精通 Sentinel</a><time datetime="2025-02-24T07:48:28.000Z" title="发表于 2025-02-24 15:48:28">2025-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/24/redis-%E9%94%81%E7%9A%845%E4%B8%AA%E5%A4%A7%E5%9D%91%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%EF%BC%9F/" title="redis 锁的5个大坑，如何规避？"><img src="/img/liushui.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis 锁的5个大坑，如何规避？"/></a><div class="content"><a class="title" href="/2025/02/24/redis-%E9%94%81%E7%9A%845%E4%B8%AA%E5%A4%A7%E5%9D%91%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%EF%BC%9F/" title="redis 锁的5个大坑，如何规避？">redis 锁的5个大坑，如何规避？</a><time datetime="2025-02-24T02:42:01.000Z" title="发表于 2025-02-24 10:42:01">2025-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/28/IDEA%E4%B8%ADGit-Reset%E9%80%89%E9%A1%B9%E8%AF%B4%E6%98%8E/" title="IDEA中Git Reset选项说明"><img src="/img/hubian.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IDEA中Git Reset选项说明"/></a><div class="content"><a class="title" href="/2024/08/28/IDEA%E4%B8%ADGit-Reset%E9%80%89%E9%A1%B9%E8%AF%B4%E6%98%8E/" title="IDEA中Git Reset选项说明">IDEA中Git Reset选项说明</a><time datetime="2024-08-28T14:58:04.000Z" title="发表于 2024-08-28 22:58:04">2024-08-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 周五打工人</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://mywaline-7unwzwfdi-motors-projects-a4d09e71.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://mywaline-7unwzwfdi-motors-projects-a4d09e71.vercel.app/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>