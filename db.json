{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"source\\CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source\\templates\\search.xml","path":"templates/search.xml","modified":0,"renderable":0},{"_id":"themes\\butterfly\\source\\css\\footer.css","path":"css/footer.css","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\css\\index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\css\\transparent.css","path":"css/transparent.css","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\css\\universe.css","path":"css/universe.css","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\css\\var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\img\\404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\img\\favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\img\\friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\img\\haibian.png","path":"img/haibian.png","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\img\\hubian.png","path":"img/hubian.png","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\img\\index.jpg","path":"img/index.jpg","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\img\\liushui.png","path":"img/liushui.png","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\img\\nav.jpg","path":"img/nav.jpg","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\js\\fishes.js","path":"js/fishes.js","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\js\\jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\js\\main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\js\\tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\js\\universe.js","path":"js/universe.js","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\js\\utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\js\\search\\algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes\\butterfly\\source\\js\\search\\local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source\\CNAME","hash":"a14ecc72617888c2cf1fd57e3f7c4d4062404fc6","modified":1717215550605},{"_id":"source\\categories\\index.md","hash":"8cf840121655d20d27a1abb54c6340f72a454685","modified":1716701410102},{"_id":"source\\_data\\link.yml","hash":"90adb8388ad24aa5b2b03c35d31f3647ebc5afbd","modified":1716214657065},{"_id":"source\\link\\index.md","hash":"4f02c78ee1f63206b7fe340583b3073edebb2411","modified":1716701425849},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT.md","hash":"952926e2de00a2693957256da0589417402b5486","modified":1717216683432},{"_id":"source\\_posts\\Springboot最热点面试题.md","hash":"414db7154d5334d8baed1aaba6df0d21ada69c10","modified":1716735235031},{"_id":"source\\_posts\\Springcloud最热点面试题.md","hash":"6e4bf780216a45b3e55632e3e787cde81fd67034","modified":1716735933395},{"_id":"source\\_posts\\Springmvc最热点面试题.md","hash":"ff856e5adc5d02f493d4d25d8b0103b2a9fcb30c","modified":1716735396694},{"_id":"source\\_posts\\Spring最热点面试题.md","hash":"3a0592b320fa0dd0f67a0be9bce6e8798f9f79db","modified":1716734666083},{"_id":"source\\_posts\\hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":499162500000},{"_id":"source\\_posts\\场景设计面试题.md","hash":"0f76fa15b3ca13e3b37cd15ca49ef9572aa6ecf8","modified":1716736799123},{"_id":"source\\_posts\\写代码神器.md","hash":"ae77c555493332ba8c0fca9bef17b2f432c21273","modified":1716733247814},{"_id":"source\\_posts\\百亿流量红包系统.md","hash":"afbec10a523d0a8ed0824d26bb4e24ec323d8e27","modified":1717214828899},{"_id":"source\\tags\\index.md","hash":"167c286b3144d91525b04bd2b24c055634df08f8","modified":1716701373578},{"_id":"source\\_posts\\统计全国重名最多的前100个.md","hash":"e09a1693fbc44a9cd73236c3fbd5ed5c96215edf","modified":1717320226849},{"_id":"source\\templates\\search.xml","hash":"55ff793e92e4bc6359b67ff822bc4472cc68b877","modified":1716216783558},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\1.png","hash":"b25993a23ae2eb230492e99e43e3b25c60e2b6d7","modified":1717216379839},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\3.png","hash":"a8e918bacb1a333364b778d481e8214391279179","modified":1717216412464},{"_id":"source\\_posts\\Springcloud最热点面试题\\1.png","hash":"74133c96884d8aa652bba827e7f2bb24273af593","modified":1716735544295},{"_id":"source\\_posts\\Springcloud最热点面试题\\5.png","hash":"d5b563a500b443dfbe755547c7ca46d35e1f8bdb","modified":1716735727042},{"_id":"source\\_posts\\Springcloud最热点面试题\\6.png","hash":"cd284de11375c3c8180bedfe4686235efddfda2f","modified":1716735738771},{"_id":"source\\_posts\\Springcloud最热点面试题\\7.png","hash":"03b42d789a9bd6b41d6346abb94db71f1c0fcd24","modified":1716735750385},{"_id":"source\\_posts\\Springcloud最热点面试题\\8.png","hash":"c1e35779ca626b6e9096320e861a8ac793a8c3b7","modified":1716735767716},{"_id":"source\\_posts\\Springcloud最热点面试题\\9.png","hash":"545ce573a50b93063cdd32e83f3f392d60329719","modified":1716735780538},{"_id":"source\\_posts\\场景设计面试题\\11.png","hash":"a5b18f79b4c90a8016d2de992cb619a51de88dd2","modified":1716736611147},{"_id":"source\\_posts\\场景设计面试题\\10.png","hash":"22845f542998d6c4348bf9d078e2fc39e1266737","modified":1716736601631},{"_id":"source\\_posts\\场景设计面试题\\12.png","hash":"5dedc836fc77c332e7299f52b32518c5d808e938","modified":1716736622129},{"_id":"source\\_posts\\场景设计面试题\\6.png","hash":"45305724c0aec07344d96fd3e82a900c09067c2c","modified":1716736540697},{"_id":"source\\_posts\\场景设计面试题\\8.png","hash":"0e34ebf4f2030ecd47ce97db7fe8333225704a3a","modified":1716736564565},{"_id":"source\\_posts\\场景设计面试题\\9.png","hash":"f830d80e9779553509ee78456368bbd74128ee4e","modified":1716736575438},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\10.png","hash":"9b1117e6d97dc40f07ce02da023ae1b3126c3f59","modified":1717216528030},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\11.png","hash":"f4d4f0bb4b6063abb31568ddd6087c6c20972ad0","modified":1717216541163},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\4.png","hash":"1e8578421656e6bc3563a587f10ecd92a5df326b","modified":1717216428122},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\8.png","hash":"9814e82372083819368025d85eb86226cc83eb20","modified":1717216498931},{"_id":"source\\_posts\\Springcloud最热点面试题\\4.png","hash":"4ed8f325ec02e456cc97351dd51fab2195adfec3","modified":1716735710759},{"_id":"source\\_posts\\Spring最热点面试题\\1.png","hash":"1a54fd4cc7bd0aa146381a578a07690fa9f3fa01","modified":1716734688171},{"_id":"source\\_posts\\写代码神器\\2.png","hash":"2c1a4c8d5490e05348017788875440647450d167","modified":1716699673592},{"_id":"source\\_posts\\写代码神器\\1.png","hash":"6d5458a4b56e47e132202173ea96a37dee0357fc","modified":1716698963649},{"_id":"source\\_posts\\写代码神器\\3.png","hash":"228bff7535038b60fea45979fa8aab30bdbbe124","modified":1716699744497},{"_id":"source\\_posts\\场景设计面试题\\3.png","hash":"f4ed04ec67beb7d94e1aa07f9e20699284d1b136","modified":1716736497410},{"_id":"source\\_posts\\场景设计面试题\\2.png","hash":"c0357bb1314dc52fa51736e9903aa9c9c302261f","modified":1716736484033},{"_id":"source\\_posts\\场景设计面试题\\5.png","hash":"3f5bcd812c160874882b7c78169d50fe9c5e7d68","modified":1716736531196},{"_id":"source\\_posts\\百亿流量红包系统\\2.png","hash":"9542b863e4ddc5c6ac1d08a42f38545a66e32663","modified":1717213559925},{"_id":"source\\_posts\\百亿流量红包系统\\3.png","hash":"7bf6bc969f35db83c4a77a483a478992f334923e","modified":1717213713311},{"_id":"source\\_posts\\场景设计面试题\\7.png","hash":"2ca62c594040efb6ac5b1de18d154c089b60b504","modified":1716736553893},{"_id":"source\\_posts\\百亿流量红包系统\\6.png","hash":"a015accafa23bd412d50a69329d81a002ac73b0f","modified":1717213078436},{"_id":"source\\_posts\\百亿流量红包系统\\5.png","hash":"fe15b865523b15d79e83babefca63445a0f65429","modified":1717213078433},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\5.png","hash":"47246db7c4451e4505308a7a7b7cc35b0b1acab8","modified":1717216446081},{"_id":"source\\_posts\\场景设计面试题\\4.png","hash":"df313ec53071699d2875e3e471a870418084e4ab","modified":1716736513045},{"_id":"source\\_posts\\百亿流量红包系统\\4.png","hash":"cdffe930dbe7fd9e97db3343d23e7048ce092c29","modified":1717213794712},{"_id":"source\\_posts\\百亿流量红包系统\\10.png","hash":"8a4c35c5a66728307f3567a8086f42e2f0337623","modified":1717213078414},{"_id":"source\\_posts\\百亿流量红包系统\\9.png","hash":"60c653e26c7edc3d153fbf9e90215396700daffc","modified":1717213078447},{"_id":"source\\_posts\\百亿流量红包系统\\11.png","hash":"7db213d216da702b94883ea8aa11ecb0592cead8","modified":1717214534065},{"_id":"source\\_posts\\百亿流量红包系统\\7.png","hash":"59be9f9deb6abad8de41c38335c792e88c15f6a1","modified":1717214190802},{"_id":"source\\_posts\\百亿流量红包系统\\1.png","hash":"13c3f20ff81933a3b99d07482fdbe562752df89d","modified":1717213078409},{"_id":"source\\_posts\\百亿流量红包系统\\8.png","hash":"1997b30d4241039907e408b9dbc54f591ca33dc1","modified":1717214437512},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\9.png","hash":"75bb4b91ab8579d0f4993ae1d36c0498f9ecc233","modified":1717216511792},{"_id":"source\\_posts\\Springmvc最热点面试题\\1.png","hash":"de87da42c021efe015af684e4288d38a41e6d6b5","modified":1716735365263},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\7.png","hash":"c3f3eb752e7c4e9d4fc2409ec82de0b875b669c1","modified":1717216483924},{"_id":"source\\_posts\\Springcloud最热点面试题\\2.png","hash":"bd76bb0b304b3a9c1b7876f6db87ee2a16ec82b6","modified":1716735670380},{"_id":"source\\_posts\\统计全国重名最多的前100个\\1.png","hash":"b5d2ab36c43e90e3b5a9477c620c4f5e6d639dad","modified":1717320020271},{"_id":"source\\_posts\\Springcloud最热点面试题\\3.png","hash":"eac5e2e7c1429bca4eea52669595ba67cfa13b5a","modified":1716735695757},{"_id":"themes\\butterfly\\LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1716213409506},{"_id":"themes\\butterfly\\README.md","hash":"20a91bea7f7ada8b8195d2abff106a7ce21bba20","modified":1716213409506},{"_id":"themes\\butterfly\\_config.yml","hash":"c6fab3700a6502b5790ca20d20113020544ea048","modified":1716213409507},{"_id":"themes\\butterfly\\README_CN.md","hash":"9d729ee2ffc5e5f703ccfbfbbb7b286d59071125","modified":1716213409507},{"_id":"themes\\butterfly\\package.json","hash":"2b6fb6f62b9fa6a829311ffd532ae760fbd0a7db","modified":1716213409524},{"_id":"themes\\butterfly\\plugins.yml","hash":"7bb2c7350c0c57850aa30213cd0f26553a614702","modified":1716213409524},{"_id":"themes\\butterfly\\.github\\FUNDING.yml","hash":"3b572099a992e30267f5fe4cd3c582ff7ac9f083","modified":1716213409505},{"_id":"themes\\butterfly\\languages\\default.yml","hash":"90e9e2f36dc51aa77eb7804ae048b4876035b12d","modified":1716213409507},{"_id":"themes\\butterfly\\languages\\en.yml","hash":"68127be0e6b44cfc5f31353d8b275c02939b3ff9","modified":1716213409507},{"_id":"themes\\butterfly\\languages\\zh-CN.yml","hash":"2dcc70a011b37890215ae0fd6d8f8c78aa8af6b0","modified":1716213409507},{"_id":"themes\\butterfly\\languages\\zh-TW.yml","hash":"1392e7b8c678cdfb54f55523693e66abc7d80538","modified":1716213409508},{"_id":"themes\\butterfly\\layout\\archive.pug","hash":"bc77220dfc269b8faad0930e1a4142ebf68165e5","modified":1716213409508},{"_id":"themes\\butterfly\\layout\\category.pug","hash":"bf979aec88d78b644fc5d31518f8679ad7625792","modified":1716213409508},{"_id":"themes\\butterfly\\layout\\index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1716213409524},{"_id":"themes\\butterfly\\layout\\page.pug","hash":"bf2d6c6d2d156777b55292e51be02b0b3acf0af8","modified":1716213409524},{"_id":"themes\\butterfly\\layout\\post.pug","hash":"fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0","modified":1716213409524},{"_id":"themes\\butterfly\\layout\\tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1716213409524},{"_id":"themes\\butterfly\\.github\\workflows\\publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1716213409506},{"_id":"themes\\butterfly\\.github\\workflows\\stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1716213409506},{"_id":"themes\\butterfly\\.github\\ISSUE_TEMPLATE\\bug_report.yml","hash":"eed9190301095b35081aa2658204cc3f15b9f5e1","modified":1716213409505},{"_id":"themes\\butterfly\\.github\\ISSUE_TEMPLATE\\config.yml","hash":"63ad2249ad09fb3fe21bd5ff9adefb304a7ab24a","modified":1716213409505},{"_id":"themes\\butterfly\\.github\\ISSUE_TEMPLATE\\feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1716213409505},{"_id":"themes\\butterfly\\layout\\includes\\404.pug","hash":"aace9ddff469de4226e47a52ede1c81e66d66d5c","modified":1716213409508},{"_id":"themes\\butterfly\\layout\\includes\\additional-js.pug","hash":"50eea5aa78cdeb6c72dd22f0aeabc407cc0f712e","modified":1716213409508},{"_id":"themes\\butterfly\\layout\\includes\\footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1716213409509},{"_id":"themes\\butterfly\\layout\\includes\\head.pug","hash":"ea8d4e8ac6af93cd268ba8f6ffcb80417bc2501e","modified":1716213409509},{"_id":"themes\\butterfly\\layout\\includes\\layout.pug","hash":"96df62e34661d8ca4a45267286127479e5178a79","modified":1716213409511},{"_id":"themes\\butterfly\\layout\\includes\\pagination.pug","hash":"c5c58714fb3cb839653e5c32e6094784c8662935","modified":1716213409513},{"_id":"themes\\butterfly\\layout\\includes\\rightside.pug","hash":"f448bf73103b88de4443e52d600e871cf3de3e32","modified":1716213409513},{"_id":"themes\\butterfly\\layout\\includes\\sidebar.pug","hash":"9277fead4c29dbe93976f078adaa26e8f9253da3","modified":1716213409514},{"_id":"themes\\butterfly\\scripts\\events\\404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1716213409525},{"_id":"themes\\butterfly\\scripts\\events\\cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1716213409525},{"_id":"themes\\butterfly\\scripts\\events\\comment.js","hash":"95479790234c291b064d031577d71214cdd1d820","modified":1716213409525},{"_id":"themes\\butterfly\\scripts\\events\\init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1716213409525},{"_id":"themes\\butterfly\\scripts\\events\\stylus.js","hash":"0a336dfe5ed08952fa0df1532421df38a74a20d6","modified":1716213409525},{"_id":"themes\\butterfly\\scripts\\events\\merge_config.js","hash":"b1dfc3c898b886eab1241b068fc27d7a26a3b7d2","modified":1716213409525},{"_id":"themes\\butterfly\\scripts\\events\\welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1716213409525},{"_id":"themes\\butterfly\\scripts\\filters\\random_cover.js","hash":"0df22d7dbfa766a65cb6032a1f003348f4307cfe","modified":1716213409526},{"_id":"themes\\butterfly\\scripts\\filters\\post_lazyload.js","hash":"5ed2d7ef240c927fe1b7a7fb5bf9e55e2bfd55a5","modified":1716213409526},{"_id":"themes\\butterfly\\scripts\\helpers\\aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1716213409526},{"_id":"themes\\butterfly\\scripts\\helpers\\aside_categories.js","hash":"cdd992c8577d583c237b6aac9f5077d8200879b2","modified":1716213409526},{"_id":"themes\\butterfly\\scripts\\helpers\\findArchiveLength.js","hash":"b12895e0765d596494e5526d121de0dd5a7c23d3","modified":1716213409526},{"_id":"themes\\butterfly\\scripts\\helpers\\inject_head_js.js","hash":"b55f71347d2ead097c7f98c0ec792b091433345c","modified":1716213409526},{"_id":"themes\\butterfly\\scripts\\helpers\\page.js","hash":"c74d6a9b8f71e69447f7847a5f5e81555d68b140","modified":1716213409527},{"_id":"themes\\butterfly\\scripts\\helpers\\related_post.js","hash":"76343ac8422c9c8539082e77eda6ffee4b877eb2","modified":1716213409527},{"_id":"themes\\butterfly\\scripts\\helpers\\series.js","hash":"17c0095bc8d612a268cdcab000b1742dc4c6f811","modified":1716213409527},{"_id":"themes\\butterfly\\scripts\\tag\\button.js","hash":"164d5f1c2d1b4cb5a813a6fc574016743a53c019","modified":1716213409527},{"_id":"themes\\butterfly\\scripts\\tag\\flink.js","hash":"3ba7677969ff01fab06fc6713455ddc6861f0024","modified":1716213409527},{"_id":"themes\\butterfly\\scripts\\tag\\gallery.js","hash":"7ec77b3093f5de67e7032f40a5b12f1389f6f6ff","modified":1716213409528},{"_id":"themes\\butterfly\\scripts\\tag\\hide.js","hash":"5d08c3552f7d3c80a724ca628bff66321abe2e5a","modified":1716213409528},{"_id":"themes\\butterfly\\scripts\\tag\\inlineImg.js","hash":"c863d2732ce4bdc084f2d0db92f50f80328c1007","modified":1716213409528},{"_id":"themes\\butterfly\\scripts\\tag\\label.js","hash":"b013dc0a3d57d2caa18b89263f23871da9ec456d","modified":1716213409528},{"_id":"themes\\butterfly\\scripts\\tag\\mermaid.js","hash":"289f85847c58f0b2b7d98a68e370a2896edb8949","modified":1716213409528},{"_id":"themes\\butterfly\\scripts\\tag\\note.js","hash":"e68d8d21f3a86e3646907a3685550ee20e8d4a9f","modified":1716213409529},{"_id":"themes\\butterfly\\scripts\\tag\\score.js","hash":"35d54adc92e717cc32e13515122b025fd1a98ea2","modified":1716213409529},{"_id":"themes\\butterfly\\scripts\\tag\\series.js","hash":"dc56e5182dd3813dc977c9bf8556dcc7615e467b","modified":1716213409529},{"_id":"themes\\butterfly\\scripts\\tag\\tabs.js","hash":"7c448886f230adb4f4a0208c88fff809abcb5637","modified":1716213409529},{"_id":"themes\\butterfly\\scripts\\tag\\timeline.js","hash":"e611074a5a7f489a8b04afac0a3f7f882ce26532","modified":1716213409529},{"_id":"themes\\butterfly\\source\\css\\footer.css","hash":"bf8de948fdcbd3cdaccbe59d056d6a8f20da4969","modified":1716215811989},{"_id":"themes\\butterfly\\source\\css\\index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1716213409537},{"_id":"themes\\butterfly\\source\\css\\transparent.css","hash":"690c24e2c1aeb384dd5a3974373efea43b1fdc2b","modified":1716215541361},{"_id":"themes\\butterfly\\source\\css\\var.styl","hash":"950250f66faeb611a67540e0fa6cedbcf5a7a321","modified":1716213409537},{"_id":"themes\\butterfly\\source\\css\\universe.css","hash":"7374d54c80015e2ae9ef699adfdc8b6cefb1059f","modified":1716613088066},{"_id":"themes\\butterfly\\source\\img\\404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1716213409537},{"_id":"themes\\butterfly\\source\\img\\favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1716213409537},{"_id":"themes\\butterfly\\source\\js\\fishes.js","hash":"add094d86b254843ad554a51dd02ff784ae110dc","modified":1716215995614},{"_id":"themes\\butterfly\\source\\js\\main.js","hash":"59cd756a94ecdf3ec7b18f50691a8a6305f7a65a","modified":1716213409538},{"_id":"themes\\butterfly\\source\\js\\tw_cn.js","hash":"d776c670e4076ad6049dbb64cdee7a734b51d37f","modified":1716213409539},{"_id":"themes\\butterfly\\source\\js\\universe.js","hash":"19a6aa51ce3cf2fecc9e41d34be346908f4478d6","modified":1716613018989},{"_id":"themes\\butterfly\\source\\js\\utils.js","hash":"7b871fe0c4456660cff4c7b9cc4ed089adac2caf","modified":1716213409539},{"_id":"themes\\butterfly\\layout\\includes\\head\\Open_Graph.pug","hash":"c8dbdfe6145a0bc6f7691c9551be8169a2698f0a","modified":1716213409509},{"_id":"themes\\butterfly\\layout\\includes\\head\\analytics.pug","hash":"c7666a10448edd93f5ace37296051b7670495f1b","modified":1716213409510},{"_id":"themes\\butterfly\\layout\\includes\\head\\config.pug","hash":"39e1ca0a54eb5fd3688a78737417a1aaa50914c9","modified":1716213409510},{"_id":"themes\\butterfly\\layout\\includes\\head\\google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1716213409510},{"_id":"themes\\butterfly\\layout\\includes\\head\\config_site.pug","hash":"bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149","modified":1716213409510},{"_id":"themes\\butterfly\\layout\\includes\\head\\preconnect.pug","hash":"a7c929b90ae52b78b39b1728e3ab0e3db1cb7b9a","modified":1716213409510},{"_id":"themes\\butterfly\\layout\\includes\\head\\pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1716213409510},{"_id":"themes\\butterfly\\layout\\includes\\head\\site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1716213409510},{"_id":"themes\\butterfly\\layout\\includes\\header\\index.pug","hash":"1bef867c799ba158c5417272fb137539951aa120","modified":1716213409511},{"_id":"themes\\butterfly\\source\\img\\friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1716213409538},{"_id":"themes\\butterfly\\layout\\includes\\header\\menu_item.pug","hash":"ca8bcd90ad9467819330bfe7c02b76322754bccf","modified":1716213409511},{"_id":"themes\\butterfly\\layout\\includes\\header\\nav.pug","hash":"962ee70a35e60a13c31eea47d16b9f98069fe417","modified":1716213409511},{"_id":"themes\\butterfly\\layout\\includes\\header\\post-info.pug","hash":"cc99b2dc5c6b1f74391b0da609853ebc11de9610","modified":1716213409511},{"_id":"themes\\butterfly\\layout\\includes\\header\\social.pug","hash":"7a641b5dd45b970e1dafd1433eb32ea149e55cf2","modified":1716213409511},{"_id":"themes\\butterfly\\layout\\includes\\loading\\fullpage-loading.pug","hash":"766baca6ddce49d1724a02312387b292ff2d0bdc","modified":1716213409511},{"_id":"themes\\butterfly\\layout\\includes\\loading\\index.pug","hash":"00ae419f527d8225a2dc03d4f977cec737248423","modified":1716213409512},{"_id":"themes\\butterfly\\layout\\includes\\loading\\pace.pug","hash":"a6fde4835d6460ce7baf792fd5e1977fad73db25","modified":1716213409512},{"_id":"themes\\butterfly\\layout\\includes\\mixins\\article-sort.pug","hash":"9155f01d4c644a2e19b2b13b2d3c6d5e34dd0abf","modified":1716213409512},{"_id":"themes\\butterfly\\layout\\includes\\mixins\\post-ui.pug","hash":"90eb453b14f6b5c25bfd8d28aa67783603a1411d","modified":1716213409512},{"_id":"themes\\butterfly\\layout\\includes\\page\\categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1716213409512},{"_id":"themes\\butterfly\\layout\\includes\\page\\default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1716213409512},{"_id":"themes\\butterfly\\layout\\includes\\page\\flink.pug","hash":"e37681bc9c169d4220f26ecda2b3d5c02b6b9a0f","modified":1716213409513},{"_id":"themes\\butterfly\\layout\\includes\\page\\tags.pug","hash":"12be059c536490af216a397e8f2a7abbf6d4610e","modified":1716213409513},{"_id":"themes\\butterfly\\layout\\includes\\post\\post-copyright.pug","hash":"0abad416b1974a17e5be7817931d5fe799180170","modified":1716213409513},{"_id":"themes\\butterfly\\layout\\includes\\post\\reward.pug","hash":"912df10a053db3135968e92b6fd1a707ee94c968","modified":1716213409513},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\aplayer.pug","hash":"e939344fd389aeb11864ee697d5fd9b036d8325f","modified":1716213409514},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\effect.pug","hash":"43014bfc63583d3ee8808d526dd165848c0ed52f","modified":1716213409518},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\pangu.pug","hash":"f0898509da70388b5c532f19e762756d74080200","modified":1716213409520},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\pjax.pug","hash":"9b734d99963f3e7f562597dcf60485ccbf6e961c","modified":1716213409521},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\prismjs.pug","hash":"08979afbfecb4476a5ae8e360947b92624d285b8","modified":1716213409521},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\subtitle.pug","hash":"dfb5e16a7e7106bb20b2ac2d0df1251d0fc79609","modified":1716213409522},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1716213409522},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1716213409522},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1716213409522},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_author.pug","hash":"ab037bf5794638bd30da4cf7cf106e5d03b5f696","modified":1716213409522},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1716213409522},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1716213409523},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_post_series.pug","hash":"e0bb72fa0ce15964b11b8fe421cae3432394e35f","modified":1716213409523},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_newest_comment.pug","hash":"8e22f53886a57a68286970d8af8b4c950fd4a1d7","modified":1716213409523},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_post_toc.pug","hash":"d48d77af1670bd568d784794408bf524a448bfcc","modified":1716213409523},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1716213409523},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1716213409523},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1716213409523},{"_id":"themes\\butterfly\\layout\\includes\\widget\\index.pug","hash":"8df529f71e25f1c0a00e533de7944ed3d1ba7bd8","modified":1716213409523},{"_id":"themes\\butterfly\\layout\\includes\\widget\\card_webinfo.pug","hash":"12185713f9ca08984fc74e3b69d8cd6828d23da8","modified":1716213409523},{"_id":"themes\\butterfly\\source\\css\\_global\\index.styl","hash":"0421da07907b3d98df64239e073b23fbb3f04149","modified":1716213409530},{"_id":"themes\\butterfly\\source\\css\\_global\\function.styl","hash":"e920dae9ce00177922468db49240f5aca0af4f64","modified":1716213409529},{"_id":"themes\\butterfly\\source\\css\\_highlight\\theme.styl","hash":"3c178608406c31d768af355ef1d7326da37cc75f","modified":1716213409531},{"_id":"themes\\butterfly\\source\\css\\_layout\\aside.styl","hash":"aae70ddd126b2e40158e45036abecbfa33cbfbba","modified":1716213409531},{"_id":"themes\\butterfly\\source\\css\\_highlight\\highlight.styl","hash":"41054740cfbd1357138785464f6859681ca58493","modified":1716213409530},{"_id":"themes\\butterfly\\source\\css\\_layout\\chat.styl","hash":"792a04d36de32f230ca3256ad87a90fe8392f333","modified":1716213409531},{"_id":"themes\\butterfly\\source\\css\\_layout\\footer.styl","hash":"5e27f7842af82ff7498d4b59787ce9ca90fa9e6f","modified":1716213409532},{"_id":"themes\\butterfly\\source\\css\\_layout\\comments.styl","hash":"fbfce4d67cacd1df22fb73d89d008693f59d9d91","modified":1716213409531},{"_id":"themes\\butterfly\\source\\css\\_layout\\head.styl","hash":"964bda8acf4180a15c33e1d8447fc3140baa4c68","modified":1716213409532},{"_id":"themes\\butterfly\\source\\css\\_layout\\pagination.styl","hash":"bd099f7d3adef4b7edd24c0a25a07415b156e587","modified":1716213409532},{"_id":"themes\\butterfly\\source\\css\\_layout\\loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1716213409532},{"_id":"themes\\butterfly\\source\\css\\_layout\\post.styl","hash":"7ae27854a737a02eca89b0b92db94cb298fef59e","modified":1716213409532},{"_id":"themes\\butterfly\\source\\css\\_layout\\reward.styl","hash":"c0b11a1a5f52e3a6af4e312a8134c93eda18a7dd","modified":1716213409532},{"_id":"themes\\butterfly\\source\\css\\_layout\\rightside.styl","hash":"0322237e762db401d7b4aa33168d0b9334a9ec26","modified":1716213409533},{"_id":"themes\\butterfly\\source\\css\\_layout\\relatedposts.styl","hash":"6dcf19c0933c8828a439f801b0f4b256447dec07","modified":1716213409532},{"_id":"themes\\butterfly\\source\\css\\_layout\\sidebar.styl","hash":"80ee9d0bfe5d38aac1f0cdcea5fc88b71d310041","modified":1716213409533},{"_id":"themes\\butterfly\\source\\css\\_layout\\third-party.styl","hash":"15ea7564b2e3bf46bc91fb6e49c94d057b37caaf","modified":1716213409533},{"_id":"themes\\butterfly\\source\\css\\_mode\\darkmode.styl","hash":"dbc855795a881f8c805bf5c9c5c4d5d542a648ec","modified":1716213409533},{"_id":"themes\\butterfly\\source\\css\\_mode\\readmode.styl","hash":"a22fd15048d21452f0015d0765d295d730203308","modified":1716213409533},{"_id":"themes\\butterfly\\source\\css\\_page\\404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1716213409533},{"_id":"themes\\butterfly\\source\\css\\_page\\categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1716213409534},{"_id":"themes\\butterfly\\source\\css\\_page\\archives.styl","hash":"5dd1ba997741d02894ff846eda939ad8051c0bb2","modified":1716213409534},{"_id":"themes\\butterfly\\source\\css\\_page\\common.styl","hash":"df7a51fcabbadab5aa31770e3202a47c9599bbb7","modified":1716213409534},{"_id":"themes\\butterfly\\source\\css\\_page\\flink.styl","hash":"ecc2b2e28c179eb9406fc2c6f00e141078249cdd","modified":1716213409534},{"_id":"themes\\butterfly\\source\\css\\_page\\homepage.styl","hash":"a977cd8161ef4d6ddd5293e81403519076657430","modified":1716213409534},{"_id":"themes\\butterfly\\source\\css\\_page\\tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1716213409534},{"_id":"themes\\butterfly\\source\\css\\_search\\algolia.styl","hash":"37db99299af380e9111dce2a78a5049b301b13e0","modified":1716213409535},{"_id":"themes\\butterfly\\source\\css\\_search\\local-search.styl","hash":"8a53d7ba5ca2f5eb4124b684e7845b648583f658","modified":1716213409535},{"_id":"themes\\butterfly\\source\\css\\_search\\index.styl","hash":"0b23010154e19f37f0c4af0110f9f834d6d41a13","modified":1716213409535},{"_id":"themes\\butterfly\\source\\css\\_tags\\button.styl","hash":"62da1de0d5b8453fcecbfacddb16985265638ba5","modified":1716213409535},{"_id":"themes\\butterfly\\source\\css\\_tags\\gallery.styl","hash":"3e9355b76f87e2ee90f652855282b37ab5ae0b3e","modified":1716213409535},{"_id":"themes\\butterfly\\source\\css\\_tags\\hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1716213409535},{"_id":"themes\\butterfly\\source\\css\\_tags\\hide.styl","hash":"b7cf7753479fcf2fe07287ffdb0e568adbba4c18","modified":1716213409535},{"_id":"themes\\butterfly\\source\\css\\_tags\\inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1716213409536},{"_id":"themes\\butterfly\\source\\css\\_tags\\note.styl","hash":"4929382bd60788d34752a66e2fe764ef797a72a0","modified":1716213409536},{"_id":"themes\\butterfly\\source\\css\\_tags\\label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1716213409536},{"_id":"themes\\butterfly\\source\\css\\_tags\\tabs.styl","hash":"353b95f9a6c2c1e777d978118cb61f909ccbf89c","modified":1716213409536},{"_id":"themes\\butterfly\\source\\css\\_tags\\timeline.styl","hash":"07ea7134db7a66c87658116f089fb1a2a6906563","modified":1716213409536},{"_id":"themes\\butterfly\\source\\css\\_third-party\\normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1716213409536},{"_id":"themes\\butterfly\\source\\js\\search\\algolia.js","hash":"a7c2fe73cc05ad3525909b86ad0ede1a9f2d3b48","modified":1716213409538},{"_id":"themes\\butterfly\\source\\js\\search\\local-search.js","hash":"ab3904451ae1d78903424b8b2ef815c8571e1749","modified":1716213409538},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\abcjs\\abcjs.pug","hash":"8f95aca305b56ccd7c8c7367b03d26db816ebd5f","modified":1716213409514},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\card-post-count\\artalk.pug","hash":"b03ee8625149191f9d5d057bbc9824b68d8dd0c4","modified":1716213409514},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\abcjs\\index.pug","hash":"58f37823f6cd9a194fb50f7ca7c2233e49939034","modified":1716213409514},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\card-post-count\\disqus.pug","hash":"d6fff5a7f84c8b09f282f9ddc0020a68a8aac9ea","modified":1716213409514},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\card-post-count\\index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1716213409515},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\card-post-count\\fb.pug","hash":"4b98145d6584d586cabf033493282afc72ae816a","modified":1716213409514},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\card-post-count\\remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1716213409515},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\card-post-count\\valine.pug","hash":"cd4fc9c5a61608a5dedf645c1295430a1623040f","modified":1716213409515},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\card-post-count\\waline.pug","hash":"fd2320ee25507bb8ef49f932c2d170586b44ea4d","modified":1716213409515},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\card-post-count\\twikoo.pug","hash":"7e233f872aea6fd6beccdc9efd86b1bf9ec9f12d","modified":1716213409515},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\chat\\crisp.pug","hash":"09d2ab2570b67e6f09244a898ccab5567cb82ace","modified":1716213409516},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\chat\\chatra.pug","hash":"08a85e52fc800d3562df869e5e2613313e76fce6","modified":1716213409515},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\chat\\daovoice.pug","hash":"0d960849d5b05d27ec87627b983ca35f2411b9e8","modified":1716213409516},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\chat\\messenger.pug","hash":"799da8f3015e6fe440681b21644bcb3810a5518c","modified":1716213409516},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\chat\\index.pug","hash":"1157118db9f5d7c0c5a0fc7c346f6e934ca00d52","modified":1716213409516},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\chat\\tidio.pug","hash":"6d40b521eec4136f6742c548a4445ed593470b1b","modified":1716213409516},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\disqus.pug","hash":"364d1fd655baca9132038ef1e312abde2c0bc7de","modified":1716213409517},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\artalk.pug","hash":"5373b822aa72ddb96f2f1f4baf6c058b40d705d6","modified":1716213409516},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\disqusjs.pug","hash":"f78c9c20c86d58c7cf099f6f8d6097103d7d43e5","modified":1716213409517},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\facebook_comments.pug","hash":"11f5dca1432e59f22955aaf4ac3e9de6b286d887","modified":1716213409517},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\giscus.pug","hash":"1eab7ca1cb16c6786f9c3ca0efef8cc15e444ab4","modified":1716213409517},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\gitalk.pug","hash":"1c86c8fc1a28514a02a1f6a25ca9ec05eb3955b7","modified":1716213409517},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\index.pug","hash":"db6713d2b90eb8183f86ac92c26761a8501c0ddb","modified":1716213409517},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1716213409517},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\livere.pug","hash":"09c2ef4bc6d005f96dfa48b1d9af1ec095c5266d","modified":1716213409518},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\remark42.pug","hash":"7f450664e6323a076ae59c393b0f22167cfa82e5","modified":1716213409518},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\twikoo.pug","hash":"9942a903227350960c1d0716e59516ae79ac24a8","modified":1716213409518},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\utterances.pug","hash":"b65a42167df5fb07e2a63f312a58c321d3112a90","modified":1716213409518},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\valine.pug","hash":"4ed7c74087e81c6fcaf4fca7dced58b4e19f4cb1","modified":1716213409518},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\comments\\waline.pug","hash":"efb72547fc2d470a124f5636391128dc59627498","modified":1716213409518},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\math\\index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1716213409519},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\math\\katex.pug","hash":"f0d3eddd2bed68e5517274b3530bfe0fa5057d8e","modified":1716213409519},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\math\\mathjax.pug","hash":"bb944185f4bb9f9a9b9d70ee215f66ccd6d4c6cf","modified":1716213409519},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\math\\mermaid.pug","hash":"c682e4d61017fb0dd2e837bfcc242371f1a13364","modified":1716213409519},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\newest-comments\\artalk.pug","hash":"2e36fac4791e99844cd56676898be0dbf5eb4e99","modified":1716213409519},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\newest-comments\\disqus-comment.pug","hash":"d8898e427acd91ceb97d6a7ee3acb011ca86b9fc","modified":1716213409519},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\newest-comments\\github-issues.pug","hash":"fc8814bd016d039874ec2fc24dcb78587892e2a6","modified":1716213409519},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\newest-comments\\index.pug","hash":"f8b65460c399973090c1fb7ab81e3708c252e7cc","modified":1716213409520},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\newest-comments\\remark42.pug","hash":"a4e52188b6effeee1df2a01dcbf4105de76a61a8","modified":1716213409520},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\newest-comments\\twikoo-comment.pug","hash":"17520a86de12ae585289463c066d3ac91b78a2ff","modified":1716213409520},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\newest-comments\\valine.pug","hash":"ecfff55b2c7f6d87ce4d5028fdf9f8c0bf155c73","modified":1716213409520},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\newest-comments\\waline.pug","hash":"0544d91c0bc9e26e0fe1b5ff490f4a8540ed1ee1","modified":1716213409520},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\search\\algolia.pug","hash":"90338ac4cd114d324fe1caaaeea8be9ca05d6a46","modified":1716213409521},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\search\\docsearch.pug","hash":"52a06a2e039f44383085333cac69f3f4e7d0ad3a","modified":1716213409521},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\search\\index.pug","hash":"3adcf28a8d205ea3ee19828eda0e668702fac07a","modified":1716213409521},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\search\\local-search.pug","hash":"420a86e73d0d748ac234fd00d06d9e433ca5e3f2","modified":1716213409521},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\share\\addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1716213409521},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\share\\index.pug","hash":"c16ee69b5ca8db016db0508d014ae0867c4ce929","modified":1716213409521},{"_id":"themes\\butterfly\\layout\\includes\\third-party\\share\\share-js.pug","hash":"8106bd031586f075a994956ee4438eb13be25d7b","modified":1716213409522},{"_id":"themes\\butterfly\\source\\css\\_highlight\\highlight\\diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1716213409530},{"_id":"themes\\butterfly\\source\\css\\_highlight\\highlight\\index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1716213409530},{"_id":"themes\\butterfly\\source\\css\\_highlight\\prismjs\\diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1716213409530},{"_id":"themes\\butterfly\\source\\css\\_highlight\\prismjs\\line-number.styl","hash":"7c9cc43e1d2577f7151039d58e603c30860fd281","modified":1716213409531},{"_id":"themes\\butterfly\\source\\css\\_highlight\\prismjs\\index.styl","hash":"01ff9e77eb1bd454bec65a6ff5972c8e219bc708","modified":1716213409531},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\2.png","hash":"2c90bee2bef7727c966417ad1230f5331bb80f49","modified":1717216400425},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\6.png","hash":"233c9acff64257980146a2ccf26761eeea11bb2f","modified":1717216471567},{"_id":"source\\_posts\\场景设计面试题\\1.png","hash":"69cbb19844a1b6d69236fd116cea2e87011709d4","modified":1716736461946},{"_id":"themes\\butterfly\\source\\js\\jquery.min.js","hash":"7309250e69570ce1d237d567e60ca62ba11042b1","modified":1716215964188},{"_id":"themes\\butterfly\\source\\img\\haibian.png","hash":"5bc666f50d9c5f178b04800da8611800c6bafb6a","modified":1717217348961},{"_id":"themes\\butterfly\\source\\img\\liushui.png","hash":"6e3a36f56bfe978cb2ba39743aee8b174f5324a6","modified":1717217224178},{"_id":"themes\\butterfly\\source\\img\\hubian.png","hash":"e82f1981f85212167aa140cfdaf87c434dc11ab2","modified":1717217428449},{"_id":"themes\\butterfly\\source\\img\\index.jpg","hash":"2712d6f241f3beefd8b9b5380b2b5dd54404d314","modified":1716215369318},{"_id":"themes\\butterfly\\source\\img\\nav.jpg","hash":"a754c37a36d8210584f146553ba661af7fa3a68d","modified":1716217684105},{"_id":"public/search.xml","hash":"35c27b5a3544f3b1d99394052e0c8509f38d6b12","modified":1717320362230},{"_id":"public/categories/index.html","hash":"4ed8e28e27f3bbbdc4679c5abbbcdf4bdf561996","modified":1717320362230},{"_id":"public/tags/index.html","hash":"81e56279b88d2bdd86580457503b800ccf00faeb","modified":1717320362230},{"_id":"public/link/index.html","hash":"236a5981167fb4874aa40ee4800396dc3268b614","modified":1717320362230},{"_id":"public/2024/06/02/统计全国重名最多的前100个/index.html","hash":"a960710ee7c2c83d56a3f435ee5888b8562c69b2","modified":1717320362230},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/index.html","hash":"bfce7c8fa6bf4387983d46f1746b035fa57cb87f","modified":1717320362230},{"_id":"public/2024/05/28/百亿流量红包系统/index.html","hash":"0a943cf9d61d255a7a5426c908da490e94b0d589","modified":1717320362230},{"_id":"public/2024/05/26/场景设计面试题/index.html","hash":"e7dc295760365bc0144b932a295f3489d9acaefb","modified":1717320362230},{"_id":"public/2024/05/26/Springcloud最热点面试题/index.html","hash":"eabc0d201a2d2815ef074ab26098a33c869b8090","modified":1717320362230},{"_id":"public/2024/05/26/Springmvc最热点面试题/index.html","hash":"2439e897c1c02f57f45bf3df7904fd35b09274c4","modified":1717320362230},{"_id":"public/2024/05/26/Springboot最热点面试题/index.html","hash":"92b7e17c4954c5c2ad965276a7133ff548d9da84","modified":1717320362230},{"_id":"public/2024/05/26/Spring最热点面试题/index.html","hash":"5a2a0130bdc5c4317aaffa0c9aaeb1b17915db0f","modified":1717320362230},{"_id":"public/2024/05/26/hello-world/index.html","hash":"1671b88342a4d862e6299cb0006b9c8585cbfbcc","modified":1717320362230},{"_id":"public/2024/05/26/写代码神器/index.html","hash":"187d3eecd2be3cd1db17f8257189e887748883ff","modified":1717320362230},{"_id":"public/archives/index.html","hash":"fbb11d758c7e9005bfdc38e015d76b1be3762fcf","modified":1717320362230},{"_id":"public/archives/2024/index.html","hash":"419c502f3a5ef7c110ebe04b83856e81ef5fdb20","modified":1717320362230},{"_id":"public/archives/2024/05/index.html","hash":"d29ec0aa9554b79a5b652f8535ebdbe74d1d6451","modified":1717320362230},{"_id":"public/archives/2024/06/index.html","hash":"74b3a09c98a72da179bafd5fbc7a6c79062eec49","modified":1717320362230},{"_id":"public/categories/利器/index.html","hash":"cf98ca5e0d5b1bfa7ca1506ce94fb6c4fb73ecb5","modified":1717320362230},{"_id":"public/index.html","hash":"60e0fcf7f289d7860542e8ce6d18d0e1cfe0cafa","modified":1717320362230},{"_id":"public/categories/面试/index.html","hash":"d7badbbd2ec52a34bd221555d67db18624174d07","modified":1717320362230},{"_id":"public/categories/工具/index.html","hash":"db7334224ca16f367ec476e839868b41770c576f","modified":1717320362230},{"_id":"public/tags/ChatGpt/index.html","hash":"b0e0606969f66b8305b8406c99e5b1a1829b7c3d","modified":1717320362230},{"_id":"public/tags/springboot/index.html","hash":"05fe2d5fc1476db0d99b9dc254a555324f1b9955","modified":1717320362230},{"_id":"public/tags/springmvc/index.html","hash":"fbb24bb4f9e5af95e675f43a70274a106ca4f547","modified":1717320362230},{"_id":"public/tags/springcloud/index.html","hash":"7d394d1e73003a58afc6e2978d8e7c3858335fc0","modified":1717320362230},{"_id":"public/tags/spring/index.html","hash":"031cc1e66dfa719c24e3620d690ad26811b0e3df","modified":1717320362230},{"_id":"public/tags/开发神器/index.html","hash":"5dd595893d1432c34ace83d7cac35f3a1b1aa7dc","modified":1717320362230},{"_id":"public/tags/场景设计/index.html","hash":"dc94c8dd86ee5b4c577221495141a9e94c0ba710","modified":1717320362230},{"_id":"public/tags/架构/index.html","hash":"c63d247ba0cc5e21ecf928224ce3b7bd0b3126cf","modified":1717320362230},{"_id":"public/tags/算法题/index.html","hash":"f2d55de1ed7a88049b4f64ff93ff2c2cbdecf95e","modified":1717320362230},{"_id":"public/templates/search.xml","hash":"55ff793e92e4bc6359b67ff822bc4472cc68b877","modified":1717320362230},{"_id":"public/CNAME","hash":"a14ecc72617888c2cf1fd57e3f7c4d4062404fc6","modified":1717320362230},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1717320362230},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1717320362230},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1717320362230},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/1.png","hash":"b25993a23ae2eb230492e99e43e3b25c60e2b6d7","modified":1717320362230},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/3.png","hash":"a8e918bacb1a333364b778d481e8214391279179","modified":1717320362230},{"_id":"public/2024/05/26/Springcloud最热点面试题/1.png","hash":"74133c96884d8aa652bba827e7f2bb24273af593","modified":1717320362230},{"_id":"public/2024/05/26/Springcloud最热点面试题/5.png","hash":"d5b563a500b443dfbe755547c7ca46d35e1f8bdb","modified":1717320362230},{"_id":"public/2024/05/26/Springcloud最热点面试题/6.png","hash":"cd284de11375c3c8180bedfe4686235efddfda2f","modified":1717320362230},{"_id":"public/2024/05/26/Springcloud最热点面试题/7.png","hash":"03b42d789a9bd6b41d6346abb94db71f1c0fcd24","modified":1717320362230},{"_id":"public/2024/05/26/Springcloud最热点面试题/8.png","hash":"c1e35779ca626b6e9096320e861a8ac793a8c3b7","modified":1717320362230},{"_id":"public/2024/05/26/Springcloud最热点面试题/9.png","hash":"545ce573a50b93063cdd32e83f3f392d60329719","modified":1717320362230},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/10.png","hash":"9b1117e6d97dc40f07ce02da023ae1b3126c3f59","modified":1717320362230},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/11.png","hash":"f4d4f0bb4b6063abb31568ddd6087c6c20972ad0","modified":1717320362230},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/4.png","hash":"1e8578421656e6bc3563a587f10ecd92a5df326b","modified":1717320362230},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/8.png","hash":"9814e82372083819368025d85eb86226cc83eb20","modified":1717320362230},{"_id":"public/2024/05/26/Springcloud最热点面试题/4.png","hash":"4ed8f325ec02e456cc97351dd51fab2195adfec3","modified":1717320362230},{"_id":"public/2024/05/26/场景设计面试题/10.png","hash":"22845f542998d6c4348bf9d078e2fc39e1266737","modified":1717320362230},{"_id":"public/2024/05/26/场景设计面试题/11.png","hash":"a5b18f79b4c90a8016d2de992cb619a51de88dd2","modified":1717320362230},{"_id":"public/2024/05/26/场景设计面试题/12.png","hash":"5dedc836fc77c332e7299f52b32518c5d808e938","modified":1717320362230},{"_id":"public/2024/05/26/场景设计面试题/6.png","hash":"45305724c0aec07344d96fd3e82a900c09067c2c","modified":1717320362230},{"_id":"public/2024/05/26/场景设计面试题/8.png","hash":"0e34ebf4f2030ecd47ce97db7fe8333225704a3a","modified":1717320362230},{"_id":"public/2024/05/26/场景设计面试题/9.png","hash":"f830d80e9779553509ee78456368bbd74128ee4e","modified":1717320362230},{"_id":"public/css/transparent.css","hash":"e399389ad434c96d70554f82847951e97944e7f3","modified":1717320362230},{"_id":"public/css/universe.css","hash":"b296f879cdef4d77f1cb8df9860065bdb5543884","modified":1717320362230},{"_id":"public/css/footer.css","hash":"b1a17d8aa6e90b77a6ba8b3abeac8c6dc7bba373","modified":1717320362230},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1717320362230},{"_id":"public/js/fishes.js","hash":"3f5f9db9737d34e440e1b07b2a48dfc73487c263","modified":1717320362230},{"_id":"public/js/universe.js","hash":"7bd55b0ba367342b4865d83c27ee3d1900d8a9d3","modified":1717320362230},{"_id":"public/js/search/algolia.js","hash":"108988d046da9a4716148df43b3975217c8ceaae","modified":1717320362230},{"_id":"public/js/utils.js","hash":"8e6b48d294e7aeaba8ff6348c43b2271cf865547","modified":1717320362230},{"_id":"public/js/search/local-search.js","hash":"e1f60ebac53a3f596fd0a4769b4f9275c48c6542","modified":1717320362230},{"_id":"public/css/index.css","hash":"4d45871d3db233b1751149cdd7a8da3bbdb786ba","modified":1717320362230},{"_id":"public/js/jquery.min.js","hash":"d6861c4a3797df061243d4a2ea8bcd0246717098","modified":1717320362230},{"_id":"public/js/main.js","hash":"0dac585446445e0c419b86eec5580bc9b0657dc6","modified":1717320362230},{"_id":"public/js/tw_cn.js","hash":"f8d2e3f31468991a7f5171cbfdb157dfb86d3372","modified":1717320362230},{"_id":"public/2024/05/26/Spring最热点面试题/1.png","hash":"1a54fd4cc7bd0aa146381a578a07690fa9f3fa01","modified":1717320362230},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/5.png","hash":"47246db7c4451e4505308a7a7b7cc35b0b1acab8","modified":1717320362230},{"_id":"public/2024/05/26/写代码神器/1.png","hash":"6d5458a4b56e47e132202173ea96a37dee0357fc","modified":1717320362230},{"_id":"public/2024/05/26/写代码神器/2.png","hash":"2c1a4c8d5490e05348017788875440647450d167","modified":1717320362230},{"_id":"public/2024/05/26/写代码神器/3.png","hash":"228bff7535038b60fea45979fa8aab30bdbbe124","modified":1717320362230},{"_id":"public/2024/05/26/场景设计面试题/3.png","hash":"f4ed04ec67beb7d94e1aa07f9e20699284d1b136","modified":1717320362230},{"_id":"public/2024/05/26/场景设计面试题/2.png","hash":"c0357bb1314dc52fa51736e9903aa9c9c302261f","modified":1717320362230},{"_id":"public/2024/05/26/场景设计面试题/5.png","hash":"3f5bcd812c160874882b7c78169d50fe9c5e7d68","modified":1717320362230},{"_id":"public/2024/05/26/场景设计面试题/7.png","hash":"2ca62c594040efb6ac5b1de18d154c089b60b504","modified":1717320362230},{"_id":"public/2024/05/28/百亿流量红包系统/2.png","hash":"9542b863e4ddc5c6ac1d08a42f38545a66e32663","modified":1717320362230},{"_id":"public/2024/05/28/百亿流量红包系统/3.png","hash":"7bf6bc969f35db83c4a77a483a478992f334923e","modified":1717320362230},{"_id":"public/2024/05/28/百亿流量红包系统/5.png","hash":"fe15b865523b15d79e83babefca63445a0f65429","modified":1717320362230},{"_id":"public/2024/05/28/百亿流量红包系统/6.png","hash":"a015accafa23bd412d50a69329d81a002ac73b0f","modified":1717320362230},{"_id":"public/2024/05/28/百亿流量红包系统/9.png","hash":"60c653e26c7edc3d153fbf9e90215396700daffc","modified":1717320362230},{"_id":"public/2024/05/26/场景设计面试题/4.png","hash":"df313ec53071699d2875e3e471a870418084e4ab","modified":1717320362230},{"_id":"public/2024/05/28/百亿流量红包系统/10.png","hash":"8a4c35c5a66728307f3567a8086f42e2f0337623","modified":1717320362230},{"_id":"public/2024/05/28/百亿流量红包系统/11.png","hash":"7db213d216da702b94883ea8aa11ecb0592cead8","modified":1717320362230},{"_id":"public/2024/05/28/百亿流量红包系统/4.png","hash":"cdffe930dbe7fd9e97db3343d23e7048ce092c29","modified":1717320362230},{"_id":"public/2024/05/28/百亿流量红包系统/7.png","hash":"59be9f9deb6abad8de41c38335c792e88c15f6a1","modified":1717320362230},{"_id":"public/2024/05/28/百亿流量红包系统/8.png","hash":"1997b30d4241039907e408b9dbc54f591ca33dc1","modified":1717320362230},{"_id":"public/img/haibian.png","hash":"5bc666f50d9c5f178b04800da8611800c6bafb6a","modified":1717320362230},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/9.png","hash":"75bb4b91ab8579d0f4993ae1d36c0498f9ecc233","modified":1717320362230},{"_id":"public/2024/05/26/Springmvc最热点面试题/1.png","hash":"de87da42c021efe015af684e4288d38a41e6d6b5","modified":1717320362230},{"_id":"public/2024/05/28/百亿流量红包系统/1.png","hash":"13c3f20ff81933a3b99d07482fdbe562752df89d","modified":1717320362230},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/7.png","hash":"c3f3eb752e7c4e9d4fc2409ec82de0b875b669c1","modified":1717320362230},{"_id":"public/2024/05/26/Springcloud最热点面试题/2.png","hash":"bd76bb0b304b3a9c1b7876f6db87ee2a16ec82b6","modified":1717320362230},{"_id":"public/img/liushui.png","hash":"6e3a36f56bfe978cb2ba39743aee8b174f5324a6","modified":1717320362230},{"_id":"public/2024/05/26/Springcloud最热点面试题/3.png","hash":"eac5e2e7c1429bca4eea52669595ba67cfa13b5a","modified":1717320362230},{"_id":"public/2024/06/02/统计全国重名最多的前100个/1.png","hash":"b5d2ab36c43e90e3b5a9477c620c4f5e6d639dad","modified":1717320362230},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/2.png","hash":"2c90bee2bef7727c966417ad1230f5331bb80f49","modified":1717320362230},{"_id":"public/2024/06/01/Edge浏览器中使用免费的ChatGPT/6.png","hash":"233c9acff64257980146a2ccf26761eeea11bb2f","modified":1717320362230},{"_id":"public/2024/05/26/场景设计面试题/1.png","hash":"69cbb19844a1b6d69236fd116cea2e87011709d4","modified":1717320362230},{"_id":"public/img/hubian.png","hash":"e82f1981f85212167aa140cfdaf87c434dc11ab2","modified":1717320362230},{"_id":"public/img/index.jpg","hash":"2712d6f241f3beefd8b9b5380b2b5dd54404d314","modified":1717320362230},{"_id":"public/img/nav.jpg","hash":"a754c37a36d8210584f146553ba661af7fa3a68d","modified":1717320362230}],"Category":[{"name":"利器","_id":"clwxc4r9r0004b4uhco12cdyi"},{"name":"面试","_id":"clwxc4r9u000ab4uhgdi136p6"},{"name":"工具","_id":"clwxc4ra0000tb4uhbt6f3v5d"}],"Data":[{"_id":"link","data":{"YAMLclass":{"class_name":"友情链接","link_list":{"1":{"name":"小康博客","link":"https://www.antmoe.com","avatar":"https://img.antmoe.com/avatar.png","descr":"每天进步一点点"},"2":{"name":"test","link":"https://www.xxxxxxcn/","avatar":"https://xxxxx/avatar.png","descr":"test"}}},"class2":{"class_name":"链接无效","link_list":{"1":{"name":"test","link":"https://blog.xxx.com","avatar":"https://img.antmoe.com/avatar.png","descr":"test"},"2":{"name":"test","link":"https://www.axxxx.cn/","avatar":"https://img.antmoe.com/avatar.png","descr":"test"}}}}}],"Page":[{"title":"categories","date":"2024-05-26T05:29:53.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2024-05-26 13:29:53\ntype: \"categories\"\n---\n","updated":"2024-05-26T05:30:10.102Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clwxc4r9k0000b4uh3ayb1ho7","content":"","cover":"/img/haibian.png","cover_type":"img","excerpt":"","more":""},{"title":"tags","date":"2024-05-20T14:16:12.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2024-05-20 22:16:12\ntype: \"tags\"\n---\n","updated":"2024-05-26T05:29:33.578Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clwxc4r9q0002b4uhf0aw3x8c","content":"","cover":"/img/hubian.png","cover_type":"img","excerpt":"","more":""},{"title":"link","date":"2024-05-20T14:16:35.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: link\ndate: 2024-05-20 22:16:35\ntype: \"link\"\n---\n","updated":"2024-05-26T05:30:25.849Z","path":"link/index.html","comments":1,"layout":"page","_id":"clwxc4r9s0006b4uhfwa50afw","content":"","cover":"/img/hubian.png","cover_type":"img","excerpt":"","more":""}],"Post":[{"title":"Edge浏览器中使用免费的ChatGPT","date":"2024-06-01T04:20:56.000Z","_content":"\n\nMicrosoft Edge浏览器中使用免费的ChatGPT\n==============================\n\n\n\n\n一、双击打开浏览器 ![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/1.png)\n-------------------------------------------------------------------------------\n\n找到：扩展，打开\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/2.png)\n\n二、打开Microsoft Edge加载项\n---------------------\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/3.png)\n\n三、Move tab新标签 获取免费ChatGPT\n-------------------------\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/4.png)\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/5.png)\n\n四、启用Move tab。启用ChatGPT。\n-----------------------\n\n扩展\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/6.png)\n\n管理扩展\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/7.png)\n\n启用\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/8.png)\n\n五、新建标签页，使用GPT\n-------------\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/9.png)\n\n六、使用举例\n------\n\n提问\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/10.png)\n\nGPT回复\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/11.png)\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/12.png)\n","source":"_posts/Edge浏览器中使用免费的ChatGPT.md","raw":"---\ntitle: Edge浏览器中使用免费的ChatGPT\ndate: 2024-06-01 12:20:56\ntags: ChatGpt\ncategories: 利器\n---\n\n\nMicrosoft Edge浏览器中使用免费的ChatGPT\n==============================\n\n\n\n\n一、双击打开浏览器 ![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/1.png)\n-------------------------------------------------------------------------------\n\n找到：扩展，打开\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/2.png)\n\n二、打开Microsoft Edge加载项\n---------------------\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/3.png)\n\n三、Move tab新标签 获取免费ChatGPT\n-------------------------\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/4.png)\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/5.png)\n\n四、启用Move tab。启用ChatGPT。\n-----------------------\n\n扩展\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/6.png)\n\n管理扩展\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/7.png)\n\n启用\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/8.png)\n\n五、新建标签页，使用GPT\n-------------\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/9.png)\n\n六、使用举例\n------\n\n提问\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/10.png)\n\nGPT回复\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/11.png)\n\n![](./2024/06/01/Edge浏览器中使用免费的ChatGPT/12.png)\n","slug":"Edge浏览器中使用免费的ChatGPT","published":1,"updated":"2024-06-01T04:38:03.432Z","comments":1,"layout":"post","photos":[],"_id":"clwxc4r9n0001b4uheged3dyu","content":"<h1 id=\"Microsoft-Edge浏览器中使用免费的ChatGPT\"><a href=\"#Microsoft-Edge浏览器中使用免费的ChatGPT\" class=\"headerlink\" title=\"Microsoft Edge浏览器中使用免费的ChatGPT\"></a>Microsoft Edge浏览器中使用免费的ChatGPT</h1><h2 id=\"一、双击打开浏览器\"><a href=\"#一、双击打开浏览器\" class=\"headerlink\" title=\"一、双击打开浏览器 \"></a>一、双击打开浏览器 <img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/1.png\"></h2><p>找到：扩展，打开</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/2.png\"></p>\n<h2 id=\"二、打开Microsoft-Edge加载项\"><a href=\"#二、打开Microsoft-Edge加载项\" class=\"headerlink\" title=\"二、打开Microsoft Edge加载项\"></a>二、打开Microsoft Edge加载项</h2><p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/3.png\"></p>\n<h2 id=\"三、Move-tab新标签-获取免费ChatGPT\"><a href=\"#三、Move-tab新标签-获取免费ChatGPT\" class=\"headerlink\" title=\"三、Move tab新标签 获取免费ChatGPT\"></a>三、Move tab新标签 获取免费ChatGPT</h2><p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/4.png\"></p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/5.png\"></p>\n<h2 id=\"四、启用Move-tab。启用ChatGPT。\"><a href=\"#四、启用Move-tab。启用ChatGPT。\" class=\"headerlink\" title=\"四、启用Move tab。启用ChatGPT。\"></a>四、启用Move tab。启用ChatGPT。</h2><p>扩展</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/6.png\"></p>\n<p>管理扩展</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/7.png\"></p>\n<p>启用</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/8.png\"></p>\n<h2 id=\"五、新建标签页，使用GPT\"><a href=\"#五、新建标签页，使用GPT\" class=\"headerlink\" title=\"五、新建标签页，使用GPT\"></a>五、新建标签页，使用GPT</h2><p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/9.png\"></p>\n<h2 id=\"六、使用举例\"><a href=\"#六、使用举例\" class=\"headerlink\" title=\"六、使用举例\"></a>六、使用举例</h2><p>提问</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/10.png\"></p>\n<p>GPT回复</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/11.png\"></p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/12.png\"></p>\n","cover":"/img/liushui.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Microsoft-Edge浏览器中使用免费的ChatGPT\"><a href=\"#Microsoft-Edge浏览器中使用免费的ChatGPT\" class=\"headerlink\" title=\"Microsoft Edge浏览器中使用免费的ChatGPT\"></a>Microsoft Edge浏览器中使用免费的ChatGPT</h1><h2 id=\"一、双击打开浏览器\"><a href=\"#一、双击打开浏览器\" class=\"headerlink\" title=\"一、双击打开浏览器 \"></a>一、双击打开浏览器 <img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/1.png\"></h2><p>找到：扩展，打开</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/2.png\"></p>\n<h2 id=\"二、打开Microsoft-Edge加载项\"><a href=\"#二、打开Microsoft-Edge加载项\" class=\"headerlink\" title=\"二、打开Microsoft Edge加载项\"></a>二、打开Microsoft Edge加载项</h2><p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/3.png\"></p>\n<h2 id=\"三、Move-tab新标签-获取免费ChatGPT\"><a href=\"#三、Move-tab新标签-获取免费ChatGPT\" class=\"headerlink\" title=\"三、Move tab新标签 获取免费ChatGPT\"></a>三、Move tab新标签 获取免费ChatGPT</h2><p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/4.png\"></p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/5.png\"></p>\n<h2 id=\"四、启用Move-tab。启用ChatGPT。\"><a href=\"#四、启用Move-tab。启用ChatGPT。\" class=\"headerlink\" title=\"四、启用Move tab。启用ChatGPT。\"></a>四、启用Move tab。启用ChatGPT。</h2><p>扩展</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/6.png\"></p>\n<p>管理扩展</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/7.png\"></p>\n<p>启用</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/8.png\"></p>\n<h2 id=\"五、新建标签页，使用GPT\"><a href=\"#五、新建标签页，使用GPT\" class=\"headerlink\" title=\"五、新建标签页，使用GPT\"></a>五、新建标签页，使用GPT</h2><p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/9.png\"></p>\n<h2 id=\"六、使用举例\"><a href=\"#六、使用举例\" class=\"headerlink\" title=\"六、使用举例\"></a>六、使用举例</h2><p>提问</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/10.png\"></p>\n<p>GPT回复</p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/11.png\"></p>\n<p><img src=\"/./2024/06/01/Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84ChatGPT/12.png\"></p>\n"},{"title":"Springboot最热点面试题","date":"2024-05-26T14:50:22.000Z","_content":"\n\n\n\n## springboot启动流程\n### 启动类上注解：@SpringBootApplication\n#### @SpringBootConfiguration\n根据Javadoc可知，该注解作用就是将当前的类作为一个JavaConfig，然后触发注解@EnableAutoConfiguration和@ComponentScan的处理，本质上与@Configuration注解没有区别\n#### @EnableAutoConfiguration\n@EnableAutoConfiguration:实现自动装配的核心注解\n- @AutoConfigurationPackage\n    - 注册当前启动类的根 package\n    - 注册 org.springframework.boot.autoconfigure.AutoConfigurationPackages 的 BeanDefinition\n- @Import(AutoConfigurationImportSelector.class)\n    - 自动装配核心功能的实现实际是通过 AutoConfigurationImportSelector(加载自动装配类)类\n    - AutoConfigurationImportSelector 类实现了 ImportSelector接口\n        - 实现了这个接口中的 selectImports方法\n            - 方法实现 重要的getAutoConfigurationEntry()方法\n                1. 判断自动装配是否打开，默认是true可以通过application.yml设置\n                2. 获取@EnableAutoConfiguration里的exclude和excludeName内容以便排除\n                3. 获取需要自动装配的所有配置类，读取META-INF/spring.factories druid 数据库连接池的 Spring Boot Starter 就创建了META-INF/spring.factories文件\n                4. 筛选满足@ConditionalOnXXX注解的类，生效才会被加载\n            - 该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中\n#### @ComponentScan\n扫描的 Spring 对应的组件，如 @Componet，@Repository\n- 我们可以通过 basePackages 等属性来细粒度的定制 @ComponentScan 自动扫描的范围，如果不指定，则默认Spring框架实现会从声明 @ComponentScan 所在类的package进行扫描，所以 SpringBoot 的启动类最好是放在根package下，我们自定义的类就放在对应的子package下，这样就可以不指定 basePackages\n### 启动类中的main方法：org.springframework.boot.SpringApplication#run(java.lang.Class<?>, java.lang.String...)\n- 从spring.factories配置文件中加载EventPublishingRunListener对象，该对象拥有SimpleApplicationEventMulticaster属性，即在SpringBoot启动过程的不同阶段用来发射内置的生命周期事件;\n    - spring-bean包下META-INF/spring.factories\n- 准备环境变量，包括系统变量，环境变量，命令行参数，默认变量，servlet相关配置变量，随机值以及配置文件（比如application.properties）等;\n    - 而后就会去创建Environment——这个时候会去加载application配置文件\n- 控制台打印SpringBoot的bannner标志；\n- 根据不同类型环境创建不同类型的applicationcontext容器，因为这里是servlet环境，所以创建的是AnnotationConfigServletWebServerApplicationContext容器对象；\n- 从spring.factories配置文件中加载FailureAnalyzers对象,用来报告SpringBoot启动过程中的异常；\n- 为刚创建的容器对象做一些初始化工作，准备一些容器属性值等，对ApplicationContext应用一些相关的后置处理和调用各个ApplicationContextInitializer的初始化方法来执行一些初始化逻辑等；\n- 刷新容器，这一步至关重要。比如调用bean factory的后置处理器，注册BeanPostProcessor后置处理器，初始化事件广播器且广播事件，初始化剩下的单例bean和SpringBoot创建内嵌的Tomcat服务器等等重要且复杂的逻辑都在这里实现，主要步骤可见代码的注释，关于这里的逻辑会在以后的spring源码分析专题详细分析；\n    - // 1）在context刷新前做一些准备工作，比如初始化一些属性设置，属性合法性校验和保存容器中的一些早期事件等；\n    - // 2）让子类刷新其内部bean factory,注意SpringBoot和Spring启动的情况执行逻辑不一样\n    - // 3）对bean factory进行配置，比如配置bean factory的类加载器，后置处理器等\n    - // 4）完成bean factory的准备工作后，此时执行一些后置处理逻辑，子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置\n        - // 在这一步，所有的bean definitions将会被加载，但此时bean还不会被实例化\n    - // 5）执行BeanFactoryPostProcessor的方法即调用bean factory的后置处理器：\n        - // BeanDefinitionRegistryPostProcessor（触发时机：bean定义注册之前）和BeanFactoryPostProcessor（触发时机：bean定义注册之后bean实例化之前）\n    - // 6）注册bean的后置处理器BeanPostProcessor，注意不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的\n    - // 7）初始化国际化MessageSource相关的组件，比如消息绑定，消息解析等\n    - // 8）初始化事件广播器，如果bean factory没有包含事件广播器，那么new一个SimpleApplicationEventMulticaster广播器对象并注册到bean factory中\n    - // 9）AbstractApplicationContext定义了一个模板方法onRefresh，留给子类覆写，比如ServletWebServerApplicationContext覆写了该方法来创建内嵌的tomcat容器\n    - // 10）注册实现了ApplicationListener接口的监听器，之前已经有了事件广播器，此时就可以派发一些early application events\n    - // 11）完成容器bean factory的初始化，并初始化所有剩余的单例bean。这一步非常重要，一些bean postprocessor会在这里调用。\n    - // 12）完成容器的刷新工作，并且调用生命周期处理器的onRefresh()方法，并且发布ContextRefreshedEvent事件\n- 执行刷新容器后的后置处理逻辑，注意这里为空方法；\n- 调用ApplicationRunner和CommandLineRunner的run方法，我们实现这两个接口可以在spring容器启动后需要的一些东西比如加载一些业务数据等;\n- 报告启动异常，即若启动过程中抛出异常，此时用FailureAnalyzers来报告异常;\n- 最终返回容器对象，这里调用方法没有声明对象来接收。\n```java\npublic static void main(String[] args) throws Exception {\n   SpringApplication.run(new Class<?>[0], args);\n}\npublic static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {\n   // 新建SpringApplication对象，再调用run方法\n   return new SpringApplication(primarySources).run(args);\n}\npublic ConfigurableApplicationContext run(String... args) {\n   // stopWatch用于统计run启动过程时长\n   StopWatch stopWatch = new StopWatch();\n   // 开始计时\n   stopWatch.start();\n   // 创建ConfigurableApplicationContext对象\n   ConfigurableApplicationContext context = null;\n   // exceptionReporters集合用来存储SpringApplication启动过程的异常，SpringBootExceptionReporter且通过spring.factories方式来加载\n   Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();\n   // 配置headless属性\n   configureHeadlessProperty();\n   /**\n    * 从spring.factories配置文件中加载到EventPublishingRunListener对象并赋值给SpringApplicationRunListeners\n    * # Run Listeners\n    * org.springframework.boot.SpringApplicationRunListener=\\\n    * org.springframework.boot.context.event.EventPublishingRunListener\n    */\n   SpringApplicationRunListeners listeners = getRunListeners(args);\n   // 启动SpringApplicationRunListeners监听\n   listeners.starting();\n   try {\n      // 创建ApplicationArguments对象，封装了args参数\n      ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n      // 备配置参数有app.properties，外部配置参数比如jvm启动参数等\n      ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);\n      // 配置spring.beaninfo.ignore属性\n      configureIgnoreBeanInfo(environment);\n      // 打印springboot的bannner\n      Banner printedBanner = printBanner(environment);\n      // 根据不同类型创建不同类型的spring applicationcontext容器\n      context = createApplicationContext();\n      /**\n       * 异常报告\n       * 从spring.factories配置文件中加载exceptionReporters，其中ConfigurableApplicationContext.class作为FailureAnalyzers构造方法的参数\n       * # Error Reporters\n       * org.springframework.boot.SpringBootExceptionReporter=\\\n       * org.springframework.boot.diagnostics.FailureAnalyzers\n       */\n      exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,\n            new Class[] { ConfigurableApplicationContext.class }, context);\n      // 准备容器事项：调用各个ApplicationContextInitializer的initialize方法\n      // 和触发SpringApplicationRunListeners的contextPrepared及contextLoaded方法等\n      prepareContext(context, environment, listeners, applicationArguments, printedBanner);\n      // 刷新容器，这一步至关重要\n      refreshContext(context);\n      // 执行刷新容器后的后置处理逻辑，注意这里为空方法\n      afterRefresh(context, applicationArguments);\n      // 停止stopWatch计时\n      stopWatch.stop();\n      // 打印springboot的启动时常\n      if (this.logStartupInfo) {\n         new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);\n      }\n      // 触发SpringApplicationRunListener的started方法，通知spring容器已经启动\n      listeners.started(context);\n      // 调用ApplicationRunner和CommandLineRunner的run方法，实现spring容器启动后需要做的一些东西\n      callRunners(context, applicationArguments);\n   }\n   // 若上面的方法抛出异常，将异常添加到exceptionReporters集合中，并抛出 IllegalStateException 异常。\n   catch (Throwable ex) {\n      handleRunFailure(context, ex, exceptionReporters, listeners);\n      throw new IllegalStateException(ex);\n   }\n\n   try {\n      // 当容器刷新完毕等，触发SpringApplicationRunListeners数组的running方法\n      listeners.running(context);\n   }\n   catch (Throwable ex) {\n      // 若上面的方法抛出异常，将异常添加到exceptionReporters集合中，并抛出 IllegalStateException 异常。\n      handleRunFailure(context, ex, exceptionReporters, null);\n      throw new IllegalStateException(ex);\n   }\n   return context;\n}\n\n```\n## 怎么让Spring把Body变成一个对象\n- @RequestBody注解原理\n- 详细看springmvc的处理流程\n## SpringBoot的starter实现原理是什么？\n原理就是因为在@EnableAutoConfiguration注解，会自动的扫描jar包下的META-INF/spring.factories文件的配置类，写在这里面的类都是需要被自动加载的\n\n将configuration类中定义的bean加入spring到容器中。就相当于加载之前我们自己配置组件的xml文件。而现在SpringBoot自己定义了一个默认的值，然后直接加载进入了Spring容器。\n\nSpringBoot提供的自动配置依赖模块都以spring-boot-starter-为命名前缀，并且这些依赖都在org.springframework.boot下。 所有的spring-boot-starter都有约定俗成的默认配置，但允许调整这些配置调整默认的行为。\n## spring 和springboot的区别\nSpring Boot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，为更快，更高效的开发生态系统铺平了道路。\n\nSpring Boot中的一些特征：\n\n- 创建独立的Spring应用。\n- 嵌入式Tomcat、Jetty、 Undertow容器（无需部署war文件）。\n- 提供的starters 简化构建配置\n- 尽可能自动配置spring应用。\n- 提供生产指标,例如指标、健壮检查和外部化配置\n- 完全没有代码生成和XML配置要求\n\nMaven依赖\n\n首先，让我们看一下使用Spring创建Web应用程序所需的最小依赖项\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-web</artifactId>\n    <version>5.1.0.RELEASE</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.1.0.RELEASE</version>\n</dependency>\n```\n与Spring不同，Spring Boot只需要一个依赖项来启动和运行Web应用程序：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n    <version>2.0.6.RELEASE</version>\n</dependency>\n```\n在进行构建期间，所有其他依赖项将自动添加到项目中。\n\n另一个很好的例子就是测试库。我们通常使用Spring Test，JUnit，Hamcrest和Mockito库。在Spring项目中，我们应该将所有这些库添加为依赖项。但是在Spring Boot中，我们只需要添加spring-boot-starter-test依赖项来自动包含这些库。\n\nspring在运行前需要使用xml文件做很多配置，而springboot帮我们实现了这些配置的自动加载，基于注解和简单的yml配置即可\n\nspring的web程序还是打包为war然后再Tomcat里运行，而springboot内嵌了Tomcat直接打成可运行的jar\n\n## Spring Boot 可执行 Jar 包运行原理\nSpring Boot 有一个很方便的功能就是可以将应用打成可执行的 Jar。那么大家有没想过这个 Jar 是怎么运行起来的呢？本篇博客就来介绍下 Spring Boot 可执行 Jar 包的运行原理。\n\n### 打可执行 Jar 包\n将 Spring Boot 应用打成可执行 Jar包很容易，只需要在 pom 中加上一个 Spring Boot 提供的插件，然后在执行mvn package即可\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n```\n运行完mvn package后，我们会在 target 目录下看到两个 jar 文件。myproject-0.0.1-SNAPSHOT.jar 和 myproject-0.0.1-SNAPSHOT.jar.original。第一个 jar 文件就是我们应用的可执行 jar 包，第二个 Jar 文件是应用原始的 jar 包。\n\n### 可执行 Jar 包内部结构\n```text\n可执行 jar 目录结构\n├─BOOT-INF\n│  ├─classes\n│  └─lib\n├─META-INF\n│  ├─maven\n│  ├─app.properties\n│  ├─MANIFEST.MF      \n└─org\n    └─springframework\n        └─boot\n            └─loader\n                ├─archive\n                ├─data\n                ├─jar\n                └─util\n\n```\n我们先来重点关注两个地方：META-INF 下面的 Jar 包描述文件和 BOOT-INF 这个目录。\n```properties\nManifest-Version: 1.0\nArchiver-Version: Plexus Archiver\nBuilt-By: xxxx\nStart-Class: com.xxxx.AppServer\nSpring-Boot-Classes: BOOT-INF/classes/\nSpring-Boot-Lib: BOOT-INF/lib/\nSpring-Boot-Version: 2.1.6.RELEASE\nCreated-By: Apache Maven 3.3.9\nBuild-Jdk: 1.8.0_73\nMain-Class: org.springframework.boot.loader.JarLauncher\n\n```\n在上面我们看到一个熟悉的配置Main-Class: org.springframework.boot.loader.JarLauncher。我们大概能猜到这个类是整个系统的入口。\n\n再看下 BOOT-INF 这个目录下面，我们会发现里面是我们项目打出来的 class 文件和项目依赖的 Jar 包。看到这里，你可能已经猜到 Spring Boot 是怎么启动项目的了。\n\n### JarLauncher\n```java\npublic class JarLauncher extends ExecutableArchiveLauncher {\n\n\tstatic final String BOOT_INF_CLASSES = \"BOOT-INF/classes/\";\n\n\tstatic final String BOOT_INF_LIB = \"BOOT-INF/lib/\";\n\n\tpublic JarLauncher() {\n\t}\n\n\tprotected JarLauncher(Archive archive) {\n\t\tsuper(archive);\n\t}\n\n\t@Override\n\tprotected boolean isNestedArchive(Archive.Entry entry) {\n\t\tif (entry.isDirectory()) {\n\t\t\treturn entry.getName().equals(BOOT_INF_CLASSES);\n\t\t}\n\t\treturn entry.getName().startsWith(BOOT_INF_LIB);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n        //项目入口，重点在launch这个方法中\n\t\tnew JarLauncher().launch(args);\n\t}\n\n}\n\n```\n```java\n//launch方法\nprotected void launch(String[] args) throws Exception {\n    JarFile.registerUrlProtocolHandler();\n    //创建LaunchedURLClassLoader。如果根类加载器和扩展类加载器没有加载到某个类的话，就会通过LaunchedURLClassLoader这个加载器来加载类。这个加载器会从Boot-INF下面的class目录和lib目录下加载类。\n    ClassLoader classLoader = createClassLoader(getClassPathArchives());\n    //这个方法会读取jar描述文件中的Start-Class属性，然后通过反射调用到这个类的main方法。\n    launch(args, getMainClass(), classLoader);\n}\n\n```\n简单总结\n- Spring Boot 可执行 Jar 包的入口点是 JarLauncher 的 main 方法；\n- 这个方法的执行逻辑是先创建一个 LaunchedURLClassLoader，这个加载器加载类的逻辑是：先判断根类加载器和扩展类加载器能否加载到某个类，如果都加载不到就从 Boot-INF 下面的 class 和 lib 目录下去加载；\n- 读取Start-Class属性，通过反射机制调用启动类的 main 方法，这样就顺利调用到我们开发的 Spring Boot 主启动类的 main 方法了。\n\n","source":"_posts/Springboot最热点面试题.md","raw":"---\ntitle: Springboot最热点面试题\ndate: 2024-05-26 22:50:22\ntags: springboot\ncategories: 面试\n---\n\n\n\n\n## springboot启动流程\n### 启动类上注解：@SpringBootApplication\n#### @SpringBootConfiguration\n根据Javadoc可知，该注解作用就是将当前的类作为一个JavaConfig，然后触发注解@EnableAutoConfiguration和@ComponentScan的处理，本质上与@Configuration注解没有区别\n#### @EnableAutoConfiguration\n@EnableAutoConfiguration:实现自动装配的核心注解\n- @AutoConfigurationPackage\n    - 注册当前启动类的根 package\n    - 注册 org.springframework.boot.autoconfigure.AutoConfigurationPackages 的 BeanDefinition\n- @Import(AutoConfigurationImportSelector.class)\n    - 自动装配核心功能的实现实际是通过 AutoConfigurationImportSelector(加载自动装配类)类\n    - AutoConfigurationImportSelector 类实现了 ImportSelector接口\n        - 实现了这个接口中的 selectImports方法\n            - 方法实现 重要的getAutoConfigurationEntry()方法\n                1. 判断自动装配是否打开，默认是true可以通过application.yml设置\n                2. 获取@EnableAutoConfiguration里的exclude和excludeName内容以便排除\n                3. 获取需要自动装配的所有配置类，读取META-INF/spring.factories druid 数据库连接池的 Spring Boot Starter 就创建了META-INF/spring.factories文件\n                4. 筛选满足@ConditionalOnXXX注解的类，生效才会被加载\n            - 该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中\n#### @ComponentScan\n扫描的 Spring 对应的组件，如 @Componet，@Repository\n- 我们可以通过 basePackages 等属性来细粒度的定制 @ComponentScan 自动扫描的范围，如果不指定，则默认Spring框架实现会从声明 @ComponentScan 所在类的package进行扫描，所以 SpringBoot 的启动类最好是放在根package下，我们自定义的类就放在对应的子package下，这样就可以不指定 basePackages\n### 启动类中的main方法：org.springframework.boot.SpringApplication#run(java.lang.Class<?>, java.lang.String...)\n- 从spring.factories配置文件中加载EventPublishingRunListener对象，该对象拥有SimpleApplicationEventMulticaster属性，即在SpringBoot启动过程的不同阶段用来发射内置的生命周期事件;\n    - spring-bean包下META-INF/spring.factories\n- 准备环境变量，包括系统变量，环境变量，命令行参数，默认变量，servlet相关配置变量，随机值以及配置文件（比如application.properties）等;\n    - 而后就会去创建Environment——这个时候会去加载application配置文件\n- 控制台打印SpringBoot的bannner标志；\n- 根据不同类型环境创建不同类型的applicationcontext容器，因为这里是servlet环境，所以创建的是AnnotationConfigServletWebServerApplicationContext容器对象；\n- 从spring.factories配置文件中加载FailureAnalyzers对象,用来报告SpringBoot启动过程中的异常；\n- 为刚创建的容器对象做一些初始化工作，准备一些容器属性值等，对ApplicationContext应用一些相关的后置处理和调用各个ApplicationContextInitializer的初始化方法来执行一些初始化逻辑等；\n- 刷新容器，这一步至关重要。比如调用bean factory的后置处理器，注册BeanPostProcessor后置处理器，初始化事件广播器且广播事件，初始化剩下的单例bean和SpringBoot创建内嵌的Tomcat服务器等等重要且复杂的逻辑都在这里实现，主要步骤可见代码的注释，关于这里的逻辑会在以后的spring源码分析专题详细分析；\n    - // 1）在context刷新前做一些准备工作，比如初始化一些属性设置，属性合法性校验和保存容器中的一些早期事件等；\n    - // 2）让子类刷新其内部bean factory,注意SpringBoot和Spring启动的情况执行逻辑不一样\n    - // 3）对bean factory进行配置，比如配置bean factory的类加载器，后置处理器等\n    - // 4）完成bean factory的准备工作后，此时执行一些后置处理逻辑，子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置\n        - // 在这一步，所有的bean definitions将会被加载，但此时bean还不会被实例化\n    - // 5）执行BeanFactoryPostProcessor的方法即调用bean factory的后置处理器：\n        - // BeanDefinitionRegistryPostProcessor（触发时机：bean定义注册之前）和BeanFactoryPostProcessor（触发时机：bean定义注册之后bean实例化之前）\n    - // 6）注册bean的后置处理器BeanPostProcessor，注意不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的\n    - // 7）初始化国际化MessageSource相关的组件，比如消息绑定，消息解析等\n    - // 8）初始化事件广播器，如果bean factory没有包含事件广播器，那么new一个SimpleApplicationEventMulticaster广播器对象并注册到bean factory中\n    - // 9）AbstractApplicationContext定义了一个模板方法onRefresh，留给子类覆写，比如ServletWebServerApplicationContext覆写了该方法来创建内嵌的tomcat容器\n    - // 10）注册实现了ApplicationListener接口的监听器，之前已经有了事件广播器，此时就可以派发一些early application events\n    - // 11）完成容器bean factory的初始化，并初始化所有剩余的单例bean。这一步非常重要，一些bean postprocessor会在这里调用。\n    - // 12）完成容器的刷新工作，并且调用生命周期处理器的onRefresh()方法，并且发布ContextRefreshedEvent事件\n- 执行刷新容器后的后置处理逻辑，注意这里为空方法；\n- 调用ApplicationRunner和CommandLineRunner的run方法，我们实现这两个接口可以在spring容器启动后需要的一些东西比如加载一些业务数据等;\n- 报告启动异常，即若启动过程中抛出异常，此时用FailureAnalyzers来报告异常;\n- 最终返回容器对象，这里调用方法没有声明对象来接收。\n```java\npublic static void main(String[] args) throws Exception {\n   SpringApplication.run(new Class<?>[0], args);\n}\npublic static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {\n   // 新建SpringApplication对象，再调用run方法\n   return new SpringApplication(primarySources).run(args);\n}\npublic ConfigurableApplicationContext run(String... args) {\n   // stopWatch用于统计run启动过程时长\n   StopWatch stopWatch = new StopWatch();\n   // 开始计时\n   stopWatch.start();\n   // 创建ConfigurableApplicationContext对象\n   ConfigurableApplicationContext context = null;\n   // exceptionReporters集合用来存储SpringApplication启动过程的异常，SpringBootExceptionReporter且通过spring.factories方式来加载\n   Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();\n   // 配置headless属性\n   configureHeadlessProperty();\n   /**\n    * 从spring.factories配置文件中加载到EventPublishingRunListener对象并赋值给SpringApplicationRunListeners\n    * # Run Listeners\n    * org.springframework.boot.SpringApplicationRunListener=\\\n    * org.springframework.boot.context.event.EventPublishingRunListener\n    */\n   SpringApplicationRunListeners listeners = getRunListeners(args);\n   // 启动SpringApplicationRunListeners监听\n   listeners.starting();\n   try {\n      // 创建ApplicationArguments对象，封装了args参数\n      ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n      // 备配置参数有app.properties，外部配置参数比如jvm启动参数等\n      ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);\n      // 配置spring.beaninfo.ignore属性\n      configureIgnoreBeanInfo(environment);\n      // 打印springboot的bannner\n      Banner printedBanner = printBanner(environment);\n      // 根据不同类型创建不同类型的spring applicationcontext容器\n      context = createApplicationContext();\n      /**\n       * 异常报告\n       * 从spring.factories配置文件中加载exceptionReporters，其中ConfigurableApplicationContext.class作为FailureAnalyzers构造方法的参数\n       * # Error Reporters\n       * org.springframework.boot.SpringBootExceptionReporter=\\\n       * org.springframework.boot.diagnostics.FailureAnalyzers\n       */\n      exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,\n            new Class[] { ConfigurableApplicationContext.class }, context);\n      // 准备容器事项：调用各个ApplicationContextInitializer的initialize方法\n      // 和触发SpringApplicationRunListeners的contextPrepared及contextLoaded方法等\n      prepareContext(context, environment, listeners, applicationArguments, printedBanner);\n      // 刷新容器，这一步至关重要\n      refreshContext(context);\n      // 执行刷新容器后的后置处理逻辑，注意这里为空方法\n      afterRefresh(context, applicationArguments);\n      // 停止stopWatch计时\n      stopWatch.stop();\n      // 打印springboot的启动时常\n      if (this.logStartupInfo) {\n         new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);\n      }\n      // 触发SpringApplicationRunListener的started方法，通知spring容器已经启动\n      listeners.started(context);\n      // 调用ApplicationRunner和CommandLineRunner的run方法，实现spring容器启动后需要做的一些东西\n      callRunners(context, applicationArguments);\n   }\n   // 若上面的方法抛出异常，将异常添加到exceptionReporters集合中，并抛出 IllegalStateException 异常。\n   catch (Throwable ex) {\n      handleRunFailure(context, ex, exceptionReporters, listeners);\n      throw new IllegalStateException(ex);\n   }\n\n   try {\n      // 当容器刷新完毕等，触发SpringApplicationRunListeners数组的running方法\n      listeners.running(context);\n   }\n   catch (Throwable ex) {\n      // 若上面的方法抛出异常，将异常添加到exceptionReporters集合中，并抛出 IllegalStateException 异常。\n      handleRunFailure(context, ex, exceptionReporters, null);\n      throw new IllegalStateException(ex);\n   }\n   return context;\n}\n\n```\n## 怎么让Spring把Body变成一个对象\n- @RequestBody注解原理\n- 详细看springmvc的处理流程\n## SpringBoot的starter实现原理是什么？\n原理就是因为在@EnableAutoConfiguration注解，会自动的扫描jar包下的META-INF/spring.factories文件的配置类，写在这里面的类都是需要被自动加载的\n\n将configuration类中定义的bean加入spring到容器中。就相当于加载之前我们自己配置组件的xml文件。而现在SpringBoot自己定义了一个默认的值，然后直接加载进入了Spring容器。\n\nSpringBoot提供的自动配置依赖模块都以spring-boot-starter-为命名前缀，并且这些依赖都在org.springframework.boot下。 所有的spring-boot-starter都有约定俗成的默认配置，但允许调整这些配置调整默认的行为。\n## spring 和springboot的区别\nSpring Boot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，为更快，更高效的开发生态系统铺平了道路。\n\nSpring Boot中的一些特征：\n\n- 创建独立的Spring应用。\n- 嵌入式Tomcat、Jetty、 Undertow容器（无需部署war文件）。\n- 提供的starters 简化构建配置\n- 尽可能自动配置spring应用。\n- 提供生产指标,例如指标、健壮检查和外部化配置\n- 完全没有代码生成和XML配置要求\n\nMaven依赖\n\n首先，让我们看一下使用Spring创建Web应用程序所需的最小依赖项\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-web</artifactId>\n    <version>5.1.0.RELEASE</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.1.0.RELEASE</version>\n</dependency>\n```\n与Spring不同，Spring Boot只需要一个依赖项来启动和运行Web应用程序：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n    <version>2.0.6.RELEASE</version>\n</dependency>\n```\n在进行构建期间，所有其他依赖项将自动添加到项目中。\n\n另一个很好的例子就是测试库。我们通常使用Spring Test，JUnit，Hamcrest和Mockito库。在Spring项目中，我们应该将所有这些库添加为依赖项。但是在Spring Boot中，我们只需要添加spring-boot-starter-test依赖项来自动包含这些库。\n\nspring在运行前需要使用xml文件做很多配置，而springboot帮我们实现了这些配置的自动加载，基于注解和简单的yml配置即可\n\nspring的web程序还是打包为war然后再Tomcat里运行，而springboot内嵌了Tomcat直接打成可运行的jar\n\n## Spring Boot 可执行 Jar 包运行原理\nSpring Boot 有一个很方便的功能就是可以将应用打成可执行的 Jar。那么大家有没想过这个 Jar 是怎么运行起来的呢？本篇博客就来介绍下 Spring Boot 可执行 Jar 包的运行原理。\n\n### 打可执行 Jar 包\n将 Spring Boot 应用打成可执行 Jar包很容易，只需要在 pom 中加上一个 Spring Boot 提供的插件，然后在执行mvn package即可\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n```\n运行完mvn package后，我们会在 target 目录下看到两个 jar 文件。myproject-0.0.1-SNAPSHOT.jar 和 myproject-0.0.1-SNAPSHOT.jar.original。第一个 jar 文件就是我们应用的可执行 jar 包，第二个 Jar 文件是应用原始的 jar 包。\n\n### 可执行 Jar 包内部结构\n```text\n可执行 jar 目录结构\n├─BOOT-INF\n│  ├─classes\n│  └─lib\n├─META-INF\n│  ├─maven\n│  ├─app.properties\n│  ├─MANIFEST.MF      \n└─org\n    └─springframework\n        └─boot\n            └─loader\n                ├─archive\n                ├─data\n                ├─jar\n                └─util\n\n```\n我们先来重点关注两个地方：META-INF 下面的 Jar 包描述文件和 BOOT-INF 这个目录。\n```properties\nManifest-Version: 1.0\nArchiver-Version: Plexus Archiver\nBuilt-By: xxxx\nStart-Class: com.xxxx.AppServer\nSpring-Boot-Classes: BOOT-INF/classes/\nSpring-Boot-Lib: BOOT-INF/lib/\nSpring-Boot-Version: 2.1.6.RELEASE\nCreated-By: Apache Maven 3.3.9\nBuild-Jdk: 1.8.0_73\nMain-Class: org.springframework.boot.loader.JarLauncher\n\n```\n在上面我们看到一个熟悉的配置Main-Class: org.springframework.boot.loader.JarLauncher。我们大概能猜到这个类是整个系统的入口。\n\n再看下 BOOT-INF 这个目录下面，我们会发现里面是我们项目打出来的 class 文件和项目依赖的 Jar 包。看到这里，你可能已经猜到 Spring Boot 是怎么启动项目的了。\n\n### JarLauncher\n```java\npublic class JarLauncher extends ExecutableArchiveLauncher {\n\n\tstatic final String BOOT_INF_CLASSES = \"BOOT-INF/classes/\";\n\n\tstatic final String BOOT_INF_LIB = \"BOOT-INF/lib/\";\n\n\tpublic JarLauncher() {\n\t}\n\n\tprotected JarLauncher(Archive archive) {\n\t\tsuper(archive);\n\t}\n\n\t@Override\n\tprotected boolean isNestedArchive(Archive.Entry entry) {\n\t\tif (entry.isDirectory()) {\n\t\t\treturn entry.getName().equals(BOOT_INF_CLASSES);\n\t\t}\n\t\treturn entry.getName().startsWith(BOOT_INF_LIB);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n        //项目入口，重点在launch这个方法中\n\t\tnew JarLauncher().launch(args);\n\t}\n\n}\n\n```\n```java\n//launch方法\nprotected void launch(String[] args) throws Exception {\n    JarFile.registerUrlProtocolHandler();\n    //创建LaunchedURLClassLoader。如果根类加载器和扩展类加载器没有加载到某个类的话，就会通过LaunchedURLClassLoader这个加载器来加载类。这个加载器会从Boot-INF下面的class目录和lib目录下加载类。\n    ClassLoader classLoader = createClassLoader(getClassPathArchives());\n    //这个方法会读取jar描述文件中的Start-Class属性，然后通过反射调用到这个类的main方法。\n    launch(args, getMainClass(), classLoader);\n}\n\n```\n简单总结\n- Spring Boot 可执行 Jar 包的入口点是 JarLauncher 的 main 方法；\n- 这个方法的执行逻辑是先创建一个 LaunchedURLClassLoader，这个加载器加载类的逻辑是：先判断根类加载器和扩展类加载器能否加载到某个类，如果都加载不到就从 Boot-INF 下面的 class 和 lib 目录下去加载；\n- 读取Start-Class属性，通过反射机制调用启动类的 main 方法，这样就顺利调用到我们开发的 Spring Boot 主启动类的 main 方法了。\n\n","slug":"Springboot最热点面试题","published":1,"updated":"2024-05-26T14:53:55.031Z","comments":1,"layout":"post","photos":[],"_id":"clwxc4r9q0003b4uhdfude5p9","content":"<h2 id=\"springboot启动流程\"><a href=\"#springboot启动流程\" class=\"headerlink\" title=\"springboot启动流程\"></a>springboot启动流程</h2><h3 id=\"启动类上注解：-SpringBootApplication\"><a href=\"#启动类上注解：-SpringBootApplication\" class=\"headerlink\" title=\"启动类上注解：@SpringBootApplication\"></a>启动类上注解：@SpringBootApplication</h3><h4 id=\"SpringBootConfiguration\"><a href=\"#SpringBootConfiguration\" class=\"headerlink\" title=\"@SpringBootConfiguration\"></a>@SpringBootConfiguration</h4><p>根据Javadoc可知，该注解作用就是将当前的类作为一个JavaConfig，然后触发注解@EnableAutoConfiguration和@ComponentScan的处理，本质上与@Configuration注解没有区别</p>\n<h4 id=\"EnableAutoConfiguration\"><a href=\"#EnableAutoConfiguration\" class=\"headerlink\" title=\"@EnableAutoConfiguration\"></a>@EnableAutoConfiguration</h4><p>@EnableAutoConfiguration:实现自动装配的核心注解</p>\n<ul>\n<li>@AutoConfigurationPackage<ul>\n<li>注册当前启动类的根 package</li>\n<li>注册 org.springframework.boot.autoconfigure.AutoConfigurationPackages 的 BeanDefinition</li>\n</ul>\n</li>\n<li>@Import(AutoConfigurationImportSelector.class)<ul>\n<li>自动装配核心功能的实现实际是通过 AutoConfigurationImportSelector(加载自动装配类)类</li>\n<li>AutoConfigurationImportSelector 类实现了 ImportSelector接口<ul>\n<li>实现了这个接口中的 selectImports方法<ul>\n<li>方法实现 重要的getAutoConfigurationEntry()方法<ol>\n<li>判断自动装配是否打开，默认是true可以通过application.yml设置</li>\n<li>获取@EnableAutoConfiguration里的exclude和excludeName内容以便排除</li>\n<li>获取需要自动装配的所有配置类，读取META-INF&#x2F;spring.factories druid 数据库连接池的 Spring Boot Starter 就创建了META-INF&#x2F;spring.factories文件</li>\n<li>筛选满足@ConditionalOnXXX注解的类，生效才会被加载</li>\n</ol>\n</li>\n<li>该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ComponentScan\"><a href=\"#ComponentScan\" class=\"headerlink\" title=\"@ComponentScan\"></a>@ComponentScan</h4><p>扫描的 Spring 对应的组件，如 @Componet，@Repository</p>\n<ul>\n<li>我们可以通过 basePackages 等属性来细粒度的定制 @ComponentScan 自动扫描的范围，如果不指定，则默认Spring框架实现会从声明 @ComponentScan 所在类的package进行扫描，所以 SpringBoot 的启动类最好是放在根package下，我们自定义的类就放在对应的子package下，这样就可以不指定 basePackages</li>\n</ul>\n<h3 id=\"启动类中的main方法：org-springframework-boot-SpringApplication-run-java-lang-Class-java-lang-String…\"><a href=\"#启动类中的main方法：org-springframework-boot-SpringApplication-run-java-lang-Class-java-lang-String…\" class=\"headerlink\" title=\"启动类中的main方法：org.springframework.boot.SpringApplication#run(java.lang.Class&lt;?&gt;, java.lang.String…)\"></a>启动类中的main方法：org.springframework.boot.SpringApplication#run(java.lang.Class&lt;?&gt;, java.lang.String…)</h3><ul>\n<li>从spring.factories配置文件中加载EventPublishingRunListener对象，该对象拥有SimpleApplicationEventMulticaster属性，即在SpringBoot启动过程的不同阶段用来发射内置的生命周期事件;<ul>\n<li>spring-bean包下META-INF&#x2F;spring.factories</li>\n</ul>\n</li>\n<li>准备环境变量，包括系统变量，环境变量，命令行参数，默认变量，servlet相关配置变量，随机值以及配置文件（比如application.properties）等;<ul>\n<li>而后就会去创建Environment——这个时候会去加载application配置文件</li>\n</ul>\n</li>\n<li>控制台打印SpringBoot的bannner标志；</li>\n<li>根据不同类型环境创建不同类型的applicationcontext容器，因为这里是servlet环境，所以创建的是AnnotationConfigServletWebServerApplicationContext容器对象；</li>\n<li>从spring.factories配置文件中加载FailureAnalyzers对象,用来报告SpringBoot启动过程中的异常；</li>\n<li>为刚创建的容器对象做一些初始化工作，准备一些容器属性值等，对ApplicationContext应用一些相关的后置处理和调用各个ApplicationContextInitializer的初始化方法来执行一些初始化逻辑等；</li>\n<li>刷新容器，这一步至关重要。比如调用bean factory的后置处理器，注册BeanPostProcessor后置处理器，初始化事件广播器且广播事件，初始化剩下的单例bean和SpringBoot创建内嵌的Tomcat服务器等等重要且复杂的逻辑都在这里实现，主要步骤可见代码的注释，关于这里的逻辑会在以后的spring源码分析专题详细分析；<ul>\n<li>&#x2F;&#x2F; 1）在context刷新前做一些准备工作，比如初始化一些属性设置，属性合法性校验和保存容器中的一些早期事件等；</li>\n<li>&#x2F;&#x2F; 2）让子类刷新其内部bean factory,注意SpringBoot和Spring启动的情况执行逻辑不一样</li>\n<li>&#x2F;&#x2F; 3）对bean factory进行配置，比如配置bean factory的类加载器，后置处理器等</li>\n<li>&#x2F;&#x2F; 4）完成bean factory的准备工作后，此时执行一些后置处理逻辑，子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置<ul>\n<li>&#x2F;&#x2F; 在这一步，所有的bean definitions将会被加载，但此时bean还不会被实例化</li>\n</ul>\n</li>\n<li>&#x2F;&#x2F; 5）执行BeanFactoryPostProcessor的方法即调用bean factory的后置处理器：<ul>\n<li>&#x2F;&#x2F; BeanDefinitionRegistryPostProcessor（触发时机：bean定义注册之前）和BeanFactoryPostProcessor（触发时机：bean定义注册之后bean实例化之前）</li>\n</ul>\n</li>\n<li>&#x2F;&#x2F; 6）注册bean的后置处理器BeanPostProcessor，注意不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的</li>\n<li>&#x2F;&#x2F; 7）初始化国际化MessageSource相关的组件，比如消息绑定，消息解析等</li>\n<li>&#x2F;&#x2F; 8）初始化事件广播器，如果bean factory没有包含事件广播器，那么new一个SimpleApplicationEventMulticaster广播器对象并注册到bean factory中</li>\n<li>&#x2F;&#x2F; 9）AbstractApplicationContext定义了一个模板方法onRefresh，留给子类覆写，比如ServletWebServerApplicationContext覆写了该方法来创建内嵌的tomcat容器</li>\n<li>&#x2F;&#x2F; 10）注册实现了ApplicationListener接口的监听器，之前已经有了事件广播器，此时就可以派发一些early application events</li>\n<li>&#x2F;&#x2F; 11）完成容器bean factory的初始化，并初始化所有剩余的单例bean。这一步非常重要，一些bean postprocessor会在这里调用。</li>\n<li>&#x2F;&#x2F; 12）完成容器的刷新工作，并且调用生命周期处理器的onRefresh()方法，并且发布ContextRefreshedEvent事件</li>\n</ul>\n</li>\n<li>执行刷新容器后的后置处理逻辑，注意这里为空方法；</li>\n<li>调用ApplicationRunner和CommandLineRunner的run方法，我们实现这两个接口可以在spring容器启动后需要的一些东西比如加载一些业务数据等;</li>\n<li>报告启动异常，即若启动过程中抛出异常，此时用FailureAnalyzers来报告异常;</li>\n<li>最终返回容器对象，这里调用方法没有声明对象来接收。<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">   SpringApplication.run(<span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[<span class=\"number\">0</span>], args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ConfigurableApplicationContext <span class=\"title function_\">run</span><span class=\"params\">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 新建SpringApplication对象，再调用run方法</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SpringApplication</span>(primarySources).run(args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">// stopWatch用于统计run启动过程时长</span></span><br><span class=\"line\">   <span class=\"type\">StopWatch</span> <span class=\"variable\">stopWatch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StopWatch</span>();</span><br><span class=\"line\">   <span class=\"comment\">// 开始计时</span></span><br><span class=\"line\">   stopWatch.start();</span><br><span class=\"line\">   <span class=\"comment\">// 创建ConfigurableApplicationContext对象</span></span><br><span class=\"line\">   <span class=\"type\">ConfigurableApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">   <span class=\"comment\">// exceptionReporters集合用来存储SpringApplication启动过程的异常，SpringBootExceptionReporter且通过spring.factories方式来加载</span></span><br><span class=\"line\">   Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">   <span class=\"comment\">// 配置headless属性</span></span><br><span class=\"line\">   configureHeadlessProperty();</span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 从spring.factories配置文件中加载到EventPublishingRunListener对象并赋值给SpringApplicationRunListeners</span></span><br><span class=\"line\"><span class=\"comment\">    * # Run Listeners</span></span><br><span class=\"line\"><span class=\"comment\">    * org.springframework.boot.SpringApplicationRunListener=\\</span></span><br><span class=\"line\"><span class=\"comment\">    * org.springframework.boot.context.event.EventPublishingRunListener</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"type\">SpringApplicationRunListeners</span> <span class=\"variable\">listeners</span> <span class=\"operator\">=</span> getRunListeners(args);</span><br><span class=\"line\">   <span class=\"comment\">// 启动SpringApplicationRunListeners监听</span></span><br><span class=\"line\">   listeners.starting();</span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 创建ApplicationArguments对象，封装了args参数</span></span><br><span class=\"line\">      <span class=\"type\">ApplicationArguments</span> <span class=\"variable\">applicationArguments</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultApplicationArguments</span>(args);</span><br><span class=\"line\">      <span class=\"comment\">// 备配置参数有app.properties，外部配置参数比如jvm启动参数等</span></span><br><span class=\"line\">      <span class=\"type\">ConfigurableEnvironment</span> <span class=\"variable\">environment</span> <span class=\"operator\">=</span> prepareEnvironment(listeners, applicationArguments);</span><br><span class=\"line\">      <span class=\"comment\">// 配置spring.beaninfo.ignore属性</span></span><br><span class=\"line\">      configureIgnoreBeanInfo(environment);</span><br><span class=\"line\">      <span class=\"comment\">// 打印springboot的bannner</span></span><br><span class=\"line\">      <span class=\"type\">Banner</span> <span class=\"variable\">printedBanner</span> <span class=\"operator\">=</span> printBanner(environment);</span><br><span class=\"line\">      <span class=\"comment\">// 根据不同类型创建不同类型的spring applicationcontext容器</span></span><br><span class=\"line\">      context = createApplicationContext();</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 异常报告</span></span><br><span class=\"line\"><span class=\"comment\">       * 从spring.factories配置文件中加载exceptionReporters，其中ConfigurableApplicationContext.class作为FailureAnalyzers构造方法的参数</span></span><br><span class=\"line\"><span class=\"comment\">       * # Error Reporters</span></span><br><span class=\"line\"><span class=\"comment\">       * org.springframework.boot.SpringBootExceptionReporter=\\</span></span><br><span class=\"line\"><span class=\"comment\">       * org.springframework.boot.diagnostics.FailureAnalyzers</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class=\"line\">      <span class=\"comment\">// 准备容器事项：调用各个ApplicationContextInitializer的initialize方法</span></span><br><span class=\"line\">      <span class=\"comment\">// 和触发SpringApplicationRunListeners的contextPrepared及contextLoaded方法等</span></span><br><span class=\"line\">      prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class=\"line\">      <span class=\"comment\">// 刷新容器，这一步至关重要</span></span><br><span class=\"line\">      refreshContext(context);</span><br><span class=\"line\">      <span class=\"comment\">// 执行刷新容器后的后置处理逻辑，注意这里为空方法</span></span><br><span class=\"line\">      afterRefresh(context, applicationArguments);</span><br><span class=\"line\">      <span class=\"comment\">// 停止stopWatch计时</span></span><br><span class=\"line\">      stopWatch.stop();</span><br><span class=\"line\">      <span class=\"comment\">// 打印springboot的启动时常</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.logStartupInfo) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">new</span> <span class=\"title class_\">StartupInfoLogger</span>(<span class=\"built_in\">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 触发SpringApplicationRunListener的started方法，通知spring容器已经启动</span></span><br><span class=\"line\">      listeners.started(context);</span><br><span class=\"line\">      <span class=\"comment\">// 调用ApplicationRunner和CommandLineRunner的run方法，实现spring容器启动后需要做的一些东西</span></span><br><span class=\"line\">      callRunners(context, applicationArguments);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 若上面的方法抛出异常，将异常添加到exceptionReporters集合中，并抛出 IllegalStateException 异常。</span></span><br><span class=\"line\">   <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">      handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当容器刷新完毕等，触发SpringApplicationRunListeners数组的running方法</span></span><br><span class=\"line\">      listeners.running(context);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 若上面的方法抛出异常，将异常添加到exceptionReporters集合中，并抛出 IllegalStateException 异常。</span></span><br><span class=\"line\">      handleRunFailure(context, ex, exceptionReporters, <span class=\"literal\">null</span>);</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"怎么让Spring把Body变成一个对象\"><a href=\"#怎么让Spring把Body变成一个对象\" class=\"headerlink\" title=\"怎么让Spring把Body变成一个对象\"></a>怎么让Spring把Body变成一个对象</h2><ul>\n<li>@RequestBody注解原理</li>\n<li>详细看springmvc的处理流程</li>\n</ul>\n<h2 id=\"SpringBoot的starter实现原理是什么？\"><a href=\"#SpringBoot的starter实现原理是什么？\" class=\"headerlink\" title=\"SpringBoot的starter实现原理是什么？\"></a>SpringBoot的starter实现原理是什么？</h2><p>原理就是因为在@EnableAutoConfiguration注解，会自动的扫描jar包下的META-INF&#x2F;spring.factories文件的配置类，写在这里面的类都是需要被自动加载的</p>\n<p>将configuration类中定义的bean加入spring到容器中。就相当于加载之前我们自己配置组件的xml文件。而现在SpringBoot自己定义了一个默认的值，然后直接加载进入了Spring容器。</p>\n<p>SpringBoot提供的自动配置依赖模块都以spring-boot-starter-为命名前缀，并且这些依赖都在org.springframework.boot下。 所有的spring-boot-starter都有约定俗成的默认配置，但允许调整这些配置调整默认的行为。</p>\n<h2 id=\"spring-和springboot的区别\"><a href=\"#spring-和springboot的区别\" class=\"headerlink\" title=\"spring 和springboot的区别\"></a>spring 和springboot的区别</h2><p>Spring Boot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，为更快，更高效的开发生态系统铺平了道路。</p>\n<p>Spring Boot中的一些特征：</p>\n<ul>\n<li>创建独立的Spring应用。</li>\n<li>嵌入式Tomcat、Jetty、 Undertow容器（无需部署war文件）。</li>\n<li>提供的starters 简化构建配置</li>\n<li>尽可能自动配置spring应用。</li>\n<li>提供生产指标,例如指标、健壮检查和外部化配置</li>\n<li>完全没有代码生成和XML配置要求</li>\n</ul>\n<p>Maven依赖</p>\n<p>首先，让我们看一下使用Spring创建Web应用程序所需的最小依赖项</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-webmvc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>与Spring不同，Spring Boot只需要一个依赖项来启动和运行Web应用程序：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.6.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在进行构建期间，所有其他依赖项将自动添加到项目中。</p>\n<p>另一个很好的例子就是测试库。我们通常使用Spring Test，JUnit，Hamcrest和Mockito库。在Spring项目中，我们应该将所有这些库添加为依赖项。但是在Spring Boot中，我们只需要添加spring-boot-starter-test依赖项来自动包含这些库。</p>\n<p>spring在运行前需要使用xml文件做很多配置，而springboot帮我们实现了这些配置的自动加载，基于注解和简单的yml配置即可</p>\n<p>spring的web程序还是打包为war然后再Tomcat里运行，而springboot内嵌了Tomcat直接打成可运行的jar</p>\n<h2 id=\"Spring-Boot-可执行-Jar-包运行原理\"><a href=\"#Spring-Boot-可执行-Jar-包运行原理\" class=\"headerlink\" title=\"Spring Boot 可执行 Jar 包运行原理\"></a>Spring Boot 可执行 Jar 包运行原理</h2><p>Spring Boot 有一个很方便的功能就是可以将应用打成可执行的 Jar。那么大家有没想过这个 Jar 是怎么运行起来的呢？本篇博客就来介绍下 Spring Boot 可执行 Jar 包的运行原理。</p>\n<h3 id=\"打可执行-Jar-包\"><a href=\"#打可执行-Jar-包\" class=\"headerlink\" title=\"打可执行 Jar 包\"></a>打可执行 Jar 包</h3><p>将 Spring Boot 应用打成可执行 Jar包很容易，只需要在 pom 中加上一个 Spring Boot 提供的插件，然后在执行mvn package即可</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>运行完mvn package后，我们会在 target 目录下看到两个 jar 文件。myproject-0.0.1-SNAPSHOT.jar 和 myproject-0.0.1-SNAPSHOT.jar.original。第一个 jar 文件就是我们应用的可执行 jar 包，第二个 Jar 文件是应用原始的 jar 包。</p>\n<h3 id=\"可执行-Jar-包内部结构\"><a href=\"#可执行-Jar-包内部结构\" class=\"headerlink\" title=\"可执行 Jar 包内部结构\"></a>可执行 Jar 包内部结构</h3><figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">可执行 jar 目录结构</span><br><span class=\"line\">├─BOOT-INF</span><br><span class=\"line\">│  ├─classes</span><br><span class=\"line\">│  └─lib</span><br><span class=\"line\">├─META-INF</span><br><span class=\"line\">│  ├─maven</span><br><span class=\"line\">│  ├─app.properties</span><br><span class=\"line\">│  ├─MANIFEST.MF      </span><br><span class=\"line\">└─org</span><br><span class=\"line\">    └─springframework</span><br><span class=\"line\">        └─boot</span><br><span class=\"line\">            └─loader</span><br><span class=\"line\">                ├─archive</span><br><span class=\"line\">                ├─data</span><br><span class=\"line\">                ├─jar</span><br><span class=\"line\">                └─util</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们先来重点关注两个地方：META-INF 下面的 Jar 包描述文件和 BOOT-INF 这个目录。</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Manifest-Version</span>: <span class=\"string\">1.0</span></span><br><span class=\"line\"><span class=\"attr\">Archiver-Version</span>: <span class=\"string\">Plexus Archiver</span></span><br><span class=\"line\"><span class=\"attr\">Built-By</span>: <span class=\"string\">xxxx</span></span><br><span class=\"line\"><span class=\"attr\">Start-Class</span>: <span class=\"string\">com.xxxx.AppServer</span></span><br><span class=\"line\"><span class=\"attr\">Spring-Boot-Classes</span>: <span class=\"string\">BOOT-INF/classes/</span></span><br><span class=\"line\"><span class=\"attr\">Spring-Boot-Lib</span>: <span class=\"string\">BOOT-INF/lib/</span></span><br><span class=\"line\"><span class=\"attr\">Spring-Boot-Version</span>: <span class=\"string\">2.1.6.RELEASE</span></span><br><span class=\"line\"><span class=\"attr\">Created-By</span>: <span class=\"string\">Apache Maven 3.3.9</span></span><br><span class=\"line\"><span class=\"attr\">Build-Jdk</span>: <span class=\"string\">1.8.0_73</span></span><br><span class=\"line\"><span class=\"attr\">Main-Class</span>: <span class=\"string\">org.springframework.boot.loader.JarLauncher</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在上面我们看到一个熟悉的配置Main-Class: org.springframework.boot.loader.JarLauncher。我们大概能猜到这个类是整个系统的入口。</p>\n<p>再看下 BOOT-INF 这个目录下面，我们会发现里面是我们项目打出来的 class 文件和项目依赖的 Jar 包。看到这里，你可能已经猜到 Spring Boot 是怎么启动项目的了。</p>\n<h3 id=\"JarLauncher\"><a href=\"#JarLauncher\" class=\"headerlink\" title=\"JarLauncher\"></a>JarLauncher</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JarLauncher</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ExecutableArchiveLauncher</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BOOT_INF_CLASSES</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;BOOT-INF/classes/&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BOOT_INF_LIB</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;BOOT-INF/lib/&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">JarLauncher</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"title function_\">JarLauncher</span><span class=\"params\">(Archive archive)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">super</span>(archive);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isNestedArchive</span><span class=\"params\">(Archive.Entry entry)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (entry.isDirectory()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> entry.getName().equals(BOOT_INF_CLASSES);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> entry.getName().startsWith(BOOT_INF_LIB);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">//项目入口，重点在launch这个方法中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> <span class=\"title class_\">JarLauncher</span>().launch(args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//launch方法</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">launch</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    JarFile.registerUrlProtocolHandler();</span><br><span class=\"line\">    <span class=\"comment\">//创建LaunchedURLClassLoader。如果根类加载器和扩展类加载器没有加载到某个类的话，就会通过LaunchedURLClassLoader这个加载器来加载类。这个加载器会从Boot-INF下面的class目录和lib目录下加载类。</span></span><br><span class=\"line\">    <span class=\"type\">ClassLoader</span> <span class=\"variable\">classLoader</span> <span class=\"operator\">=</span> createClassLoader(getClassPathArchives());</span><br><span class=\"line\">    <span class=\"comment\">//这个方法会读取jar描述文件中的Start-Class属性，然后通过反射调用到这个类的main方法。</span></span><br><span class=\"line\">    launch(args, getMainClass(), classLoader);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>简单总结</p>\n<ul>\n<li>Spring Boot 可执行 Jar 包的入口点是 JarLauncher 的 main 方法；</li>\n<li>这个方法的执行逻辑是先创建一个 LaunchedURLClassLoader，这个加载器加载类的逻辑是：先判断根类加载器和扩展类加载器能否加载到某个类，如果都加载不到就从 Boot-INF 下面的 class 和 lib 目录下去加载；</li>\n<li>读取Start-Class属性，通过反射机制调用启动类的 main 方法，这样就顺利调用到我们开发的 Spring Boot 主启动类的 main 方法了。</li>\n</ul>\n","cover":"/img/liushui.png","cover_type":"img","excerpt":"","more":"<h2 id=\"springboot启动流程\"><a href=\"#springboot启动流程\" class=\"headerlink\" title=\"springboot启动流程\"></a>springboot启动流程</h2><h3 id=\"启动类上注解：-SpringBootApplication\"><a href=\"#启动类上注解：-SpringBootApplication\" class=\"headerlink\" title=\"启动类上注解：@SpringBootApplication\"></a>启动类上注解：@SpringBootApplication</h3><h4 id=\"SpringBootConfiguration\"><a href=\"#SpringBootConfiguration\" class=\"headerlink\" title=\"@SpringBootConfiguration\"></a>@SpringBootConfiguration</h4><p>根据Javadoc可知，该注解作用就是将当前的类作为一个JavaConfig，然后触发注解@EnableAutoConfiguration和@ComponentScan的处理，本质上与@Configuration注解没有区别</p>\n<h4 id=\"EnableAutoConfiguration\"><a href=\"#EnableAutoConfiguration\" class=\"headerlink\" title=\"@EnableAutoConfiguration\"></a>@EnableAutoConfiguration</h4><p>@EnableAutoConfiguration:实现自动装配的核心注解</p>\n<ul>\n<li>@AutoConfigurationPackage<ul>\n<li>注册当前启动类的根 package</li>\n<li>注册 org.springframework.boot.autoconfigure.AutoConfigurationPackages 的 BeanDefinition</li>\n</ul>\n</li>\n<li>@Import(AutoConfigurationImportSelector.class)<ul>\n<li>自动装配核心功能的实现实际是通过 AutoConfigurationImportSelector(加载自动装配类)类</li>\n<li>AutoConfigurationImportSelector 类实现了 ImportSelector接口<ul>\n<li>实现了这个接口中的 selectImports方法<ul>\n<li>方法实现 重要的getAutoConfigurationEntry()方法<ol>\n<li>判断自动装配是否打开，默认是true可以通过application.yml设置</li>\n<li>获取@EnableAutoConfiguration里的exclude和excludeName内容以便排除</li>\n<li>获取需要自动装配的所有配置类，读取META-INF&#x2F;spring.factories druid 数据库连接池的 Spring Boot Starter 就创建了META-INF&#x2F;spring.factories文件</li>\n<li>筛选满足@ConditionalOnXXX注解的类，生效才会被加载</li>\n</ol>\n</li>\n<li>该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ComponentScan\"><a href=\"#ComponentScan\" class=\"headerlink\" title=\"@ComponentScan\"></a>@ComponentScan</h4><p>扫描的 Spring 对应的组件，如 @Componet，@Repository</p>\n<ul>\n<li>我们可以通过 basePackages 等属性来细粒度的定制 @ComponentScan 自动扫描的范围，如果不指定，则默认Spring框架实现会从声明 @ComponentScan 所在类的package进行扫描，所以 SpringBoot 的启动类最好是放在根package下，我们自定义的类就放在对应的子package下，这样就可以不指定 basePackages</li>\n</ul>\n<h3 id=\"启动类中的main方法：org-springframework-boot-SpringApplication-run-java-lang-Class-java-lang-String…\"><a href=\"#启动类中的main方法：org-springframework-boot-SpringApplication-run-java-lang-Class-java-lang-String…\" class=\"headerlink\" title=\"启动类中的main方法：org.springframework.boot.SpringApplication#run(java.lang.Class&lt;?&gt;, java.lang.String…)\"></a>启动类中的main方法：org.springframework.boot.SpringApplication#run(java.lang.Class&lt;?&gt;, java.lang.String…)</h3><ul>\n<li>从spring.factories配置文件中加载EventPublishingRunListener对象，该对象拥有SimpleApplicationEventMulticaster属性，即在SpringBoot启动过程的不同阶段用来发射内置的生命周期事件;<ul>\n<li>spring-bean包下META-INF&#x2F;spring.factories</li>\n</ul>\n</li>\n<li>准备环境变量，包括系统变量，环境变量，命令行参数，默认变量，servlet相关配置变量，随机值以及配置文件（比如application.properties）等;<ul>\n<li>而后就会去创建Environment——这个时候会去加载application配置文件</li>\n</ul>\n</li>\n<li>控制台打印SpringBoot的bannner标志；</li>\n<li>根据不同类型环境创建不同类型的applicationcontext容器，因为这里是servlet环境，所以创建的是AnnotationConfigServletWebServerApplicationContext容器对象；</li>\n<li>从spring.factories配置文件中加载FailureAnalyzers对象,用来报告SpringBoot启动过程中的异常；</li>\n<li>为刚创建的容器对象做一些初始化工作，准备一些容器属性值等，对ApplicationContext应用一些相关的后置处理和调用各个ApplicationContextInitializer的初始化方法来执行一些初始化逻辑等；</li>\n<li>刷新容器，这一步至关重要。比如调用bean factory的后置处理器，注册BeanPostProcessor后置处理器，初始化事件广播器且广播事件，初始化剩下的单例bean和SpringBoot创建内嵌的Tomcat服务器等等重要且复杂的逻辑都在这里实现，主要步骤可见代码的注释，关于这里的逻辑会在以后的spring源码分析专题详细分析；<ul>\n<li>&#x2F;&#x2F; 1）在context刷新前做一些准备工作，比如初始化一些属性设置，属性合法性校验和保存容器中的一些早期事件等；</li>\n<li>&#x2F;&#x2F; 2）让子类刷新其内部bean factory,注意SpringBoot和Spring启动的情况执行逻辑不一样</li>\n<li>&#x2F;&#x2F; 3）对bean factory进行配置，比如配置bean factory的类加载器，后置处理器等</li>\n<li>&#x2F;&#x2F; 4）完成bean factory的准备工作后，此时执行一些后置处理逻辑，子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置<ul>\n<li>&#x2F;&#x2F; 在这一步，所有的bean definitions将会被加载，但此时bean还不会被实例化</li>\n</ul>\n</li>\n<li>&#x2F;&#x2F; 5）执行BeanFactoryPostProcessor的方法即调用bean factory的后置处理器：<ul>\n<li>&#x2F;&#x2F; BeanDefinitionRegistryPostProcessor（触发时机：bean定义注册之前）和BeanFactoryPostProcessor（触发时机：bean定义注册之后bean实例化之前）</li>\n</ul>\n</li>\n<li>&#x2F;&#x2F; 6）注册bean的后置处理器BeanPostProcessor，注意不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的</li>\n<li>&#x2F;&#x2F; 7）初始化国际化MessageSource相关的组件，比如消息绑定，消息解析等</li>\n<li>&#x2F;&#x2F; 8）初始化事件广播器，如果bean factory没有包含事件广播器，那么new一个SimpleApplicationEventMulticaster广播器对象并注册到bean factory中</li>\n<li>&#x2F;&#x2F; 9）AbstractApplicationContext定义了一个模板方法onRefresh，留给子类覆写，比如ServletWebServerApplicationContext覆写了该方法来创建内嵌的tomcat容器</li>\n<li>&#x2F;&#x2F; 10）注册实现了ApplicationListener接口的监听器，之前已经有了事件广播器，此时就可以派发一些early application events</li>\n<li>&#x2F;&#x2F; 11）完成容器bean factory的初始化，并初始化所有剩余的单例bean。这一步非常重要，一些bean postprocessor会在这里调用。</li>\n<li>&#x2F;&#x2F; 12）完成容器的刷新工作，并且调用生命周期处理器的onRefresh()方法，并且发布ContextRefreshedEvent事件</li>\n</ul>\n</li>\n<li>执行刷新容器后的后置处理逻辑，注意这里为空方法；</li>\n<li>调用ApplicationRunner和CommandLineRunner的run方法，我们实现这两个接口可以在spring容器启动后需要的一些东西比如加载一些业务数据等;</li>\n<li>报告启动异常，即若启动过程中抛出异常，此时用FailureAnalyzers来报告异常;</li>\n<li>最终返回容器对象，这里调用方法没有声明对象来接收。<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">   SpringApplication.run(<span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[<span class=\"number\">0</span>], args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ConfigurableApplicationContext <span class=\"title function_\">run</span><span class=\"params\">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 新建SpringApplication对象，再调用run方法</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SpringApplication</span>(primarySources).run(args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">// stopWatch用于统计run启动过程时长</span></span><br><span class=\"line\">   <span class=\"type\">StopWatch</span> <span class=\"variable\">stopWatch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StopWatch</span>();</span><br><span class=\"line\">   <span class=\"comment\">// 开始计时</span></span><br><span class=\"line\">   stopWatch.start();</span><br><span class=\"line\">   <span class=\"comment\">// 创建ConfigurableApplicationContext对象</span></span><br><span class=\"line\">   <span class=\"type\">ConfigurableApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">   <span class=\"comment\">// exceptionReporters集合用来存储SpringApplication启动过程的异常，SpringBootExceptionReporter且通过spring.factories方式来加载</span></span><br><span class=\"line\">   Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">   <span class=\"comment\">// 配置headless属性</span></span><br><span class=\"line\">   configureHeadlessProperty();</span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 从spring.factories配置文件中加载到EventPublishingRunListener对象并赋值给SpringApplicationRunListeners</span></span><br><span class=\"line\"><span class=\"comment\">    * # Run Listeners</span></span><br><span class=\"line\"><span class=\"comment\">    * org.springframework.boot.SpringApplicationRunListener=\\</span></span><br><span class=\"line\"><span class=\"comment\">    * org.springframework.boot.context.event.EventPublishingRunListener</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"type\">SpringApplicationRunListeners</span> <span class=\"variable\">listeners</span> <span class=\"operator\">=</span> getRunListeners(args);</span><br><span class=\"line\">   <span class=\"comment\">// 启动SpringApplicationRunListeners监听</span></span><br><span class=\"line\">   listeners.starting();</span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 创建ApplicationArguments对象，封装了args参数</span></span><br><span class=\"line\">      <span class=\"type\">ApplicationArguments</span> <span class=\"variable\">applicationArguments</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultApplicationArguments</span>(args);</span><br><span class=\"line\">      <span class=\"comment\">// 备配置参数有app.properties，外部配置参数比如jvm启动参数等</span></span><br><span class=\"line\">      <span class=\"type\">ConfigurableEnvironment</span> <span class=\"variable\">environment</span> <span class=\"operator\">=</span> prepareEnvironment(listeners, applicationArguments);</span><br><span class=\"line\">      <span class=\"comment\">// 配置spring.beaninfo.ignore属性</span></span><br><span class=\"line\">      configureIgnoreBeanInfo(environment);</span><br><span class=\"line\">      <span class=\"comment\">// 打印springboot的bannner</span></span><br><span class=\"line\">      <span class=\"type\">Banner</span> <span class=\"variable\">printedBanner</span> <span class=\"operator\">=</span> printBanner(environment);</span><br><span class=\"line\">      <span class=\"comment\">// 根据不同类型创建不同类型的spring applicationcontext容器</span></span><br><span class=\"line\">      context = createApplicationContext();</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 异常报告</span></span><br><span class=\"line\"><span class=\"comment\">       * 从spring.factories配置文件中加载exceptionReporters，其中ConfigurableApplicationContext.class作为FailureAnalyzers构造方法的参数</span></span><br><span class=\"line\"><span class=\"comment\">       * # Error Reporters</span></span><br><span class=\"line\"><span class=\"comment\">       * org.springframework.boot.SpringBootExceptionReporter=\\</span></span><br><span class=\"line\"><span class=\"comment\">       * org.springframework.boot.diagnostics.FailureAnalyzers</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class=\"line\">      <span class=\"comment\">// 准备容器事项：调用各个ApplicationContextInitializer的initialize方法</span></span><br><span class=\"line\">      <span class=\"comment\">// 和触发SpringApplicationRunListeners的contextPrepared及contextLoaded方法等</span></span><br><span class=\"line\">      prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class=\"line\">      <span class=\"comment\">// 刷新容器，这一步至关重要</span></span><br><span class=\"line\">      refreshContext(context);</span><br><span class=\"line\">      <span class=\"comment\">// 执行刷新容器后的后置处理逻辑，注意这里为空方法</span></span><br><span class=\"line\">      afterRefresh(context, applicationArguments);</span><br><span class=\"line\">      <span class=\"comment\">// 停止stopWatch计时</span></span><br><span class=\"line\">      stopWatch.stop();</span><br><span class=\"line\">      <span class=\"comment\">// 打印springboot的启动时常</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.logStartupInfo) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">new</span> <span class=\"title class_\">StartupInfoLogger</span>(<span class=\"built_in\">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 触发SpringApplicationRunListener的started方法，通知spring容器已经启动</span></span><br><span class=\"line\">      listeners.started(context);</span><br><span class=\"line\">      <span class=\"comment\">// 调用ApplicationRunner和CommandLineRunner的run方法，实现spring容器启动后需要做的一些东西</span></span><br><span class=\"line\">      callRunners(context, applicationArguments);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 若上面的方法抛出异常，将异常添加到exceptionReporters集合中，并抛出 IllegalStateException 异常。</span></span><br><span class=\"line\">   <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">      handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当容器刷新完毕等，触发SpringApplicationRunListeners数组的running方法</span></span><br><span class=\"line\">      listeners.running(context);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 若上面的方法抛出异常，将异常添加到exceptionReporters集合中，并抛出 IllegalStateException 异常。</span></span><br><span class=\"line\">      handleRunFailure(context, ex, exceptionReporters, <span class=\"literal\">null</span>);</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"怎么让Spring把Body变成一个对象\"><a href=\"#怎么让Spring把Body变成一个对象\" class=\"headerlink\" title=\"怎么让Spring把Body变成一个对象\"></a>怎么让Spring把Body变成一个对象</h2><ul>\n<li>@RequestBody注解原理</li>\n<li>详细看springmvc的处理流程</li>\n</ul>\n<h2 id=\"SpringBoot的starter实现原理是什么？\"><a href=\"#SpringBoot的starter实现原理是什么？\" class=\"headerlink\" title=\"SpringBoot的starter实现原理是什么？\"></a>SpringBoot的starter实现原理是什么？</h2><p>原理就是因为在@EnableAutoConfiguration注解，会自动的扫描jar包下的META-INF&#x2F;spring.factories文件的配置类，写在这里面的类都是需要被自动加载的</p>\n<p>将configuration类中定义的bean加入spring到容器中。就相当于加载之前我们自己配置组件的xml文件。而现在SpringBoot自己定义了一个默认的值，然后直接加载进入了Spring容器。</p>\n<p>SpringBoot提供的自动配置依赖模块都以spring-boot-starter-为命名前缀，并且这些依赖都在org.springframework.boot下。 所有的spring-boot-starter都有约定俗成的默认配置，但允许调整这些配置调整默认的行为。</p>\n<h2 id=\"spring-和springboot的区别\"><a href=\"#spring-和springboot的区别\" class=\"headerlink\" title=\"spring 和springboot的区别\"></a>spring 和springboot的区别</h2><p>Spring Boot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，为更快，更高效的开发生态系统铺平了道路。</p>\n<p>Spring Boot中的一些特征：</p>\n<ul>\n<li>创建独立的Spring应用。</li>\n<li>嵌入式Tomcat、Jetty、 Undertow容器（无需部署war文件）。</li>\n<li>提供的starters 简化构建配置</li>\n<li>尽可能自动配置spring应用。</li>\n<li>提供生产指标,例如指标、健壮检查和外部化配置</li>\n<li>完全没有代码生成和XML配置要求</li>\n</ul>\n<p>Maven依赖</p>\n<p>首先，让我们看一下使用Spring创建Web应用程序所需的最小依赖项</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-webmvc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>与Spring不同，Spring Boot只需要一个依赖项来启动和运行Web应用程序：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.6.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在进行构建期间，所有其他依赖项将自动添加到项目中。</p>\n<p>另一个很好的例子就是测试库。我们通常使用Spring Test，JUnit，Hamcrest和Mockito库。在Spring项目中，我们应该将所有这些库添加为依赖项。但是在Spring Boot中，我们只需要添加spring-boot-starter-test依赖项来自动包含这些库。</p>\n<p>spring在运行前需要使用xml文件做很多配置，而springboot帮我们实现了这些配置的自动加载，基于注解和简单的yml配置即可</p>\n<p>spring的web程序还是打包为war然后再Tomcat里运行，而springboot内嵌了Tomcat直接打成可运行的jar</p>\n<h2 id=\"Spring-Boot-可执行-Jar-包运行原理\"><a href=\"#Spring-Boot-可执行-Jar-包运行原理\" class=\"headerlink\" title=\"Spring Boot 可执行 Jar 包运行原理\"></a>Spring Boot 可执行 Jar 包运行原理</h2><p>Spring Boot 有一个很方便的功能就是可以将应用打成可执行的 Jar。那么大家有没想过这个 Jar 是怎么运行起来的呢？本篇博客就来介绍下 Spring Boot 可执行 Jar 包的运行原理。</p>\n<h3 id=\"打可执行-Jar-包\"><a href=\"#打可执行-Jar-包\" class=\"headerlink\" title=\"打可执行 Jar 包\"></a>打可执行 Jar 包</h3><p>将 Spring Boot 应用打成可执行 Jar包很容易，只需要在 pom 中加上一个 Spring Boot 提供的插件，然后在执行mvn package即可</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>运行完mvn package后，我们会在 target 目录下看到两个 jar 文件。myproject-0.0.1-SNAPSHOT.jar 和 myproject-0.0.1-SNAPSHOT.jar.original。第一个 jar 文件就是我们应用的可执行 jar 包，第二个 Jar 文件是应用原始的 jar 包。</p>\n<h3 id=\"可执行-Jar-包内部结构\"><a href=\"#可执行-Jar-包内部结构\" class=\"headerlink\" title=\"可执行 Jar 包内部结构\"></a>可执行 Jar 包内部结构</h3><figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">可执行 jar 目录结构</span><br><span class=\"line\">├─BOOT-INF</span><br><span class=\"line\">│  ├─classes</span><br><span class=\"line\">│  └─lib</span><br><span class=\"line\">├─META-INF</span><br><span class=\"line\">│  ├─maven</span><br><span class=\"line\">│  ├─app.properties</span><br><span class=\"line\">│  ├─MANIFEST.MF      </span><br><span class=\"line\">└─org</span><br><span class=\"line\">    └─springframework</span><br><span class=\"line\">        └─boot</span><br><span class=\"line\">            └─loader</span><br><span class=\"line\">                ├─archive</span><br><span class=\"line\">                ├─data</span><br><span class=\"line\">                ├─jar</span><br><span class=\"line\">                └─util</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们先来重点关注两个地方：META-INF 下面的 Jar 包描述文件和 BOOT-INF 这个目录。</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Manifest-Version</span>: <span class=\"string\">1.0</span></span><br><span class=\"line\"><span class=\"attr\">Archiver-Version</span>: <span class=\"string\">Plexus Archiver</span></span><br><span class=\"line\"><span class=\"attr\">Built-By</span>: <span class=\"string\">xxxx</span></span><br><span class=\"line\"><span class=\"attr\">Start-Class</span>: <span class=\"string\">com.xxxx.AppServer</span></span><br><span class=\"line\"><span class=\"attr\">Spring-Boot-Classes</span>: <span class=\"string\">BOOT-INF/classes/</span></span><br><span class=\"line\"><span class=\"attr\">Spring-Boot-Lib</span>: <span class=\"string\">BOOT-INF/lib/</span></span><br><span class=\"line\"><span class=\"attr\">Spring-Boot-Version</span>: <span class=\"string\">2.1.6.RELEASE</span></span><br><span class=\"line\"><span class=\"attr\">Created-By</span>: <span class=\"string\">Apache Maven 3.3.9</span></span><br><span class=\"line\"><span class=\"attr\">Build-Jdk</span>: <span class=\"string\">1.8.0_73</span></span><br><span class=\"line\"><span class=\"attr\">Main-Class</span>: <span class=\"string\">org.springframework.boot.loader.JarLauncher</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在上面我们看到一个熟悉的配置Main-Class: org.springframework.boot.loader.JarLauncher。我们大概能猜到这个类是整个系统的入口。</p>\n<p>再看下 BOOT-INF 这个目录下面，我们会发现里面是我们项目打出来的 class 文件和项目依赖的 Jar 包。看到这里，你可能已经猜到 Spring Boot 是怎么启动项目的了。</p>\n<h3 id=\"JarLauncher\"><a href=\"#JarLauncher\" class=\"headerlink\" title=\"JarLauncher\"></a>JarLauncher</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JarLauncher</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ExecutableArchiveLauncher</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BOOT_INF_CLASSES</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;BOOT-INF/classes/&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">BOOT_INF_LIB</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;BOOT-INF/lib/&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">JarLauncher</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"title function_\">JarLauncher</span><span class=\"params\">(Archive archive)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">super</span>(archive);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isNestedArchive</span><span class=\"params\">(Archive.Entry entry)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (entry.isDirectory()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> entry.getName().equals(BOOT_INF_CLASSES);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> entry.getName().startsWith(BOOT_INF_LIB);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">//项目入口，重点在launch这个方法中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> <span class=\"title class_\">JarLauncher</span>().launch(args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//launch方法</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">launch</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    JarFile.registerUrlProtocolHandler();</span><br><span class=\"line\">    <span class=\"comment\">//创建LaunchedURLClassLoader。如果根类加载器和扩展类加载器没有加载到某个类的话，就会通过LaunchedURLClassLoader这个加载器来加载类。这个加载器会从Boot-INF下面的class目录和lib目录下加载类。</span></span><br><span class=\"line\">    <span class=\"type\">ClassLoader</span> <span class=\"variable\">classLoader</span> <span class=\"operator\">=</span> createClassLoader(getClassPathArchives());</span><br><span class=\"line\">    <span class=\"comment\">//这个方法会读取jar描述文件中的Start-Class属性，然后通过反射调用到这个类的main方法。</span></span><br><span class=\"line\">    launch(args, getMainClass(), classLoader);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>简单总结</p>\n<ul>\n<li>Spring Boot 可执行 Jar 包的入口点是 JarLauncher 的 main 方法；</li>\n<li>这个方法的执行逻辑是先创建一个 LaunchedURLClassLoader，这个加载器加载类的逻辑是：先判断根类加载器和扩展类加载器能否加载到某个类，如果都加载不到就从 Boot-INF 下面的 class 和 lib 目录下去加载；</li>\n<li>读取Start-Class属性，通过反射机制调用启动类的 main 方法，这样就顺利调用到我们开发的 Spring Boot 主启动类的 main 方法了。</li>\n</ul>\n"},{"title":"Springmvc最热点面试题","date":"2024-05-26T14:54:57.000Z","_content":"\n\n\n\n## 流程\n![流程图](./2024/05/26/Springmvc最热点面试题/1.png)\n## 执行流程\n1. **用户发送请求至前端控制器DispatcherServlet**\n    1. DispatcherServlet：前端控制器。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性,系统扩展性提高。由框架实现\n    2. doService doDispatch(request, response);\n2. **DispatcherServlet收到请求调用处理器映射器HandlerMapping**\n    1. HandlerMapping：处理器映射器。HandlerMapping负责根据用户请求的url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，根据一定的规则去查找,例如：xml配置方式，实现接口方式，注解方式等。由框架实现\n3. **处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet**\n4. **DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作**\n    1. Handler：处理器。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。\n    2. 将http报文转换为对象\n        1. HttpMessageConverter接口\n            1. `canRead` http->object\n            2. `canWrite` 对象的序列化输出\n        2. HttpMessageConverter有很多的实现类，根据HTTP协议的Accept和Content-Type属性，以及参数数据类型来判别使用哪一种HttpMessageConverter\n5. **执行处理器Handler(Controller，也叫页面控制器)**\n6. **Handler执行完成返回ModelAndView**\n7. **HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet**\n    1. HandlAdapter：处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。由框架实现。\n8. **DispatcherServlet将ModelAndView传给ViewReslover视图解析器**\n    1. ModelAndView是springmvc的封装对象，将model和view封装在一起\n9. **ViewReslover解析后返回具体View**\n    1. ViewResolver：视图解析器。ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户\n10. **DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）**\n    1. View:是springmvc的封装对象，是一个接口, springmvc框架提供了很多的View视图类型，包括：jspview，pdfview,jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。\n11. **DispatcherServlet响应用户**","source":"_posts/Springmvc最热点面试题.md","raw":"---\ntitle: Springmvc最热点面试题\ndate: 2024-05-26 22:54:57\ntags: springmvc\ncategories: 面试\n---\n\n\n\n\n## 流程\n![流程图](./2024/05/26/Springmvc最热点面试题/1.png)\n## 执行流程\n1. **用户发送请求至前端控制器DispatcherServlet**\n    1. DispatcherServlet：前端控制器。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性,系统扩展性提高。由框架实现\n    2. doService doDispatch(request, response);\n2. **DispatcherServlet收到请求调用处理器映射器HandlerMapping**\n    1. HandlerMapping：处理器映射器。HandlerMapping负责根据用户请求的url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，根据一定的规则去查找,例如：xml配置方式，实现接口方式，注解方式等。由框架实现\n3. **处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet**\n4. **DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作**\n    1. Handler：处理器。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。\n    2. 将http报文转换为对象\n        1. HttpMessageConverter接口\n            1. `canRead` http->object\n            2. `canWrite` 对象的序列化输出\n        2. HttpMessageConverter有很多的实现类，根据HTTP协议的Accept和Content-Type属性，以及参数数据类型来判别使用哪一种HttpMessageConverter\n5. **执行处理器Handler(Controller，也叫页面控制器)**\n6. **Handler执行完成返回ModelAndView**\n7. **HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet**\n    1. HandlAdapter：处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。由框架实现。\n8. **DispatcherServlet将ModelAndView传给ViewReslover视图解析器**\n    1. ModelAndView是springmvc的封装对象，将model和view封装在一起\n9. **ViewReslover解析后返回具体View**\n    1. ViewResolver：视图解析器。ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户\n10. **DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）**\n    1. View:是springmvc的封装对象，是一个接口, springmvc框架提供了很多的View视图类型，包括：jspview，pdfview,jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。\n11. **DispatcherServlet响应用户**","slug":"Springmvc最热点面试题","published":1,"updated":"2024-05-26T14:56:36.694Z","comments":1,"layout":"post","photos":[],"_id":"clwxc4r9t0007b4uh4vrvcr3g","content":"<h2 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h2><p><img src=\"/./2024/05/26/Springmvc%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/1.png\" alt=\"流程图\"></p>\n<h2 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h2><ol>\n<li><strong>用户发送请求至前端控制器DispatcherServlet</strong><ol>\n<li>DispatcherServlet：前端控制器。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性,系统扩展性提高。由框架实现</li>\n<li>doService doDispatch(request, response);</li>\n</ol>\n</li>\n<li><strong>DispatcherServlet收到请求调用处理器映射器HandlerMapping</strong><ol>\n<li>HandlerMapping：处理器映射器。HandlerMapping负责根据用户请求的url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，根据一定的规则去查找,例如：xml配置方式，实现接口方式，注解方式等。由框架实现</li>\n</ol>\n</li>\n<li><strong>处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet</strong></li>\n<li><strong>DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作</strong><ol>\n<li>Handler：处理器。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</li>\n<li>将http报文转换为对象<ol>\n<li>HttpMessageConverter接口<ol>\n<li><code>canRead</code> http-&gt;object</li>\n<li><code>canWrite</code> 对象的序列化输出</li>\n</ol>\n</li>\n<li>HttpMessageConverter有很多的实现类，根据HTTP协议的Accept和Content-Type属性，以及参数数据类型来判别使用哪一种HttpMessageConverter</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><strong>执行处理器Handler(Controller，也叫页面控制器)</strong></li>\n<li><strong>Handler执行完成返回ModelAndView</strong></li>\n<li><strong>HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet</strong><ol>\n<li>HandlAdapter：处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。由框架实现。</li>\n</ol>\n</li>\n<li><strong>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</strong><ol>\n<li>ModelAndView是springmvc的封装对象，将model和view封装在一起</li>\n</ol>\n</li>\n<li><strong>ViewReslover解析后返回具体View</strong><ol>\n<li>ViewResolver：视图解析器。ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户</li>\n</ol>\n</li>\n<li><strong>DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）</strong><ol>\n<li>View:是springmvc的封装对象，是一个接口, springmvc框架提供了很多的View视图类型，包括：jspview，pdfview,jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</li>\n</ol>\n</li>\n<li><strong>DispatcherServlet响应用户</strong></li>\n</ol>\n","cover":"/img/hubian.png","cover_type":"img","excerpt":"","more":"<h2 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h2><p><img src=\"/./2024/05/26/Springmvc%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/1.png\" alt=\"流程图\"></p>\n<h2 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h2><ol>\n<li><strong>用户发送请求至前端控制器DispatcherServlet</strong><ol>\n<li>DispatcherServlet：前端控制器。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性,系统扩展性提高。由框架实现</li>\n<li>doService doDispatch(request, response);</li>\n</ol>\n</li>\n<li><strong>DispatcherServlet收到请求调用处理器映射器HandlerMapping</strong><ol>\n<li>HandlerMapping：处理器映射器。HandlerMapping负责根据用户请求的url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，根据一定的规则去查找,例如：xml配置方式，实现接口方式，注解方式等。由框架实现</li>\n</ol>\n</li>\n<li><strong>处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet</strong></li>\n<li><strong>DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作</strong><ol>\n<li>Handler：处理器。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</li>\n<li>将http报文转换为对象<ol>\n<li>HttpMessageConverter接口<ol>\n<li><code>canRead</code> http-&gt;object</li>\n<li><code>canWrite</code> 对象的序列化输出</li>\n</ol>\n</li>\n<li>HttpMessageConverter有很多的实现类，根据HTTP协议的Accept和Content-Type属性，以及参数数据类型来判别使用哪一种HttpMessageConverter</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><strong>执行处理器Handler(Controller，也叫页面控制器)</strong></li>\n<li><strong>Handler执行完成返回ModelAndView</strong></li>\n<li><strong>HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet</strong><ol>\n<li>HandlAdapter：处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。由框架实现。</li>\n</ol>\n</li>\n<li><strong>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</strong><ol>\n<li>ModelAndView是springmvc的封装对象，将model和view封装在一起</li>\n</ol>\n</li>\n<li><strong>ViewReslover解析后返回具体View</strong><ol>\n<li>ViewResolver：视图解析器。ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户</li>\n</ol>\n</li>\n<li><strong>DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）</strong><ol>\n<li>View:是springmvc的封装对象，是一个接口, springmvc框架提供了很多的View视图类型，包括：jspview，pdfview,jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</li>\n</ol>\n</li>\n<li><strong>DispatcherServlet响应用户</strong></li>\n</ol>\n"},{"title":"Springcloud最热点面试题","date":"2024-05-26T14:57:29.000Z","_content":"\n\n\nSpring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。\n\nSpring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。\n## 服务注册与发现\n### eureka\n服务治理组件，包括服务端的注册中心和客户端的服务发现机制；\n### consul\n基于Hashicorp Consul的服务治理组件。\n## 服务负载与均衡\n### ribbon\n负载均衡的服务调用组件，具有多种负载均衡调用策略；\n### loadbalancer\n## 服务负载与调用\n### feign\n基于Ribbon和Hystrix的声明式服务调用组件；\n### openFeign\n基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。\n## 服务熔断与降级\n### hystrix\n服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；\n### resilience4j\n## 服务网关\n### zuul\nAPI网关组件，对请求提供路由及过滤功能。\n### zuul2\n### getway\nAPI网关组件，对请求提供路由及过滤功能。\n## 服务分布式配置\n### springcloud config\n集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。\n### Nacos\n## 总线\n### Spring Cloud Bus\n用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。\n# springcloudAlibaba\n## Nacos\nNacos 是一个开源的分布式系统服务发现、配置管理和服务管理平台。它主要包含以下功能：\n\n服务发现与注册：Nacos 可以管理服务的注册和发现，支持 DNS 和 HTTP/RESTful 方式。\n配置管理：Nacos 可以动态管理配置，支持多种数据类型和版本控制。\n服务管理：Nacos 可以对服务进行健康检查、流量管理、负载均衡等。\n### 服务发现与注册\nNacos 实现服务发现和注册的核心代码位于 nacos/naming 目录下，包括以下文件：\n\n- naming-common/src/main/java/com/alibaba/nacos/api/naming: 定义了服务发现和注册的 API 接口和数据模型。\n- naming-core/src/main/java/com/alibaba/nacos/naming: 实现了服务发现和注册的核心逻辑。\n- naming-impl/src/main/java/com/alibaba/nacos/naming: 实现了服务发现和注册的具体实现。\n\n下面简单介绍一下 Nacos 的服务发现和注册的实现流程。\n\n#### 服务注册流程\n服务提供者向 Nacos 注册服务时，会调用 NamingService.registerInstance() 方法，该方法会做以下几件事情：\n\n1. 将服务实例的元数据封装为 Instance 对象，包括服务名、IP、端口号、健康状态、元数据等。\n2. 将 Instance 对象转换为 InstanceEntity 对象，包含了实例 ID 和实例元数据的 JSON 字符串。\n3. 将 InstanceEntity 对象存储到 Nacos 中，可以存储到内存中或者持久化到磁盘中。\n\n#### 服务发现流程\n服务消费者向 Nacos 发现服务时，会调用 NamingService.getAllInstances() 或 NamingService.selectInstances() 方法，该方法会做以下几件事情：\n\n1. 从 Nacos 中获取服务实例的元数据，包括服务名、IP、端口号、健康状态、元数据等。\n2. 将元数据封装为 Instance 对象，存储到本地缓存中。\n3. 根据负载均衡算法选择一个服务实例处理请求，可以选择轮询、随机、权重等算法。\n\n服务发现和注册的核心逻辑在 naming-core 目录下的 com.alibaba.nacos.naming 包中实现，主要包括以下类：\n\n- com.alibaba.nacos.naming.core.InstancesManager: 维护服务实例的元数据和状态信息。\n- com.alibaba.nacos.naming.core.Cluster: 维护一个服务的所有实例信息和负载均衡策略。\n- com.alibaba.nacos.naming.core.InstanceOperator: 实现了服务实例的注册、注销和更新操作。\n- com.alibaba.nacos.naming.core.DomainsManager: 维护多个服务的信息，包括服务名、集群名、命名空间等。\n\n服务发现和注册的具体实现在 naming-impl 目录下的 com.alibaba.nacos.naming 包中，主要包括以下类：\n\n- com.alibaba.nacos.naming.push.PushService: 实现了服务实例的推送功能。\n- com.alibaba.nacos.naming.healthcheck.HealthCheckProcessor: 实现了服务实例的健康检查功能。\n- com.alibaba.nacos.naming.misc.GlobalConfig: 存储了一些全局配置，例如默认权重值、心跳间隔\n\n### 配置动态刷新\n\n从远端服务器获取变更数据的主要模式有两种：推（push）和拉（pull）。Push 模式简单来说就是服务端主动将数据变更信息推送给客户端，这种模式优点是时效性好，服务端数据发生变更可以立马通知到客户端，但这种模式需要服务端维持与客户端的心跳连接，会增加服务端实现的复杂度，服务端也需要占用更多的资源来维持与客户端的连接。\n\n而 Pull 模式则是客户端主动去服务器请求数据，例如，每间隔10ms就向服务端发起请求获取数据。显而易见pull模式存在时效性问题。请求的间隔也不太好设置，间隔太短，对服务器请求压力过大。间隔时间过长，那么必然会造成时效性很差。而且如果配置长时间不更新，并且存在大量的客户端就会产生大量无效的pull请求。\n\nNacos 没有采用上述的两种模式，而是采用了长轮询方式结合了推和拉的优点：\n\n![动态刷新图](./2024/05/26/Springcloud最热点面试题/1.png)\n\n长轮询也是轮询，因此 Nacos 客户端会默认每10ms向服务端发起请求，当客户端请求服务端时会在请求头上携带长轮询的超时时间，默认是30s。而服务端接收到该请求时会hang住请求，为了防止客户端超时会在请求头携带的超时时间上减去500ms，因此默认会hang住请求29.5s。在这期间如果服务端发生了配置变更会产生相应的事件，监听到该事件后，会响应对应的客户端。这样一来客户端不会频繁发起轮询请求，而服务端也不需要维持与客户端的心跳，兼备了时效性和复杂度。\n\n![长轮询图](./2024/05/26/Springcloud最热点面试题/2.png)\n\n\n> 1.4版本nacos使用Http短连接+长轮询的方式，客户端发起http请求，服务端hold住请求，当配置变更时响应客户端，超时时间30s。\n> 2.0版本nacos用gRPC长连接代替了http短连接长轮询。配置同步采用推拉结合的方式。\n\n#### Nacos Config 长轮询源码剖析\n首先，打开 com.alibaba.cloud.nacos.NacosConfigBootstrapConfiguration 这个类，从类名也可以看出该类是Nacos Config的启动配置类，是Nacos Config自动装配的入口。在该类中的 nacosConfigManager 方法实例化了一个 NacosConfigManager 对象，并注册到容器中：\n\n```java\n@Bean\n@ConditionalOnMissingBean\npublic NacosConfigManager nacosConfigManager(\n\t\tNacosConfigProperties nacosConfigProperties) {\n\treturn new NacosConfigManager(nacosConfigProperties);\n}\n```\n在 NacosConfigManager 的构造器中调用了 createConfigService 方法，这是一个静态方法用来创建 ConfigService 对象的单例。\n```java\n/**\n * Compatible with old design,It will be perfected in the future.\n */\nstatic ConfigService createConfigService(\n\t\tNacosConfigProperties nacosConfigProperties) {\n    // 双重检查锁模式的单例\n\tif (Objects.isNull(service)) {\n\t\tsynchronized (NacosConfigManager.class) {\n\t\t\ttry {\n\t\t\t\tif (Objects.isNull(service)) {\n\t\t\t\t\tservice = NacosFactory.createConfigService(\n\t\t\t\t\t\t\tnacosConfigProperties.assembleConfigServiceProperties());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NacosException e) {\n\t\t\t\tlog.error(e.getMessage());\n\t\t\t\tthrow new NacosConnectionFailureException(\n\t\t\t\t\t\tnacosConfigProperties.getServerAddr(), e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}\n\treturn service;\n}\n```\nConfigService 的具体实现是 NacosConfigService，在该类的构造器中主要初始化了 HttpAgent 和 ClientWorker 对象。ClientWorker 的构造器中则初始化了几个线程池：\n\n```java\npublic ClientWorker(final HttpAgent agent, final ConfigFilterChainManager configFilterChainManager,\n        final Properties properties) {\n    this.agent = agent;\n    this.configFilterChainManager = configFilterChainManager;\n    \n    // Initialize the timeout parameter\n    init(properties);\n    \n    // 创建具有定时执行功能的单线程池，用于定时执行 checkConfigInfo 方法\n    this.executor = Executors.newScheduledThreadPool(1, new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n            Thread t = new Thread(r);\n            t.setName(\"com.alibaba.nacos.client.Worker.\" + agent.getName());\n            t.setDaemon(true);\n            return t;\n        }\n    });\n    \n    // 创建具有定时执行功能的且线程数与cpu核数相对应的线程池，用于根据需要动态刷新的配置文件执行 LongPollingRunnable，因此长轮询任务是可以有多个并行的\n    this.executorService = Executors\n            .newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), new ThreadFactory() {\n                @Override\n                public Thread newThread(Runnable r) {\n                    Thread t = new Thread(r);\n                    t.setName(\"com.alibaba.nacos.client.Worker.longPolling.\" + agent.getName());\n                    t.setDaemon(true);\n                    return t;\n                }\n            });\n            \n    // 每10ms执行一次 checkConfigInfo 方法\n    this.executor.scheduleWithFixedDelay(new Runnable() {\n        @Override\n        public void run() {\n            try {\n                checkConfigInfo();\n            } catch (Throwable e) {\n                LOGGER.error(\"[\" + agent.getName() + \"] [sub-check] rotate check error\", e);\n            }\n        }\n    }, 1L, 10L, TimeUnit.MILLISECONDS);\n}\n\nprivate void init(Properties properties) {\n    // 长轮询的超时时间，默认为30秒，此参数会被放到请求头中带到服务端，服务端会根据该参数去做长轮询的hold\n    timeout = Math.max(ConvertUtils.toInt(properties.getProperty(PropertyKeyConst.CONFIG_LONG_POLL_TIMEOUT),\n            Constants.CONFIG_LONG_POLL_TIMEOUT), Constants.MIN_CONFIG_LONG_POLL_TIMEOUT);\n    \n    taskPenaltyTime = ConvertUtils\n            .toInt(properties.getProperty(PropertyKeyConst.CONFIG_RETRY_TIME), Constants.CONFIG_RETRY_TIME);\n    \n    this.enableRemoteSyncConfig = Boolean\n            .parseBoolean(properties.getProperty(PropertyKeyConst.ENABLE_REMOTE_SYNC_CONFIG));\n}\n\n/**\n * Check config info.\n */\npublic void checkConfigInfo() {\n    // Dispatch taskes.\n    // 获取需要监听的文件数量\n    int listenerSize = cacheMap.size();\n    // Round up the longingTaskCount.\n    // 默认一个 LongPollingRunnable 可以处理监听3k个配置文件的变化，超过3k个才会创建新的 LongPollingRunnable\n    int longingTaskCount = (int) Math.ceil(listenerSize / ParamUtil.getPerTaskConfigSize());\n    if (longingTaskCount > currentLongingTaskCount) {\n        for (int i = (int) currentLongingTaskCount; i < longingTaskCount; i++) {\n            // The task list is no order.So it maybe has issues when changing.\n            executorService.execute(new LongPollingRunnable(i));\n        }\n        currentLongingTaskCount = longingTaskCount;\n    }\n}\n```\nLongPollingRunnable 类主要用于检查本地配置，以及长轮询地去服务端获取变更配置的 dataid 和 group，其代码位于 com.alibaba.nacos.client.config.impl.ClientWorker 类，代码如下：\n```java\nclass LongPollingRunnable implements Runnable {\n    \n    private final int taskId;\n    \n    public LongPollingRunnable(int taskId) {\n        this.taskId = taskId;\n    }\n    \n    @Override\n    public void run() {\n        \n        List<CacheData> cacheDatas = new ArrayList<CacheData>();\n        List<String> inInitializingCacheList = new ArrayList<String>();\n        try {\n            // check failover config\n            // 遍历本地缓存的配置\n            for (CacheData cacheData : cacheMap.values()) {\n                if (cacheData.getTaskId() == taskId) {\n                    cacheDatas.add(cacheData);\n                    try {\n                        // 检查本地配置\n                        checkLocalConfig(cacheData);\n                        if (cacheData.isUseLocalConfigInfo()) {\n                            cacheData.checkListenerMd5();\n                        }\n                    } catch (Exception e) {\n                        LOGGER.error(\"get local config info error\", e);\n                    }\n                }\n            }\n            \n            // check server config\n            // 通过长轮询检查服务端配置\n            List<String> changedGroupKeys = checkUpdateDataIds(cacheDatas, inInitializingCacheList);\n            if (!CollectionUtils.isEmpty(changedGroupKeys)) {\n                LOGGER.info(\"get changedGroupKeys:\" + changedGroupKeys);\n            }\n            \n            for (String groupKey : changedGroupKeys) {\n                String[] key = GroupKey.parseKey(groupKey);\n                String dataId = key[0];\n                String group = key[1];\n                String tenant = null;\n                if (key.length == 3) {\n                    tenant = key[2];\n                }\n                try {\n                    String[] ct = getServerConfig(dataId, group, tenant, 3000L);\n                    CacheData cache = cacheMap.get(GroupKey.getKeyTenant(dataId, group, tenant));\n                    cache.setContent(ct[0]);\n                    if (null != ct[1]) {\n                        cache.setType(ct[1]);\n                    }\n                    LOGGER.info(\"[{}] [data-received] dataId={}, group={}, tenant={}, md5={}, content={}, type={}\",\n                            agent.getName(), dataId, group, tenant, cache.getMd5(),\n                            ContentUtils.truncateContent(ct[0]), ct[1]);\n                } catch (NacosException ioe) {\n                    String message = String\n                            .format(\"[%s] [get-update] get changed config exception. dataId=%s, group=%s, tenant=%s\",\n                                    agent.getName(), dataId, group, tenant);\n                    LOGGER.error(message, ioe);\n                }\n            }\n            for (CacheData cacheData : cacheDatas) {\n                if (!cacheData.isInitializing() || inInitializingCacheList\n                        .contains(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant))) {\n                    cacheData.checkListenerMd5();\n                    cacheData.setInitializing(false);\n                }\n            }\n            inInitializingCacheList.clear();\n            \n            executorService.execute(this);\n            \n        } catch (Throwable e) {\n            \n            // If the rotation training task is abnormal, the next execution time of the task will be punished\n            LOGGER.error(\"longPolling error : \", e);\n            executorService.schedule(this, taskPenaltyTime, TimeUnit.MILLISECONDS);\n        }\n    }\n}\n```\n上面有个 checkUpdateDataIds 方法，用于获取发生变更了的配置文件的dataId列表，它同样位于 ClientWorker 内。如下：\n```java\n/**\n * Fetch the dataId list from server.\n *\n * @param cacheDatas              CacheDatas for config infomations.\n * @param inInitializingCacheList initial cache lists.\n * @return String include dataId and group (ps: it maybe null).\n * @throws Exception Exception.\n */\nList<String> checkUpdateDataIds(List<CacheData> cacheDatas, List<String> inInitializingCacheList) throws Exception {\n    // 拼接出配置文件的唯一标识\n    StringBuilder sb = new StringBuilder();\n    for (CacheData cacheData : cacheDatas) {\n        if (!cacheData.isUseLocalConfigInfo()) {\n            sb.append(cacheData.dataId).append(WORD_SEPARATOR);\n            sb.append(cacheData.group).append(WORD_SEPARATOR);\n            if (StringUtils.isBlank(cacheData.tenant)) {\n                sb.append(cacheData.getMd5()).append(LINE_SEPARATOR);\n            } else {\n                sb.append(cacheData.getMd5()).append(WORD_SEPARATOR);\n                sb.append(cacheData.getTenant()).append(LINE_SEPARATOR);\n            }\n            if (cacheData.isInitializing()) {\n                // It updates when cacheData occours in cacheMap by first time.\n                inInitializingCacheList\n                        .add(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant));\n            }\n        }\n    }\n    boolean isInitializingCacheList = !inInitializingCacheList.isEmpty();\n    return checkUpdateConfigStr(sb.toString(), isInitializingCacheList);\n}\n\n/**\n * Fetch the updated dataId list from server.\n *\n * @param probeUpdateString       updated attribute string value.\n * @param isInitializingCacheList initial cache lists.\n * @return The updated dataId list(ps: it maybe null).\n * @throws IOException Exception.\n */\nList<String> checkUpdateConfigStr(String probeUpdateString, boolean isInitializingCacheList) throws Exception {\n    \n    Map<String, String> params = new HashMap<String, String>(2);\n    params.put(Constants.PROBE_MODIFY_REQUEST, probeUpdateString);\n    Map<String, String> headers = new HashMap<String, String>(2);\n    // 长轮询的超时时间\n    headers.put(\"Long-Pulling-Timeout\", \"\" + timeout);\n    \n    // told server do not hang me up if new initializing cacheData added in\n    if (isInitializingCacheList) {\n        headers.put(\"Long-Pulling-Timeout-No-Hangup\", \"true\");\n    }\n    \n    if (StringUtils.isBlank(probeUpdateString)) {\n        return Collections.emptyList();\n    }\n    \n    try {\n        // In order to prevent the server from handling the delay of the client's long task,\n        // increase the client's read timeout to avoid this problem.\n        \n        long readTimeoutMs = timeout + (long) Math.round(timeout >> 1);\n        // 向服务端发起一个http请求，该请求在服务端配置没有变更的情况下默认会hang住30s\n        HttpRestResult<String> result = agent\n                .httpPost(Constants.CONFIG_CONTROLLER_PATH + \"/listener\", headers, params, agent.getEncode(),\n                        readTimeoutMs);\n        \n        if (result.ok()) {\n            setHealthServer(true);\n            // 响应状态是成功则解析响应体得到 dataId、group、tenant 等信息并返回\n            return parseUpdateDataIdResponse(result.getData());\n        } else {\n            setHealthServer(false);\n            LOGGER.error(\"[{}] [check-update] get changed dataId error, code: {}\", agent.getName(),\n                    result.getCode());\n        }\n    } catch (Exception e) {\n        setHealthServer(false);\n        LOGGER.error(\"[\" + agent.getName() + \"] [check-update] get changed dataId exception\", e);\n        throw e;\n    }\n    return Collections.emptyList();\n}\n```\n客户端对 listener 接口的请求会进入到服务端的 com.alibaba.nacos.config.server.controller.ConfigController#listener 方法进行处理，该方法主要是调用了 com.alibaba.nacos.config.server.controller.ConfigServletInner#doPollingConfig 方法。代码如下：\n```java\n/**\n * 轮询接口\n */\npublic String doPollingConfig(HttpServletRequest request, HttpServletResponse response,\n                              Map<String, String> clientMd5Map, int probeRequestSize)\n    throws IOException, ServletException {\n\n    // 如果支持长轮询则进入长轮询的流程\n    if (LongPollingService.isSupportLongPolling(request)) {\n        longPollingService.addLongPollingClient(request, response, clientMd5Map, probeRequestSize);\n        return HttpServletResponse.SC_OK + \"\";\n    }\n\n    // else 兼容短轮询逻辑\n    List<String> changedGroups = MD5Util.compareMd5(request, response, clientMd5Map);\n\n    // 兼容短轮询result\n    String oldResult = MD5Util.compareMd5OldResult(changedGroups);\n    String newResult = MD5Util.compareMd5ResultString(changedGroups);\n\n    String version = request.getHeader(Constants.CLIENT_VERSION_HEADER);\n    if (version == null) {\n        version = \"2.0.0\";\n    }\n    int versionNum = Protocol.getVersionNumber(version);\n\n    /**\n     * 2.0.4版本以前, 返回值放入header中\n     */\n    if (versionNum < START_LONGPOLLING_VERSION_NUM) {\n        response.addHeader(Constants.PROBE_MODIFY_RESPONSE, oldResult);\n        response.addHeader(Constants.PROBE_MODIFY_RESPONSE_NEW, newResult);\n    } else {\n        request.setAttribute(\"content\", newResult);\n    }\n\n    // 禁用缓存\n    response.setHeader(\"Pragma\", \"no-cache\");\n    response.setDateHeader(\"Expires\", 0);\n    response.setHeader(\"Cache-Control\", \"no-cache,no-store\");\n    response.setStatus(HttpServletResponse.SC_OK);\n    return HttpServletResponse.SC_OK + \"\";\n}\n```\n我们主要关注上面的 com.alibaba.nacos.config.server.service.LongPollingService#addLongPollingClient 长轮询流程的方法。代码如下：\n```java\npublic void addLongPollingClient(HttpServletRequest req, HttpServletResponse rsp, Map<String, String> clientMd5Map,\n                                 int probeRequestSize) {\n\n    String str = req.getHeader(LongPollingService.LONG_POLLING_HEADER);\n    String noHangUpFlag = req.getHeader(LongPollingService.LONG_POLLING_NO_HANG_UP_HEADER);\n    String appName = req.getHeader(RequestUtil.CLIENT_APPNAME_HEADER);\n    String tag = req.getHeader(\"Vipserver-Tag\");\n    int delayTime = SwitchService.getSwitchInteger(SwitchService.FIXED_DELAY_TIME, 500);\n    /**\n     * 提前500ms返回响应，为避免客户端超时 @qiaoyi.dingqy 2013.10.22改动  add delay time for LoadBalance\n     */\n    long timeout = Math.max(10000, Long.parseLong(str) - delayTime);\n    if (isFixedPolling()) {\n        timeout = Math.max(10000, getFixedPollingInterval());\n        // do nothing but set fix polling timeout\n    } else {\n        long start = System.currentTimeMillis();\n        List<String> changedGroups = MD5Util.compareMd5(req, rsp, clientMd5Map);\n        if (changedGroups.size() > 0) {\n            generateResponse(req, rsp, changedGroups);\n            LogUtil.clientLog.info(\"{}|{}|{}|{}|{}|{}|{}\",\n                System.currentTimeMillis() - start, \"instant\", RequestUtil.getRemoteIp(req), \"polling\",\n                clientMd5Map.size(), probeRequestSize, changedGroups.size());\n            return;\n        } else if (noHangUpFlag != null && noHangUpFlag.equalsIgnoreCase(TRUE_STR)) {\n            LogUtil.clientLog.info(\"{}|{}|{}|{}|{}|{}|{}\", System.currentTimeMillis() - start, \"nohangup\",\n                RequestUtil.getRemoteIp(req), \"polling\", clientMd5Map.size(), probeRequestSize,\n                changedGroups.size());\n            return;\n        }\n    }\n    String ip = RequestUtil.getRemoteIp(req);\n    // 一定要由HTTP线程调用，否则离开后容器会立即发送响应\n    final AsyncContext asyncContext = req.startAsync();\n    // AsyncContext.setTimeout()的超时时间不准，所以只能自己控制\n    asyncContext.setTimeout(0L);\n\t\n\t// 在 ClientLongPolling 的 run 方法会将 ClientLongPolling 实例（携带了本次请求的相关信息）放入 allSubs 中，然后会在29.5s后再执行另一个 Runnable，该 Runnable 用于等待29.5s后依旧没有相应的配置变更时对客户端进行响应，并将相应的 ClientLongPolling 实例从 allSubs 中移出\n    scheduler.execute(\n        new ClientLongPolling(asyncContext, clientMd5Map, ip, probeRequestSize, timeout, appName, tag));\n}\n```\n而 LongPollingService 实现了 AbstractEventListener，也就是说能接收事件通知，在其 com.alibaba.nacos.config.server.service.LongPollingService#onEvent 方法中可以看到，它关注的是 LocalDataChangeEvent 事件：\n```java\n@Override\npublic void onEvent(Event event) {\n    if (isFixedPolling()) {\n        // ignore\n    } else {\n        if (event instanceof LocalDataChangeEvent) {\n            LocalDataChangeEvent evt = (LocalDataChangeEvent)event;\n            scheduler.execute(new DataChangeTask(evt.groupKey, evt.isBeta, evt.betaIps));\n        }\n    }\n}\n```\n在nacos上修改配置后就会产生 LocalDataChangeEvent 事件，此时 LongPollingService 也就能监听到，当收到该事件时就会遍历 allSubs，找到匹配的请求并将 groupKey 返回给客户端。具体代码在 DataChangeTask 中：\n```java\nclass DataChangeTask implements Runnable {\n    @Override\n    public void run() {\n        try {\n            ConfigService.getContentBetaMd5(groupKey);\n            for (Iterator<ClientLongPolling> iter = allSubs.iterator(); iter.hasNext(); ) {\n                ClientLongPolling clientSub = iter.next();\n                if (clientSub.clientMd5Map.containsKey(groupKey)) {\n                    // 如果beta发布且不在beta列表直接跳过\n                    if (isBeta && !betaIps.contains(clientSub.ip)) {\n                        continue;\n                    }\n\n                    // 如果tag发布且不在tag列表直接跳过\n                    if (StringUtils.isNotBlank(tag) && !tag.equals(clientSub.tag)) {\n                        continue;\n                    }\n\n                    getRetainIps().put(clientSub.ip, System.currentTimeMillis());\n                    iter.remove(); // 删除订阅关系\n                    LogUtil.clientLog.info(\"{}|{}|{}|{}|{}|{}|{}\",\n                        (System.currentTimeMillis() - changeTime),\n                        \"in-advance\",\n                        RequestUtil.getRemoteIp((HttpServletRequest)clientSub.asyncContext.getRequest()),\n                        \"polling\",\n                        clientSub.clientMd5Map.size(), clientSub.probeRequestSize, groupKey);\n                    clientSub.sendResponse(Arrays.asList(groupKey));\n                }\n            }\n        } catch (Throwable t) {\n            LogUtil.defaultLog.error(\"data change error:\" + t.getMessage(), t.getCause());\n        }\n    }\n\n    DataChangeTask(String groupKey) {\n        this(groupKey, false, null);\n    }\n\n    DataChangeTask(String groupKey, boolean isBeta, List<String> betaIps) {\n        this(groupKey, isBeta, betaIps, null);\n    }\n\n    DataChangeTask(String groupKey, boolean isBeta, List<String> betaIps, String tag) {\n        this.groupKey = groupKey;\n        this.isBeta = isBeta;\n        this.betaIps = betaIps;\n        this.tag = tag;\n    }\n\n    final String groupKey;\n    final long changeTime = System.currentTimeMillis();\n    final boolean isBeta;\n    final List<String> betaIps;\n    final String tag;\n}\n```\n当客户端收到变更的dataid+group后，就会去服务端获取最新的配置数据，并更新本地数据 cacheData，然后发送数据变更事件，整个流程结束。\n\n- 获取服务端最新配置数据的方法：com.alibaba.nacos.client.config.impl.ClientWorker#getServerConfig\n- 发送数据变更事件的方法：com.alibaba.nacos.client.config.impl.CacheData#checkListenerMd5\n\n## Sentienl\nSentinel是阿里巴巴开源的一款流量控制和熔断降级框架，主要用于微服务架构中服务的流量控制和熔断降级。其限流实现原理主要分为两个部分：\n\n> 统计信息收集\n\nSentinel会在运行过程中对服务的各种统计信息进行收集，包括请求的响应时间、请求通过的QPS（每秒查询率）、线程池队列大小等指标。这些指标通过定义的规则进行分析，判断当前请求是否超过了设定的阈值。\n\n> 阈值判断\n\nSentinel根据收集到的统计信息，通过定义的规则对请求进行判断。规则中包括以下几个要素：\n\n资源名：对哪个资源进行限流\n流控模式：直接拒绝或者匀速通过\n流控阈值：单位时间内允许通过的请求个数\n统计时间窗口：多长时间内统计一次流量，单位秒\n降级处理：当请求超过阈值时的处理策略，如直接拒绝、返回默认值等\nSentinel会根据以上规则进行限流，当请求超过阈值时，根据设置的降级处理策略进行处理，比如直接拒绝请求、返回默认值等。同时，Sentinel还可以进行自适应的流控，根据实际情况调整阈值，保证服务的可用性和稳定性。\n\n### 工作原理\n#### Slot 插槽\n在 Sentinel 里面，所有的资源都对应一个资源名称（resourceName），每次资源调用都会创建一个 Entry 对象。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 SphU API 显式创建。Entry 创建的时候，同时也会创建一系列功能插槽（slot chain），这些插槽有不同的职责，例如:\n\n- NodeSelectorSlot 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；\n- ClusterBuilderSlot 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；\n- StatisticSlot 则用于记录、统计不同纬度的 runtime 指标监控信息；\n- FlowSlot 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；\n- AuthoritySlot 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；\n- DegradeSlot 则通过统计信息以及预设的规则，来做熔断降级；\n- SystemSlot 则通过系统的状态，例如 load1 等，来控制总的入口流量；\n\nSentinel 提供了插槽接口 ProcessorSlot，其中提供了方法 enrty 处理进入请求 和 exit 处理请求结束操作\n```java\npublic interface ProcessorSlot<T> {\n \n    /**\n     * Entrance of this slot.\n     *\n     * @param context         current {@link Context}\n     * @param resourceWrapper current resource\n     * @param param           generics parameter, usually is a {@link com.alibaba.csp.sentinel.node.Node}\n     * @param count           tokens needed\n     * @param prioritized     whether the entry is prioritized\n     * @param args            parameters of the original call\n     * @throws Throwable blocked exception or unexpected error\n     */\n    void entry(Context context, ResourceWrapper resourceWrapper, T param, int count, boolean prioritized,\n               Object... args) throws Throwable;\n \n    /**\n     * Means finish of {@link #entry(Context, ResourceWrapper, Object, int, boolean, Object...)}.\n     *\n     * @param context         current {@link Context}\n     * @param resourceWrapper current resource\n     * @param obj             relevant object (e.g. Node)\n     * @param count           tokens needed\n     * @param prioritized     whether the entry is prioritized\n     * @param args            parameters of the original call\n     * @throws Throwable blocked exception or unexpected error\n     */\n    void fireEntry(Context context, ResourceWrapper resourceWrapper, Object obj, int count, boolean prioritized,\n                   Object... args) throws Throwable;\n \n    /**\n     * Exit of this slot.\n     *\n     * @param context         current {@link Context}\n     * @param resourceWrapper current resource\n     * @param count           tokens needed\n     * @param args            parameters of the original call\n     */\n    void exit(Context context, ResourceWrapper resourceWrapper, int count, Object... args);\n \n    /**\n     * Means finish of {@link #exit(Context, ResourceWrapper, int, Object...)}.\n     *\n     * @param context         current {@link Context}\n     * @param resourceWrapper current resource\n     * @param count           tokens needed\n     * @param args            parameters of the original call\n     */\n    void fireExit(Context context, ResourceWrapper resourceWrapper, int count, Object... args);\n}\n```\n总体的框架如下:\n\n![结构图](./2024/05/26/Springcloud最热点面试题/3.png)\n\nSentinel 将 SlotChainBuilder 作为 SPI 接口进行扩展，使得 Slot Chain 具备了扩展的能力。您可以自行加入自定义的 slot 并编排 slot 间的顺序，从而可以给 Sentinel 添加自定义的功能。\n\n![Sentinel图](./2024/05/26/Springcloud最热点面试题/4.png)\n\n#### RuleManager 规则管理器\n每个 Slot 插槽背后都对应着一个 RuleManager 的实现类，简单理解就是每个 Slot 有一套规则，规则验证处理由对应的 RuleManager 来进行处理。\n\n流量控制：FlowSolt 对应 FlowRuleManager\n\n降级控制：DegradeSlot  对应 DegradeRuleManager\n\n权限控制：AuthoritySlot 对应 AuthorityRuleManager\n\n系统规则控制： SystemSlot 对应 SystemRuleManager\n\n#### 降级控制实现原理\n1. 新增资源配置降级规则，目前对于降级策有如下三种：\n\nRT：平均响应时间 (DEGRADE_GRADE_RT)：当 1s 内持续进入 5 个请求，对应时刻的平均响应时间（秒级）均超过阈值（count，以 ms 为单位），那么在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt=xxx 来配置。\n\n![平均响应图](./2024/05/26/Springcloud最热点面试题/5.png)\n\n异常比例：当资源的每秒请求量 >= 5，并且每秒异常总数占通过量的比值超过阈值（DegradeRule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。\n\n![异常比例图](./2024/05/26/Springcloud最热点面试题/6.png)\n\n异常数：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。\n\n![异常数图](./2024/05/26/Springcloud最热点面试题/7.png)\n\n限流结果信息\n\n```text\nBlocked by Sentinel (flow limiting)\n```\n\n2. 实现逻辑\n\n在之前我们已经提及 Sentinel 是通过 slot 链来实现的，对于降级功能其提供了 DegradeSlot，实现源码如下：\n```java\npublic class DegradeSlot extends AbstractLinkedProcessorSlot<DefaultNode> {\n \n    @Override\n    public void entry(Context context, ResourceWrapper resourceWrapper, DefaultNode node, int count, boolean prioritized, Object... args)\n        throws Throwable {\n        DegradeRuleManager.checkDegrade(resourceWrapper, context, node, count);\n        fireEntry(context, resourceWrapper, node, count, prioritized, args);\n    }\n \n    @Override\n    public void exit(Context context, ResourceWrapper resourceWrapper, int count, Object... args) {\n        fireExit(context, resourceWrapper, count, args);\n    }\n}\n```\n通过上面代码我们可以了解到，限流规则的实现是在 DegradeRuleManager 的checkDegrade中来处理的，限流可以-配置多个规则，依次按照规则来处理。\n```java\npublic static void checkDegrade(ResourceWrapper resource, Context context, DefaultNode node, int count)\n        throws BlockException {\n \n        Set<DegradeRule> rules = degradeRules.get(resource.getName());\n        if (rules == null) {\n            return;\n        }\n \n        for (DegradeRule rule : rules) {\n            if (!rule.passCheck(context, node, count)) {\n                throw new DegradeException(rule.getLimitApp(), rule);\n            }\n        }\n    }\n```\n在 DegradeRule 的 passCheck 方法中我们可以看到可以根据 RT、异常数和异常比例来进行熔断降级处理。\n```java\n@Override\n    public boolean passCheck(Context context, DefaultNode node, int acquireCount, Object... args) {\n        if (cut.get()) {\n            return false;\n        }\n \n        ClusterNode clusterNode = ClusterBuilderSlot.getClusterNode(this.getResource());\n        if (clusterNode == null) {\n            return true;\n        }\n \n\t\t// 请求处理时间\n        if (grade == RuleConstant.DEGRADE_GRADE_RT) {\n            double rt = clusterNode.avgRt();\n            if (rt < this.count) {\n                passCount.set(0);\n                return true;\n            }\n \n            // Sentinel will degrade the service only if count exceeds.\n            if (passCount.incrementAndGet() < rtSlowRequestAmount) {\n                return true;\n            }\n        } else if (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO) {\n\t\t\t//异常比例\n            double exception = clusterNode.exceptionQps();\n            double success = clusterNode.successQps();\n            double total = clusterNode.totalQps();\n            // If total amount is less than minRequestAmount, the request will pass.\n            if (total < minRequestAmount) {\n                return true;\n            }\n \n            // In the same aligned statistic time window,\n            // \"success\" (aka. completed count) = exception count + non-exception count (realSuccess)\n            double realSuccess = success - exception;\n            if (realSuccess <= 0 && exception < minRequestAmount) {\n                return true;\n            }\n \n            if (exception / success < count) {\n                return true;\n            }\n        } else if (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT) {\n\t\t\t//异常数\n            double exception = clusterNode.totalException();\n            if (exception < count) {\n                return true;\n            }\n        }\n \n        if (cut.compareAndSet(false, true)) {\n            ResetTask resetTask = new ResetTask(this);\n            pool.schedule(resetTask, timeWindow, TimeUnit.SECONDS);\n        }\n \n        return false;\n    }\n```\n\n#### 流量控制实现原理\n接下来我们了解学习一下 Sentinel 是如何实现流量控制的\n\n流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。\n\nFlowSlot 会根据预设的规则，结合前面 NodeSelectorSlot、ClusterNodeBuilderSlot、StatisticSlot 统计出来的实时信息进行流量控制。\n\n限流的直接表现是在执行 Entry nodeA = SphU.entry(resourceName) 的时候抛出 FlowException 异常。FlowException 是 BlockException 的子类，您可以捕捉 BlockException 来自定义被限流之后的处理逻辑。\n\n同一个资源可以创建多条限流规则。FlowSlot 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。\n\n一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：\n\n- resource：资源名，即限流规则的作用对象\n- count: 限流阈值\n- grade: 限流阈值类型（QPS 或并发线程数）\n- limitApp: 流控针对的调用来源，若为 default 则不区分调用来源\n- strategy: 调用关系限流策略\n- controlBehavior: 流量控制效果（直接拒绝、Warm Up、匀速排队）\n\n流控-QPS配置\n\n![QPS配置图](./2024/05/26/Springcloud最热点面试题/8.png)\n\n流控-线程数配置\n\n![流控图](./2024/05/26/Springcloud最热点面试题/9.png)\n\n##### 实现流程\nSentinel 提供了 FlowSlot 用来进行流量控制，流量规则的最终实现在 FlowRuleChecker 的 checkFlow 中实现的。\n```java\npublic class FlowSlot extends AbstractLinkedProcessorSlot<DefaultNode> {\n \n    private final FlowRuleChecker checker;\n \n    public FlowSlot() {\n        this(new FlowRuleChecker());\n    }\n \n    /**\n     * Package-private for test.\n     *\n     * @param checker flow rule checker\n     * @since 1.6.1\n     */\n    FlowSlot(FlowRuleChecker checker) {\n        AssertUtil.notNull(checker, \"flow checker should not be null\");\n        this.checker = checker;\n    }\n \n    @Override\n    public void entry(Context context, ResourceWrapper resourceWrapper, DefaultNode node, int count,\n                      boolean prioritized, Object... args) throws Throwable {\n        checkFlow(resourceWrapper, context, node, count, prioritized);\n \n        fireEntry(context, resourceWrapper, node, count, prioritized, args);\n    }\n \n    void checkFlow(ResourceWrapper resource, Context context, DefaultNode node, int count, boolean prioritized)\n        throws BlockException {\n        checker.checkFlow(ruleProvider, resource, context, node, count, prioritized);\n    }\n \n    @Override\n    public void exit(Context context, ResourceWrapper resourceWrapper, int count, Object... args) {\n        fireExit(context, resourceWrapper, count, args);\n    }\n \n    private final Function<String, Collection<FlowRule>> ruleProvider = new Function<String, Collection<FlowRule>>() {\n        @Override\n        public Collection<FlowRule> apply(String resource) {\n            // Flow rule map should not be null.\n            Map<String, List<FlowRule>> flowRules = FlowRuleManager.getFlowRuleMap();\n            return flowRules.get(resource);\n        }\n    };\n}\n```\n在 checkFlow 中会依次获取我们配置的流控规则，然后依次进行流控判断处理，如果被流控则抛出异常 FlowException\n```java\npublic void checkFlow(Function<String, Collection<FlowRule>> ruleProvider, ResourceWrapper resource,\n                          Context context, DefaultNode node, int count, boolean prioritized) throws BlockException {\n        if (ruleProvider == null || resource == null) {\n            return;\n        }\n        Collection<FlowRule> rules = ruleProvider.apply(resource.getName());\n        if (rules != null) {\n            for (FlowRule rule : rules) {\n                if (!canPassCheck(rule, context, node, count, prioritized)) {\n                    throw new FlowException(rule.getLimitApp(), rule);\n                }\n            }\n        }\n    }\n```\n在 canPassCheck 中会判断是集群限流还是本地限流\n```java\npublic boolean canPassCheck(/*@NonNull*/ FlowRule rule, Context context, DefaultNode node, int acquireCount,\n                                                    boolean prioritized) {\n        String limitApp = rule.getLimitApp();\n        if (limitApp == null) {\n            return true;\n        }\n \n        if (rule.isClusterMode()) {\n            return passClusterCheck(rule, context, node, acquireCount, prioritized);\n        }\n \n        return passLocalCheck(rule, context, node, acquireCount, prioritized);\n    }\n```\n如果是本地限流则获取节点信息，然后根据流控规则进行流控判断\n```java\nprivate static boolean passLocalCheck(FlowRule rule, Context context, DefaultNode node, int acquireCount,\n                                          boolean prioritized) {\n        Node selectedNode = selectNodeByRequesterAndStrategy(rule, context, node);\n        if (selectedNode == null) {\n            return true;\n        }\n \n        return rule.getRater().canPass(selectedNode, acquireCount, prioritized);\n    }\n```\n当 QPS 超过某个阈值的时候，则采取措施进行流量控制。流量控制的手段包括以下几种：直接拒绝、Warm Up、匀速排队。对应 FlowRule 中的 controlBehavior 字段。\n\n直接拒绝（RuleConstant.CONTROL_BEHAVIOR_DEFAULT）方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。具体的例子参见 FlowQpsDemo。\n\nWarm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）方式，即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过\"冷启动\"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。详细文档可以参考 流量控制 - Warm Up 文档\n\n目前 Sentinel 对于流量控制提供了如下几种方式：\n\n- 直接拒绝（DefaultController）：支持抛出异常\n```java\n    @Override\n    public boolean canPass(Node node, int acquireCount, boolean prioritized) {\n        int curCount = avgUsedTokens(node);\n        if (curCount + acquireCount > count) {\n            if (prioritized && grade == RuleConstant.FLOW_GRADE_QPS) {\n                long currentTime;\n                long waitInMs;\n                currentTime = TimeUtil.currentTimeMillis();\n                waitInMs = node.tryOccupyNext(currentTime, acquireCount, count);\n                if (waitInMs < OccupyTimeoutProperty.getOccupyTimeout()) {\n                    node.addWaitingRequest(currentTime + waitInMs, acquireCount);\n                    node.addOccupiedPass(acquireCount);\n                    sleep(waitInMs);\n \n                    // PriorityWaitException indicates that the request will pass after waiting for {@link @waitInMs}.\n                    throw new PriorityWaitException(waitInMs);\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n```\n- 匀速排队（RateLimiterController）：判断等待时间，如果等待时间过长也是会限流，并且使用 Thread.sleep 如果配置不正确可能会导致线程过多。\n```java\n@Override\n    public boolean canPass(Node node, int acquireCount, boolean prioritized) {\n        // Pass when acquire count is less or equal than 0.\n        if (acquireCount <= 0) {\n            return true;\n        }\n        // Reject when count is less or equal than 0.\n        // Otherwise,the costTime will be max of long and waitTime will overflow in some cases.\n        if (count <= 0) {\n            return false;\n        }\n \n        long currentTime = TimeUtil.currentTimeMillis();\n        // Calculate the interval between every two requests.\n        long costTime = Math.round(1.0 * (acquireCount) / count * 1000);\n \n        // Expected pass time of this request.\n        long expectedTime = costTime + latestPassedTime.get();\n \n        if (expectedTime <= currentTime) {\n            // Contention may exist here, but it's okay.\n            latestPassedTime.set(currentTime);\n            return true;\n        } else {\n            // Calculate the time to wait.\n            long waitTime = costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();\n            if (waitTime > maxQueueingTimeMs) {\n                return false;\n            } else {\n                long oldTime = latestPassedTime.addAndGet(costTime);\n                try {\n                    waitTime = oldTime - TimeUtil.currentTimeMillis();\n                    if (waitTime > maxQueueingTimeMs) {\n                        latestPassedTime.addAndGet(-costTime);\n                        return false;\n                    }\n                    // in race condition waitTime may <= 0\n                    if (waitTime > 0) {\n                        Thread.sleep(waitTime);\n                    }\n                    return true;\n                } catch (InterruptedException e) {\n                }\n            }\n        }\n        return false;\n    }\n```\n- Warm Up（WarmUpController 和 WarmUpRateLimiterController）：预热启动\n```java\n    @Override\n    public boolean canPass(Node node, int acquireCount, boolean prioritized) {\n        long passQps = (long) node.passQps();\n \n        long previousQps = (long) node.previousPassQps();\n        syncToken(previousQps);\n \n        // 开始计算它的斜率\n        // 如果进入了警戒线，开始调整他的qps\n        long restToken = storedTokens.get();\n        if (restToken >= warningToken) {\n            long aboveToken = restToken - warningToken;\n            // 消耗的速度要比warning快，但是要比慢\n            // current interval = restToken*slope+1/count\n            double warningQps = Math.nextUp(1.0 / (aboveToken * slope + 1.0 / count));\n            if (passQps + acquireCount <= warningQps) {\n                return true;\n            }\n        } else {\n            if (passQps + acquireCount <= count) {\n                return true;\n            }\n        }\n \n        return false;\n    }\n```\n\n","source":"_posts/Springcloud最热点面试题.md","raw":"---\ntitle: Springcloud最热点面试题\ndate: 2024-05-26 22:57:29\ntags: springcloud\ncategories: 面试\n---\n\n\n\nSpring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。\n\nSpring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。\n## 服务注册与发现\n### eureka\n服务治理组件，包括服务端的注册中心和客户端的服务发现机制；\n### consul\n基于Hashicorp Consul的服务治理组件。\n## 服务负载与均衡\n### ribbon\n负载均衡的服务调用组件，具有多种负载均衡调用策略；\n### loadbalancer\n## 服务负载与调用\n### feign\n基于Ribbon和Hystrix的声明式服务调用组件；\n### openFeign\n基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。\n## 服务熔断与降级\n### hystrix\n服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；\n### resilience4j\n## 服务网关\n### zuul\nAPI网关组件，对请求提供路由及过滤功能。\n### zuul2\n### getway\nAPI网关组件，对请求提供路由及过滤功能。\n## 服务分布式配置\n### springcloud config\n集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。\n### Nacos\n## 总线\n### Spring Cloud Bus\n用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。\n# springcloudAlibaba\n## Nacos\nNacos 是一个开源的分布式系统服务发现、配置管理和服务管理平台。它主要包含以下功能：\n\n服务发现与注册：Nacos 可以管理服务的注册和发现，支持 DNS 和 HTTP/RESTful 方式。\n配置管理：Nacos 可以动态管理配置，支持多种数据类型和版本控制。\n服务管理：Nacos 可以对服务进行健康检查、流量管理、负载均衡等。\n### 服务发现与注册\nNacos 实现服务发现和注册的核心代码位于 nacos/naming 目录下，包括以下文件：\n\n- naming-common/src/main/java/com/alibaba/nacos/api/naming: 定义了服务发现和注册的 API 接口和数据模型。\n- naming-core/src/main/java/com/alibaba/nacos/naming: 实现了服务发现和注册的核心逻辑。\n- naming-impl/src/main/java/com/alibaba/nacos/naming: 实现了服务发现和注册的具体实现。\n\n下面简单介绍一下 Nacos 的服务发现和注册的实现流程。\n\n#### 服务注册流程\n服务提供者向 Nacos 注册服务时，会调用 NamingService.registerInstance() 方法，该方法会做以下几件事情：\n\n1. 将服务实例的元数据封装为 Instance 对象，包括服务名、IP、端口号、健康状态、元数据等。\n2. 将 Instance 对象转换为 InstanceEntity 对象，包含了实例 ID 和实例元数据的 JSON 字符串。\n3. 将 InstanceEntity 对象存储到 Nacos 中，可以存储到内存中或者持久化到磁盘中。\n\n#### 服务发现流程\n服务消费者向 Nacos 发现服务时，会调用 NamingService.getAllInstances() 或 NamingService.selectInstances() 方法，该方法会做以下几件事情：\n\n1. 从 Nacos 中获取服务实例的元数据，包括服务名、IP、端口号、健康状态、元数据等。\n2. 将元数据封装为 Instance 对象，存储到本地缓存中。\n3. 根据负载均衡算法选择一个服务实例处理请求，可以选择轮询、随机、权重等算法。\n\n服务发现和注册的核心逻辑在 naming-core 目录下的 com.alibaba.nacos.naming 包中实现，主要包括以下类：\n\n- com.alibaba.nacos.naming.core.InstancesManager: 维护服务实例的元数据和状态信息。\n- com.alibaba.nacos.naming.core.Cluster: 维护一个服务的所有实例信息和负载均衡策略。\n- com.alibaba.nacos.naming.core.InstanceOperator: 实现了服务实例的注册、注销和更新操作。\n- com.alibaba.nacos.naming.core.DomainsManager: 维护多个服务的信息，包括服务名、集群名、命名空间等。\n\n服务发现和注册的具体实现在 naming-impl 目录下的 com.alibaba.nacos.naming 包中，主要包括以下类：\n\n- com.alibaba.nacos.naming.push.PushService: 实现了服务实例的推送功能。\n- com.alibaba.nacos.naming.healthcheck.HealthCheckProcessor: 实现了服务实例的健康检查功能。\n- com.alibaba.nacos.naming.misc.GlobalConfig: 存储了一些全局配置，例如默认权重值、心跳间隔\n\n### 配置动态刷新\n\n从远端服务器获取变更数据的主要模式有两种：推（push）和拉（pull）。Push 模式简单来说就是服务端主动将数据变更信息推送给客户端，这种模式优点是时效性好，服务端数据发生变更可以立马通知到客户端，但这种模式需要服务端维持与客户端的心跳连接，会增加服务端实现的复杂度，服务端也需要占用更多的资源来维持与客户端的连接。\n\n而 Pull 模式则是客户端主动去服务器请求数据，例如，每间隔10ms就向服务端发起请求获取数据。显而易见pull模式存在时效性问题。请求的间隔也不太好设置，间隔太短，对服务器请求压力过大。间隔时间过长，那么必然会造成时效性很差。而且如果配置长时间不更新，并且存在大量的客户端就会产生大量无效的pull请求。\n\nNacos 没有采用上述的两种模式，而是采用了长轮询方式结合了推和拉的优点：\n\n![动态刷新图](./2024/05/26/Springcloud最热点面试题/1.png)\n\n长轮询也是轮询，因此 Nacos 客户端会默认每10ms向服务端发起请求，当客户端请求服务端时会在请求头上携带长轮询的超时时间，默认是30s。而服务端接收到该请求时会hang住请求，为了防止客户端超时会在请求头携带的超时时间上减去500ms，因此默认会hang住请求29.5s。在这期间如果服务端发生了配置变更会产生相应的事件，监听到该事件后，会响应对应的客户端。这样一来客户端不会频繁发起轮询请求，而服务端也不需要维持与客户端的心跳，兼备了时效性和复杂度。\n\n![长轮询图](./2024/05/26/Springcloud最热点面试题/2.png)\n\n\n> 1.4版本nacos使用Http短连接+长轮询的方式，客户端发起http请求，服务端hold住请求，当配置变更时响应客户端，超时时间30s。\n> 2.0版本nacos用gRPC长连接代替了http短连接长轮询。配置同步采用推拉结合的方式。\n\n#### Nacos Config 长轮询源码剖析\n首先，打开 com.alibaba.cloud.nacos.NacosConfigBootstrapConfiguration 这个类，从类名也可以看出该类是Nacos Config的启动配置类，是Nacos Config自动装配的入口。在该类中的 nacosConfigManager 方法实例化了一个 NacosConfigManager 对象，并注册到容器中：\n\n```java\n@Bean\n@ConditionalOnMissingBean\npublic NacosConfigManager nacosConfigManager(\n\t\tNacosConfigProperties nacosConfigProperties) {\n\treturn new NacosConfigManager(nacosConfigProperties);\n}\n```\n在 NacosConfigManager 的构造器中调用了 createConfigService 方法，这是一个静态方法用来创建 ConfigService 对象的单例。\n```java\n/**\n * Compatible with old design,It will be perfected in the future.\n */\nstatic ConfigService createConfigService(\n\t\tNacosConfigProperties nacosConfigProperties) {\n    // 双重检查锁模式的单例\n\tif (Objects.isNull(service)) {\n\t\tsynchronized (NacosConfigManager.class) {\n\t\t\ttry {\n\t\t\t\tif (Objects.isNull(service)) {\n\t\t\t\t\tservice = NacosFactory.createConfigService(\n\t\t\t\t\t\t\tnacosConfigProperties.assembleConfigServiceProperties());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NacosException e) {\n\t\t\t\tlog.error(e.getMessage());\n\t\t\t\tthrow new NacosConnectionFailureException(\n\t\t\t\t\t\tnacosConfigProperties.getServerAddr(), e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}\n\treturn service;\n}\n```\nConfigService 的具体实现是 NacosConfigService，在该类的构造器中主要初始化了 HttpAgent 和 ClientWorker 对象。ClientWorker 的构造器中则初始化了几个线程池：\n\n```java\npublic ClientWorker(final HttpAgent agent, final ConfigFilterChainManager configFilterChainManager,\n        final Properties properties) {\n    this.agent = agent;\n    this.configFilterChainManager = configFilterChainManager;\n    \n    // Initialize the timeout parameter\n    init(properties);\n    \n    // 创建具有定时执行功能的单线程池，用于定时执行 checkConfigInfo 方法\n    this.executor = Executors.newScheduledThreadPool(1, new ThreadFactory() {\n        @Override\n        public Thread newThread(Runnable r) {\n            Thread t = new Thread(r);\n            t.setName(\"com.alibaba.nacos.client.Worker.\" + agent.getName());\n            t.setDaemon(true);\n            return t;\n        }\n    });\n    \n    // 创建具有定时执行功能的且线程数与cpu核数相对应的线程池，用于根据需要动态刷新的配置文件执行 LongPollingRunnable，因此长轮询任务是可以有多个并行的\n    this.executorService = Executors\n            .newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), new ThreadFactory() {\n                @Override\n                public Thread newThread(Runnable r) {\n                    Thread t = new Thread(r);\n                    t.setName(\"com.alibaba.nacos.client.Worker.longPolling.\" + agent.getName());\n                    t.setDaemon(true);\n                    return t;\n                }\n            });\n            \n    // 每10ms执行一次 checkConfigInfo 方法\n    this.executor.scheduleWithFixedDelay(new Runnable() {\n        @Override\n        public void run() {\n            try {\n                checkConfigInfo();\n            } catch (Throwable e) {\n                LOGGER.error(\"[\" + agent.getName() + \"] [sub-check] rotate check error\", e);\n            }\n        }\n    }, 1L, 10L, TimeUnit.MILLISECONDS);\n}\n\nprivate void init(Properties properties) {\n    // 长轮询的超时时间，默认为30秒，此参数会被放到请求头中带到服务端，服务端会根据该参数去做长轮询的hold\n    timeout = Math.max(ConvertUtils.toInt(properties.getProperty(PropertyKeyConst.CONFIG_LONG_POLL_TIMEOUT),\n            Constants.CONFIG_LONG_POLL_TIMEOUT), Constants.MIN_CONFIG_LONG_POLL_TIMEOUT);\n    \n    taskPenaltyTime = ConvertUtils\n            .toInt(properties.getProperty(PropertyKeyConst.CONFIG_RETRY_TIME), Constants.CONFIG_RETRY_TIME);\n    \n    this.enableRemoteSyncConfig = Boolean\n            .parseBoolean(properties.getProperty(PropertyKeyConst.ENABLE_REMOTE_SYNC_CONFIG));\n}\n\n/**\n * Check config info.\n */\npublic void checkConfigInfo() {\n    // Dispatch taskes.\n    // 获取需要监听的文件数量\n    int listenerSize = cacheMap.size();\n    // Round up the longingTaskCount.\n    // 默认一个 LongPollingRunnable 可以处理监听3k个配置文件的变化，超过3k个才会创建新的 LongPollingRunnable\n    int longingTaskCount = (int) Math.ceil(listenerSize / ParamUtil.getPerTaskConfigSize());\n    if (longingTaskCount > currentLongingTaskCount) {\n        for (int i = (int) currentLongingTaskCount; i < longingTaskCount; i++) {\n            // The task list is no order.So it maybe has issues when changing.\n            executorService.execute(new LongPollingRunnable(i));\n        }\n        currentLongingTaskCount = longingTaskCount;\n    }\n}\n```\nLongPollingRunnable 类主要用于检查本地配置，以及长轮询地去服务端获取变更配置的 dataid 和 group，其代码位于 com.alibaba.nacos.client.config.impl.ClientWorker 类，代码如下：\n```java\nclass LongPollingRunnable implements Runnable {\n    \n    private final int taskId;\n    \n    public LongPollingRunnable(int taskId) {\n        this.taskId = taskId;\n    }\n    \n    @Override\n    public void run() {\n        \n        List<CacheData> cacheDatas = new ArrayList<CacheData>();\n        List<String> inInitializingCacheList = new ArrayList<String>();\n        try {\n            // check failover config\n            // 遍历本地缓存的配置\n            for (CacheData cacheData : cacheMap.values()) {\n                if (cacheData.getTaskId() == taskId) {\n                    cacheDatas.add(cacheData);\n                    try {\n                        // 检查本地配置\n                        checkLocalConfig(cacheData);\n                        if (cacheData.isUseLocalConfigInfo()) {\n                            cacheData.checkListenerMd5();\n                        }\n                    } catch (Exception e) {\n                        LOGGER.error(\"get local config info error\", e);\n                    }\n                }\n            }\n            \n            // check server config\n            // 通过长轮询检查服务端配置\n            List<String> changedGroupKeys = checkUpdateDataIds(cacheDatas, inInitializingCacheList);\n            if (!CollectionUtils.isEmpty(changedGroupKeys)) {\n                LOGGER.info(\"get changedGroupKeys:\" + changedGroupKeys);\n            }\n            \n            for (String groupKey : changedGroupKeys) {\n                String[] key = GroupKey.parseKey(groupKey);\n                String dataId = key[0];\n                String group = key[1];\n                String tenant = null;\n                if (key.length == 3) {\n                    tenant = key[2];\n                }\n                try {\n                    String[] ct = getServerConfig(dataId, group, tenant, 3000L);\n                    CacheData cache = cacheMap.get(GroupKey.getKeyTenant(dataId, group, tenant));\n                    cache.setContent(ct[0]);\n                    if (null != ct[1]) {\n                        cache.setType(ct[1]);\n                    }\n                    LOGGER.info(\"[{}] [data-received] dataId={}, group={}, tenant={}, md5={}, content={}, type={}\",\n                            agent.getName(), dataId, group, tenant, cache.getMd5(),\n                            ContentUtils.truncateContent(ct[0]), ct[1]);\n                } catch (NacosException ioe) {\n                    String message = String\n                            .format(\"[%s] [get-update] get changed config exception. dataId=%s, group=%s, tenant=%s\",\n                                    agent.getName(), dataId, group, tenant);\n                    LOGGER.error(message, ioe);\n                }\n            }\n            for (CacheData cacheData : cacheDatas) {\n                if (!cacheData.isInitializing() || inInitializingCacheList\n                        .contains(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant))) {\n                    cacheData.checkListenerMd5();\n                    cacheData.setInitializing(false);\n                }\n            }\n            inInitializingCacheList.clear();\n            \n            executorService.execute(this);\n            \n        } catch (Throwable e) {\n            \n            // If the rotation training task is abnormal, the next execution time of the task will be punished\n            LOGGER.error(\"longPolling error : \", e);\n            executorService.schedule(this, taskPenaltyTime, TimeUnit.MILLISECONDS);\n        }\n    }\n}\n```\n上面有个 checkUpdateDataIds 方法，用于获取发生变更了的配置文件的dataId列表，它同样位于 ClientWorker 内。如下：\n```java\n/**\n * Fetch the dataId list from server.\n *\n * @param cacheDatas              CacheDatas for config infomations.\n * @param inInitializingCacheList initial cache lists.\n * @return String include dataId and group (ps: it maybe null).\n * @throws Exception Exception.\n */\nList<String> checkUpdateDataIds(List<CacheData> cacheDatas, List<String> inInitializingCacheList) throws Exception {\n    // 拼接出配置文件的唯一标识\n    StringBuilder sb = new StringBuilder();\n    for (CacheData cacheData : cacheDatas) {\n        if (!cacheData.isUseLocalConfigInfo()) {\n            sb.append(cacheData.dataId).append(WORD_SEPARATOR);\n            sb.append(cacheData.group).append(WORD_SEPARATOR);\n            if (StringUtils.isBlank(cacheData.tenant)) {\n                sb.append(cacheData.getMd5()).append(LINE_SEPARATOR);\n            } else {\n                sb.append(cacheData.getMd5()).append(WORD_SEPARATOR);\n                sb.append(cacheData.getTenant()).append(LINE_SEPARATOR);\n            }\n            if (cacheData.isInitializing()) {\n                // It updates when cacheData occours in cacheMap by first time.\n                inInitializingCacheList\n                        .add(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant));\n            }\n        }\n    }\n    boolean isInitializingCacheList = !inInitializingCacheList.isEmpty();\n    return checkUpdateConfigStr(sb.toString(), isInitializingCacheList);\n}\n\n/**\n * Fetch the updated dataId list from server.\n *\n * @param probeUpdateString       updated attribute string value.\n * @param isInitializingCacheList initial cache lists.\n * @return The updated dataId list(ps: it maybe null).\n * @throws IOException Exception.\n */\nList<String> checkUpdateConfigStr(String probeUpdateString, boolean isInitializingCacheList) throws Exception {\n    \n    Map<String, String> params = new HashMap<String, String>(2);\n    params.put(Constants.PROBE_MODIFY_REQUEST, probeUpdateString);\n    Map<String, String> headers = new HashMap<String, String>(2);\n    // 长轮询的超时时间\n    headers.put(\"Long-Pulling-Timeout\", \"\" + timeout);\n    \n    // told server do not hang me up if new initializing cacheData added in\n    if (isInitializingCacheList) {\n        headers.put(\"Long-Pulling-Timeout-No-Hangup\", \"true\");\n    }\n    \n    if (StringUtils.isBlank(probeUpdateString)) {\n        return Collections.emptyList();\n    }\n    \n    try {\n        // In order to prevent the server from handling the delay of the client's long task,\n        // increase the client's read timeout to avoid this problem.\n        \n        long readTimeoutMs = timeout + (long) Math.round(timeout >> 1);\n        // 向服务端发起一个http请求，该请求在服务端配置没有变更的情况下默认会hang住30s\n        HttpRestResult<String> result = agent\n                .httpPost(Constants.CONFIG_CONTROLLER_PATH + \"/listener\", headers, params, agent.getEncode(),\n                        readTimeoutMs);\n        \n        if (result.ok()) {\n            setHealthServer(true);\n            // 响应状态是成功则解析响应体得到 dataId、group、tenant 等信息并返回\n            return parseUpdateDataIdResponse(result.getData());\n        } else {\n            setHealthServer(false);\n            LOGGER.error(\"[{}] [check-update] get changed dataId error, code: {}\", agent.getName(),\n                    result.getCode());\n        }\n    } catch (Exception e) {\n        setHealthServer(false);\n        LOGGER.error(\"[\" + agent.getName() + \"] [check-update] get changed dataId exception\", e);\n        throw e;\n    }\n    return Collections.emptyList();\n}\n```\n客户端对 listener 接口的请求会进入到服务端的 com.alibaba.nacos.config.server.controller.ConfigController#listener 方法进行处理，该方法主要是调用了 com.alibaba.nacos.config.server.controller.ConfigServletInner#doPollingConfig 方法。代码如下：\n```java\n/**\n * 轮询接口\n */\npublic String doPollingConfig(HttpServletRequest request, HttpServletResponse response,\n                              Map<String, String> clientMd5Map, int probeRequestSize)\n    throws IOException, ServletException {\n\n    // 如果支持长轮询则进入长轮询的流程\n    if (LongPollingService.isSupportLongPolling(request)) {\n        longPollingService.addLongPollingClient(request, response, clientMd5Map, probeRequestSize);\n        return HttpServletResponse.SC_OK + \"\";\n    }\n\n    // else 兼容短轮询逻辑\n    List<String> changedGroups = MD5Util.compareMd5(request, response, clientMd5Map);\n\n    // 兼容短轮询result\n    String oldResult = MD5Util.compareMd5OldResult(changedGroups);\n    String newResult = MD5Util.compareMd5ResultString(changedGroups);\n\n    String version = request.getHeader(Constants.CLIENT_VERSION_HEADER);\n    if (version == null) {\n        version = \"2.0.0\";\n    }\n    int versionNum = Protocol.getVersionNumber(version);\n\n    /**\n     * 2.0.4版本以前, 返回值放入header中\n     */\n    if (versionNum < START_LONGPOLLING_VERSION_NUM) {\n        response.addHeader(Constants.PROBE_MODIFY_RESPONSE, oldResult);\n        response.addHeader(Constants.PROBE_MODIFY_RESPONSE_NEW, newResult);\n    } else {\n        request.setAttribute(\"content\", newResult);\n    }\n\n    // 禁用缓存\n    response.setHeader(\"Pragma\", \"no-cache\");\n    response.setDateHeader(\"Expires\", 0);\n    response.setHeader(\"Cache-Control\", \"no-cache,no-store\");\n    response.setStatus(HttpServletResponse.SC_OK);\n    return HttpServletResponse.SC_OK + \"\";\n}\n```\n我们主要关注上面的 com.alibaba.nacos.config.server.service.LongPollingService#addLongPollingClient 长轮询流程的方法。代码如下：\n```java\npublic void addLongPollingClient(HttpServletRequest req, HttpServletResponse rsp, Map<String, String> clientMd5Map,\n                                 int probeRequestSize) {\n\n    String str = req.getHeader(LongPollingService.LONG_POLLING_HEADER);\n    String noHangUpFlag = req.getHeader(LongPollingService.LONG_POLLING_NO_HANG_UP_HEADER);\n    String appName = req.getHeader(RequestUtil.CLIENT_APPNAME_HEADER);\n    String tag = req.getHeader(\"Vipserver-Tag\");\n    int delayTime = SwitchService.getSwitchInteger(SwitchService.FIXED_DELAY_TIME, 500);\n    /**\n     * 提前500ms返回响应，为避免客户端超时 @qiaoyi.dingqy 2013.10.22改动  add delay time for LoadBalance\n     */\n    long timeout = Math.max(10000, Long.parseLong(str) - delayTime);\n    if (isFixedPolling()) {\n        timeout = Math.max(10000, getFixedPollingInterval());\n        // do nothing but set fix polling timeout\n    } else {\n        long start = System.currentTimeMillis();\n        List<String> changedGroups = MD5Util.compareMd5(req, rsp, clientMd5Map);\n        if (changedGroups.size() > 0) {\n            generateResponse(req, rsp, changedGroups);\n            LogUtil.clientLog.info(\"{}|{}|{}|{}|{}|{}|{}\",\n                System.currentTimeMillis() - start, \"instant\", RequestUtil.getRemoteIp(req), \"polling\",\n                clientMd5Map.size(), probeRequestSize, changedGroups.size());\n            return;\n        } else if (noHangUpFlag != null && noHangUpFlag.equalsIgnoreCase(TRUE_STR)) {\n            LogUtil.clientLog.info(\"{}|{}|{}|{}|{}|{}|{}\", System.currentTimeMillis() - start, \"nohangup\",\n                RequestUtil.getRemoteIp(req), \"polling\", clientMd5Map.size(), probeRequestSize,\n                changedGroups.size());\n            return;\n        }\n    }\n    String ip = RequestUtil.getRemoteIp(req);\n    // 一定要由HTTP线程调用，否则离开后容器会立即发送响应\n    final AsyncContext asyncContext = req.startAsync();\n    // AsyncContext.setTimeout()的超时时间不准，所以只能自己控制\n    asyncContext.setTimeout(0L);\n\t\n\t// 在 ClientLongPolling 的 run 方法会将 ClientLongPolling 实例（携带了本次请求的相关信息）放入 allSubs 中，然后会在29.5s后再执行另一个 Runnable，该 Runnable 用于等待29.5s后依旧没有相应的配置变更时对客户端进行响应，并将相应的 ClientLongPolling 实例从 allSubs 中移出\n    scheduler.execute(\n        new ClientLongPolling(asyncContext, clientMd5Map, ip, probeRequestSize, timeout, appName, tag));\n}\n```\n而 LongPollingService 实现了 AbstractEventListener，也就是说能接收事件通知，在其 com.alibaba.nacos.config.server.service.LongPollingService#onEvent 方法中可以看到，它关注的是 LocalDataChangeEvent 事件：\n```java\n@Override\npublic void onEvent(Event event) {\n    if (isFixedPolling()) {\n        // ignore\n    } else {\n        if (event instanceof LocalDataChangeEvent) {\n            LocalDataChangeEvent evt = (LocalDataChangeEvent)event;\n            scheduler.execute(new DataChangeTask(evt.groupKey, evt.isBeta, evt.betaIps));\n        }\n    }\n}\n```\n在nacos上修改配置后就会产生 LocalDataChangeEvent 事件，此时 LongPollingService 也就能监听到，当收到该事件时就会遍历 allSubs，找到匹配的请求并将 groupKey 返回给客户端。具体代码在 DataChangeTask 中：\n```java\nclass DataChangeTask implements Runnable {\n    @Override\n    public void run() {\n        try {\n            ConfigService.getContentBetaMd5(groupKey);\n            for (Iterator<ClientLongPolling> iter = allSubs.iterator(); iter.hasNext(); ) {\n                ClientLongPolling clientSub = iter.next();\n                if (clientSub.clientMd5Map.containsKey(groupKey)) {\n                    // 如果beta发布且不在beta列表直接跳过\n                    if (isBeta && !betaIps.contains(clientSub.ip)) {\n                        continue;\n                    }\n\n                    // 如果tag发布且不在tag列表直接跳过\n                    if (StringUtils.isNotBlank(tag) && !tag.equals(clientSub.tag)) {\n                        continue;\n                    }\n\n                    getRetainIps().put(clientSub.ip, System.currentTimeMillis());\n                    iter.remove(); // 删除订阅关系\n                    LogUtil.clientLog.info(\"{}|{}|{}|{}|{}|{}|{}\",\n                        (System.currentTimeMillis() - changeTime),\n                        \"in-advance\",\n                        RequestUtil.getRemoteIp((HttpServletRequest)clientSub.asyncContext.getRequest()),\n                        \"polling\",\n                        clientSub.clientMd5Map.size(), clientSub.probeRequestSize, groupKey);\n                    clientSub.sendResponse(Arrays.asList(groupKey));\n                }\n            }\n        } catch (Throwable t) {\n            LogUtil.defaultLog.error(\"data change error:\" + t.getMessage(), t.getCause());\n        }\n    }\n\n    DataChangeTask(String groupKey) {\n        this(groupKey, false, null);\n    }\n\n    DataChangeTask(String groupKey, boolean isBeta, List<String> betaIps) {\n        this(groupKey, isBeta, betaIps, null);\n    }\n\n    DataChangeTask(String groupKey, boolean isBeta, List<String> betaIps, String tag) {\n        this.groupKey = groupKey;\n        this.isBeta = isBeta;\n        this.betaIps = betaIps;\n        this.tag = tag;\n    }\n\n    final String groupKey;\n    final long changeTime = System.currentTimeMillis();\n    final boolean isBeta;\n    final List<String> betaIps;\n    final String tag;\n}\n```\n当客户端收到变更的dataid+group后，就会去服务端获取最新的配置数据，并更新本地数据 cacheData，然后发送数据变更事件，整个流程结束。\n\n- 获取服务端最新配置数据的方法：com.alibaba.nacos.client.config.impl.ClientWorker#getServerConfig\n- 发送数据变更事件的方法：com.alibaba.nacos.client.config.impl.CacheData#checkListenerMd5\n\n## Sentienl\nSentinel是阿里巴巴开源的一款流量控制和熔断降级框架，主要用于微服务架构中服务的流量控制和熔断降级。其限流实现原理主要分为两个部分：\n\n> 统计信息收集\n\nSentinel会在运行过程中对服务的各种统计信息进行收集，包括请求的响应时间、请求通过的QPS（每秒查询率）、线程池队列大小等指标。这些指标通过定义的规则进行分析，判断当前请求是否超过了设定的阈值。\n\n> 阈值判断\n\nSentinel根据收集到的统计信息，通过定义的规则对请求进行判断。规则中包括以下几个要素：\n\n资源名：对哪个资源进行限流\n流控模式：直接拒绝或者匀速通过\n流控阈值：单位时间内允许通过的请求个数\n统计时间窗口：多长时间内统计一次流量，单位秒\n降级处理：当请求超过阈值时的处理策略，如直接拒绝、返回默认值等\nSentinel会根据以上规则进行限流，当请求超过阈值时，根据设置的降级处理策略进行处理，比如直接拒绝请求、返回默认值等。同时，Sentinel还可以进行自适应的流控，根据实际情况调整阈值，保证服务的可用性和稳定性。\n\n### 工作原理\n#### Slot 插槽\n在 Sentinel 里面，所有的资源都对应一个资源名称（resourceName），每次资源调用都会创建一个 Entry 对象。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 SphU API 显式创建。Entry 创建的时候，同时也会创建一系列功能插槽（slot chain），这些插槽有不同的职责，例如:\n\n- NodeSelectorSlot 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；\n- ClusterBuilderSlot 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；\n- StatisticSlot 则用于记录、统计不同纬度的 runtime 指标监控信息；\n- FlowSlot 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；\n- AuthoritySlot 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；\n- DegradeSlot 则通过统计信息以及预设的规则，来做熔断降级；\n- SystemSlot 则通过系统的状态，例如 load1 等，来控制总的入口流量；\n\nSentinel 提供了插槽接口 ProcessorSlot，其中提供了方法 enrty 处理进入请求 和 exit 处理请求结束操作\n```java\npublic interface ProcessorSlot<T> {\n \n    /**\n     * Entrance of this slot.\n     *\n     * @param context         current {@link Context}\n     * @param resourceWrapper current resource\n     * @param param           generics parameter, usually is a {@link com.alibaba.csp.sentinel.node.Node}\n     * @param count           tokens needed\n     * @param prioritized     whether the entry is prioritized\n     * @param args            parameters of the original call\n     * @throws Throwable blocked exception or unexpected error\n     */\n    void entry(Context context, ResourceWrapper resourceWrapper, T param, int count, boolean prioritized,\n               Object... args) throws Throwable;\n \n    /**\n     * Means finish of {@link #entry(Context, ResourceWrapper, Object, int, boolean, Object...)}.\n     *\n     * @param context         current {@link Context}\n     * @param resourceWrapper current resource\n     * @param obj             relevant object (e.g. Node)\n     * @param count           tokens needed\n     * @param prioritized     whether the entry is prioritized\n     * @param args            parameters of the original call\n     * @throws Throwable blocked exception or unexpected error\n     */\n    void fireEntry(Context context, ResourceWrapper resourceWrapper, Object obj, int count, boolean prioritized,\n                   Object... args) throws Throwable;\n \n    /**\n     * Exit of this slot.\n     *\n     * @param context         current {@link Context}\n     * @param resourceWrapper current resource\n     * @param count           tokens needed\n     * @param args            parameters of the original call\n     */\n    void exit(Context context, ResourceWrapper resourceWrapper, int count, Object... args);\n \n    /**\n     * Means finish of {@link #exit(Context, ResourceWrapper, int, Object...)}.\n     *\n     * @param context         current {@link Context}\n     * @param resourceWrapper current resource\n     * @param count           tokens needed\n     * @param args            parameters of the original call\n     */\n    void fireExit(Context context, ResourceWrapper resourceWrapper, int count, Object... args);\n}\n```\n总体的框架如下:\n\n![结构图](./2024/05/26/Springcloud最热点面试题/3.png)\n\nSentinel 将 SlotChainBuilder 作为 SPI 接口进行扩展，使得 Slot Chain 具备了扩展的能力。您可以自行加入自定义的 slot 并编排 slot 间的顺序，从而可以给 Sentinel 添加自定义的功能。\n\n![Sentinel图](./2024/05/26/Springcloud最热点面试题/4.png)\n\n#### RuleManager 规则管理器\n每个 Slot 插槽背后都对应着一个 RuleManager 的实现类，简单理解就是每个 Slot 有一套规则，规则验证处理由对应的 RuleManager 来进行处理。\n\n流量控制：FlowSolt 对应 FlowRuleManager\n\n降级控制：DegradeSlot  对应 DegradeRuleManager\n\n权限控制：AuthoritySlot 对应 AuthorityRuleManager\n\n系统规则控制： SystemSlot 对应 SystemRuleManager\n\n#### 降级控制实现原理\n1. 新增资源配置降级规则，目前对于降级策有如下三种：\n\nRT：平均响应时间 (DEGRADE_GRADE_RT)：当 1s 内持续进入 5 个请求，对应时刻的平均响应时间（秒级）均超过阈值（count，以 ms 为单位），那么在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt=xxx 来配置。\n\n![平均响应图](./2024/05/26/Springcloud最热点面试题/5.png)\n\n异常比例：当资源的每秒请求量 >= 5，并且每秒异常总数占通过量的比值超过阈值（DegradeRule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。\n\n![异常比例图](./2024/05/26/Springcloud最热点面试题/6.png)\n\n异常数：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。\n\n![异常数图](./2024/05/26/Springcloud最热点面试题/7.png)\n\n限流结果信息\n\n```text\nBlocked by Sentinel (flow limiting)\n```\n\n2. 实现逻辑\n\n在之前我们已经提及 Sentinel 是通过 slot 链来实现的，对于降级功能其提供了 DegradeSlot，实现源码如下：\n```java\npublic class DegradeSlot extends AbstractLinkedProcessorSlot<DefaultNode> {\n \n    @Override\n    public void entry(Context context, ResourceWrapper resourceWrapper, DefaultNode node, int count, boolean prioritized, Object... args)\n        throws Throwable {\n        DegradeRuleManager.checkDegrade(resourceWrapper, context, node, count);\n        fireEntry(context, resourceWrapper, node, count, prioritized, args);\n    }\n \n    @Override\n    public void exit(Context context, ResourceWrapper resourceWrapper, int count, Object... args) {\n        fireExit(context, resourceWrapper, count, args);\n    }\n}\n```\n通过上面代码我们可以了解到，限流规则的实现是在 DegradeRuleManager 的checkDegrade中来处理的，限流可以-配置多个规则，依次按照规则来处理。\n```java\npublic static void checkDegrade(ResourceWrapper resource, Context context, DefaultNode node, int count)\n        throws BlockException {\n \n        Set<DegradeRule> rules = degradeRules.get(resource.getName());\n        if (rules == null) {\n            return;\n        }\n \n        for (DegradeRule rule : rules) {\n            if (!rule.passCheck(context, node, count)) {\n                throw new DegradeException(rule.getLimitApp(), rule);\n            }\n        }\n    }\n```\n在 DegradeRule 的 passCheck 方法中我们可以看到可以根据 RT、异常数和异常比例来进行熔断降级处理。\n```java\n@Override\n    public boolean passCheck(Context context, DefaultNode node, int acquireCount, Object... args) {\n        if (cut.get()) {\n            return false;\n        }\n \n        ClusterNode clusterNode = ClusterBuilderSlot.getClusterNode(this.getResource());\n        if (clusterNode == null) {\n            return true;\n        }\n \n\t\t// 请求处理时间\n        if (grade == RuleConstant.DEGRADE_GRADE_RT) {\n            double rt = clusterNode.avgRt();\n            if (rt < this.count) {\n                passCount.set(0);\n                return true;\n            }\n \n            // Sentinel will degrade the service only if count exceeds.\n            if (passCount.incrementAndGet() < rtSlowRequestAmount) {\n                return true;\n            }\n        } else if (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO) {\n\t\t\t//异常比例\n            double exception = clusterNode.exceptionQps();\n            double success = clusterNode.successQps();\n            double total = clusterNode.totalQps();\n            // If total amount is less than minRequestAmount, the request will pass.\n            if (total < minRequestAmount) {\n                return true;\n            }\n \n            // In the same aligned statistic time window,\n            // \"success\" (aka. completed count) = exception count + non-exception count (realSuccess)\n            double realSuccess = success - exception;\n            if (realSuccess <= 0 && exception < minRequestAmount) {\n                return true;\n            }\n \n            if (exception / success < count) {\n                return true;\n            }\n        } else if (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT) {\n\t\t\t//异常数\n            double exception = clusterNode.totalException();\n            if (exception < count) {\n                return true;\n            }\n        }\n \n        if (cut.compareAndSet(false, true)) {\n            ResetTask resetTask = new ResetTask(this);\n            pool.schedule(resetTask, timeWindow, TimeUnit.SECONDS);\n        }\n \n        return false;\n    }\n```\n\n#### 流量控制实现原理\n接下来我们了解学习一下 Sentinel 是如何实现流量控制的\n\n流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。\n\nFlowSlot 会根据预设的规则，结合前面 NodeSelectorSlot、ClusterNodeBuilderSlot、StatisticSlot 统计出来的实时信息进行流量控制。\n\n限流的直接表现是在执行 Entry nodeA = SphU.entry(resourceName) 的时候抛出 FlowException 异常。FlowException 是 BlockException 的子类，您可以捕捉 BlockException 来自定义被限流之后的处理逻辑。\n\n同一个资源可以创建多条限流规则。FlowSlot 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。\n\n一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：\n\n- resource：资源名，即限流规则的作用对象\n- count: 限流阈值\n- grade: 限流阈值类型（QPS 或并发线程数）\n- limitApp: 流控针对的调用来源，若为 default 则不区分调用来源\n- strategy: 调用关系限流策略\n- controlBehavior: 流量控制效果（直接拒绝、Warm Up、匀速排队）\n\n流控-QPS配置\n\n![QPS配置图](./2024/05/26/Springcloud最热点面试题/8.png)\n\n流控-线程数配置\n\n![流控图](./2024/05/26/Springcloud最热点面试题/9.png)\n\n##### 实现流程\nSentinel 提供了 FlowSlot 用来进行流量控制，流量规则的最终实现在 FlowRuleChecker 的 checkFlow 中实现的。\n```java\npublic class FlowSlot extends AbstractLinkedProcessorSlot<DefaultNode> {\n \n    private final FlowRuleChecker checker;\n \n    public FlowSlot() {\n        this(new FlowRuleChecker());\n    }\n \n    /**\n     * Package-private for test.\n     *\n     * @param checker flow rule checker\n     * @since 1.6.1\n     */\n    FlowSlot(FlowRuleChecker checker) {\n        AssertUtil.notNull(checker, \"flow checker should not be null\");\n        this.checker = checker;\n    }\n \n    @Override\n    public void entry(Context context, ResourceWrapper resourceWrapper, DefaultNode node, int count,\n                      boolean prioritized, Object... args) throws Throwable {\n        checkFlow(resourceWrapper, context, node, count, prioritized);\n \n        fireEntry(context, resourceWrapper, node, count, prioritized, args);\n    }\n \n    void checkFlow(ResourceWrapper resource, Context context, DefaultNode node, int count, boolean prioritized)\n        throws BlockException {\n        checker.checkFlow(ruleProvider, resource, context, node, count, prioritized);\n    }\n \n    @Override\n    public void exit(Context context, ResourceWrapper resourceWrapper, int count, Object... args) {\n        fireExit(context, resourceWrapper, count, args);\n    }\n \n    private final Function<String, Collection<FlowRule>> ruleProvider = new Function<String, Collection<FlowRule>>() {\n        @Override\n        public Collection<FlowRule> apply(String resource) {\n            // Flow rule map should not be null.\n            Map<String, List<FlowRule>> flowRules = FlowRuleManager.getFlowRuleMap();\n            return flowRules.get(resource);\n        }\n    };\n}\n```\n在 checkFlow 中会依次获取我们配置的流控规则，然后依次进行流控判断处理，如果被流控则抛出异常 FlowException\n```java\npublic void checkFlow(Function<String, Collection<FlowRule>> ruleProvider, ResourceWrapper resource,\n                          Context context, DefaultNode node, int count, boolean prioritized) throws BlockException {\n        if (ruleProvider == null || resource == null) {\n            return;\n        }\n        Collection<FlowRule> rules = ruleProvider.apply(resource.getName());\n        if (rules != null) {\n            for (FlowRule rule : rules) {\n                if (!canPassCheck(rule, context, node, count, prioritized)) {\n                    throw new FlowException(rule.getLimitApp(), rule);\n                }\n            }\n        }\n    }\n```\n在 canPassCheck 中会判断是集群限流还是本地限流\n```java\npublic boolean canPassCheck(/*@NonNull*/ FlowRule rule, Context context, DefaultNode node, int acquireCount,\n                                                    boolean prioritized) {\n        String limitApp = rule.getLimitApp();\n        if (limitApp == null) {\n            return true;\n        }\n \n        if (rule.isClusterMode()) {\n            return passClusterCheck(rule, context, node, acquireCount, prioritized);\n        }\n \n        return passLocalCheck(rule, context, node, acquireCount, prioritized);\n    }\n```\n如果是本地限流则获取节点信息，然后根据流控规则进行流控判断\n```java\nprivate static boolean passLocalCheck(FlowRule rule, Context context, DefaultNode node, int acquireCount,\n                                          boolean prioritized) {\n        Node selectedNode = selectNodeByRequesterAndStrategy(rule, context, node);\n        if (selectedNode == null) {\n            return true;\n        }\n \n        return rule.getRater().canPass(selectedNode, acquireCount, prioritized);\n    }\n```\n当 QPS 超过某个阈值的时候，则采取措施进行流量控制。流量控制的手段包括以下几种：直接拒绝、Warm Up、匀速排队。对应 FlowRule 中的 controlBehavior 字段。\n\n直接拒绝（RuleConstant.CONTROL_BEHAVIOR_DEFAULT）方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。具体的例子参见 FlowQpsDemo。\n\nWarm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）方式，即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过\"冷启动\"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。详细文档可以参考 流量控制 - Warm Up 文档\n\n目前 Sentinel 对于流量控制提供了如下几种方式：\n\n- 直接拒绝（DefaultController）：支持抛出异常\n```java\n    @Override\n    public boolean canPass(Node node, int acquireCount, boolean prioritized) {\n        int curCount = avgUsedTokens(node);\n        if (curCount + acquireCount > count) {\n            if (prioritized && grade == RuleConstant.FLOW_GRADE_QPS) {\n                long currentTime;\n                long waitInMs;\n                currentTime = TimeUtil.currentTimeMillis();\n                waitInMs = node.tryOccupyNext(currentTime, acquireCount, count);\n                if (waitInMs < OccupyTimeoutProperty.getOccupyTimeout()) {\n                    node.addWaitingRequest(currentTime + waitInMs, acquireCount);\n                    node.addOccupiedPass(acquireCount);\n                    sleep(waitInMs);\n \n                    // PriorityWaitException indicates that the request will pass after waiting for {@link @waitInMs}.\n                    throw new PriorityWaitException(waitInMs);\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n```\n- 匀速排队（RateLimiterController）：判断等待时间，如果等待时间过长也是会限流，并且使用 Thread.sleep 如果配置不正确可能会导致线程过多。\n```java\n@Override\n    public boolean canPass(Node node, int acquireCount, boolean prioritized) {\n        // Pass when acquire count is less or equal than 0.\n        if (acquireCount <= 0) {\n            return true;\n        }\n        // Reject when count is less or equal than 0.\n        // Otherwise,the costTime will be max of long and waitTime will overflow in some cases.\n        if (count <= 0) {\n            return false;\n        }\n \n        long currentTime = TimeUtil.currentTimeMillis();\n        // Calculate the interval between every two requests.\n        long costTime = Math.round(1.0 * (acquireCount) / count * 1000);\n \n        // Expected pass time of this request.\n        long expectedTime = costTime + latestPassedTime.get();\n \n        if (expectedTime <= currentTime) {\n            // Contention may exist here, but it's okay.\n            latestPassedTime.set(currentTime);\n            return true;\n        } else {\n            // Calculate the time to wait.\n            long waitTime = costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();\n            if (waitTime > maxQueueingTimeMs) {\n                return false;\n            } else {\n                long oldTime = latestPassedTime.addAndGet(costTime);\n                try {\n                    waitTime = oldTime - TimeUtil.currentTimeMillis();\n                    if (waitTime > maxQueueingTimeMs) {\n                        latestPassedTime.addAndGet(-costTime);\n                        return false;\n                    }\n                    // in race condition waitTime may <= 0\n                    if (waitTime > 0) {\n                        Thread.sleep(waitTime);\n                    }\n                    return true;\n                } catch (InterruptedException e) {\n                }\n            }\n        }\n        return false;\n    }\n```\n- Warm Up（WarmUpController 和 WarmUpRateLimiterController）：预热启动\n```java\n    @Override\n    public boolean canPass(Node node, int acquireCount, boolean prioritized) {\n        long passQps = (long) node.passQps();\n \n        long previousQps = (long) node.previousPassQps();\n        syncToken(previousQps);\n \n        // 开始计算它的斜率\n        // 如果进入了警戒线，开始调整他的qps\n        long restToken = storedTokens.get();\n        if (restToken >= warningToken) {\n            long aboveToken = restToken - warningToken;\n            // 消耗的速度要比warning快，但是要比慢\n            // current interval = restToken*slope+1/count\n            double warningQps = Math.nextUp(1.0 / (aboveToken * slope + 1.0 / count));\n            if (passQps + acquireCount <= warningQps) {\n                return true;\n            }\n        } else {\n            if (passQps + acquireCount <= count) {\n                return true;\n            }\n        }\n \n        return false;\n    }\n```\n\n","slug":"Springcloud最热点面试题","published":1,"updated":"2024-05-26T15:05:33.395Z","comments":1,"layout":"post","photos":[],"_id":"clwxc4r9t0008b4uh4hkbejn1","content":"<p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p>\n<p>Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>\n<h2 id=\"服务注册与发现\"><a href=\"#服务注册与发现\" class=\"headerlink\" title=\"服务注册与发现\"></a>服务注册与发现</h2><h3 id=\"eureka\"><a href=\"#eureka\" class=\"headerlink\" title=\"eureka\"></a>eureka</h3><p>服务治理组件，包括服务端的注册中心和客户端的服务发现机制；</p>\n<h3 id=\"consul\"><a href=\"#consul\" class=\"headerlink\" title=\"consul\"></a>consul</h3><p>基于Hashicorp Consul的服务治理组件。</p>\n<h2 id=\"服务负载与均衡\"><a href=\"#服务负载与均衡\" class=\"headerlink\" title=\"服务负载与均衡\"></a>服务负载与均衡</h2><h3 id=\"ribbon\"><a href=\"#ribbon\" class=\"headerlink\" title=\"ribbon\"></a>ribbon</h3><p>负载均衡的服务调用组件，具有多种负载均衡调用策略；</p>\n<h3 id=\"loadbalancer\"><a href=\"#loadbalancer\" class=\"headerlink\" title=\"loadbalancer\"></a>loadbalancer</h3><h2 id=\"服务负载与调用\"><a href=\"#服务负载与调用\" class=\"headerlink\" title=\"服务负载与调用\"></a>服务负载与调用</h2><h3 id=\"feign\"><a href=\"#feign\" class=\"headerlink\" title=\"feign\"></a>feign</h3><p>基于Ribbon和Hystrix的声明式服务调用组件；</p>\n<h3 id=\"openFeign\"><a href=\"#openFeign\" class=\"headerlink\" title=\"openFeign\"></a>openFeign</h3><p>基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。</p>\n<h2 id=\"服务熔断与降级\"><a href=\"#服务熔断与降级\" class=\"headerlink\" title=\"服务熔断与降级\"></a>服务熔断与降级</h2><h3 id=\"hystrix\"><a href=\"#hystrix\" class=\"headerlink\" title=\"hystrix\"></a>hystrix</h3><p>服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；</p>\n<h3 id=\"resilience4j\"><a href=\"#resilience4j\" class=\"headerlink\" title=\"resilience4j\"></a>resilience4j</h3><h2 id=\"服务网关\"><a href=\"#服务网关\" class=\"headerlink\" title=\"服务网关\"></a>服务网关</h2><h3 id=\"zuul\"><a href=\"#zuul\" class=\"headerlink\" title=\"zuul\"></a>zuul</h3><p>API网关组件，对请求提供路由及过滤功能。</p>\n<h3 id=\"zuul2\"><a href=\"#zuul2\" class=\"headerlink\" title=\"zuul2\"></a>zuul2</h3><h3 id=\"getway\"><a href=\"#getway\" class=\"headerlink\" title=\"getway\"></a>getway</h3><p>API网关组件，对请求提供路由及过滤功能。</p>\n<h2 id=\"服务分布式配置\"><a href=\"#服务分布式配置\" class=\"headerlink\" title=\"服务分布式配置\"></a>服务分布式配置</h2><h3 id=\"springcloud-config\"><a href=\"#springcloud-config\" class=\"headerlink\" title=\"springcloud config\"></a>springcloud config</h3><p>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</p>\n<h3 id=\"Nacos\"><a href=\"#Nacos\" class=\"headerlink\" title=\"Nacos\"></a>Nacos</h3><h2 id=\"总线\"><a href=\"#总线\" class=\"headerlink\" title=\"总线\"></a>总线</h2><h3 id=\"Spring-Cloud-Bus\"><a href=\"#Spring-Cloud-Bus\" class=\"headerlink\" title=\"Spring Cloud Bus\"></a>Spring Cloud Bus</h3><p>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。</p>\n<h1 id=\"springcloudAlibaba\"><a href=\"#springcloudAlibaba\" class=\"headerlink\" title=\"springcloudAlibaba\"></a>springcloudAlibaba</h1><h2 id=\"Nacos-1\"><a href=\"#Nacos-1\" class=\"headerlink\" title=\"Nacos\"></a>Nacos</h2><p>Nacos 是一个开源的分布式系统服务发现、配置管理和服务管理平台。它主要包含以下功能：</p>\n<p>服务发现与注册：Nacos 可以管理服务的注册和发现，支持 DNS 和 HTTP&#x2F;RESTful 方式。<br>配置管理：Nacos 可以动态管理配置，支持多种数据类型和版本控制。<br>服务管理：Nacos 可以对服务进行健康检查、流量管理、负载均衡等。</p>\n<h3 id=\"服务发现与注册\"><a href=\"#服务发现与注册\" class=\"headerlink\" title=\"服务发现与注册\"></a>服务发现与注册</h3><p>Nacos 实现服务发现和注册的核心代码位于 nacos&#x2F;naming 目录下，包括以下文件：</p>\n<ul>\n<li>naming-common&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;api&#x2F;naming: 定义了服务发现和注册的 API 接口和数据模型。</li>\n<li>naming-core&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;naming: 实现了服务发现和注册的核心逻辑。</li>\n<li>naming-impl&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;naming: 实现了服务发现和注册的具体实现。</li>\n</ul>\n<p>下面简单介绍一下 Nacos 的服务发现和注册的实现流程。</p>\n<h4 id=\"服务注册流程\"><a href=\"#服务注册流程\" class=\"headerlink\" title=\"服务注册流程\"></a>服务注册流程</h4><p>服务提供者向 Nacos 注册服务时，会调用 NamingService.registerInstance() 方法，该方法会做以下几件事情：</p>\n<ol>\n<li>将服务实例的元数据封装为 Instance 对象，包括服务名、IP、端口号、健康状态、元数据等。</li>\n<li>将 Instance 对象转换为 InstanceEntity 对象，包含了实例 ID 和实例元数据的 JSON 字符串。</li>\n<li>将 InstanceEntity 对象存储到 Nacos 中，可以存储到内存中或者持久化到磁盘中。</li>\n</ol>\n<h4 id=\"服务发现流程\"><a href=\"#服务发现流程\" class=\"headerlink\" title=\"服务发现流程\"></a>服务发现流程</h4><p>服务消费者向 Nacos 发现服务时，会调用 NamingService.getAllInstances() 或 NamingService.selectInstances() 方法，该方法会做以下几件事情：</p>\n<ol>\n<li>从 Nacos 中获取服务实例的元数据，包括服务名、IP、端口号、健康状态、元数据等。</li>\n<li>将元数据封装为 Instance 对象，存储到本地缓存中。</li>\n<li>根据负载均衡算法选择一个服务实例处理请求，可以选择轮询、随机、权重等算法。</li>\n</ol>\n<p>服务发现和注册的核心逻辑在 naming-core 目录下的 com.alibaba.nacos.naming 包中实现，主要包括以下类：</p>\n<ul>\n<li>com.alibaba.nacos.naming.core.InstancesManager: 维护服务实例的元数据和状态信息。</li>\n<li>com.alibaba.nacos.naming.core.Cluster: 维护一个服务的所有实例信息和负载均衡策略。</li>\n<li>com.alibaba.nacos.naming.core.InstanceOperator: 实现了服务实例的注册、注销和更新操作。</li>\n<li>com.alibaba.nacos.naming.core.DomainsManager: 维护多个服务的信息，包括服务名、集群名、命名空间等。</li>\n</ul>\n<p>服务发现和注册的具体实现在 naming-impl 目录下的 com.alibaba.nacos.naming 包中，主要包括以下类：</p>\n<ul>\n<li>com.alibaba.nacos.naming.push.PushService: 实现了服务实例的推送功能。</li>\n<li>com.alibaba.nacos.naming.healthcheck.HealthCheckProcessor: 实现了服务实例的健康检查功能。</li>\n<li>com.alibaba.nacos.naming.misc.GlobalConfig: 存储了一些全局配置，例如默认权重值、心跳间隔</li>\n</ul>\n<h3 id=\"配置动态刷新\"><a href=\"#配置动态刷新\" class=\"headerlink\" title=\"配置动态刷新\"></a>配置动态刷新</h3><p>从远端服务器获取变更数据的主要模式有两种：推（push）和拉（pull）。Push 模式简单来说就是服务端主动将数据变更信息推送给客户端，这种模式优点是时效性好，服务端数据发生变更可以立马通知到客户端，但这种模式需要服务端维持与客户端的心跳连接，会增加服务端实现的复杂度，服务端也需要占用更多的资源来维持与客户端的连接。</p>\n<p>而 Pull 模式则是客户端主动去服务器请求数据，例如，每间隔10ms就向服务端发起请求获取数据。显而易见pull模式存在时效性问题。请求的间隔也不太好设置，间隔太短，对服务器请求压力过大。间隔时间过长，那么必然会造成时效性很差。而且如果配置长时间不更新，并且存在大量的客户端就会产生大量无效的pull请求。</p>\n<p>Nacos 没有采用上述的两种模式，而是采用了长轮询方式结合了推和拉的优点：</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/1.png\" alt=\"动态刷新图\"></p>\n<p>长轮询也是轮询，因此 Nacos 客户端会默认每10ms向服务端发起请求，当客户端请求服务端时会在请求头上携带长轮询的超时时间，默认是30s。而服务端接收到该请求时会hang住请求，为了防止客户端超时会在请求头携带的超时时间上减去500ms，因此默认会hang住请求29.5s。在这期间如果服务端发生了配置变更会产生相应的事件，监听到该事件后，会响应对应的客户端。这样一来客户端不会频繁发起轮询请求，而服务端也不需要维持与客户端的心跳，兼备了时效性和复杂度。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/2.png\" alt=\"长轮询图\"></p>\n<blockquote>\n<p>1.4版本nacos使用Http短连接+长轮询的方式，客户端发起http请求，服务端hold住请求，当配置变更时响应客户端，超时时间30s。<br>2.0版本nacos用gRPC长连接代替了http短连接长轮询。配置同步采用推拉结合的方式。</p>\n</blockquote>\n<h4 id=\"Nacos-Config-长轮询源码剖析\"><a href=\"#Nacos-Config-长轮询源码剖析\" class=\"headerlink\" title=\"Nacos Config 长轮询源码剖析\"></a>Nacos Config 长轮询源码剖析</h4><p>首先，打开 com.alibaba.cloud.nacos.NacosConfigBootstrapConfiguration 这个类，从类名也可以看出该类是Nacos Config的启动配置类，是Nacos Config自动装配的入口。在该类中的 nacosConfigManager 方法实例化了一个 NacosConfigManager 对象，并注册到容器中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingBean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> NacosConfigManager <span class=\"title function_\">nacosConfigManager</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">\t\tNacosConfigProperties nacosConfigProperties)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NacosConfigManager</span>(nacosConfigProperties);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 NacosConfigManager 的构造器中调用了 createConfigService 方法，这是一个静态方法用来创建 ConfigService 对象的单例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Compatible with old design,It will be perfected in the future.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> ConfigService <span class=\"title function_\">createConfigService</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">\t\tNacosConfigProperties nacosConfigProperties)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 双重检查锁模式的单例</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Objects.isNull(service)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (NacosConfigManager.class) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (Objects.isNull(service)) &#123;</span><br><span class=\"line\">\t\t\t\t\tservice = NacosFactory.createConfigService(</span><br><span class=\"line\">\t\t\t\t\t\t\tnacosConfigProperties.assembleConfigServiceProperties());</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">catch</span> (NacosException e) &#123;</span><br><span class=\"line\">\t\t\t\tlog.error(e.getMessage());</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NacosConnectionFailureException</span>(</span><br><span class=\"line\">\t\t\t\t\t\tnacosConfigProperties.getServerAddr(), e.getMessage(), e);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> service;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ConfigService 的具体实现是 NacosConfigService，在该类的构造器中主要初始化了 HttpAgent 和 ClientWorker 对象。ClientWorker 的构造器中则初始化了几个线程池：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ClientWorker</span><span class=\"params\">(<span class=\"keyword\">final</span> HttpAgent agent, <span class=\"keyword\">final</span> ConfigFilterChainManager configFilterChainManager,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"keyword\">final</span> Properties properties)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.agent = agent;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.configFilterChainManager = configFilterChainManager;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Initialize the timeout parameter</span></span><br><span class=\"line\">    init(properties);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建具有定时执行功能的单线程池，用于定时执行 checkConfigInfo 方法</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.executor = Executors.newScheduledThreadPool(<span class=\"number\">1</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadFactory</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Thread <span class=\"title function_\">newThread</span><span class=\"params\">(Runnable r)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(r);</span><br><span class=\"line\">            t.setName(<span class=\"string\">&quot;com.alibaba.nacos.client.Worker.&quot;</span> + agent.getName());</span><br><span class=\"line\">            t.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建具有定时执行功能的且线程数与cpu核数相对应的线程池，用于根据需要动态刷新的配置文件执行 LongPollingRunnable，因此长轮询任务是可以有多个并行的</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.executorService = Executors</span><br><span class=\"line\">            .newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadFactory</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> Thread <span class=\"title function_\">newThread</span><span class=\"params\">(Runnable r)</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(r);</span><br><span class=\"line\">                    t.setName(<span class=\"string\">&quot;com.alibaba.nacos.client.Worker.longPolling.&quot;</span> + agent.getName());</span><br><span class=\"line\">                    t.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"comment\">// 每10ms执行一次 checkConfigInfo 方法</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.executor.scheduleWithFixedDelay(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                checkConfigInfo();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                LOGGER.error(<span class=\"string\">&quot;[&quot;</span> + agent.getName() + <span class=\"string\">&quot;] [sub-check] rotate check error&quot;</span>, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"number\">1L</span>, <span class=\"number\">10L</span>, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">(Properties properties)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 长轮询的超时时间，默认为30秒，此参数会被放到请求头中带到服务端，服务端会根据该参数去做长轮询的hold</span></span><br><span class=\"line\">    timeout = Math.max(ConvertUtils.toInt(properties.getProperty(PropertyKeyConst.CONFIG_LONG_POLL_TIMEOUT),</span><br><span class=\"line\">            Constants.CONFIG_LONG_POLL_TIMEOUT), Constants.MIN_CONFIG_LONG_POLL_TIMEOUT);</span><br><span class=\"line\">    </span><br><span class=\"line\">    taskPenaltyTime = ConvertUtils</span><br><span class=\"line\">            .toInt(properties.getProperty(PropertyKeyConst.CONFIG_RETRY_TIME), Constants.CONFIG_RETRY_TIME);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.enableRemoteSyncConfig = Boolean</span><br><span class=\"line\">            .parseBoolean(properties.getProperty(PropertyKeyConst.ENABLE_REMOTE_SYNC_CONFIG));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Check config info.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkConfigInfo</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Dispatch taskes.</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取需要监听的文件数量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">listenerSize</span> <span class=\"operator\">=</span> cacheMap.size();</span><br><span class=\"line\">    <span class=\"comment\">// Round up the longingTaskCount.</span></span><br><span class=\"line\">    <span class=\"comment\">// 默认一个 LongPollingRunnable 可以处理监听3k个配置文件的变化，超过3k个才会创建新的 LongPollingRunnable</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">longingTaskCount</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) Math.ceil(listenerSize / ParamUtil.getPerTaskConfigSize());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (longingTaskCount &gt; currentLongingTaskCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) currentLongingTaskCount; i &lt; longingTaskCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The task list is no order.So it maybe has issues when changing.</span></span><br><span class=\"line\">            executorService.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">LongPollingRunnable</span>(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        currentLongingTaskCount = longingTaskCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LongPollingRunnable 类主要用于检查本地配置，以及长轮询地去服务端获取变更配置的 dataid 和 group，其代码位于 com.alibaba.nacos.client.config.impl.ClientWorker 类，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LongPollingRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> taskId;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LongPollingRunnable</span><span class=\"params\">(<span class=\"type\">int</span> taskId)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.taskId = taskId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        List&lt;CacheData&gt; cacheDatas = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;CacheData&gt;();</span><br><span class=\"line\">        List&lt;String&gt; inInitializingCacheList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// check failover config</span></span><br><span class=\"line\">            <span class=\"comment\">// 遍历本地缓存的配置</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (CacheData cacheData : cacheMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cacheData.getTaskId() == taskId) &#123;</span><br><span class=\"line\">                    cacheDatas.add(cacheData);</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 检查本地配置</span></span><br><span class=\"line\">                        checkLocalConfig(cacheData);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (cacheData.isUseLocalConfigInfo()) &#123;</span><br><span class=\"line\">                            cacheData.checkListenerMd5();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        LOGGER.error(<span class=\"string\">&quot;get local config info error&quot;</span>, e);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// check server config</span></span><br><span class=\"line\">            <span class=\"comment\">// 通过长轮询检查服务端配置</span></span><br><span class=\"line\">            List&lt;String&gt; changedGroupKeys = checkUpdateDataIds(cacheDatas, inInitializingCacheList);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!CollectionUtils.isEmpty(changedGroupKeys)) &#123;</span><br><span class=\"line\">                LOGGER.info(<span class=\"string\">&quot;get changedGroupKeys:&quot;</span> + changedGroupKeys);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String groupKey : changedGroupKeys) &#123;</span><br><span class=\"line\">                String[] key = GroupKey.parseKey(groupKey);</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">dataId</span> <span class=\"operator\">=</span> key[<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> key[<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">tenant</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key.length == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                    tenant = key[<span class=\"number\">2</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    String[] ct = getServerConfig(dataId, group, tenant, <span class=\"number\">3000L</span>);</span><br><span class=\"line\">                    <span class=\"type\">CacheData</span> <span class=\"variable\">cache</span> <span class=\"operator\">=</span> cacheMap.get(GroupKey.getKeyTenant(dataId, group, tenant));</span><br><span class=\"line\">                    cache.setContent(ct[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != ct[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                        cache.setType(ct[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    LOGGER.info(<span class=\"string\">&quot;[&#123;&#125;] [data-received] dataId=&#123;&#125;, group=&#123;&#125;, tenant=&#123;&#125;, md5=&#123;&#125;, content=&#123;&#125;, type=&#123;&#125;&quot;</span>,</span><br><span class=\"line\">                            agent.getName(), dataId, group, tenant, cache.getMd5(),</span><br><span class=\"line\">                            ContentUtils.truncateContent(ct[<span class=\"number\">0</span>]), ct[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (NacosException ioe) &#123;</span><br><span class=\"line\">                    <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> String</span><br><span class=\"line\">                            .format(<span class=\"string\">&quot;[%s] [get-update] get changed config exception. dataId=%s, group=%s, tenant=%s&quot;</span>,</span><br><span class=\"line\">                                    agent.getName(), dataId, group, tenant);</span><br><span class=\"line\">                    LOGGER.error(message, ioe);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (CacheData cacheData : cacheDatas) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!cacheData.isInitializing() || inInitializingCacheList</span><br><span class=\"line\">                        .contains(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant))) &#123;</span><br><span class=\"line\">                    cacheData.checkListenerMd5();</span><br><span class=\"line\">                    cacheData.setInitializing(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            inInitializingCacheList.clear();</span><br><span class=\"line\">            </span><br><span class=\"line\">            executorService.execute(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// If the rotation training task is abnormal, the next execution time of the task will be punished</span></span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">&quot;longPolling error : &quot;</span>, e);</span><br><span class=\"line\">            executorService.schedule(<span class=\"built_in\">this</span>, taskPenaltyTime, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面有个 checkUpdateDataIds 方法，用于获取发生变更了的配置文件的dataId列表，它同样位于 ClientWorker 内。如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Fetch the dataId list from server.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> cacheDatas              CacheDatas for config infomations.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> inInitializingCacheList initial cache lists.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> String include dataId and group (ps: it maybe null).</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> Exception Exception.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">List&lt;String&gt; <span class=\"title function_\">checkUpdateDataIds</span><span class=\"params\">(List&lt;CacheData&gt; cacheDatas, List&lt;String&gt; inInitializingCacheList)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 拼接出配置文件的唯一标识</span></span><br><span class=\"line\">    <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (CacheData cacheData : cacheDatas) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cacheData.isUseLocalConfigInfo()) &#123;</span><br><span class=\"line\">            sb.append(cacheData.dataId).append(WORD_SEPARATOR);</span><br><span class=\"line\">            sb.append(cacheData.group).append(WORD_SEPARATOR);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (StringUtils.isBlank(cacheData.tenant)) &#123;</span><br><span class=\"line\">                sb.append(cacheData.getMd5()).append(LINE_SEPARATOR);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                sb.append(cacheData.getMd5()).append(WORD_SEPARATOR);</span><br><span class=\"line\">                sb.append(cacheData.getTenant()).append(LINE_SEPARATOR);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cacheData.isInitializing()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// It updates when cacheData occours in cacheMap by first time.</span></span><br><span class=\"line\">                inInitializingCacheList</span><br><span class=\"line\">                        .add(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">isInitializingCacheList</span> <span class=\"operator\">=</span> !inInitializingCacheList.isEmpty();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> checkUpdateConfigStr(sb.toString(), isInitializingCacheList);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Fetch the updated dataId list from server.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> probeUpdateString       updated attribute string value.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> isInitializingCacheList initial cache lists.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> The updated dataId list(ps: it maybe null).</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> IOException Exception.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">List&lt;String&gt; <span class=\"title function_\">checkUpdateConfigStr</span><span class=\"params\">(String probeUpdateString, <span class=\"type\">boolean</span> isInitializingCacheList)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Map&lt;String, String&gt; params = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, String&gt;(<span class=\"number\">2</span>);</span><br><span class=\"line\">    params.put(Constants.PROBE_MODIFY_REQUEST, probeUpdateString);</span><br><span class=\"line\">    Map&lt;String, String&gt; headers = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, String&gt;(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 长轮询的超时时间</span></span><br><span class=\"line\">    headers.put(<span class=\"string\">&quot;Long-Pulling-Timeout&quot;</span>, <span class=\"string\">&quot;&quot;</span> + timeout);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// told server do not hang me up if new initializing cacheData added in</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isInitializingCacheList) &#123;</span><br><span class=\"line\">        headers.put(<span class=\"string\">&quot;Long-Pulling-Timeout-No-Hangup&quot;</span>, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(probeUpdateString)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// In order to prevent the server from handling the delay of the client&#x27;s long task,</span></span><br><span class=\"line\">        <span class=\"comment\">// increase the client&#x27;s read timeout to avoid this problem.</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">readTimeoutMs</span> <span class=\"operator\">=</span> timeout + (<span class=\"type\">long</span>) Math.round(timeout &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 向服务端发起一个http请求，该请求在服务端配置没有变更的情况下默认会hang住30s</span></span><br><span class=\"line\">        HttpRestResult&lt;String&gt; result = agent</span><br><span class=\"line\">                .httpPost(Constants.CONFIG_CONTROLLER_PATH + <span class=\"string\">&quot;/listener&quot;</span>, headers, params, agent.getEncode(),</span><br><span class=\"line\">                        readTimeoutMs);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result.ok()) &#123;</span><br><span class=\"line\">            setHealthServer(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 响应状态是成功则解析响应体得到 dataId、group、tenant 等信息并返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> parseUpdateDataIdResponse(result.getData());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            setHealthServer(<span class=\"literal\">false</span>);</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">&quot;[&#123;&#125;] [check-update] get changed dataId error, code: &#123;&#125;&quot;</span>, agent.getName(),</span><br><span class=\"line\">                    result.getCode());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        setHealthServer(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        LOGGER.error(<span class=\"string\">&quot;[&quot;</span> + agent.getName() + <span class=\"string\">&quot;] [check-update] get changed dataId exception&quot;</span>, e);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端对 listener 接口的请求会进入到服务端的 com.alibaba.nacos.config.server.controller.ConfigController#listener 方法进行处理，该方法主要是调用了 com.alibaba.nacos.config.server.controller.ConfigServletInner#doPollingConfig 方法。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 轮询接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">doPollingConfig</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class=\"line\"><span class=\"params\">                              Map&lt;String, String&gt; clientMd5Map, <span class=\"type\">int</span> probeRequestSize)</span></span><br><span class=\"line\">    <span class=\"keyword\">throws</span> IOException, ServletException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果支持长轮询则进入长轮询的流程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LongPollingService.isSupportLongPolling(request)) &#123;</span><br><span class=\"line\">        longPollingService.addLongPollingClient(request, response, clientMd5Map, probeRequestSize);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpServletResponse.SC_OK + <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// else 兼容短轮询逻辑</span></span><br><span class=\"line\">    List&lt;String&gt; changedGroups = MD5Util.compareMd5(request, response, clientMd5Map);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 兼容短轮询result</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">oldResult</span> <span class=\"operator\">=</span> MD5Util.compareMd5OldResult(changedGroups);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">newResult</span> <span class=\"operator\">=</span> MD5Util.compareMd5ResultString(changedGroups);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">version</span> <span class=\"operator\">=</span> request.getHeader(Constants.CLIENT_VERSION_HEADER);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (version == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        version = <span class=\"string\">&quot;2.0.0&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">versionNum</span> <span class=\"operator\">=</span> Protocol.getVersionNumber(version);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.0.4版本以前, 返回值放入header中</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (versionNum &lt; START_LONGPOLLING_VERSION_NUM) &#123;</span><br><span class=\"line\">        response.addHeader(Constants.PROBE_MODIFY_RESPONSE, oldResult);</span><br><span class=\"line\">        response.addHeader(Constants.PROBE_MODIFY_RESPONSE_NEW, newResult);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        request.setAttribute(<span class=\"string\">&quot;content&quot;</span>, newResult);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 禁用缓存</span></span><br><span class=\"line\">    response.setHeader(<span class=\"string\">&quot;Pragma&quot;</span>, <span class=\"string\">&quot;no-cache&quot;</span>);</span><br><span class=\"line\">    response.setDateHeader(<span class=\"string\">&quot;Expires&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    response.setHeader(<span class=\"string\">&quot;Cache-Control&quot;</span>, <span class=\"string\">&quot;no-cache,no-store&quot;</span>);</span><br><span class=\"line\">    response.setStatus(HttpServletResponse.SC_OK);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpServletResponse.SC_OK + <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们主要关注上面的 com.alibaba.nacos.config.server.service.LongPollingService#addLongPollingClient 长轮询流程的方法。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addLongPollingClient</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse rsp, Map&lt;String, String&gt; clientMd5Map,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">int</span> probeRequestSize)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> req.getHeader(LongPollingService.LONG_POLLING_HEADER);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">noHangUpFlag</span> <span class=\"operator\">=</span> req.getHeader(LongPollingService.LONG_POLLING_NO_HANG_UP_HEADER);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">appName</span> <span class=\"operator\">=</span> req.getHeader(RequestUtil.CLIENT_APPNAME_HEADER);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">tag</span> <span class=\"operator\">=</span> req.getHeader(<span class=\"string\">&quot;Vipserver-Tag&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">delayTime</span> <span class=\"operator\">=</span> SwitchService.getSwitchInteger(SwitchService.FIXED_DELAY_TIME, <span class=\"number\">500</span>);</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 提前500ms返回响应，为避免客户端超时 <span class=\"doctag\">@qiaoyi</span>.dingqy 2013.10.22改动  add delay time for LoadBalance</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">timeout</span> <span class=\"operator\">=</span> Math.max(<span class=\"number\">10000</span>, Long.parseLong(str) - delayTime);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isFixedPolling()) &#123;</span><br><span class=\"line\">        timeout = Math.max(<span class=\"number\">10000</span>, getFixedPollingInterval());</span><br><span class=\"line\">        <span class=\"comment\">// do nothing but set fix polling timeout</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        List&lt;String&gt; changedGroups = MD5Util.compareMd5(req, rsp, clientMd5Map);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (changedGroups.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            generateResponse(req, rsp, changedGroups);</span><br><span class=\"line\">            LogUtil.clientLog.info(<span class=\"string\">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class=\"line\">                System.currentTimeMillis() - start, <span class=\"string\">&quot;instant&quot;</span>, RequestUtil.getRemoteIp(req), <span class=\"string\">&quot;polling&quot;</span>,</span><br><span class=\"line\">                clientMd5Map.size(), probeRequestSize, changedGroups.size());</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (noHangUpFlag != <span class=\"literal\">null</span> &amp;&amp; noHangUpFlag.equalsIgnoreCase(TRUE_STR)) &#123;</span><br><span class=\"line\">            LogUtil.clientLog.info(<span class=\"string\">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>, System.currentTimeMillis() - start, <span class=\"string\">&quot;nohangup&quot;</span>,</span><br><span class=\"line\">                RequestUtil.getRemoteIp(req), <span class=\"string\">&quot;polling&quot;</span>, clientMd5Map.size(), probeRequestSize,</span><br><span class=\"line\">                changedGroups.size());</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ip</span> <span class=\"operator\">=</span> RequestUtil.getRemoteIp(req);</span><br><span class=\"line\">    <span class=\"comment\">// 一定要由HTTP线程调用，否则离开后容器会立即发送响应</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">AsyncContext</span> <span class=\"variable\">asyncContext</span> <span class=\"operator\">=</span> req.startAsync();</span><br><span class=\"line\">    <span class=\"comment\">// AsyncContext.setTimeout()的超时时间不准，所以只能自己控制</span></span><br><span class=\"line\">    asyncContext.setTimeout(<span class=\"number\">0L</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 在 ClientLongPolling 的 run 方法会将 ClientLongPolling 实例（携带了本次请求的相关信息）放入 allSubs 中，然后会在29.5s后再执行另一个 Runnable，该 Runnable 用于等待29.5s后依旧没有相应的配置变更时对客户端进行响应，并将相应的 ClientLongPolling 实例从 allSubs 中移出</span></span><br><span class=\"line\">    scheduler.execute(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ClientLongPolling</span>(asyncContext, clientMd5Map, ip, probeRequestSize, timeout, appName, tag));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而 LongPollingService 实现了 AbstractEventListener，也就是说能接收事件通知，在其 com.alibaba.nacos.config.server.service.LongPollingService#onEvent 方法中可以看到，它关注的是 LocalDataChangeEvent 事件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onEvent</span><span class=\"params\">(Event event)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isFixedPolling()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ignore</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (event <span class=\"keyword\">instanceof</span> LocalDataChangeEvent) &#123;</span><br><span class=\"line\">            <span class=\"type\">LocalDataChangeEvent</span> <span class=\"variable\">evt</span> <span class=\"operator\">=</span> (LocalDataChangeEvent)event;</span><br><span class=\"line\">            scheduler.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">DataChangeTask</span>(evt.groupKey, evt.isBeta, evt.betaIps));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在nacos上修改配置后就会产生 LocalDataChangeEvent 事件，此时 LongPollingService 也就能监听到，当收到该事件时就会遍历 allSubs，找到匹配的请求并将 groupKey 返回给客户端。具体代码在 DataChangeTask 中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DataChangeTask</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ConfigService.getContentBetaMd5(groupKey);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;ClientLongPolling&gt; iter = allSubs.iterator(); iter.hasNext(); ) &#123;</span><br><span class=\"line\">                <span class=\"type\">ClientLongPolling</span> <span class=\"variable\">clientSub</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (clientSub.clientMd5Map.containsKey(groupKey)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果beta发布且不在beta列表直接跳过</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (isBeta &amp;&amp; !betaIps.contains(clientSub.ip)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 如果tag发布且不在tag列表直接跳过</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (StringUtils.isNotBlank(tag) &amp;&amp; !tag.equals(clientSub.tag)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    getRetainIps().put(clientSub.ip, System.currentTimeMillis());</span><br><span class=\"line\">                    iter.remove(); <span class=\"comment\">// 删除订阅关系</span></span><br><span class=\"line\">                    LogUtil.clientLog.info(<span class=\"string\">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class=\"line\">                        (System.currentTimeMillis() - changeTime),</span><br><span class=\"line\">                        <span class=\"string\">&quot;in-advance&quot;</span>,</span><br><span class=\"line\">                        RequestUtil.getRemoteIp((HttpServletRequest)clientSub.asyncContext.getRequest()),</span><br><span class=\"line\">                        <span class=\"string\">&quot;polling&quot;</span>,</span><br><span class=\"line\">                        clientSub.clientMd5Map.size(), clientSub.probeRequestSize, groupKey);</span><br><span class=\"line\">                    clientSub.sendResponse(Arrays.asList(groupKey));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            LogUtil.defaultLog.error(<span class=\"string\">&quot;data change error:&quot;</span> + t.getMessage(), t.getCause());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    DataChangeTask(String groupKey) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(groupKey, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    DataChangeTask(String groupKey, <span class=\"type\">boolean</span> isBeta, List&lt;String&gt; betaIps) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(groupKey, isBeta, betaIps, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    DataChangeTask(String groupKey, <span class=\"type\">boolean</span> isBeta, List&lt;String&gt; betaIps, String tag) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.groupKey = groupKey;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.isBeta = isBeta;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.betaIps = betaIps;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.tag = tag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String groupKey;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">changeTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> isBeta;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> List&lt;String&gt; betaIps;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String tag;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当客户端收到变更的dataid+group后，就会去服务端获取最新的配置数据，并更新本地数据 cacheData，然后发送数据变更事件，整个流程结束。</p>\n<ul>\n<li>获取服务端最新配置数据的方法：com.alibaba.nacos.client.config.impl.ClientWorker#getServerConfig</li>\n<li>发送数据变更事件的方法：com.alibaba.nacos.client.config.impl.CacheData#checkListenerMd5</li>\n</ul>\n<h2 id=\"Sentienl\"><a href=\"#Sentienl\" class=\"headerlink\" title=\"Sentienl\"></a>Sentienl</h2><p>Sentinel是阿里巴巴开源的一款流量控制和熔断降级框架，主要用于微服务架构中服务的流量控制和熔断降级。其限流实现原理主要分为两个部分：</p>\n<blockquote>\n<p>统计信息收集</p>\n</blockquote>\n<p>Sentinel会在运行过程中对服务的各种统计信息进行收集，包括请求的响应时间、请求通过的QPS（每秒查询率）、线程池队列大小等指标。这些指标通过定义的规则进行分析，判断当前请求是否超过了设定的阈值。</p>\n<blockquote>\n<p>阈值判断</p>\n</blockquote>\n<p>Sentinel根据收集到的统计信息，通过定义的规则对请求进行判断。规则中包括以下几个要素：</p>\n<p>资源名：对哪个资源进行限流<br>流控模式：直接拒绝或者匀速通过<br>流控阈值：单位时间内允许通过的请求个数<br>统计时间窗口：多长时间内统计一次流量，单位秒<br>降级处理：当请求超过阈值时的处理策略，如直接拒绝、返回默认值等<br>Sentinel会根据以上规则进行限流，当请求超过阈值时，根据设置的降级处理策略进行处理，比如直接拒绝请求、返回默认值等。同时，Sentinel还可以进行自适应的流控，根据实际情况调整阈值，保证服务的可用性和稳定性。</p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><h4 id=\"Slot-插槽\"><a href=\"#Slot-插槽\" class=\"headerlink\" title=\"Slot 插槽\"></a>Slot 插槽</h4><p>在 Sentinel 里面，所有的资源都对应一个资源名称（resourceName），每次资源调用都会创建一个 Entry 对象。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 SphU API 显式创建。Entry 创建的时候，同时也会创建一系列功能插槽（slot chain），这些插槽有不同的职责，例如:</p>\n<ul>\n<li>NodeSelectorSlot 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</li>\n<li>ClusterBuilderSlot 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；</li>\n<li>StatisticSlot 则用于记录、统计不同纬度的 runtime 指标监控信息；</li>\n<li>FlowSlot 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；</li>\n<li>AuthoritySlot 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li>\n<li>DegradeSlot 则通过统计信息以及预设的规则，来做熔断降级；</li>\n<li>SystemSlot 则通过系统的状态，例如 load1 等，来控制总的入口流量；</li>\n</ul>\n<p>Sentinel 提供了插槽接口 ProcessorSlot，其中提供了方法 enrty 处理进入请求 和 exit 处理请求结束操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ProcessorSlot</span>&lt;T&gt; &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Entrance of this slot.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context         current &#123;<span class=\"doctag\">@link</span> Context&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> resourceWrapper current resource</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> param           generics parameter, usually is a &#123;<span class=\"doctag\">@link</span> com.alibaba.csp.sentinel.node.Node&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count           tokens needed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> prioritized     whether the entry is prioritized</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args            parameters of the original call</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable blocked exception or unexpected error</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">entry</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, T param, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized,</span></span><br><span class=\"line\"><span class=\"params\">               Object... args)</span> <span class=\"keyword\">throws</span> Throwable;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Means finish of &#123;<span class=\"doctag\">@link</span> #entry(Context, ResourceWrapper, Object, int, boolean, Object...)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context         current &#123;<span class=\"doctag\">@link</span> Context&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> resourceWrapper current resource</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> obj             relevant object (e.g. Node)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count           tokens needed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> prioritized     whether the entry is prioritized</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args            parameters of the original call</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable blocked exception or unexpected error</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">fireEntry</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, Object obj, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized,</span></span><br><span class=\"line\"><span class=\"params\">                   Object... args)</span> <span class=\"keyword\">throws</span> Throwable;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Exit of this slot.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context         current &#123;<span class=\"doctag\">@link</span> Context&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> resourceWrapper current resource</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count           tokens needed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args            parameters of the original call</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">exit</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, <span class=\"type\">int</span> count, Object... args)</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Means finish of &#123;<span class=\"doctag\">@link</span> #exit(Context, ResourceWrapper, int, Object...)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context         current &#123;<span class=\"doctag\">@link</span> Context&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> resourceWrapper current resource</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count           tokens needed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args            parameters of the original call</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">fireExit</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, <span class=\"type\">int</span> count, Object... args)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总体的框架如下:</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/3.png\" alt=\"结构图\"></p>\n<p>Sentinel 将 SlotChainBuilder 作为 SPI 接口进行扩展，使得 Slot Chain 具备了扩展的能力。您可以自行加入自定义的 slot 并编排 slot 间的顺序，从而可以给 Sentinel 添加自定义的功能。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/4.png\" alt=\"Sentinel图\"></p>\n<h4 id=\"RuleManager-规则管理器\"><a href=\"#RuleManager-规则管理器\" class=\"headerlink\" title=\"RuleManager 规则管理器\"></a>RuleManager 规则管理器</h4><p>每个 Slot 插槽背后都对应着一个 RuleManager 的实现类，简单理解就是每个 Slot 有一套规则，规则验证处理由对应的 RuleManager 来进行处理。</p>\n<p>流量控制：FlowSolt 对应 FlowRuleManager</p>\n<p>降级控制：DegradeSlot  对应 DegradeRuleManager</p>\n<p>权限控制：AuthoritySlot 对应 AuthorityRuleManager</p>\n<p>系统规则控制： SystemSlot 对应 SystemRuleManager</p>\n<h4 id=\"降级控制实现原理\"><a href=\"#降级控制实现原理\" class=\"headerlink\" title=\"降级控制实现原理\"></a>降级控制实现原理</h4><ol>\n<li>新增资源配置降级规则，目前对于降级策有如下三种：</li>\n</ol>\n<p>RT：平均响应时间 (DEGRADE_GRADE_RT)：当 1s 内持续进入 5 个请求，对应时刻的平均响应时间（秒级）均超过阈值（count，以 ms 为单位），那么在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt&#x3D;xxx 来配置。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/5.png\" alt=\"平均响应图\"></p>\n<p>异常比例：当资源的每秒请求量 &gt;&#x3D; 5，并且每秒异常总数占通过量的比值超过阈值（DegradeRule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/6.png\" alt=\"异常比例图\"></p>\n<p>异常数：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/7.png\" alt=\"异常数图\"></p>\n<p>限流结果信息</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">Blocked by Sentinel (flow limiting)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>实现逻辑</li>\n</ol>\n<p>在之前我们已经提及 Sentinel 是通过 slot 链来实现的，对于降级功能其提供了 DegradeSlot，实现源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DegradeSlot</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLinkedProcessorSlot</span>&lt;DefaultNode&gt; &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">entry</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized, Object... args)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        DegradeRuleManager.checkDegrade(resourceWrapper, context, node, count);</span><br><span class=\"line\">        fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">exit</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, <span class=\"type\">int</span> count, Object... args)</span> &#123;</span><br><span class=\"line\">        fireExit(context, resourceWrapper, count, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上面代码我们可以了解到，限流规则的实现是在 DegradeRuleManager 的checkDegrade中来处理的，限流可以-配置多个规则，依次按照规则来处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkDegrade</span><span class=\"params\">(ResourceWrapper resource, Context context, DefaultNode node, <span class=\"type\">int</span> count)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> BlockException &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">        Set&lt;DegradeRule&gt; rules = degradeRules.get(resource.getName());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rules == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (DegradeRule rule : rules) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!rule.passCheck(context, node, count)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DegradeException</span>(rule.getLimitApp(), rule);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在 DegradeRule 的 passCheck 方法中我们可以看到可以根据 RT、异常数和异常比例来进行熔断降级处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">passCheck</span><span class=\"params\">(Context context, DefaultNode node, <span class=\"type\">int</span> acquireCount, Object... args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cut.get()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"type\">ClusterNode</span> <span class=\"variable\">clusterNode</span> <span class=\"operator\">=</span> ClusterBuilderSlot.getClusterNode(<span class=\"built_in\">this</span>.getResource());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (clusterNode == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t<span class=\"comment\">// 请求处理时间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (grade == RuleConstant.DEGRADE_GRADE_RT) &#123;</span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">rt</span> <span class=\"operator\">=</span> clusterNode.avgRt();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rt &lt; <span class=\"built_in\">this</span>.count) &#123;</span><br><span class=\"line\">                passCount.set(<span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"comment\">// Sentinel will degrade the service only if count exceeds.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (passCount.incrementAndGet() &lt; rtSlowRequestAmount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//异常比例</span></span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">exception</span> <span class=\"operator\">=</span> clusterNode.exceptionQps();</span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> clusterNode.successQps();</span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">total</span> <span class=\"operator\">=</span> clusterNode.totalQps();</span><br><span class=\"line\">            <span class=\"comment\">// If total amount is less than minRequestAmount, the request will pass.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (total &lt; minRequestAmount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"comment\">// In the same aligned statistic time window,</span></span><br><span class=\"line\">            <span class=\"comment\">// &quot;success&quot; (aka. completed count) = exception count + non-exception count (realSuccess)</span></span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">realSuccess</span> <span class=\"operator\">=</span> success - exception;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (realSuccess &lt;= <span class=\"number\">0</span> &amp;&amp; exception &lt; minRequestAmount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (exception / success &lt; count) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//异常数</span></span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">exception</span> <span class=\"operator\">=</span> clusterNode.totalException();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (exception &lt; count) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cut.compareAndSet(<span class=\"literal\">false</span>, <span class=\"literal\">true</span>)) &#123;</span><br><span class=\"line\">            <span class=\"type\">ResetTask</span> <span class=\"variable\">resetTask</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResetTask</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">            pool.schedule(resetTask, timeWindow, TimeUnit.SECONDS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"流量控制实现原理\"><a href=\"#流量控制实现原理\" class=\"headerlink\" title=\"流量控制实现原理\"></a>流量控制实现原理</h4><p>接下来我们了解学习一下 Sentinel 是如何实现流量控制的</p>\n<p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。</p>\n<p>FlowSlot 会根据预设的规则，结合前面 NodeSelectorSlot、ClusterNodeBuilderSlot、StatisticSlot 统计出来的实时信息进行流量控制。</p>\n<p>限流的直接表现是在执行 Entry nodeA &#x3D; SphU.entry(resourceName) 的时候抛出 FlowException 异常。FlowException 是 BlockException 的子类，您可以捕捉 BlockException 来自定义被限流之后的处理逻辑。</p>\n<p>同一个资源可以创建多条限流规则。FlowSlot 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。</p>\n<p>一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：</p>\n<ul>\n<li>resource：资源名，即限流规则的作用对象</li>\n<li>count: 限流阈值</li>\n<li>grade: 限流阈值类型（QPS 或并发线程数）</li>\n<li>limitApp: 流控针对的调用来源，若为 default 则不区分调用来源</li>\n<li>strategy: 调用关系限流策略</li>\n<li>controlBehavior: 流量控制效果（直接拒绝、Warm Up、匀速排队）</li>\n</ul>\n<p>流控-QPS配置</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/8.png\" alt=\"QPS配置图\"></p>\n<p>流控-线程数配置</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/9.png\" alt=\"流控图\"></p>\n<h5 id=\"实现流程\"><a href=\"#实现流程\" class=\"headerlink\" title=\"实现流程\"></a>实现流程</h5><p>Sentinel 提供了 FlowSlot 用来进行流量控制，流量规则的最终实现在 FlowRuleChecker 的 checkFlow 中实现的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FlowSlot</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLinkedProcessorSlot</span>&lt;DefaultNode&gt; &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FlowRuleChecker checker;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FlowSlot</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FlowRuleChecker</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Package-private for test.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> checker flow rule checker</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 1.6.1</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    FlowSlot(FlowRuleChecker checker) &#123;</span><br><span class=\"line\">        AssertUtil.notNull(checker, <span class=\"string\">&quot;flow checker should not be null&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.checker = checker;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">entry</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class=\"type\">int</span> count,</span></span><br><span class=\"line\"><span class=\"params\">                      <span class=\"type\">boolean</span> prioritized, Object... args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        checkFlow(resourceWrapper, context, node, count, prioritized);</span><br><span class=\"line\"> </span><br><span class=\"line\">        fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">checkFlow</span><span class=\"params\">(ResourceWrapper resource, Context context, DefaultNode node, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> BlockException &#123;</span><br><span class=\"line\">        checker.checkFlow(ruleProvider, resource, context, node, count, prioritized);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">exit</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, <span class=\"type\">int</span> count, Object... args)</span> &#123;</span><br><span class=\"line\">        fireExit(context, resourceWrapper, count, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Function&lt;String, Collection&lt;FlowRule&gt;&gt; ruleProvider = <span class=\"keyword\">new</span> <span class=\"title class_\">Function</span>&lt;String, Collection&lt;FlowRule&gt;&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Collection&lt;FlowRule&gt; <span class=\"title function_\">apply</span><span class=\"params\">(String resource)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Flow rule map should not be null.</span></span><br><span class=\"line\">            Map&lt;String, List&lt;FlowRule&gt;&gt; flowRules = FlowRuleManager.getFlowRuleMap();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> flowRules.get(resource);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 checkFlow 中会依次获取我们配置的流控规则，然后依次进行流控判断处理，如果被流控则抛出异常 FlowException</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkFlow</span><span class=\"params\">(Function&lt;String, Collection&lt;FlowRule&gt;&gt; ruleProvider, ResourceWrapper resource,</span></span><br><span class=\"line\"><span class=\"params\">                          Context context, DefaultNode node, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized)</span> <span class=\"keyword\">throws</span> BlockException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ruleProvider == <span class=\"literal\">null</span> || resource == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Collection&lt;FlowRule&gt; rules = ruleProvider.apply(resource.getName());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rules != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (FlowRule rule : rules) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!canPassCheck(rule, context, node, count, prioritized)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FlowException</span>(rule.getLimitApp(), rule);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在 canPassCheck 中会判断是集群限流还是本地限流</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPassCheck</span><span class=\"params\">(<span class=\"comment\">/*@NonNull*/</span> FlowRule rule, Context context, DefaultNode node, <span class=\"type\">int</span> acquireCount,</span></span><br><span class=\"line\"><span class=\"params\">                                                    <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">limitApp</span> <span class=\"operator\">=</span> rule.getLimitApp();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (limitApp == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rule.isClusterMode()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> passClusterCheck(rule, context, node, acquireCount, prioritized);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> passLocalCheck(rule, context, node, acquireCount, prioritized);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>如果是本地限流则获取节点信息，然后根据流控规则进行流控判断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">passLocalCheck</span><span class=\"params\">(FlowRule rule, Context context, DefaultNode node, <span class=\"type\">int</span> acquireCount,</span></span><br><span class=\"line\"><span class=\"params\">                                          <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">selectedNode</span> <span class=\"operator\">=</span> selectNodeByRequesterAndStrategy(rule, context, node);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedNode == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> rule.getRater().canPass(selectedNode, acquireCount, prioritized);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>当 QPS 超过某个阈值的时候，则采取措施进行流量控制。流量控制的手段包括以下几种：直接拒绝、Warm Up、匀速排队。对应 FlowRule 中的 controlBehavior 字段。</p>\n<p>直接拒绝（RuleConstant.CONTROL_BEHAVIOR_DEFAULT）方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。具体的例子参见 FlowQpsDemo。</p>\n<p>Warm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）方式，即预热&#x2F;冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。详细文档可以参考 流量控制 - Warm Up 文档</p>\n<p>目前 Sentinel 对于流量控制提供了如下几种方式：</p>\n<ul>\n<li>直接拒绝（DefaultController）：支持抛出异常<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPass</span><span class=\"params\">(Node node, <span class=\"type\">int</span> acquireCount, <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">curCount</span> <span class=\"operator\">=</span> avgUsedTokens(node);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curCount + acquireCount &gt; count) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prioritized &amp;&amp; grade == RuleConstant.FLOW_GRADE_QPS) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> currentTime;</span><br><span class=\"line\">            <span class=\"type\">long</span> waitInMs;</span><br><span class=\"line\">            currentTime = TimeUtil.currentTimeMillis();</span><br><span class=\"line\">            waitInMs = node.tryOccupyNext(currentTime, acquireCount, count);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitInMs &lt; OccupyTimeoutProperty.getOccupyTimeout()) &#123;</span><br><span class=\"line\">                node.addWaitingRequest(currentTime + waitInMs, acquireCount);</span><br><span class=\"line\">                node.addOccupiedPass(acquireCount);</span><br><span class=\"line\">                sleep(waitInMs);</span><br><span class=\"line\"> </span><br><span class=\"line\">                <span class=\"comment\">// PriorityWaitException indicates that the request will pass after waiting for &#123;@link @waitInMs&#125;.</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityWaitException</span>(waitInMs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>匀速排队（RateLimiterController）：判断等待时间，如果等待时间过长也是会限流，并且使用 Thread.sleep 如果配置不正确可能会导致线程过多。<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPass</span><span class=\"params\">(Node node, <span class=\"type\">int</span> acquireCount, <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Pass when acquire count is less or equal than 0.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (acquireCount &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Reject when count is less or equal than 0.</span></span><br><span class=\"line\">        <span class=\"comment\">// Otherwise,the costTime will be max of long and waitTime will overflow in some cases.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">currentTime</span> <span class=\"operator\">=</span> TimeUtil.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"comment\">// Calculate the interval between every two requests.</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">costTime</span> <span class=\"operator\">=</span> Math.round(<span class=\"number\">1.0</span> * (acquireCount) / count * <span class=\"number\">1000</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// Expected pass time of this request.</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">expectedTime</span> <span class=\"operator\">=</span> costTime + latestPassedTime.get();</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (expectedTime &lt;= currentTime) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Contention may exist here, but it&#x27;s okay.</span></span><br><span class=\"line\">            latestPassedTime.set(currentTime);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Calculate the time to wait.</span></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">waitTime</span> <span class=\"operator\">=</span> costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">long</span> <span class=\"variable\">oldTime</span> <span class=\"operator\">=</span> latestPassedTime.addAndGet(costTime);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    waitTime = oldTime - TimeUtil.currentTimeMillis();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class=\"line\">                        latestPassedTime.addAndGet(-costTime);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// in race condition waitTime may &lt;= 0</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (waitTime &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        Thread.sleep(waitTime);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n<li>Warm Up（WarmUpController 和 WarmUpRateLimiterController）：预热启动<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPass</span><span class=\"params\">(Node node, <span class=\"type\">int</span> acquireCount, <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">passQps</span> <span class=\"operator\">=</span> (<span class=\"type\">long</span>) node.passQps();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">previousQps</span> <span class=\"operator\">=</span> (<span class=\"type\">long</span>) node.previousPassQps();</span><br><span class=\"line\">    syncToken(previousQps);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 开始计算它的斜率</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果进入了警戒线，开始调整他的qps</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">restToken</span> <span class=\"operator\">=</span> storedTokens.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (restToken &gt;= warningToken) &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">aboveToken</span> <span class=\"operator\">=</span> restToken - warningToken;</span><br><span class=\"line\">        <span class=\"comment\">// 消耗的速度要比warning快，但是要比慢</span></span><br><span class=\"line\">        <span class=\"comment\">// current interval = restToken*slope+1/count</span></span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">warningQps</span> <span class=\"operator\">=</span> Math.nextUp(<span class=\"number\">1.0</span> / (aboveToken * slope + <span class=\"number\">1.0</span> / count));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (passQps + acquireCount &lt;= warningQps) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (passQps + acquireCount &lt;= count) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","cover":"/img/hubian.png","cover_type":"img","excerpt":"","more":"<p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p>\n<p>Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>\n<h2 id=\"服务注册与发现\"><a href=\"#服务注册与发现\" class=\"headerlink\" title=\"服务注册与发现\"></a>服务注册与发现</h2><h3 id=\"eureka\"><a href=\"#eureka\" class=\"headerlink\" title=\"eureka\"></a>eureka</h3><p>服务治理组件，包括服务端的注册中心和客户端的服务发现机制；</p>\n<h3 id=\"consul\"><a href=\"#consul\" class=\"headerlink\" title=\"consul\"></a>consul</h3><p>基于Hashicorp Consul的服务治理组件。</p>\n<h2 id=\"服务负载与均衡\"><a href=\"#服务负载与均衡\" class=\"headerlink\" title=\"服务负载与均衡\"></a>服务负载与均衡</h2><h3 id=\"ribbon\"><a href=\"#ribbon\" class=\"headerlink\" title=\"ribbon\"></a>ribbon</h3><p>负载均衡的服务调用组件，具有多种负载均衡调用策略；</p>\n<h3 id=\"loadbalancer\"><a href=\"#loadbalancer\" class=\"headerlink\" title=\"loadbalancer\"></a>loadbalancer</h3><h2 id=\"服务负载与调用\"><a href=\"#服务负载与调用\" class=\"headerlink\" title=\"服务负载与调用\"></a>服务负载与调用</h2><h3 id=\"feign\"><a href=\"#feign\" class=\"headerlink\" title=\"feign\"></a>feign</h3><p>基于Ribbon和Hystrix的声明式服务调用组件；</p>\n<h3 id=\"openFeign\"><a href=\"#openFeign\" class=\"headerlink\" title=\"openFeign\"></a>openFeign</h3><p>基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。</p>\n<h2 id=\"服务熔断与降级\"><a href=\"#服务熔断与降级\" class=\"headerlink\" title=\"服务熔断与降级\"></a>服务熔断与降级</h2><h3 id=\"hystrix\"><a href=\"#hystrix\" class=\"headerlink\" title=\"hystrix\"></a>hystrix</h3><p>服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；</p>\n<h3 id=\"resilience4j\"><a href=\"#resilience4j\" class=\"headerlink\" title=\"resilience4j\"></a>resilience4j</h3><h2 id=\"服务网关\"><a href=\"#服务网关\" class=\"headerlink\" title=\"服务网关\"></a>服务网关</h2><h3 id=\"zuul\"><a href=\"#zuul\" class=\"headerlink\" title=\"zuul\"></a>zuul</h3><p>API网关组件，对请求提供路由及过滤功能。</p>\n<h3 id=\"zuul2\"><a href=\"#zuul2\" class=\"headerlink\" title=\"zuul2\"></a>zuul2</h3><h3 id=\"getway\"><a href=\"#getway\" class=\"headerlink\" title=\"getway\"></a>getway</h3><p>API网关组件，对请求提供路由及过滤功能。</p>\n<h2 id=\"服务分布式配置\"><a href=\"#服务分布式配置\" class=\"headerlink\" title=\"服务分布式配置\"></a>服务分布式配置</h2><h3 id=\"springcloud-config\"><a href=\"#springcloud-config\" class=\"headerlink\" title=\"springcloud config\"></a>springcloud config</h3><p>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</p>\n<h3 id=\"Nacos\"><a href=\"#Nacos\" class=\"headerlink\" title=\"Nacos\"></a>Nacos</h3><h2 id=\"总线\"><a href=\"#总线\" class=\"headerlink\" title=\"总线\"></a>总线</h2><h3 id=\"Spring-Cloud-Bus\"><a href=\"#Spring-Cloud-Bus\" class=\"headerlink\" title=\"Spring Cloud Bus\"></a>Spring Cloud Bus</h3><p>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。</p>\n<h1 id=\"springcloudAlibaba\"><a href=\"#springcloudAlibaba\" class=\"headerlink\" title=\"springcloudAlibaba\"></a>springcloudAlibaba</h1><h2 id=\"Nacos-1\"><a href=\"#Nacos-1\" class=\"headerlink\" title=\"Nacos\"></a>Nacos</h2><p>Nacos 是一个开源的分布式系统服务发现、配置管理和服务管理平台。它主要包含以下功能：</p>\n<p>服务发现与注册：Nacos 可以管理服务的注册和发现，支持 DNS 和 HTTP&#x2F;RESTful 方式。<br>配置管理：Nacos 可以动态管理配置，支持多种数据类型和版本控制。<br>服务管理：Nacos 可以对服务进行健康检查、流量管理、负载均衡等。</p>\n<h3 id=\"服务发现与注册\"><a href=\"#服务发现与注册\" class=\"headerlink\" title=\"服务发现与注册\"></a>服务发现与注册</h3><p>Nacos 实现服务发现和注册的核心代码位于 nacos&#x2F;naming 目录下，包括以下文件：</p>\n<ul>\n<li>naming-common&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;api&#x2F;naming: 定义了服务发现和注册的 API 接口和数据模型。</li>\n<li>naming-core&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;naming: 实现了服务发现和注册的核心逻辑。</li>\n<li>naming-impl&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;alibaba&#x2F;nacos&#x2F;naming: 实现了服务发现和注册的具体实现。</li>\n</ul>\n<p>下面简单介绍一下 Nacos 的服务发现和注册的实现流程。</p>\n<h4 id=\"服务注册流程\"><a href=\"#服务注册流程\" class=\"headerlink\" title=\"服务注册流程\"></a>服务注册流程</h4><p>服务提供者向 Nacos 注册服务时，会调用 NamingService.registerInstance() 方法，该方法会做以下几件事情：</p>\n<ol>\n<li>将服务实例的元数据封装为 Instance 对象，包括服务名、IP、端口号、健康状态、元数据等。</li>\n<li>将 Instance 对象转换为 InstanceEntity 对象，包含了实例 ID 和实例元数据的 JSON 字符串。</li>\n<li>将 InstanceEntity 对象存储到 Nacos 中，可以存储到内存中或者持久化到磁盘中。</li>\n</ol>\n<h4 id=\"服务发现流程\"><a href=\"#服务发现流程\" class=\"headerlink\" title=\"服务发现流程\"></a>服务发现流程</h4><p>服务消费者向 Nacos 发现服务时，会调用 NamingService.getAllInstances() 或 NamingService.selectInstances() 方法，该方法会做以下几件事情：</p>\n<ol>\n<li>从 Nacos 中获取服务实例的元数据，包括服务名、IP、端口号、健康状态、元数据等。</li>\n<li>将元数据封装为 Instance 对象，存储到本地缓存中。</li>\n<li>根据负载均衡算法选择一个服务实例处理请求，可以选择轮询、随机、权重等算法。</li>\n</ol>\n<p>服务发现和注册的核心逻辑在 naming-core 目录下的 com.alibaba.nacos.naming 包中实现，主要包括以下类：</p>\n<ul>\n<li>com.alibaba.nacos.naming.core.InstancesManager: 维护服务实例的元数据和状态信息。</li>\n<li>com.alibaba.nacos.naming.core.Cluster: 维护一个服务的所有实例信息和负载均衡策略。</li>\n<li>com.alibaba.nacos.naming.core.InstanceOperator: 实现了服务实例的注册、注销和更新操作。</li>\n<li>com.alibaba.nacos.naming.core.DomainsManager: 维护多个服务的信息，包括服务名、集群名、命名空间等。</li>\n</ul>\n<p>服务发现和注册的具体实现在 naming-impl 目录下的 com.alibaba.nacos.naming 包中，主要包括以下类：</p>\n<ul>\n<li>com.alibaba.nacos.naming.push.PushService: 实现了服务实例的推送功能。</li>\n<li>com.alibaba.nacos.naming.healthcheck.HealthCheckProcessor: 实现了服务实例的健康检查功能。</li>\n<li>com.alibaba.nacos.naming.misc.GlobalConfig: 存储了一些全局配置，例如默认权重值、心跳间隔</li>\n</ul>\n<h3 id=\"配置动态刷新\"><a href=\"#配置动态刷新\" class=\"headerlink\" title=\"配置动态刷新\"></a>配置动态刷新</h3><p>从远端服务器获取变更数据的主要模式有两种：推（push）和拉（pull）。Push 模式简单来说就是服务端主动将数据变更信息推送给客户端，这种模式优点是时效性好，服务端数据发生变更可以立马通知到客户端，但这种模式需要服务端维持与客户端的心跳连接，会增加服务端实现的复杂度，服务端也需要占用更多的资源来维持与客户端的连接。</p>\n<p>而 Pull 模式则是客户端主动去服务器请求数据，例如，每间隔10ms就向服务端发起请求获取数据。显而易见pull模式存在时效性问题。请求的间隔也不太好设置，间隔太短，对服务器请求压力过大。间隔时间过长，那么必然会造成时效性很差。而且如果配置长时间不更新，并且存在大量的客户端就会产生大量无效的pull请求。</p>\n<p>Nacos 没有采用上述的两种模式，而是采用了长轮询方式结合了推和拉的优点：</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/1.png\" alt=\"动态刷新图\"></p>\n<p>长轮询也是轮询，因此 Nacos 客户端会默认每10ms向服务端发起请求，当客户端请求服务端时会在请求头上携带长轮询的超时时间，默认是30s。而服务端接收到该请求时会hang住请求，为了防止客户端超时会在请求头携带的超时时间上减去500ms，因此默认会hang住请求29.5s。在这期间如果服务端发生了配置变更会产生相应的事件，监听到该事件后，会响应对应的客户端。这样一来客户端不会频繁发起轮询请求，而服务端也不需要维持与客户端的心跳，兼备了时效性和复杂度。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/2.png\" alt=\"长轮询图\"></p>\n<blockquote>\n<p>1.4版本nacos使用Http短连接+长轮询的方式，客户端发起http请求，服务端hold住请求，当配置变更时响应客户端，超时时间30s。<br>2.0版本nacos用gRPC长连接代替了http短连接长轮询。配置同步采用推拉结合的方式。</p>\n</blockquote>\n<h4 id=\"Nacos-Config-长轮询源码剖析\"><a href=\"#Nacos-Config-长轮询源码剖析\" class=\"headerlink\" title=\"Nacos Config 长轮询源码剖析\"></a>Nacos Config 长轮询源码剖析</h4><p>首先，打开 com.alibaba.cloud.nacos.NacosConfigBootstrapConfiguration 这个类，从类名也可以看出该类是Nacos Config的启动配置类，是Nacos Config自动装配的入口。在该类中的 nacosConfigManager 方法实例化了一个 NacosConfigManager 对象，并注册到容器中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingBean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> NacosConfigManager <span class=\"title function_\">nacosConfigManager</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">\t\tNacosConfigProperties nacosConfigProperties)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NacosConfigManager</span>(nacosConfigProperties);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 NacosConfigManager 的构造器中调用了 createConfigService 方法，这是一个静态方法用来创建 ConfigService 对象的单例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Compatible with old design,It will be perfected in the future.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> ConfigService <span class=\"title function_\">createConfigService</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">\t\tNacosConfigProperties nacosConfigProperties)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 双重检查锁模式的单例</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Objects.isNull(service)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (NacosConfigManager.class) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (Objects.isNull(service)) &#123;</span><br><span class=\"line\">\t\t\t\t\tservice = NacosFactory.createConfigService(</span><br><span class=\"line\">\t\t\t\t\t\t\tnacosConfigProperties.assembleConfigServiceProperties());</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">catch</span> (NacosException e) &#123;</span><br><span class=\"line\">\t\t\t\tlog.error(e.getMessage());</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NacosConnectionFailureException</span>(</span><br><span class=\"line\">\t\t\t\t\t\tnacosConfigProperties.getServerAddr(), e.getMessage(), e);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> service;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ConfigService 的具体实现是 NacosConfigService，在该类的构造器中主要初始化了 HttpAgent 和 ClientWorker 对象。ClientWorker 的构造器中则初始化了几个线程池：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ClientWorker</span><span class=\"params\">(<span class=\"keyword\">final</span> HttpAgent agent, <span class=\"keyword\">final</span> ConfigFilterChainManager configFilterChainManager,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"keyword\">final</span> Properties properties)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.agent = agent;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.configFilterChainManager = configFilterChainManager;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Initialize the timeout parameter</span></span><br><span class=\"line\">    init(properties);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建具有定时执行功能的单线程池，用于定时执行 checkConfigInfo 方法</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.executor = Executors.newScheduledThreadPool(<span class=\"number\">1</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadFactory</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Thread <span class=\"title function_\">newThread</span><span class=\"params\">(Runnable r)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(r);</span><br><span class=\"line\">            t.setName(<span class=\"string\">&quot;com.alibaba.nacos.client.Worker.&quot;</span> + agent.getName());</span><br><span class=\"line\">            t.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建具有定时执行功能的且线程数与cpu核数相对应的线程池，用于根据需要动态刷新的配置文件执行 LongPollingRunnable，因此长轮询任务是可以有多个并行的</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.executorService = Executors</span><br><span class=\"line\">            .newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadFactory</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> Thread <span class=\"title function_\">newThread</span><span class=\"params\">(Runnable r)</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(r);</span><br><span class=\"line\">                    t.setName(<span class=\"string\">&quot;com.alibaba.nacos.client.Worker.longPolling.&quot;</span> + agent.getName());</span><br><span class=\"line\">                    t.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"comment\">// 每10ms执行一次 checkConfigInfo 方法</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.executor.scheduleWithFixedDelay(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                checkConfigInfo();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                LOGGER.error(<span class=\"string\">&quot;[&quot;</span> + agent.getName() + <span class=\"string\">&quot;] [sub-check] rotate check error&quot;</span>, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"number\">1L</span>, <span class=\"number\">10L</span>, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">(Properties properties)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 长轮询的超时时间，默认为30秒，此参数会被放到请求头中带到服务端，服务端会根据该参数去做长轮询的hold</span></span><br><span class=\"line\">    timeout = Math.max(ConvertUtils.toInt(properties.getProperty(PropertyKeyConst.CONFIG_LONG_POLL_TIMEOUT),</span><br><span class=\"line\">            Constants.CONFIG_LONG_POLL_TIMEOUT), Constants.MIN_CONFIG_LONG_POLL_TIMEOUT);</span><br><span class=\"line\">    </span><br><span class=\"line\">    taskPenaltyTime = ConvertUtils</span><br><span class=\"line\">            .toInt(properties.getProperty(PropertyKeyConst.CONFIG_RETRY_TIME), Constants.CONFIG_RETRY_TIME);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.enableRemoteSyncConfig = Boolean</span><br><span class=\"line\">            .parseBoolean(properties.getProperty(PropertyKeyConst.ENABLE_REMOTE_SYNC_CONFIG));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Check config info.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkConfigInfo</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Dispatch taskes.</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取需要监听的文件数量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">listenerSize</span> <span class=\"operator\">=</span> cacheMap.size();</span><br><span class=\"line\">    <span class=\"comment\">// Round up the longingTaskCount.</span></span><br><span class=\"line\">    <span class=\"comment\">// 默认一个 LongPollingRunnable 可以处理监听3k个配置文件的变化，超过3k个才会创建新的 LongPollingRunnable</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">longingTaskCount</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) Math.ceil(listenerSize / ParamUtil.getPerTaskConfigSize());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (longingTaskCount &gt; currentLongingTaskCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) currentLongingTaskCount; i &lt; longingTaskCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The task list is no order.So it maybe has issues when changing.</span></span><br><span class=\"line\">            executorService.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">LongPollingRunnable</span>(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        currentLongingTaskCount = longingTaskCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LongPollingRunnable 类主要用于检查本地配置，以及长轮询地去服务端获取变更配置的 dataid 和 group，其代码位于 com.alibaba.nacos.client.config.impl.ClientWorker 类，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LongPollingRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> taskId;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LongPollingRunnable</span><span class=\"params\">(<span class=\"type\">int</span> taskId)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.taskId = taskId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        List&lt;CacheData&gt; cacheDatas = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;CacheData&gt;();</span><br><span class=\"line\">        List&lt;String&gt; inInitializingCacheList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// check failover config</span></span><br><span class=\"line\">            <span class=\"comment\">// 遍历本地缓存的配置</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (CacheData cacheData : cacheMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cacheData.getTaskId() == taskId) &#123;</span><br><span class=\"line\">                    cacheDatas.add(cacheData);</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 检查本地配置</span></span><br><span class=\"line\">                        checkLocalConfig(cacheData);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (cacheData.isUseLocalConfigInfo()) &#123;</span><br><span class=\"line\">                            cacheData.checkListenerMd5();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        LOGGER.error(<span class=\"string\">&quot;get local config info error&quot;</span>, e);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// check server config</span></span><br><span class=\"line\">            <span class=\"comment\">// 通过长轮询检查服务端配置</span></span><br><span class=\"line\">            List&lt;String&gt; changedGroupKeys = checkUpdateDataIds(cacheDatas, inInitializingCacheList);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!CollectionUtils.isEmpty(changedGroupKeys)) &#123;</span><br><span class=\"line\">                LOGGER.info(<span class=\"string\">&quot;get changedGroupKeys:&quot;</span> + changedGroupKeys);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String groupKey : changedGroupKeys) &#123;</span><br><span class=\"line\">                String[] key = GroupKey.parseKey(groupKey);</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">dataId</span> <span class=\"operator\">=</span> key[<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> key[<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">tenant</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key.length == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                    tenant = key[<span class=\"number\">2</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    String[] ct = getServerConfig(dataId, group, tenant, <span class=\"number\">3000L</span>);</span><br><span class=\"line\">                    <span class=\"type\">CacheData</span> <span class=\"variable\">cache</span> <span class=\"operator\">=</span> cacheMap.get(GroupKey.getKeyTenant(dataId, group, tenant));</span><br><span class=\"line\">                    cache.setContent(ct[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != ct[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                        cache.setType(ct[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    LOGGER.info(<span class=\"string\">&quot;[&#123;&#125;] [data-received] dataId=&#123;&#125;, group=&#123;&#125;, tenant=&#123;&#125;, md5=&#123;&#125;, content=&#123;&#125;, type=&#123;&#125;&quot;</span>,</span><br><span class=\"line\">                            agent.getName(), dataId, group, tenant, cache.getMd5(),</span><br><span class=\"line\">                            ContentUtils.truncateContent(ct[<span class=\"number\">0</span>]), ct[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (NacosException ioe) &#123;</span><br><span class=\"line\">                    <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> String</span><br><span class=\"line\">                            .format(<span class=\"string\">&quot;[%s] [get-update] get changed config exception. dataId=%s, group=%s, tenant=%s&quot;</span>,</span><br><span class=\"line\">                                    agent.getName(), dataId, group, tenant);</span><br><span class=\"line\">                    LOGGER.error(message, ioe);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (CacheData cacheData : cacheDatas) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!cacheData.isInitializing() || inInitializingCacheList</span><br><span class=\"line\">                        .contains(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant))) &#123;</span><br><span class=\"line\">                    cacheData.checkListenerMd5();</span><br><span class=\"line\">                    cacheData.setInitializing(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            inInitializingCacheList.clear();</span><br><span class=\"line\">            </span><br><span class=\"line\">            executorService.execute(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// If the rotation training task is abnormal, the next execution time of the task will be punished</span></span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">&quot;longPolling error : &quot;</span>, e);</span><br><span class=\"line\">            executorService.schedule(<span class=\"built_in\">this</span>, taskPenaltyTime, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面有个 checkUpdateDataIds 方法，用于获取发生变更了的配置文件的dataId列表，它同样位于 ClientWorker 内。如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Fetch the dataId list from server.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> cacheDatas              CacheDatas for config infomations.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> inInitializingCacheList initial cache lists.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> String include dataId and group (ps: it maybe null).</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> Exception Exception.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">List&lt;String&gt; <span class=\"title function_\">checkUpdateDataIds</span><span class=\"params\">(List&lt;CacheData&gt; cacheDatas, List&lt;String&gt; inInitializingCacheList)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 拼接出配置文件的唯一标识</span></span><br><span class=\"line\">    <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (CacheData cacheData : cacheDatas) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cacheData.isUseLocalConfigInfo()) &#123;</span><br><span class=\"line\">            sb.append(cacheData.dataId).append(WORD_SEPARATOR);</span><br><span class=\"line\">            sb.append(cacheData.group).append(WORD_SEPARATOR);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (StringUtils.isBlank(cacheData.tenant)) &#123;</span><br><span class=\"line\">                sb.append(cacheData.getMd5()).append(LINE_SEPARATOR);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                sb.append(cacheData.getMd5()).append(WORD_SEPARATOR);</span><br><span class=\"line\">                sb.append(cacheData.getTenant()).append(LINE_SEPARATOR);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cacheData.isInitializing()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// It updates when cacheData occours in cacheMap by first time.</span></span><br><span class=\"line\">                inInitializingCacheList</span><br><span class=\"line\">                        .add(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">isInitializingCacheList</span> <span class=\"operator\">=</span> !inInitializingCacheList.isEmpty();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> checkUpdateConfigStr(sb.toString(), isInitializingCacheList);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Fetch the updated dataId list from server.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> probeUpdateString       updated attribute string value.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> isInitializingCacheList initial cache lists.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> The updated dataId list(ps: it maybe null).</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> IOException Exception.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">List&lt;String&gt; <span class=\"title function_\">checkUpdateConfigStr</span><span class=\"params\">(String probeUpdateString, <span class=\"type\">boolean</span> isInitializingCacheList)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Map&lt;String, String&gt; params = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, String&gt;(<span class=\"number\">2</span>);</span><br><span class=\"line\">    params.put(Constants.PROBE_MODIFY_REQUEST, probeUpdateString);</span><br><span class=\"line\">    Map&lt;String, String&gt; headers = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, String&gt;(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 长轮询的超时时间</span></span><br><span class=\"line\">    headers.put(<span class=\"string\">&quot;Long-Pulling-Timeout&quot;</span>, <span class=\"string\">&quot;&quot;</span> + timeout);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// told server do not hang me up if new initializing cacheData added in</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isInitializingCacheList) &#123;</span><br><span class=\"line\">        headers.put(<span class=\"string\">&quot;Long-Pulling-Timeout-No-Hangup&quot;</span>, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (StringUtils.isBlank(probeUpdateString)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// In order to prevent the server from handling the delay of the client&#x27;s long task,</span></span><br><span class=\"line\">        <span class=\"comment\">// increase the client&#x27;s read timeout to avoid this problem.</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">readTimeoutMs</span> <span class=\"operator\">=</span> timeout + (<span class=\"type\">long</span>) Math.round(timeout &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 向服务端发起一个http请求，该请求在服务端配置没有变更的情况下默认会hang住30s</span></span><br><span class=\"line\">        HttpRestResult&lt;String&gt; result = agent</span><br><span class=\"line\">                .httpPost(Constants.CONFIG_CONTROLLER_PATH + <span class=\"string\">&quot;/listener&quot;</span>, headers, params, agent.getEncode(),</span><br><span class=\"line\">                        readTimeoutMs);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result.ok()) &#123;</span><br><span class=\"line\">            setHealthServer(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 响应状态是成功则解析响应体得到 dataId、group、tenant 等信息并返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> parseUpdateDataIdResponse(result.getData());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            setHealthServer(<span class=\"literal\">false</span>);</span><br><span class=\"line\">            LOGGER.error(<span class=\"string\">&quot;[&#123;&#125;] [check-update] get changed dataId error, code: &#123;&#125;&quot;</span>, agent.getName(),</span><br><span class=\"line\">                    result.getCode());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        setHealthServer(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        LOGGER.error(<span class=\"string\">&quot;[&quot;</span> + agent.getName() + <span class=\"string\">&quot;] [check-update] get changed dataId exception&quot;</span>, e);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端对 listener 接口的请求会进入到服务端的 com.alibaba.nacos.config.server.controller.ConfigController#listener 方法进行处理，该方法主要是调用了 com.alibaba.nacos.config.server.controller.ConfigServletInner#doPollingConfig 方法。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 轮询接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">doPollingConfig</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class=\"line\"><span class=\"params\">                              Map&lt;String, String&gt; clientMd5Map, <span class=\"type\">int</span> probeRequestSize)</span></span><br><span class=\"line\">    <span class=\"keyword\">throws</span> IOException, ServletException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果支持长轮询则进入长轮询的流程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LongPollingService.isSupportLongPolling(request)) &#123;</span><br><span class=\"line\">        longPollingService.addLongPollingClient(request, response, clientMd5Map, probeRequestSize);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpServletResponse.SC_OK + <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// else 兼容短轮询逻辑</span></span><br><span class=\"line\">    List&lt;String&gt; changedGroups = MD5Util.compareMd5(request, response, clientMd5Map);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 兼容短轮询result</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">oldResult</span> <span class=\"operator\">=</span> MD5Util.compareMd5OldResult(changedGroups);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">newResult</span> <span class=\"operator\">=</span> MD5Util.compareMd5ResultString(changedGroups);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">version</span> <span class=\"operator\">=</span> request.getHeader(Constants.CLIENT_VERSION_HEADER);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (version == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        version = <span class=\"string\">&quot;2.0.0&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">versionNum</span> <span class=\"operator\">=</span> Protocol.getVersionNumber(version);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.0.4版本以前, 返回值放入header中</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (versionNum &lt; START_LONGPOLLING_VERSION_NUM) &#123;</span><br><span class=\"line\">        response.addHeader(Constants.PROBE_MODIFY_RESPONSE, oldResult);</span><br><span class=\"line\">        response.addHeader(Constants.PROBE_MODIFY_RESPONSE_NEW, newResult);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        request.setAttribute(<span class=\"string\">&quot;content&quot;</span>, newResult);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 禁用缓存</span></span><br><span class=\"line\">    response.setHeader(<span class=\"string\">&quot;Pragma&quot;</span>, <span class=\"string\">&quot;no-cache&quot;</span>);</span><br><span class=\"line\">    response.setDateHeader(<span class=\"string\">&quot;Expires&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    response.setHeader(<span class=\"string\">&quot;Cache-Control&quot;</span>, <span class=\"string\">&quot;no-cache,no-store&quot;</span>);</span><br><span class=\"line\">    response.setStatus(HttpServletResponse.SC_OK);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpServletResponse.SC_OK + <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们主要关注上面的 com.alibaba.nacos.config.server.service.LongPollingService#addLongPollingClient 长轮询流程的方法。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addLongPollingClient</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse rsp, Map&lt;String, String&gt; clientMd5Map,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">int</span> probeRequestSize)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> req.getHeader(LongPollingService.LONG_POLLING_HEADER);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">noHangUpFlag</span> <span class=\"operator\">=</span> req.getHeader(LongPollingService.LONG_POLLING_NO_HANG_UP_HEADER);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">appName</span> <span class=\"operator\">=</span> req.getHeader(RequestUtil.CLIENT_APPNAME_HEADER);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">tag</span> <span class=\"operator\">=</span> req.getHeader(<span class=\"string\">&quot;Vipserver-Tag&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">delayTime</span> <span class=\"operator\">=</span> SwitchService.getSwitchInteger(SwitchService.FIXED_DELAY_TIME, <span class=\"number\">500</span>);</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 提前500ms返回响应，为避免客户端超时 <span class=\"doctag\">@qiaoyi</span>.dingqy 2013.10.22改动  add delay time for LoadBalance</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">timeout</span> <span class=\"operator\">=</span> Math.max(<span class=\"number\">10000</span>, Long.parseLong(str) - delayTime);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isFixedPolling()) &#123;</span><br><span class=\"line\">        timeout = Math.max(<span class=\"number\">10000</span>, getFixedPollingInterval());</span><br><span class=\"line\">        <span class=\"comment\">// do nothing but set fix polling timeout</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        List&lt;String&gt; changedGroups = MD5Util.compareMd5(req, rsp, clientMd5Map);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (changedGroups.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            generateResponse(req, rsp, changedGroups);</span><br><span class=\"line\">            LogUtil.clientLog.info(<span class=\"string\">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class=\"line\">                System.currentTimeMillis() - start, <span class=\"string\">&quot;instant&quot;</span>, RequestUtil.getRemoteIp(req), <span class=\"string\">&quot;polling&quot;</span>,</span><br><span class=\"line\">                clientMd5Map.size(), probeRequestSize, changedGroups.size());</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (noHangUpFlag != <span class=\"literal\">null</span> &amp;&amp; noHangUpFlag.equalsIgnoreCase(TRUE_STR)) &#123;</span><br><span class=\"line\">            LogUtil.clientLog.info(<span class=\"string\">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>, System.currentTimeMillis() - start, <span class=\"string\">&quot;nohangup&quot;</span>,</span><br><span class=\"line\">                RequestUtil.getRemoteIp(req), <span class=\"string\">&quot;polling&quot;</span>, clientMd5Map.size(), probeRequestSize,</span><br><span class=\"line\">                changedGroups.size());</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ip</span> <span class=\"operator\">=</span> RequestUtil.getRemoteIp(req);</span><br><span class=\"line\">    <span class=\"comment\">// 一定要由HTTP线程调用，否则离开后容器会立即发送响应</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">AsyncContext</span> <span class=\"variable\">asyncContext</span> <span class=\"operator\">=</span> req.startAsync();</span><br><span class=\"line\">    <span class=\"comment\">// AsyncContext.setTimeout()的超时时间不准，所以只能自己控制</span></span><br><span class=\"line\">    asyncContext.setTimeout(<span class=\"number\">0L</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 在 ClientLongPolling 的 run 方法会将 ClientLongPolling 实例（携带了本次请求的相关信息）放入 allSubs 中，然后会在29.5s后再执行另一个 Runnable，该 Runnable 用于等待29.5s后依旧没有相应的配置变更时对客户端进行响应，并将相应的 ClientLongPolling 实例从 allSubs 中移出</span></span><br><span class=\"line\">    scheduler.execute(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ClientLongPolling</span>(asyncContext, clientMd5Map, ip, probeRequestSize, timeout, appName, tag));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而 LongPollingService 实现了 AbstractEventListener，也就是说能接收事件通知，在其 com.alibaba.nacos.config.server.service.LongPollingService#onEvent 方法中可以看到，它关注的是 LocalDataChangeEvent 事件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onEvent</span><span class=\"params\">(Event event)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isFixedPolling()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ignore</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (event <span class=\"keyword\">instanceof</span> LocalDataChangeEvent) &#123;</span><br><span class=\"line\">            <span class=\"type\">LocalDataChangeEvent</span> <span class=\"variable\">evt</span> <span class=\"operator\">=</span> (LocalDataChangeEvent)event;</span><br><span class=\"line\">            scheduler.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">DataChangeTask</span>(evt.groupKey, evt.isBeta, evt.betaIps));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在nacos上修改配置后就会产生 LocalDataChangeEvent 事件，此时 LongPollingService 也就能监听到，当收到该事件时就会遍历 allSubs，找到匹配的请求并将 groupKey 返回给客户端。具体代码在 DataChangeTask 中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DataChangeTask</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ConfigService.getContentBetaMd5(groupKey);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;ClientLongPolling&gt; iter = allSubs.iterator(); iter.hasNext(); ) &#123;</span><br><span class=\"line\">                <span class=\"type\">ClientLongPolling</span> <span class=\"variable\">clientSub</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (clientSub.clientMd5Map.containsKey(groupKey)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果beta发布且不在beta列表直接跳过</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (isBeta &amp;&amp; !betaIps.contains(clientSub.ip)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 如果tag发布且不在tag列表直接跳过</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (StringUtils.isNotBlank(tag) &amp;&amp; !tag.equals(clientSub.tag)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    getRetainIps().put(clientSub.ip, System.currentTimeMillis());</span><br><span class=\"line\">                    iter.remove(); <span class=\"comment\">// 删除订阅关系</span></span><br><span class=\"line\">                    LogUtil.clientLog.info(<span class=\"string\">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class=\"line\">                        (System.currentTimeMillis() - changeTime),</span><br><span class=\"line\">                        <span class=\"string\">&quot;in-advance&quot;</span>,</span><br><span class=\"line\">                        RequestUtil.getRemoteIp((HttpServletRequest)clientSub.asyncContext.getRequest()),</span><br><span class=\"line\">                        <span class=\"string\">&quot;polling&quot;</span>,</span><br><span class=\"line\">                        clientSub.clientMd5Map.size(), clientSub.probeRequestSize, groupKey);</span><br><span class=\"line\">                    clientSub.sendResponse(Arrays.asList(groupKey));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            LogUtil.defaultLog.error(<span class=\"string\">&quot;data change error:&quot;</span> + t.getMessage(), t.getCause());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    DataChangeTask(String groupKey) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(groupKey, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    DataChangeTask(String groupKey, <span class=\"type\">boolean</span> isBeta, List&lt;String&gt; betaIps) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(groupKey, isBeta, betaIps, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    DataChangeTask(String groupKey, <span class=\"type\">boolean</span> isBeta, List&lt;String&gt; betaIps, String tag) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.groupKey = groupKey;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.isBeta = isBeta;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.betaIps = betaIps;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.tag = tag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String groupKey;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">changeTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> isBeta;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> List&lt;String&gt; betaIps;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String tag;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当客户端收到变更的dataid+group后，就会去服务端获取最新的配置数据，并更新本地数据 cacheData，然后发送数据变更事件，整个流程结束。</p>\n<ul>\n<li>获取服务端最新配置数据的方法：com.alibaba.nacos.client.config.impl.ClientWorker#getServerConfig</li>\n<li>发送数据变更事件的方法：com.alibaba.nacos.client.config.impl.CacheData#checkListenerMd5</li>\n</ul>\n<h2 id=\"Sentienl\"><a href=\"#Sentienl\" class=\"headerlink\" title=\"Sentienl\"></a>Sentienl</h2><p>Sentinel是阿里巴巴开源的一款流量控制和熔断降级框架，主要用于微服务架构中服务的流量控制和熔断降级。其限流实现原理主要分为两个部分：</p>\n<blockquote>\n<p>统计信息收集</p>\n</blockquote>\n<p>Sentinel会在运行过程中对服务的各种统计信息进行收集，包括请求的响应时间、请求通过的QPS（每秒查询率）、线程池队列大小等指标。这些指标通过定义的规则进行分析，判断当前请求是否超过了设定的阈值。</p>\n<blockquote>\n<p>阈值判断</p>\n</blockquote>\n<p>Sentinel根据收集到的统计信息，通过定义的规则对请求进行判断。规则中包括以下几个要素：</p>\n<p>资源名：对哪个资源进行限流<br>流控模式：直接拒绝或者匀速通过<br>流控阈值：单位时间内允许通过的请求个数<br>统计时间窗口：多长时间内统计一次流量，单位秒<br>降级处理：当请求超过阈值时的处理策略，如直接拒绝、返回默认值等<br>Sentinel会根据以上规则进行限流，当请求超过阈值时，根据设置的降级处理策略进行处理，比如直接拒绝请求、返回默认值等。同时，Sentinel还可以进行自适应的流控，根据实际情况调整阈值，保证服务的可用性和稳定性。</p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><h4 id=\"Slot-插槽\"><a href=\"#Slot-插槽\" class=\"headerlink\" title=\"Slot 插槽\"></a>Slot 插槽</h4><p>在 Sentinel 里面，所有的资源都对应一个资源名称（resourceName），每次资源调用都会创建一个 Entry 对象。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 SphU API 显式创建。Entry 创建的时候，同时也会创建一系列功能插槽（slot chain），这些插槽有不同的职责，例如:</p>\n<ul>\n<li>NodeSelectorSlot 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</li>\n<li>ClusterBuilderSlot 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；</li>\n<li>StatisticSlot 则用于记录、统计不同纬度的 runtime 指标监控信息；</li>\n<li>FlowSlot 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；</li>\n<li>AuthoritySlot 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li>\n<li>DegradeSlot 则通过统计信息以及预设的规则，来做熔断降级；</li>\n<li>SystemSlot 则通过系统的状态，例如 load1 等，来控制总的入口流量；</li>\n</ul>\n<p>Sentinel 提供了插槽接口 ProcessorSlot，其中提供了方法 enrty 处理进入请求 和 exit 处理请求结束操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ProcessorSlot</span>&lt;T&gt; &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Entrance of this slot.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context         current &#123;<span class=\"doctag\">@link</span> Context&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> resourceWrapper current resource</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> param           generics parameter, usually is a &#123;<span class=\"doctag\">@link</span> com.alibaba.csp.sentinel.node.Node&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count           tokens needed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> prioritized     whether the entry is prioritized</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args            parameters of the original call</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable blocked exception or unexpected error</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">entry</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, T param, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized,</span></span><br><span class=\"line\"><span class=\"params\">               Object... args)</span> <span class=\"keyword\">throws</span> Throwable;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Means finish of &#123;<span class=\"doctag\">@link</span> #entry(Context, ResourceWrapper, Object, int, boolean, Object...)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context         current &#123;<span class=\"doctag\">@link</span> Context&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> resourceWrapper current resource</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> obj             relevant object (e.g. Node)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count           tokens needed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> prioritized     whether the entry is prioritized</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args            parameters of the original call</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable blocked exception or unexpected error</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">fireEntry</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, Object obj, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized,</span></span><br><span class=\"line\"><span class=\"params\">                   Object... args)</span> <span class=\"keyword\">throws</span> Throwable;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Exit of this slot.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context         current &#123;<span class=\"doctag\">@link</span> Context&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> resourceWrapper current resource</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count           tokens needed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args            parameters of the original call</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">exit</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, <span class=\"type\">int</span> count, Object... args)</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Means finish of &#123;<span class=\"doctag\">@link</span> #exit(Context, ResourceWrapper, int, Object...)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context         current &#123;<span class=\"doctag\">@link</span> Context&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> resourceWrapper current resource</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count           tokens needed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args            parameters of the original call</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">fireExit</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, <span class=\"type\">int</span> count, Object... args)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总体的框架如下:</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/3.png\" alt=\"结构图\"></p>\n<p>Sentinel 将 SlotChainBuilder 作为 SPI 接口进行扩展，使得 Slot Chain 具备了扩展的能力。您可以自行加入自定义的 slot 并编排 slot 间的顺序，从而可以给 Sentinel 添加自定义的功能。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/4.png\" alt=\"Sentinel图\"></p>\n<h4 id=\"RuleManager-规则管理器\"><a href=\"#RuleManager-规则管理器\" class=\"headerlink\" title=\"RuleManager 规则管理器\"></a>RuleManager 规则管理器</h4><p>每个 Slot 插槽背后都对应着一个 RuleManager 的实现类，简单理解就是每个 Slot 有一套规则，规则验证处理由对应的 RuleManager 来进行处理。</p>\n<p>流量控制：FlowSolt 对应 FlowRuleManager</p>\n<p>降级控制：DegradeSlot  对应 DegradeRuleManager</p>\n<p>权限控制：AuthoritySlot 对应 AuthorityRuleManager</p>\n<p>系统规则控制： SystemSlot 对应 SystemRuleManager</p>\n<h4 id=\"降级控制实现原理\"><a href=\"#降级控制实现原理\" class=\"headerlink\" title=\"降级控制实现原理\"></a>降级控制实现原理</h4><ol>\n<li>新增资源配置降级规则，目前对于降级策有如下三种：</li>\n</ol>\n<p>RT：平均响应时间 (DEGRADE_GRADE_RT)：当 1s 内持续进入 5 个请求，对应时刻的平均响应时间（秒级）均超过阈值（count，以 ms 为单位），那么在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt&#x3D;xxx 来配置。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/5.png\" alt=\"平均响应图\"></p>\n<p>异常比例：当资源的每秒请求量 &gt;&#x3D; 5，并且每秒异常总数占通过量的比值超过阈值（DegradeRule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/6.png\" alt=\"异常比例图\"></p>\n<p>异常数：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/7.png\" alt=\"异常数图\"></p>\n<p>限流结果信息</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">Blocked by Sentinel (flow limiting)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>实现逻辑</li>\n</ol>\n<p>在之前我们已经提及 Sentinel 是通过 slot 链来实现的，对于降级功能其提供了 DegradeSlot，实现源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DegradeSlot</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLinkedProcessorSlot</span>&lt;DefaultNode&gt; &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">entry</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized, Object... args)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        DegradeRuleManager.checkDegrade(resourceWrapper, context, node, count);</span><br><span class=\"line\">        fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">exit</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, <span class=\"type\">int</span> count, Object... args)</span> &#123;</span><br><span class=\"line\">        fireExit(context, resourceWrapper, count, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上面代码我们可以了解到，限流规则的实现是在 DegradeRuleManager 的checkDegrade中来处理的，限流可以-配置多个规则，依次按照规则来处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkDegrade</span><span class=\"params\">(ResourceWrapper resource, Context context, DefaultNode node, <span class=\"type\">int</span> count)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> BlockException &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">        Set&lt;DegradeRule&gt; rules = degradeRules.get(resource.getName());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rules == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (DegradeRule rule : rules) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!rule.passCheck(context, node, count)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DegradeException</span>(rule.getLimitApp(), rule);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在 DegradeRule 的 passCheck 方法中我们可以看到可以根据 RT、异常数和异常比例来进行熔断降级处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">passCheck</span><span class=\"params\">(Context context, DefaultNode node, <span class=\"type\">int</span> acquireCount, Object... args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cut.get()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"type\">ClusterNode</span> <span class=\"variable\">clusterNode</span> <span class=\"operator\">=</span> ClusterBuilderSlot.getClusterNode(<span class=\"built_in\">this</span>.getResource());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (clusterNode == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t<span class=\"comment\">// 请求处理时间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (grade == RuleConstant.DEGRADE_GRADE_RT) &#123;</span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">rt</span> <span class=\"operator\">=</span> clusterNode.avgRt();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rt &lt; <span class=\"built_in\">this</span>.count) &#123;</span><br><span class=\"line\">                passCount.set(<span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"comment\">// Sentinel will degrade the service only if count exceeds.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (passCount.incrementAndGet() &lt; rtSlowRequestAmount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//异常比例</span></span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">exception</span> <span class=\"operator\">=</span> clusterNode.exceptionQps();</span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> clusterNode.successQps();</span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">total</span> <span class=\"operator\">=</span> clusterNode.totalQps();</span><br><span class=\"line\">            <span class=\"comment\">// If total amount is less than minRequestAmount, the request will pass.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (total &lt; minRequestAmount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"comment\">// In the same aligned statistic time window,</span></span><br><span class=\"line\">            <span class=\"comment\">// &quot;success&quot; (aka. completed count) = exception count + non-exception count (realSuccess)</span></span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">realSuccess</span> <span class=\"operator\">=</span> success - exception;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (realSuccess &lt;= <span class=\"number\">0</span> &amp;&amp; exception &lt; minRequestAmount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (exception / success &lt; count) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//异常数</span></span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">exception</span> <span class=\"operator\">=</span> clusterNode.totalException();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (exception &lt; count) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cut.compareAndSet(<span class=\"literal\">false</span>, <span class=\"literal\">true</span>)) &#123;</span><br><span class=\"line\">            <span class=\"type\">ResetTask</span> <span class=\"variable\">resetTask</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResetTask</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">            pool.schedule(resetTask, timeWindow, TimeUnit.SECONDS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"流量控制实现原理\"><a href=\"#流量控制实现原理\" class=\"headerlink\" title=\"流量控制实现原理\"></a>流量控制实现原理</h4><p>接下来我们了解学习一下 Sentinel 是如何实现流量控制的</p>\n<p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。</p>\n<p>FlowSlot 会根据预设的规则，结合前面 NodeSelectorSlot、ClusterNodeBuilderSlot、StatisticSlot 统计出来的实时信息进行流量控制。</p>\n<p>限流的直接表现是在执行 Entry nodeA &#x3D; SphU.entry(resourceName) 的时候抛出 FlowException 异常。FlowException 是 BlockException 的子类，您可以捕捉 BlockException 来自定义被限流之后的处理逻辑。</p>\n<p>同一个资源可以创建多条限流规则。FlowSlot 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。</p>\n<p>一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：</p>\n<ul>\n<li>resource：资源名，即限流规则的作用对象</li>\n<li>count: 限流阈值</li>\n<li>grade: 限流阈值类型（QPS 或并发线程数）</li>\n<li>limitApp: 流控针对的调用来源，若为 default 则不区分调用来源</li>\n<li>strategy: 调用关系限流策略</li>\n<li>controlBehavior: 流量控制效果（直接拒绝、Warm Up、匀速排队）</li>\n</ul>\n<p>流控-QPS配置</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/8.png\" alt=\"QPS配置图\"></p>\n<p>流控-线程数配置</p>\n<p><img src=\"/./2024/05/26/Springcloud%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/9.png\" alt=\"流控图\"></p>\n<h5 id=\"实现流程\"><a href=\"#实现流程\" class=\"headerlink\" title=\"实现流程\"></a>实现流程</h5><p>Sentinel 提供了 FlowSlot 用来进行流量控制，流量规则的最终实现在 FlowRuleChecker 的 checkFlow 中实现的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FlowSlot</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLinkedProcessorSlot</span>&lt;DefaultNode&gt; &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FlowRuleChecker checker;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">FlowSlot</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FlowRuleChecker</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Package-private for test.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> checker flow rule checker</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@since</span> 1.6.1</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    FlowSlot(FlowRuleChecker checker) &#123;</span><br><span class=\"line\">        AssertUtil.notNull(checker, <span class=\"string\">&quot;flow checker should not be null&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.checker = checker;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">entry</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class=\"type\">int</span> count,</span></span><br><span class=\"line\"><span class=\"params\">                      <span class=\"type\">boolean</span> prioritized, Object... args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        checkFlow(resourceWrapper, context, node, count, prioritized);</span><br><span class=\"line\"> </span><br><span class=\"line\">        fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">checkFlow</span><span class=\"params\">(ResourceWrapper resource, Context context, DefaultNode node, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> BlockException &#123;</span><br><span class=\"line\">        checker.checkFlow(ruleProvider, resource, context, node, count, prioritized);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">exit</span><span class=\"params\">(Context context, ResourceWrapper resourceWrapper, <span class=\"type\">int</span> count, Object... args)</span> &#123;</span><br><span class=\"line\">        fireExit(context, resourceWrapper, count, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Function&lt;String, Collection&lt;FlowRule&gt;&gt; ruleProvider = <span class=\"keyword\">new</span> <span class=\"title class_\">Function</span>&lt;String, Collection&lt;FlowRule&gt;&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Collection&lt;FlowRule&gt; <span class=\"title function_\">apply</span><span class=\"params\">(String resource)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Flow rule map should not be null.</span></span><br><span class=\"line\">            Map&lt;String, List&lt;FlowRule&gt;&gt; flowRules = FlowRuleManager.getFlowRuleMap();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> flowRules.get(resource);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 checkFlow 中会依次获取我们配置的流控规则，然后依次进行流控判断处理，如果被流控则抛出异常 FlowException</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkFlow</span><span class=\"params\">(Function&lt;String, Collection&lt;FlowRule&gt;&gt; ruleProvider, ResourceWrapper resource,</span></span><br><span class=\"line\"><span class=\"params\">                          Context context, DefaultNode node, <span class=\"type\">int</span> count, <span class=\"type\">boolean</span> prioritized)</span> <span class=\"keyword\">throws</span> BlockException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ruleProvider == <span class=\"literal\">null</span> || resource == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Collection&lt;FlowRule&gt; rules = ruleProvider.apply(resource.getName());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rules != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (FlowRule rule : rules) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!canPassCheck(rule, context, node, count, prioritized)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FlowException</span>(rule.getLimitApp(), rule);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在 canPassCheck 中会判断是集群限流还是本地限流</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPassCheck</span><span class=\"params\">(<span class=\"comment\">/*@NonNull*/</span> FlowRule rule, Context context, DefaultNode node, <span class=\"type\">int</span> acquireCount,</span></span><br><span class=\"line\"><span class=\"params\">                                                    <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">limitApp</span> <span class=\"operator\">=</span> rule.getLimitApp();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (limitApp == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rule.isClusterMode()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> passClusterCheck(rule, context, node, acquireCount, prioritized);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> passLocalCheck(rule, context, node, acquireCount, prioritized);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>如果是本地限流则获取节点信息，然后根据流控规则进行流控判断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">passLocalCheck</span><span class=\"params\">(FlowRule rule, Context context, DefaultNode node, <span class=\"type\">int</span> acquireCount,</span></span><br><span class=\"line\"><span class=\"params\">                                          <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">selectedNode</span> <span class=\"operator\">=</span> selectNodeByRequesterAndStrategy(rule, context, node);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedNode == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> rule.getRater().canPass(selectedNode, acquireCount, prioritized);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>当 QPS 超过某个阈值的时候，则采取措施进行流量控制。流量控制的手段包括以下几种：直接拒绝、Warm Up、匀速排队。对应 FlowRule 中的 controlBehavior 字段。</p>\n<p>直接拒绝（RuleConstant.CONTROL_BEHAVIOR_DEFAULT）方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。具体的例子参见 FlowQpsDemo。</p>\n<p>Warm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）方式，即预热&#x2F;冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。详细文档可以参考 流量控制 - Warm Up 文档</p>\n<p>目前 Sentinel 对于流量控制提供了如下几种方式：</p>\n<ul>\n<li>直接拒绝（DefaultController）：支持抛出异常<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPass</span><span class=\"params\">(Node node, <span class=\"type\">int</span> acquireCount, <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">curCount</span> <span class=\"operator\">=</span> avgUsedTokens(node);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curCount + acquireCount &gt; count) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prioritized &amp;&amp; grade == RuleConstant.FLOW_GRADE_QPS) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> currentTime;</span><br><span class=\"line\">            <span class=\"type\">long</span> waitInMs;</span><br><span class=\"line\">            currentTime = TimeUtil.currentTimeMillis();</span><br><span class=\"line\">            waitInMs = node.tryOccupyNext(currentTime, acquireCount, count);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitInMs &lt; OccupyTimeoutProperty.getOccupyTimeout()) &#123;</span><br><span class=\"line\">                node.addWaitingRequest(currentTime + waitInMs, acquireCount);</span><br><span class=\"line\">                node.addOccupiedPass(acquireCount);</span><br><span class=\"line\">                sleep(waitInMs);</span><br><span class=\"line\"> </span><br><span class=\"line\">                <span class=\"comment\">// PriorityWaitException indicates that the request will pass after waiting for &#123;@link @waitInMs&#125;.</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityWaitException</span>(waitInMs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>匀速排队（RateLimiterController）：判断等待时间，如果等待时间过长也是会限流，并且使用 Thread.sleep 如果配置不正确可能会导致线程过多。<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPass</span><span class=\"params\">(Node node, <span class=\"type\">int</span> acquireCount, <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Pass when acquire count is less or equal than 0.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (acquireCount &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Reject when count is less or equal than 0.</span></span><br><span class=\"line\">        <span class=\"comment\">// Otherwise,the costTime will be max of long and waitTime will overflow in some cases.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">currentTime</span> <span class=\"operator\">=</span> TimeUtil.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"comment\">// Calculate the interval between every two requests.</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">costTime</span> <span class=\"operator\">=</span> Math.round(<span class=\"number\">1.0</span> * (acquireCount) / count * <span class=\"number\">1000</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// Expected pass time of this request.</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">expectedTime</span> <span class=\"operator\">=</span> costTime + latestPassedTime.get();</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (expectedTime &lt;= currentTime) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Contention may exist here, but it&#x27;s okay.</span></span><br><span class=\"line\">            latestPassedTime.set(currentTime);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Calculate the time to wait.</span></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">waitTime</span> <span class=\"operator\">=</span> costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">long</span> <span class=\"variable\">oldTime</span> <span class=\"operator\">=</span> latestPassedTime.addAndGet(costTime);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    waitTime = oldTime - TimeUtil.currentTimeMillis();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class=\"line\">                        latestPassedTime.addAndGet(-costTime);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// in race condition waitTime may &lt;= 0</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (waitTime &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        Thread.sleep(waitTime);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n<li>Warm Up（WarmUpController 和 WarmUpRateLimiterController）：预热启动<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPass</span><span class=\"params\">(Node node, <span class=\"type\">int</span> acquireCount, <span class=\"type\">boolean</span> prioritized)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">passQps</span> <span class=\"operator\">=</span> (<span class=\"type\">long</span>) node.passQps();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">previousQps</span> <span class=\"operator\">=</span> (<span class=\"type\">long</span>) node.previousPassQps();</span><br><span class=\"line\">    syncToken(previousQps);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 开始计算它的斜率</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果进入了警戒线，开始调整他的qps</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">restToken</span> <span class=\"operator\">=</span> storedTokens.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (restToken &gt;= warningToken) &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">aboveToken</span> <span class=\"operator\">=</span> restToken - warningToken;</span><br><span class=\"line\">        <span class=\"comment\">// 消耗的速度要比warning快，但是要比慢</span></span><br><span class=\"line\">        <span class=\"comment\">// current interval = restToken*slope+1/count</span></span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">warningQps</span> <span class=\"operator\">=</span> Math.nextUp(<span class=\"number\">1.0</span> / (aboveToken * slope + <span class=\"number\">1.0</span> / count));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (passQps + acquireCount &lt;= warningQps) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (passQps + acquireCount &lt;= count) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"Spring最热点面试题","date":"2024-05-26T14:42:28.000Z","_content":"\n# spring\n\n## 架构图\n\n![结构图](./2024/05/26/Spring最热点面试题/1.png)\n\n## 模块\n\n### Core Container\n\n核心容器(Core Container)\n\n- `spring-beans` 该模块是依赖注入IoC与DI的最基本实现\n- `spring-core` 该模块是Bean工厂与bean的装配\n- `spring-context` 该模块构架于核心模块之上，它扩展了 BeanFactory，为它添加了 Bean 生命周期控制、框架事件体系以及资源加载透明化等功能。ApplicationContext 是该模块的核心接口，它的超类是\n  BeanFactory。与BeanFactory 不同，ApplicationContext 容器实例化后会自动对所有的单实例 Bean 进行实例化与依赖关系的装配，使之处于待用状态\n- `spring-context-indexer` 该模块是 Spring 的类管理组件和 Classpath 扫描\n- `spring-context-support` 该模块是对 Spring IOC 容器的扩展支持，以及 IOC 子容器\n- `spring-expression` 该模块是Spring表达式语言块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等\n\n### Data Access/Integration\n\n数据访问/集成\n\n- `spring-jdbc` 该模块提供了 JDBC抽象层，它消除了冗长的 JDBC 编码和对数据库供应商特定错误代码的解析\n- `spring-tx` 该模块支持编程式事务和声明式事务，可用于实现了特定接口的类和所有的 POJO 对象。编程式事务需要自己写beginTransaction()、commit()、rollback()\n  等事务管理方法，声明式事务是通过注解或配置由 spring 自动处理，编程式事务粒度更细\n- `spring-orm` 该模块提供了对流行的对象关系映射 API的集成，包括 JPA、JDO 和 Hibernate 等。通过此模块可以让这些 ORM 框架和 spring 的其它功能整合，比如前面提及的事务管理\n- `spring-oxm` 该模块提供了对 OXM 实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等\n- `spring-jms` 该模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了 spring-messaging 模块\n\n### Web\n\n网络部分\n\n- `spring-web` 该模块为 Spring 提供了最基础 Web 支持，主要建立于核心容器之上，通过 Servlet 或者 Listeners 来初始化 IOC 容器，也包含一些与 Web 相关的支持\n- `spring-webmvc` 该模块众所周知是一个的 Web-Servlet 模块，实现了 Spring MVC（model-view-Controller）的 Web 应用\n- `spring-websocket` 该模块主要是与 Web 前端的全双工通讯的协议\n- `spring-webflux` 该模块是一个新的非堵塞函数式 Reactive Web 框架，可以用来建立异步的，非阻塞，事件驱动的服务，并且扩展性非常好。\n\n### 面向切面编程(AOP和Aspects)\n\n- `spring-aop` 该模块是Spring的另一个核心模块，是 AOP 主要的实现模块\n- `spring-aspects` 该模块提供了对 AspectJ 的集成，主要是为 Spring AOP提供多种 AOP 实现方法，如前置方法后置方法等\n\n### 设备(Instrumentation)\n\n- `spring-instrument` 该模块是基于JAVA SE 中的\"java.lang.instrument\"进行设计的，应该算是 AOP的一个支援模块，主要作用是在 JVM\n  启用时，生成一个代理类，程序员通过代理类在运行时修改类的字节，从而改变一个类的功能，实现 AOP 的功能\n\n### 消息(Messaging)\n\n- `spring-messaging` 是从 Spring4 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用\n\n### 测试(Test)\n\n- `spring-test` 主要为测试提供支持的，通过 JUnit 和 TestNG 组件支持单元测试和集成测试。它提供了一致性地加载和缓存 Spring 上下文，也提供了用于单独测试代码的模拟对象（mock object）\n\n## IOC\n\n### IOC是什么？\n\n控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。\n\nSpring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。\n\n### 使用IOC的好处\n\n- 不用自己组装，拿来就用。\n- 享受单例的好处，效率高，不浪费空间\n- 便于单元测试，方便切换mock组件\n- 便于进行AOP操作，对于使用者是透明的\n- 统一配置，便于修改\n\n## BeanFactory 和 ApplicationContext有什么区别\n\nBeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。\n\n### 依赖关系\n\nBeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。\n\nApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：\n\n- 继承MessageSource，因此支持国际化。\n- 统一的资源文件访问方式。\n- 提供在监听器中注册bean的事件。\n- 同时加载多个配置文件。\n- 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。\n\n### 加载方式\n\nBeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())\n，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。\n\nApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。\nApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。\n\n相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。\n\n### 创建方式\n\nBeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。\n\n### 注册方式\n\nBeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。\n\n### Spring IoC的初始化过程\n\n#### IOC粗略总结\n\n1. 首先入口是xml或者注解或者其他形式，要实现beanDefinationReader接口，然后 读取的时候，会将他们解析为bean的定义信息；\n2. beanFactory在加载bean信息实例化（底层用的反射）之前，spring加了一个接口beanFactoryPostProcessor,用作扩展用。\n3. beanFactory内部实例化bean之后，在要初始化bean对象之前，增加了一个一系列aware接口，将他的容器，以及工厂都暴露出来供使用者做扩展用。\n4. 经过一些列容器以及容器对象的注入之后，在初始化之前，spring又增加了一个接口 beanPostProcessor,该接口是可以作用于所有创建的bean,在初始化前后，均能通过重写该接口获取bean对象进行定制操作。\n5. 经过实现初始化接口完成初始化功能。\n6. 经过实现销毁接口disposableBean结束其生命。\n\n#### 重要的组件\n\n- `BeanDefinition` 描述bean的属性的接口，例如bean的scope是单例还是多例，构造方法，有哪些property value，依赖等，相当于对这个bean的一份身份描述\n    - Bean配置 --> BeanDefinition --> Bean对象\n      -\n      懒加载情况下，refresh只是把BeanDefinition注册到BeanFactory中，而不是把Bean注册到BeanFactory中。在调用上下文的getBean的时候才会去根据BeanDefinition生成具体的bean对象\n- `BeanDefinitionMap`\n- `BeanFactory`\n    - spring的基础bean容器\n    - 相当于存放所有bean的容器\n- `ApplicationContext`\n    - BeanFactory 的子接口，在 BeanFactory 的基础上构建，是相对比较高级的 IoC 容器实现。包含 BeanFactory\n      的所有功能，还提供了其他高级的特性，比如：事件发布、国际化信息支持、统一资源加载策略等。正常情况下，我们都是使用的 ApplicationContext\n    - 相当于丰富了beanfactory的功能，这里理解为上下文就好\n- `FactoryBean`\n\n#### 源码解析\n\n首先抛开其他组件的启动，我们只需要引入spring-context就可以启动一个容器了\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n</dependency>\n```\n\n而在springboot出来之前最常见的加载bean的方式是读取配置文件\n\n```java\npublic static void main(String[]args){\n        ApplicationContext context=new ClassPathXmlApplicationContext(\"classpath:applicationfile.xml\");\n}\n```\n\n这里ApplicationContext是一个接口，主要的实现类有：\n\n- ClassPathXmlApplicationContext 需要一个 xml 配置文件在系统中的路径\n- FileSystemXmlApplicationContext 需要一个 xml 配置文件在系统中的路径\n- AnnotationConfigApplicationContext 基于注解，大势所趋\n\n下面的分析都基于 ClassPathXmlApplicationContext 进行分析，因为比较好理解点\n\n在 resources 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml就可以了,对应的类实现一个：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\n       default-autowire=\"byName\">\n\n    <bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\"/>\n</beans>\n```\n\nmain\n\n```java\npublic class App {\n    public static void main(String[] args) {\n        // 用我们的配置文件来启动一个 ApplicationContext\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:application.xml\");\n\n        System.out.println(\"context 启动成功\");\n\n        // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式\n        MessageService messageService = context.getBean(MessageService.class);\n        // 这句将输出: hello world\n        System.out.println(messageService.getMessage());\n    }\n}\n```\n\n在构造方法中的refresh()方法是启动加载整个容器的关键方法\n\n方法在springboot容器启动时也会加载,方法为\n\n- org.springframework.boot.SpringApplication#run\n- org.springframework.boot.SpringApplication#refreshContext\n\n```java\n@Override\npublic void refresh()throws BeansException,IllegalStateException{\n    // 1. 首先是一个synchronized加锁，当然要加锁，不然你先调一次refresh()然后这次还没处理完又调一次，就会乱套了；\n    synchronized (this.startupShutdownMonitor){\n        // 2. 这个方法是做准备工作的，记录容器的启动时间、标记“已启动”状态、处理配置文件中的占位符，可以点进去看看，这里就不多说了。\n        prepareRefresh();\n\n        // 3. 这个就很重要了，这一步是把配置文件解析成一个个Bean，并且注册到BeanFactory中，注意这里只是注册进去，并没有初始化。先继续往下看，等会展开这个方法详细解读\n        ConfigurableListableBeanFactory beanFactory=obtainFreshBeanFactory();\n\n        //4. 这个方法的作用是：设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean，这里都是spring里面的特殊处理，然后继续往下看\n        prepareBeanFactory(beanFactory);\n\n        try{\n            // 5. 方法是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化，具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类，来完成一些其他的操作。\n            postProcessBeanFactory(beanFactory);\n    \n            // 6. 接下来是这个方法是调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法；\n            invokeBeanFactoryPostProcessors(beanFactory);\n    \n            // 7. 然后这个方法注册 BeanPostProcessor 的实现类，和上面的BeanFactoryPostProcessor 是有区别的，这个方法调用的其实是PostProcessorRegistrationDelegate类的registerBeanPostProcessors方法；\n            // 这个类里面有个内部类BeanPostProcessorChecker，BeanPostProcessorChecker里面有两个方法postProcessBeforeInitialization和postProcessAfterInitialization，这两个方法分别在 Bean 初始化之前和初始化之后得到执行。\n            // 然后回到refresh()方法中继续往下看\n            registerBeanPostProcessors(beanFactory);\n    \n            // 8. 方法是初始化当前 ApplicationContext 的 MessageSource，国际化处理，继续往下\n            initMessageSource();\n    \n            // 9. 方法初始化当前 ApplicationContext 的事件广播器继续往下\n            initApplicationEventMulticaster();\n    \n            // 10. 方法初始化一些特殊的 Bean（在初始化 singleton beans 之前）；继续往下\n            onRefresh();\n    \n            // 11. 方法注册事件监听器，监听器需要实现 ApplicationListener 接口；继续往下\n            registerListeners();\n    \n            // 12. 重点到了 初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说\n            finishBeanFactoryInitialization(beanFactory);\n    \n            // 13. 方法是最后一步，广播事件，ApplicationContext 初始化完成\n            finishRefresh();\n        } catch(BeansException ex){\n            if(logger.isWarnEnabled()){\n                logger.warn(\"Exception encountered during context initialization - \"+\"cancelling refresh attempt: \"+ex);\n            }\n\n            // Destroy already created singletons to avoid dangling resources.\n            // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源\n            destroyBeans();\n    \n            // Reset 'active' flag.\n            cancelRefresh(ex);\n    \n            // Propagate exception to caller.\n            throw ex;\n        } finally{\n            // Reset common introspection caches in Spring's core, since we\n            // might not ever need metadata for singleton beans anymore...\n            resetCommonCaches();\n        }\n    }\n}\n```\n\n### Spring bean的生命周期\n\nSpring Bean的生命周期分为四个阶段和多个扩展点。扩展点又可以分为影响多个Bean和影响单个Bean。整理如下：\n\n四个阶段\n\n- 实例化 Instantiation\n- 属性赋值 Populate\n- 初始化 Initialization\n- 销毁 Destruction\n\n多个扩展点\n\n- 影响多个Bean\n    - BeanPostProcessor(作用于初始化阶段的前后)\n    - InstantiationAwareBeanPostProcessor(作用于实例化阶段的前后)\n- 影响单个Bean\n    - Aware(Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源)\n        - Aware Group1\n            - BeanNameAware\n            - BeanClassLoaderAware\n            - BeanFactoryAware\n        - Aware Group2\n            - EnvironmentAware\n            - EmbeddedValueResolverAware(实现该接口能够获取Spring EL解析器，用户的自定义注解需要支持spel表达式的时候可以使用)\n            - ApplicationContextAware(ResourceLoaderAware\\ApplicationEventPublisherAware\\MessageSourceAware)\n    - 生命周期(实例化和属性赋值都是Spring帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段)\n        - InitializingBean\n        - DisposableBean\n\n### bean的作用域\n\nSpring Bean 中所说的作用域，在配置文件中即是“scope”\n\n在面向对象程序设计中作用域一般指对象或变量之间的可见范围。\n\n而在Spring容器中是指其创建的Bean对象相对于其他Bean对象的请求可见范围。\n\n在Spring 容器当中，一共提供了5种作用域类型，在配置文件中，通过属性scope来设置bean的作用域范围\n\n#### singleton\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\"singleton\"></bean>\n```\n\n当Bean的作用域为singleton的时候,Spring容器中只会存在一个共享的Bean实例，所有对Bean的请求只要id与bean的定义相匹配，则只会返回bean的同一实例。单一实例会被存储在单例缓存中，为Spring的缺省作用域。\n\n#### prototype\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\" prototype \"></bean>\n```\n\n每次对该Bean请求的时候，Spring IoC都会创建一个新的作用域。\n\n对于有状态的Bean应该使用prototype，对于无状态的Bean则使用singleton\n\n#### request\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\" request \"></bean>\n```\n\nRequest作用域针对的是每次的Http请求，Spring容器会根据相关的Bean的\n\n定义来创建一个全新的Bean实例。而且该Bean只在当前request内是有效的。\n\n#### session\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\" session \"></bean>\n```\n\n针对http session起作用，Spring容器会根据该Bean的定义来创建一个全新的Bean的实例。而且该Bean只在当前http session内是有效的。\n\n#### global session\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\"globalSession\"></bean>\n```\n\n类似标准的http session作用域，不过仅仅在基于portlet的web应用当中才有意义。Portlet规范定义了全局的Session的概念。他被所有构成某个portlet外部应用中的各种不同的portlet所共享。在global\nsession作用域中所定义的bean被限定于全局的portlet session的生命周期范围之内。\n\n### 循环依赖问题\n\n#### 三级缓存\n\nSpring 解决循环依赖的核心就是提前暴露对象，而提前暴露的对象就是放置于第二级缓存中。下表是三级缓存的说明：\n\n| 名称                  | 描述                                                         |\n| --------------------- | ------------------------------------------------------------ |\n| singletonObjects      | 一级缓存，存放完整的 Bean。                                  |\n| earlySingletonObjects | 二级缓存，存放提前暴露的Bean，Bean 是不完整的，未完成属性注入和执行 init 方法。 |\n| singletonFactories    | 三级缓存，存放的是 Bean 工厂，主要是生产 Bean，存放到二级缓存中。 |\n\n所有被Spring 管理的 Bean，最终都会存放在 singletonObjects 中，这里面存放的 Bean 是经历了所有生命周期的（除了销毁的生命周期），完整的，可以给用户使用的。\n\nearlySingletonObjects 存放的是已经被实例化，但是还没有注入属性和执行 init 方法的 Bean。\n\nsingletonFactories 存放的是生产 Bean 的工厂。\n\nBean 都已经实例化了，为什么还需要一个生产 Bean 的工厂呢？这里实际上是跟 AOP 有关，如果项目中不需要为 Bean 进行代理，那么这个 Bean 工厂就会直接返回一开始实例化的对象，如果需要使用 AOP 进行代理，那么这个工厂就会发挥重要的作用了，这也是本文需要重点关注的问题之一。\n\n#### 解决循环依赖\n\nSpring 是如何通过上面介绍的三级缓存来解决循环依赖的呢？这里只用 A，B 形成的循环依赖来举例：\n\n1. 实例化 A，此时 A 还未完成属性填充和初始化方法（@PostConstruct）的执行，A 只是一个半成品。\n2. 为 A 创建一个 Bean 工厂，并放入到  singletonFactories 中。\n3. 发现 A 需要注入 B 对象，但是一级、二级、三级缓存均为发现对象 B。\n4. 实例化 B，此时 B 还未完成属性填充和初始化方法（@PostConstruct）的执行，B 只是一个半成品。\n5. 为 B 创建一个 Bean 工厂，并放入到  singletonFactories 中。\n6. 发现 B 需要注入 A 对象，此时在一级、二级未发现对象 A，但是在三级缓存中发现了对象 A，从三级缓存中得到对象 A，并将对象 A 放入二级缓存中，同时删除三级缓存中的对象 A。（注意，此时的 A 还是一个半成品，并没有完成属性填充和执行初始化方法）\n7. 将对象 A 注入到对象 B 中。\n8. 对象 B 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 B。（此时对象 B 已经是一个成品）\n9. 对象 A 得到对象 B，将对象 B 注入到对象 A 中。（对象 A 得到的是一个完整的对象 B）\n10. 对象 A 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 A。\n\n\n## Spring框架中的单例bean是否线程安全\n\nSpring框架中的单例bean是线程安全的吗？它是如何处理线程并发问题的?\n\n不是，Spring框架中的单例bean不是线程安全的。\n\nspring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。实际上大部分 spring bean 是无状态的（比如 dao 类），在某种程度上来说 bean 也是安全的，但如果 bean\n有状态的话（比如 view model ）就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了， 保证线程安全了。\n\n- 有状态就是有数据存储功能。\n- 无状态就是不会保存数据。\n\nSpring如何处理线程并发问题?\n\n一般只有无状态的Bean才可以在多线程下共享，大部分是无状态的Bean。当存有状态的Bean的时候，spring一般是使用ThreadLocal进行处理，解决线程安全问题。\n\nThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。\nThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，所以没有相同变量的访问冲突问题。所以在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。\n\n## AOP\n\nOOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。\n\nAOP(Aspect-Oriented Programming)\n，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。\n\n### AOP原理\n\n原理是在IOC过程中，创建bean实例时，最后都会对bean进行处理来实现增强，对于AOP来说就是创建代理类\n\n- 底层是动态代理技术\n    - JDK动态代理(基于接口)\n    - CGLib动态代理(基于类)\n    - 在Spring AOP中，如果使用的是单例，推荐使用CGLib代理\n\n### JDK动态代理\n\n(一）实现原理\n\nJDK的动态代理是基于反射实现。JDK通过反射，生成一个代理类，这个代理类实现了原来那个类的全部接口，并对接口中定义的所有方法进行了代理。当我们通过代理对象执行原来那个类的方法时，代理类底层会通过反射机制，回调我们实现的InvocationHandler接口的invoke方法。并且这个代理类是Proxy类的子类（记住这个结论，后面测试要用）。这就是JDK动态代理大致的实现方式。\n\n（二）优点\n\nJDK动态代理是JDK原生的，不需要任何依赖即可使用；\n\n通过反射机制生成代理类的速度要比CGLib操作字节码生成代理类的速度更快；\n\n（三）缺点\n\n如果要使用JDK动态代理，被代理的类必须实现了接口，否则无法代理；\n\nJDK动态代理无法为没有在接口中定义的方法实现代理，假设我们有一个实现了接口的类，我们为它的一个不属于接口中的方法配置了切面，Spring仍然会使用JDK的动态代理，但是由于配置了切面的方法不属于接口，为这个方法配置的切面将不会被织入。\n\nJDK动态代理执行代理方法时，需要通过反射机制进行回调，此时方法执行的效率比较低；\n\n### CGLib动态代理\n\n（一）实现原理\n\nCGLib实现动态代理的原理是，底层采用了ASM字节码生成框架，直接对需要代理的类的字节码进行操作，生成这个类的一个子类，并重写了类的所有可以重写的方法，在重写的过程中，将我们定义的额外的逻辑（简单理解为Spring中的切面）织入到方法中，对方法进行了增强。而通过字节码操作生成的代理类，和我们自己编写并编译后的类没有太大区别。\n\n（二）优点\n\n使用CGLib代理的类，不需要实现接口，因为CGLib生成的代理类是直接继承自需要被代理的类；\n\nCGLib生成的代理类是原来那个类的子类，这就意味着这个代理类可以为原来那个类中，所有能够被子类重写的方法进行代理；\n\nCGLib生成的代理类，和我们自己编写并编译的类没有太大区别，对方法的调用和直接调用普通类的方式一致，所以CGLib执行代理方法的效率要高于JDK的动态代理；\n\n（三）缺点\n\n由于CGLib的代理类使用的是继承，这也就意味着如果需要被代理的类是一个final类，则无法使用CGLib代理；\n\n由于CGLib实现代理方法的方式是重写父类的方法，所以无法对final方法，或者private方法进行代理，因为子类无法重写这些方法；\n\nCGLib生成代理类的方式是通过操作字节码，这种方式生成代理类的速度要比JDK通过反射生成代理类的速度更慢；\n\n### AOP术语\n\n#### 连接点(Join point)\n\n能够被拦截的地方\n\n#### 切点(Poincut)\n\n具体定位的连接点\n\n#### 增强/通知(Advice)\n\n表示添加到切点的一段逻辑代码，并定位连接点的方位信息\n\n#### 织入(Weaving)\n\n将增强/通知添加到目标类的具体连接点上的过程。\n\n#### 引入/引介(Introduction)\n\n允许我们向现有的类添加新方法或属性。是一种特殊的增强！\n\n#### 切面(Aspect)\n\n切面由切点和增强/通知组成，它既包括了横切逻辑的定义、也包括了连接点的定义\n\n### Spring对AOP的支持\n\n- 基于代理的经典SpringAOP：需要实现接口，手动创建代理\n- 纯POJO切面：使用XML配置，aop命名空间\n- @AspectJ注解驱动的切面：使用注解的方式，这是最简洁和最方便的！\n\n## 怎么定义一个注解\n\n### 引入依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n```\n\n### 定义注解\n\n#### 元注解\n\njava.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：\n\n- @Documented – 注解是否将包含在JavaDoc中\n- @Retention – 什么时候使用该注解\n- @Target – 注解用于什么地方\n- @Inherited – 是否允许子类继承该注解\n\n##### @Retention\n\n定义该注解的生命周期\n\n- RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。\n- RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式\n- RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。\n\n##### @Target\n\n表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType 参数包括\n\n- ElementType.CONSTRUCTOR: 用于描述构造器\n- ElementType.FIELD: 成员变量、对象、属性（包括enum实例）\n- ElementType.LOCAL_VARIABLE: 用于描述局部变量\n- ElementType.METHOD: 用于描述方法\n- ElementType.PACKAGE: 用于描述包\n- ElementType.PARAMETER: 用于描述参数\n- ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明\n\n##### @Documented\n\n一个简单的Annotations 标记注解，表示是否将注解信息添加在java文档中。\n\n##### @Inherited\n\n定义该注释和子类的关系\n\n@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class\n的子类。\n\n### 示例\n\n自定义一个检查是否登录的注解\n\n```java\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface CheckLogin {\n\n}\n```\n\n实现\n\n```java\n@Aspect\n@Component\n@Slf4j\n@Order(1)\npublic class CheckLoginAspect {\n\n    @Autowired\n    RedisTemplate redisTemplate;\n\n    @Before(\"execution(* *..controller..*(..))\")\n    public void before(JoinPoint joinPoint) {\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n        Method method = signature.getMethod();\n        CheckLogin annotation = method.getAnnotation(CheckLogin.class);\n\n        if (annotation == null) {\n            //获取类上注解\n            annotation = joinPoint.getTarget().getClass().getAnnotation(CheckLogin.class);\n        }\n        if (annotation != null) {\n            //获取到请求的属性\n            ServletRequestAttributes attributes =\n                    (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n            //获取到请求对象\n            HttpServletRequest request = attributes.getRequest();\n            String ssoToken = HttpUtil.getSsoToken(request);\n            if (ssoToken != null) {\n                String loginUserTokenKey = AuthRedisKeyUtil.getLoginUserTokenKey(ssoToken);\n                if (redisTemplate.hasKey(loginUserTokenKey)) {\n                    //通过\n                } else {\n                    throw new LoginException(\"登录已过期\");\n                }\n            } else {\n                throw new IllegalRequestException(\"非法请求\");\n            }\n        }\n    }\n}\n```\n\n使用\n\n```java\n@RestController\npublic class AccountController {\n\n    @CheckLogin\n    @GetMapping(\"/query\")\n    public JSONObject queryRegulation(Integer pageNum, Integer pageSize) {\n        //....业务逻辑\n    }\n}\n```\n\n## 事务\n\n### Spring 支持两种方式的事务管理\n\n#### 1、编程式事务管理\n\n- TransactionTemplate\n\n```java\n@Autowired\nprivate TransactionTemplate transactionTemplate;\n\npublic void testTransaction(){\n    transactionTemplate.execute(new TransactionCallbackWithoutResult(){\n        @Override\n        protected void doInTransactionWithoutResult(TransactionStatus status){\n                try{\n                    //...业务代码\n                }catch(Exception e){\n                    status.setRollbackOnly();\n                }\n        }\n    });\n}\n```\n\n- TransactionManager\n\n```java\n    @Autowired\nprivate PlatformTransactionManager transactionManager;\n\npublic void testTransaction2(){\n        TransactionStatus status=transactionManager.getTransaction(new DefaultTransactionDefinition());\n        try{\n            //...业务代码\n            transactionManager.commit(status);\n        }catch(Exception e){\n            transactionManager.rollback(status);\n        }\n}\n```\n\n#### 2、注解\n\n- @Transactional\n\n### 事务的传播性 Propagation\n\n① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。\n\n② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。\n\n③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。\n\n④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。\n\n⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n\n⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。\n\n⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。\n\n### spring事务失效的场景\n\n1. 非被Spring管理的Bean上的事务： 如果你在一个非被Spring容器管理的Bean（例如通过new关键字直接创建的对象）上使用事务注解，事务将不会生效。Spring的事务管理是基于AOP（面向切面编程）实现的，因此只能在由Spring容器管理的Bean上起作用。\n\n2. 未捕获的异常： 如果在事务内发生未捕获的运行时异常，事务将回滚。但是，如果异常被捕获并在方法内处理，事务可能不会回滚。确保在事务边界内处理异常或者允许异常传播到事务管理器以便正确回滚。\n\n   ```java\n   @Transactional\n   public void transactionalMethod() {\n       try {\n           // some code that may throw an exception\n       } catch (Exception e) {\n           // handle the exception (not recommended within a transaction)\n       }\n   }\n   ```\n\n3. 嵌套事务问题： Spring事务支持嵌套事务，但是嵌套事务的行为取决于底层事务管理器的支持。如果使用的事务管理器不支持嵌套事务，嵌套事务可能会被忽略，导致事务行为不一致。\n\n4. 方法调用问题： Spring事务是通过AOP实现的，它依赖于代理对象来拦截方法调用并处理事务。如果你在同一个类内部调用一个带有事务注解的方法，事务可能不会起作用，因为代理对象无法拦截内部方法的调用。确保事务注解生效，要么调用方法是通过代理对象，要么通过self-invocation，例如通过this关键字。\n\n   ```java\n   @Transactional\n   public class MyService {\n       public void outerMethod() {\n           innerMethod(); // Transactional annotation may not work here\n           this.innerMethod(); // Transactional annotation should work here\n       }\n   \n       @Transactional\n       public void innerMethod() {\n           // some transactional logic\n       }\n   }\n   \n   ```\n\n5. 异步方法问题： 如果使用了异步方法（通过@Async注解），事务可能会失效。在异步方法内，事务上下文可能无法正确传播，导致事务不起作用。要在异步方法中使用事务，可以使用TransactionContext传播方式。\n\n\n## spring使用的设计模式\n\n### 简单工厂\n\n**实现方式：**\n\nBeanFactory。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。\n\n**实现原理：**\n\nbean容器的启动阶段：\n\n读取bean的xml配置文件,将bean元素分别转换成一个BeanDefinition对象。\n然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个ConcurrentHashMap中。\n将BeanDefinition注册到了beanFactory之后，在这里Spring为我们提供了一个扩展的切口，允许我们通过实现接口BeanFactoryPostProcessor\n在此处来插入我们定义的代码。典型的例子就是：PropertyPlaceholderConfigurer，我们一般在配置数据库的dataSource时使用到的占位符的值，就是它注入进去的。\n\n容器中bean的实例化阶段：\n\n实例化阶段主要是通过反射或者CGLIB对bean进行实例化，在这个阶段Spring又给我们暴露了很多的扩展点：\n\n各种的Aware接口 ，比如 BeanFactoryAware，对于实现了这些Aware接口的bean，在实例化bean时Spring会帮我们注入对应的BeanFactory的实例。 BeanPostProcessor接口\n，实现了BeanPostProcessor接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 InitializingBean接口\n，实现了InitializingBean接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 DisposableBean接口\n，实现了DisposableBean接口的bean，在该bean死亡时Spring会帮我们调用接口中的方法。\n\n**设计意义：**\n\n松耦合。\n可以将原来硬编码的依赖，通过Spring这个beanFactory这个工厂来注入依赖，也就是说原来只有依赖方和被依赖方，现在我们引入了第三方——spring这个beanFactory，由它来解决bean之间的依赖问题，达到了松耦合的效果.\n\nbean的额外处理。 通过Spring接口的暴露，在实例化bean的阶段我们可以进行一些额外的处理，这些额外的处理只需要让bean实现对应的接口即可，那么spring就会在bean的生命周期调用我们实现的接口来处理该bean。[非常重要]\n\n### 工厂方法\n\n**实现方式：**\n\nFactoryBean接口。\n\n**实现原理：**\n\n实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()\n方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。\n\n### 单例模式\n\nSpring依赖注入Bean实例默认是单例的。\n\nSpring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。\n\n### 适配器模式\n\n**实现方式：**\n\nSpringMVC中的适配器HandlerAdatper。\n\n**实现原理：**\n\nHandlerAdatper根据Handler规则执行不同的Handler。\n\n**实现过程：**\n\nDispatcherServlet根据HandlerMapping返回的handler，向HandlerAdatper发起请求，处理Handler。\n\nHandlerAdapter根据规则找到对应的Handler并让其执行，执行完毕后Handler会向HandlerAdapter返回一个ModelAndView，最后由HandlerAdapter向DispatchServelet返回一个ModelAndView。\n\n### 装饰器模式\n\n**实现方式：**\n\nSpring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。\n\n**实质：**\n\n动态地给一个对象添加一些额外的职责。\n\n就增加功能来说，Decorator模式相比生成子类更为灵活。\n\n### 代理模式\n\n**实现方式：**\n\nAOP底层，就是动态代理模式的实现。\n\n**动态代理：**\n\n在内存中构建的，不需要手动编写代理类\n\n## spring中properties和yml的加载顺序\n\n相同内容properties和yml的加载顺序是properties优先\n\n## 使用@Autowired注解自动装配的过程是怎样的？\n\n使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，<context:annotation-config />。\n\n在启动spring\nIoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：\n\n- 如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；\n- 如果查询的结果不止一个，那么@Autowired会根据名称来查找；\n- 如果上述查找的结果为空，那么会抛出异常。解决方法是，使用required=false。\n\n## @Autowired和@Resource之间的区别\n\n@Autowired可用于：构造函数、成员变量、Setter方法\n\n@Autowired和@Resource之间的区别\n\n- @Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。\n- @Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。\n\n## Spring中BeanFactory与FactoryBean的区别\n\n### BeanFactory\n\nBeanFactory是一个接口，它是Spring中工厂的顶层规范，是SpringIoc容器的核心接口，它定义了getBean()、containsBean()等管理Bean的通用方法。Spring的容器都是它的具体实现如：\n\n- DefaultListableBeanFactory\n- XmlBeanFactory\n- ApplicationContext\n\n这些实现类又从不同的维度分别有不同的扩展。\n\n### FactoryBean\n\n首先它是一个Bean，但又不仅仅是一个Bean。它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式。它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。\n\nFactoryBean表现的是一个工厂的职责。 即一个Bean A如果实现了FactoryBean接口，那么A就变成了一个工厂，根据A的名称获取到的实际上是工厂调用getObject()\n返回的对象，而不是A本身，如果要获取工厂A自身的实例，那么需要在名称前面加上'&'符号。\n\n- getObject('name')返回工厂中的实例\n- getObject('&name')返回工厂本身的实例\n","source":"_posts/Spring最热点面试题.md","raw":"---\ntitle: Spring最热点面试题\ndate: 2024-05-26 22:42:28\ntags: spring\ncategories: 面试\n---\n\n# spring\n\n## 架构图\n\n![结构图](./2024/05/26/Spring最热点面试题/1.png)\n\n## 模块\n\n### Core Container\n\n核心容器(Core Container)\n\n- `spring-beans` 该模块是依赖注入IoC与DI的最基本实现\n- `spring-core` 该模块是Bean工厂与bean的装配\n- `spring-context` 该模块构架于核心模块之上，它扩展了 BeanFactory，为它添加了 Bean 生命周期控制、框架事件体系以及资源加载透明化等功能。ApplicationContext 是该模块的核心接口，它的超类是\n  BeanFactory。与BeanFactory 不同，ApplicationContext 容器实例化后会自动对所有的单实例 Bean 进行实例化与依赖关系的装配，使之处于待用状态\n- `spring-context-indexer` 该模块是 Spring 的类管理组件和 Classpath 扫描\n- `spring-context-support` 该模块是对 Spring IOC 容器的扩展支持，以及 IOC 子容器\n- `spring-expression` 该模块是Spring表达式语言块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等\n\n### Data Access/Integration\n\n数据访问/集成\n\n- `spring-jdbc` 该模块提供了 JDBC抽象层，它消除了冗长的 JDBC 编码和对数据库供应商特定错误代码的解析\n- `spring-tx` 该模块支持编程式事务和声明式事务，可用于实现了特定接口的类和所有的 POJO 对象。编程式事务需要自己写beginTransaction()、commit()、rollback()\n  等事务管理方法，声明式事务是通过注解或配置由 spring 自动处理，编程式事务粒度更细\n- `spring-orm` 该模块提供了对流行的对象关系映射 API的集成，包括 JPA、JDO 和 Hibernate 等。通过此模块可以让这些 ORM 框架和 spring 的其它功能整合，比如前面提及的事务管理\n- `spring-oxm` 该模块提供了对 OXM 实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等\n- `spring-jms` 该模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了 spring-messaging 模块\n\n### Web\n\n网络部分\n\n- `spring-web` 该模块为 Spring 提供了最基础 Web 支持，主要建立于核心容器之上，通过 Servlet 或者 Listeners 来初始化 IOC 容器，也包含一些与 Web 相关的支持\n- `spring-webmvc` 该模块众所周知是一个的 Web-Servlet 模块，实现了 Spring MVC（model-view-Controller）的 Web 应用\n- `spring-websocket` 该模块主要是与 Web 前端的全双工通讯的协议\n- `spring-webflux` 该模块是一个新的非堵塞函数式 Reactive Web 框架，可以用来建立异步的，非阻塞，事件驱动的服务，并且扩展性非常好。\n\n### 面向切面编程(AOP和Aspects)\n\n- `spring-aop` 该模块是Spring的另一个核心模块，是 AOP 主要的实现模块\n- `spring-aspects` 该模块提供了对 AspectJ 的集成，主要是为 Spring AOP提供多种 AOP 实现方法，如前置方法后置方法等\n\n### 设备(Instrumentation)\n\n- `spring-instrument` 该模块是基于JAVA SE 中的\"java.lang.instrument\"进行设计的，应该算是 AOP的一个支援模块，主要作用是在 JVM\n  启用时，生成一个代理类，程序员通过代理类在运行时修改类的字节，从而改变一个类的功能，实现 AOP 的功能\n\n### 消息(Messaging)\n\n- `spring-messaging` 是从 Spring4 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用\n\n### 测试(Test)\n\n- `spring-test` 主要为测试提供支持的，通过 JUnit 和 TestNG 组件支持单元测试和集成测试。它提供了一致性地加载和缓存 Spring 上下文，也提供了用于单独测试代码的模拟对象（mock object）\n\n## IOC\n\n### IOC是什么？\n\n控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。\n\nSpring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。\n\n### 使用IOC的好处\n\n- 不用自己组装，拿来就用。\n- 享受单例的好处，效率高，不浪费空间\n- 便于单元测试，方便切换mock组件\n- 便于进行AOP操作，对于使用者是透明的\n- 统一配置，便于修改\n\n## BeanFactory 和 ApplicationContext有什么区别\n\nBeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。\n\n### 依赖关系\n\nBeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。\n\nApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：\n\n- 继承MessageSource，因此支持国际化。\n- 统一的资源文件访问方式。\n- 提供在监听器中注册bean的事件。\n- 同时加载多个配置文件。\n- 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。\n\n### 加载方式\n\nBeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())\n，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。\n\nApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。\nApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。\n\n相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。\n\n### 创建方式\n\nBeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。\n\n### 注册方式\n\nBeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。\n\n### Spring IoC的初始化过程\n\n#### IOC粗略总结\n\n1. 首先入口是xml或者注解或者其他形式，要实现beanDefinationReader接口，然后 读取的时候，会将他们解析为bean的定义信息；\n2. beanFactory在加载bean信息实例化（底层用的反射）之前，spring加了一个接口beanFactoryPostProcessor,用作扩展用。\n3. beanFactory内部实例化bean之后，在要初始化bean对象之前，增加了一个一系列aware接口，将他的容器，以及工厂都暴露出来供使用者做扩展用。\n4. 经过一些列容器以及容器对象的注入之后，在初始化之前，spring又增加了一个接口 beanPostProcessor,该接口是可以作用于所有创建的bean,在初始化前后，均能通过重写该接口获取bean对象进行定制操作。\n5. 经过实现初始化接口完成初始化功能。\n6. 经过实现销毁接口disposableBean结束其生命。\n\n#### 重要的组件\n\n- `BeanDefinition` 描述bean的属性的接口，例如bean的scope是单例还是多例，构造方法，有哪些property value，依赖等，相当于对这个bean的一份身份描述\n    - Bean配置 --> BeanDefinition --> Bean对象\n      -\n      懒加载情况下，refresh只是把BeanDefinition注册到BeanFactory中，而不是把Bean注册到BeanFactory中。在调用上下文的getBean的时候才会去根据BeanDefinition生成具体的bean对象\n- `BeanDefinitionMap`\n- `BeanFactory`\n    - spring的基础bean容器\n    - 相当于存放所有bean的容器\n- `ApplicationContext`\n    - BeanFactory 的子接口，在 BeanFactory 的基础上构建，是相对比较高级的 IoC 容器实现。包含 BeanFactory\n      的所有功能，还提供了其他高级的特性，比如：事件发布、国际化信息支持、统一资源加载策略等。正常情况下，我们都是使用的 ApplicationContext\n    - 相当于丰富了beanfactory的功能，这里理解为上下文就好\n- `FactoryBean`\n\n#### 源码解析\n\n首先抛开其他组件的启动，我们只需要引入spring-context就可以启动一个容器了\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n</dependency>\n```\n\n而在springboot出来之前最常见的加载bean的方式是读取配置文件\n\n```java\npublic static void main(String[]args){\n        ApplicationContext context=new ClassPathXmlApplicationContext(\"classpath:applicationfile.xml\");\n}\n```\n\n这里ApplicationContext是一个接口，主要的实现类有：\n\n- ClassPathXmlApplicationContext 需要一个 xml 配置文件在系统中的路径\n- FileSystemXmlApplicationContext 需要一个 xml 配置文件在系统中的路径\n- AnnotationConfigApplicationContext 基于注解，大势所趋\n\n下面的分析都基于 ClassPathXmlApplicationContext 进行分析，因为比较好理解点\n\n在 resources 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml就可以了,对应的类实现一个：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns=\"http://www.springframework.org/schema/beans\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\n       default-autowire=\"byName\">\n\n    <bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\"/>\n</beans>\n```\n\nmain\n\n```java\npublic class App {\n    public static void main(String[] args) {\n        // 用我们的配置文件来启动一个 ApplicationContext\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:application.xml\");\n\n        System.out.println(\"context 启动成功\");\n\n        // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式\n        MessageService messageService = context.getBean(MessageService.class);\n        // 这句将输出: hello world\n        System.out.println(messageService.getMessage());\n    }\n}\n```\n\n在构造方法中的refresh()方法是启动加载整个容器的关键方法\n\n方法在springboot容器启动时也会加载,方法为\n\n- org.springframework.boot.SpringApplication#run\n- org.springframework.boot.SpringApplication#refreshContext\n\n```java\n@Override\npublic void refresh()throws BeansException,IllegalStateException{\n    // 1. 首先是一个synchronized加锁，当然要加锁，不然你先调一次refresh()然后这次还没处理完又调一次，就会乱套了；\n    synchronized (this.startupShutdownMonitor){\n        // 2. 这个方法是做准备工作的，记录容器的启动时间、标记“已启动”状态、处理配置文件中的占位符，可以点进去看看，这里就不多说了。\n        prepareRefresh();\n\n        // 3. 这个就很重要了，这一步是把配置文件解析成一个个Bean，并且注册到BeanFactory中，注意这里只是注册进去，并没有初始化。先继续往下看，等会展开这个方法详细解读\n        ConfigurableListableBeanFactory beanFactory=obtainFreshBeanFactory();\n\n        //4. 这个方法的作用是：设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean，这里都是spring里面的特殊处理，然后继续往下看\n        prepareBeanFactory(beanFactory);\n\n        try{\n            // 5. 方法是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化，具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类，来完成一些其他的操作。\n            postProcessBeanFactory(beanFactory);\n    \n            // 6. 接下来是这个方法是调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法；\n            invokeBeanFactoryPostProcessors(beanFactory);\n    \n            // 7. 然后这个方法注册 BeanPostProcessor 的实现类，和上面的BeanFactoryPostProcessor 是有区别的，这个方法调用的其实是PostProcessorRegistrationDelegate类的registerBeanPostProcessors方法；\n            // 这个类里面有个内部类BeanPostProcessorChecker，BeanPostProcessorChecker里面有两个方法postProcessBeforeInitialization和postProcessAfterInitialization，这两个方法分别在 Bean 初始化之前和初始化之后得到执行。\n            // 然后回到refresh()方法中继续往下看\n            registerBeanPostProcessors(beanFactory);\n    \n            // 8. 方法是初始化当前 ApplicationContext 的 MessageSource，国际化处理，继续往下\n            initMessageSource();\n    \n            // 9. 方法初始化当前 ApplicationContext 的事件广播器继续往下\n            initApplicationEventMulticaster();\n    \n            // 10. 方法初始化一些特殊的 Bean（在初始化 singleton beans 之前）；继续往下\n            onRefresh();\n    \n            // 11. 方法注册事件监听器，监听器需要实现 ApplicationListener 接口；继续往下\n            registerListeners();\n    \n            // 12. 重点到了 初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说\n            finishBeanFactoryInitialization(beanFactory);\n    \n            // 13. 方法是最后一步，广播事件，ApplicationContext 初始化完成\n            finishRefresh();\n        } catch(BeansException ex){\n            if(logger.isWarnEnabled()){\n                logger.warn(\"Exception encountered during context initialization - \"+\"cancelling refresh attempt: \"+ex);\n            }\n\n            // Destroy already created singletons to avoid dangling resources.\n            // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源\n            destroyBeans();\n    \n            // Reset 'active' flag.\n            cancelRefresh(ex);\n    \n            // Propagate exception to caller.\n            throw ex;\n        } finally{\n            // Reset common introspection caches in Spring's core, since we\n            // might not ever need metadata for singleton beans anymore...\n            resetCommonCaches();\n        }\n    }\n}\n```\n\n### Spring bean的生命周期\n\nSpring Bean的生命周期分为四个阶段和多个扩展点。扩展点又可以分为影响多个Bean和影响单个Bean。整理如下：\n\n四个阶段\n\n- 实例化 Instantiation\n- 属性赋值 Populate\n- 初始化 Initialization\n- 销毁 Destruction\n\n多个扩展点\n\n- 影响多个Bean\n    - BeanPostProcessor(作用于初始化阶段的前后)\n    - InstantiationAwareBeanPostProcessor(作用于实例化阶段的前后)\n- 影响单个Bean\n    - Aware(Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源)\n        - Aware Group1\n            - BeanNameAware\n            - BeanClassLoaderAware\n            - BeanFactoryAware\n        - Aware Group2\n            - EnvironmentAware\n            - EmbeddedValueResolverAware(实现该接口能够获取Spring EL解析器，用户的自定义注解需要支持spel表达式的时候可以使用)\n            - ApplicationContextAware(ResourceLoaderAware\\ApplicationEventPublisherAware\\MessageSourceAware)\n    - 生命周期(实例化和属性赋值都是Spring帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段)\n        - InitializingBean\n        - DisposableBean\n\n### bean的作用域\n\nSpring Bean 中所说的作用域，在配置文件中即是“scope”\n\n在面向对象程序设计中作用域一般指对象或变量之间的可见范围。\n\n而在Spring容器中是指其创建的Bean对象相对于其他Bean对象的请求可见范围。\n\n在Spring 容器当中，一共提供了5种作用域类型，在配置文件中，通过属性scope来设置bean的作用域范围\n\n#### singleton\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\"singleton\"></bean>\n```\n\n当Bean的作用域为singleton的时候,Spring容器中只会存在一个共享的Bean实例，所有对Bean的请求只要id与bean的定义相匹配，则只会返回bean的同一实例。单一实例会被存储在单例缓存中，为Spring的缺省作用域。\n\n#### prototype\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\" prototype \"></bean>\n```\n\n每次对该Bean请求的时候，Spring IoC都会创建一个新的作用域。\n\n对于有状态的Bean应该使用prototype，对于无状态的Bean则使用singleton\n\n#### request\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\" request \"></bean>\n```\n\nRequest作用域针对的是每次的Http请求，Spring容器会根据相关的Bean的\n\n定义来创建一个全新的Bean实例。而且该Bean只在当前request内是有效的。\n\n#### session\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\" session \"></bean>\n```\n\n针对http session起作用，Spring容器会根据该Bean的定义来创建一个全新的Bean的实例。而且该Bean只在当前http session内是有效的。\n\n#### global session\n\n```xml\n<bean id=\"userInfo\" class=\"cn.lovepi.UserInfo\" scope=\"globalSession\"></bean>\n```\n\n类似标准的http session作用域，不过仅仅在基于portlet的web应用当中才有意义。Portlet规范定义了全局的Session的概念。他被所有构成某个portlet外部应用中的各种不同的portlet所共享。在global\nsession作用域中所定义的bean被限定于全局的portlet session的生命周期范围之内。\n\n### 循环依赖问题\n\n#### 三级缓存\n\nSpring 解决循环依赖的核心就是提前暴露对象，而提前暴露的对象就是放置于第二级缓存中。下表是三级缓存的说明：\n\n| 名称                  | 描述                                                         |\n| --------------------- | ------------------------------------------------------------ |\n| singletonObjects      | 一级缓存，存放完整的 Bean。                                  |\n| earlySingletonObjects | 二级缓存，存放提前暴露的Bean，Bean 是不完整的，未完成属性注入和执行 init 方法。 |\n| singletonFactories    | 三级缓存，存放的是 Bean 工厂，主要是生产 Bean，存放到二级缓存中。 |\n\n所有被Spring 管理的 Bean，最终都会存放在 singletonObjects 中，这里面存放的 Bean 是经历了所有生命周期的（除了销毁的生命周期），完整的，可以给用户使用的。\n\nearlySingletonObjects 存放的是已经被实例化，但是还没有注入属性和执行 init 方法的 Bean。\n\nsingletonFactories 存放的是生产 Bean 的工厂。\n\nBean 都已经实例化了，为什么还需要一个生产 Bean 的工厂呢？这里实际上是跟 AOP 有关，如果项目中不需要为 Bean 进行代理，那么这个 Bean 工厂就会直接返回一开始实例化的对象，如果需要使用 AOP 进行代理，那么这个工厂就会发挥重要的作用了，这也是本文需要重点关注的问题之一。\n\n#### 解决循环依赖\n\nSpring 是如何通过上面介绍的三级缓存来解决循环依赖的呢？这里只用 A，B 形成的循环依赖来举例：\n\n1. 实例化 A，此时 A 还未完成属性填充和初始化方法（@PostConstruct）的执行，A 只是一个半成品。\n2. 为 A 创建一个 Bean 工厂，并放入到  singletonFactories 中。\n3. 发现 A 需要注入 B 对象，但是一级、二级、三级缓存均为发现对象 B。\n4. 实例化 B，此时 B 还未完成属性填充和初始化方法（@PostConstruct）的执行，B 只是一个半成品。\n5. 为 B 创建一个 Bean 工厂，并放入到  singletonFactories 中。\n6. 发现 B 需要注入 A 对象，此时在一级、二级未发现对象 A，但是在三级缓存中发现了对象 A，从三级缓存中得到对象 A，并将对象 A 放入二级缓存中，同时删除三级缓存中的对象 A。（注意，此时的 A 还是一个半成品，并没有完成属性填充和执行初始化方法）\n7. 将对象 A 注入到对象 B 中。\n8. 对象 B 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 B。（此时对象 B 已经是一个成品）\n9. 对象 A 得到对象 B，将对象 B 注入到对象 A 中。（对象 A 得到的是一个完整的对象 B）\n10. 对象 A 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 A。\n\n\n## Spring框架中的单例bean是否线程安全\n\nSpring框架中的单例bean是线程安全的吗？它是如何处理线程并发问题的?\n\n不是，Spring框架中的单例bean不是线程安全的。\n\nspring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。实际上大部分 spring bean 是无状态的（比如 dao 类），在某种程度上来说 bean 也是安全的，但如果 bean\n有状态的话（比如 view model ）就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了， 保证线程安全了。\n\n- 有状态就是有数据存储功能。\n- 无状态就是不会保存数据。\n\nSpring如何处理线程并发问题?\n\n一般只有无状态的Bean才可以在多线程下共享，大部分是无状态的Bean。当存有状态的Bean的时候，spring一般是使用ThreadLocal进行处理，解决线程安全问题。\n\nThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。\nThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，所以没有相同变量的访问冲突问题。所以在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。\n\n## AOP\n\nOOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。\n\nAOP(Aspect-Oriented Programming)\n，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。\n\n### AOP原理\n\n原理是在IOC过程中，创建bean实例时，最后都会对bean进行处理来实现增强，对于AOP来说就是创建代理类\n\n- 底层是动态代理技术\n    - JDK动态代理(基于接口)\n    - CGLib动态代理(基于类)\n    - 在Spring AOP中，如果使用的是单例，推荐使用CGLib代理\n\n### JDK动态代理\n\n(一）实现原理\n\nJDK的动态代理是基于反射实现。JDK通过反射，生成一个代理类，这个代理类实现了原来那个类的全部接口，并对接口中定义的所有方法进行了代理。当我们通过代理对象执行原来那个类的方法时，代理类底层会通过反射机制，回调我们实现的InvocationHandler接口的invoke方法。并且这个代理类是Proxy类的子类（记住这个结论，后面测试要用）。这就是JDK动态代理大致的实现方式。\n\n（二）优点\n\nJDK动态代理是JDK原生的，不需要任何依赖即可使用；\n\n通过反射机制生成代理类的速度要比CGLib操作字节码生成代理类的速度更快；\n\n（三）缺点\n\n如果要使用JDK动态代理，被代理的类必须实现了接口，否则无法代理；\n\nJDK动态代理无法为没有在接口中定义的方法实现代理，假设我们有一个实现了接口的类，我们为它的一个不属于接口中的方法配置了切面，Spring仍然会使用JDK的动态代理，但是由于配置了切面的方法不属于接口，为这个方法配置的切面将不会被织入。\n\nJDK动态代理执行代理方法时，需要通过反射机制进行回调，此时方法执行的效率比较低；\n\n### CGLib动态代理\n\n（一）实现原理\n\nCGLib实现动态代理的原理是，底层采用了ASM字节码生成框架，直接对需要代理的类的字节码进行操作，生成这个类的一个子类，并重写了类的所有可以重写的方法，在重写的过程中，将我们定义的额外的逻辑（简单理解为Spring中的切面）织入到方法中，对方法进行了增强。而通过字节码操作生成的代理类，和我们自己编写并编译后的类没有太大区别。\n\n（二）优点\n\n使用CGLib代理的类，不需要实现接口，因为CGLib生成的代理类是直接继承自需要被代理的类；\n\nCGLib生成的代理类是原来那个类的子类，这就意味着这个代理类可以为原来那个类中，所有能够被子类重写的方法进行代理；\n\nCGLib生成的代理类，和我们自己编写并编译的类没有太大区别，对方法的调用和直接调用普通类的方式一致，所以CGLib执行代理方法的效率要高于JDK的动态代理；\n\n（三）缺点\n\n由于CGLib的代理类使用的是继承，这也就意味着如果需要被代理的类是一个final类，则无法使用CGLib代理；\n\n由于CGLib实现代理方法的方式是重写父类的方法，所以无法对final方法，或者private方法进行代理，因为子类无法重写这些方法；\n\nCGLib生成代理类的方式是通过操作字节码，这种方式生成代理类的速度要比JDK通过反射生成代理类的速度更慢；\n\n### AOP术语\n\n#### 连接点(Join point)\n\n能够被拦截的地方\n\n#### 切点(Poincut)\n\n具体定位的连接点\n\n#### 增强/通知(Advice)\n\n表示添加到切点的一段逻辑代码，并定位连接点的方位信息\n\n#### 织入(Weaving)\n\n将增强/通知添加到目标类的具体连接点上的过程。\n\n#### 引入/引介(Introduction)\n\n允许我们向现有的类添加新方法或属性。是一种特殊的增强！\n\n#### 切面(Aspect)\n\n切面由切点和增强/通知组成，它既包括了横切逻辑的定义、也包括了连接点的定义\n\n### Spring对AOP的支持\n\n- 基于代理的经典SpringAOP：需要实现接口，手动创建代理\n- 纯POJO切面：使用XML配置，aop命名空间\n- @AspectJ注解驱动的切面：使用注解的方式，这是最简洁和最方便的！\n\n## 怎么定义一个注解\n\n### 引入依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n```\n\n### 定义注解\n\n#### 元注解\n\njava.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：\n\n- @Documented – 注解是否将包含在JavaDoc中\n- @Retention – 什么时候使用该注解\n- @Target – 注解用于什么地方\n- @Inherited – 是否允许子类继承该注解\n\n##### @Retention\n\n定义该注解的生命周期\n\n- RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。\n- RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式\n- RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。\n\n##### @Target\n\n表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType 参数包括\n\n- ElementType.CONSTRUCTOR: 用于描述构造器\n- ElementType.FIELD: 成员变量、对象、属性（包括enum实例）\n- ElementType.LOCAL_VARIABLE: 用于描述局部变量\n- ElementType.METHOD: 用于描述方法\n- ElementType.PACKAGE: 用于描述包\n- ElementType.PARAMETER: 用于描述参数\n- ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明\n\n##### @Documented\n\n一个简单的Annotations 标记注解，表示是否将注解信息添加在java文档中。\n\n##### @Inherited\n\n定义该注释和子类的关系\n\n@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class\n的子类。\n\n### 示例\n\n自定义一个检查是否登录的注解\n\n```java\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface CheckLogin {\n\n}\n```\n\n实现\n\n```java\n@Aspect\n@Component\n@Slf4j\n@Order(1)\npublic class CheckLoginAspect {\n\n    @Autowired\n    RedisTemplate redisTemplate;\n\n    @Before(\"execution(* *..controller..*(..))\")\n    public void before(JoinPoint joinPoint) {\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n        Method method = signature.getMethod();\n        CheckLogin annotation = method.getAnnotation(CheckLogin.class);\n\n        if (annotation == null) {\n            //获取类上注解\n            annotation = joinPoint.getTarget().getClass().getAnnotation(CheckLogin.class);\n        }\n        if (annotation != null) {\n            //获取到请求的属性\n            ServletRequestAttributes attributes =\n                    (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n            //获取到请求对象\n            HttpServletRequest request = attributes.getRequest();\n            String ssoToken = HttpUtil.getSsoToken(request);\n            if (ssoToken != null) {\n                String loginUserTokenKey = AuthRedisKeyUtil.getLoginUserTokenKey(ssoToken);\n                if (redisTemplate.hasKey(loginUserTokenKey)) {\n                    //通过\n                } else {\n                    throw new LoginException(\"登录已过期\");\n                }\n            } else {\n                throw new IllegalRequestException(\"非法请求\");\n            }\n        }\n    }\n}\n```\n\n使用\n\n```java\n@RestController\npublic class AccountController {\n\n    @CheckLogin\n    @GetMapping(\"/query\")\n    public JSONObject queryRegulation(Integer pageNum, Integer pageSize) {\n        //....业务逻辑\n    }\n}\n```\n\n## 事务\n\n### Spring 支持两种方式的事务管理\n\n#### 1、编程式事务管理\n\n- TransactionTemplate\n\n```java\n@Autowired\nprivate TransactionTemplate transactionTemplate;\n\npublic void testTransaction(){\n    transactionTemplate.execute(new TransactionCallbackWithoutResult(){\n        @Override\n        protected void doInTransactionWithoutResult(TransactionStatus status){\n                try{\n                    //...业务代码\n                }catch(Exception e){\n                    status.setRollbackOnly();\n                }\n        }\n    });\n}\n```\n\n- TransactionManager\n\n```java\n    @Autowired\nprivate PlatformTransactionManager transactionManager;\n\npublic void testTransaction2(){\n        TransactionStatus status=transactionManager.getTransaction(new DefaultTransactionDefinition());\n        try{\n            //...业务代码\n            transactionManager.commit(status);\n        }catch(Exception e){\n            transactionManager.rollback(status);\n        }\n}\n```\n\n#### 2、注解\n\n- @Transactional\n\n### 事务的传播性 Propagation\n\n① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。\n\n② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。\n\n③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。\n\n④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。\n\n⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n\n⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。\n\n⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。\n\n### spring事务失效的场景\n\n1. 非被Spring管理的Bean上的事务： 如果你在一个非被Spring容器管理的Bean（例如通过new关键字直接创建的对象）上使用事务注解，事务将不会生效。Spring的事务管理是基于AOP（面向切面编程）实现的，因此只能在由Spring容器管理的Bean上起作用。\n\n2. 未捕获的异常： 如果在事务内发生未捕获的运行时异常，事务将回滚。但是，如果异常被捕获并在方法内处理，事务可能不会回滚。确保在事务边界内处理异常或者允许异常传播到事务管理器以便正确回滚。\n\n   ```java\n   @Transactional\n   public void transactionalMethod() {\n       try {\n           // some code that may throw an exception\n       } catch (Exception e) {\n           // handle the exception (not recommended within a transaction)\n       }\n   }\n   ```\n\n3. 嵌套事务问题： Spring事务支持嵌套事务，但是嵌套事务的行为取决于底层事务管理器的支持。如果使用的事务管理器不支持嵌套事务，嵌套事务可能会被忽略，导致事务行为不一致。\n\n4. 方法调用问题： Spring事务是通过AOP实现的，它依赖于代理对象来拦截方法调用并处理事务。如果你在同一个类内部调用一个带有事务注解的方法，事务可能不会起作用，因为代理对象无法拦截内部方法的调用。确保事务注解生效，要么调用方法是通过代理对象，要么通过self-invocation，例如通过this关键字。\n\n   ```java\n   @Transactional\n   public class MyService {\n       public void outerMethod() {\n           innerMethod(); // Transactional annotation may not work here\n           this.innerMethod(); // Transactional annotation should work here\n       }\n   \n       @Transactional\n       public void innerMethod() {\n           // some transactional logic\n       }\n   }\n   \n   ```\n\n5. 异步方法问题： 如果使用了异步方法（通过@Async注解），事务可能会失效。在异步方法内，事务上下文可能无法正确传播，导致事务不起作用。要在异步方法中使用事务，可以使用TransactionContext传播方式。\n\n\n## spring使用的设计模式\n\n### 简单工厂\n\n**实现方式：**\n\nBeanFactory。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。\n\n**实现原理：**\n\nbean容器的启动阶段：\n\n读取bean的xml配置文件,将bean元素分别转换成一个BeanDefinition对象。\n然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个ConcurrentHashMap中。\n将BeanDefinition注册到了beanFactory之后，在这里Spring为我们提供了一个扩展的切口，允许我们通过实现接口BeanFactoryPostProcessor\n在此处来插入我们定义的代码。典型的例子就是：PropertyPlaceholderConfigurer，我们一般在配置数据库的dataSource时使用到的占位符的值，就是它注入进去的。\n\n容器中bean的实例化阶段：\n\n实例化阶段主要是通过反射或者CGLIB对bean进行实例化，在这个阶段Spring又给我们暴露了很多的扩展点：\n\n各种的Aware接口 ，比如 BeanFactoryAware，对于实现了这些Aware接口的bean，在实例化bean时Spring会帮我们注入对应的BeanFactory的实例。 BeanPostProcessor接口\n，实现了BeanPostProcessor接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 InitializingBean接口\n，实现了InitializingBean接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 DisposableBean接口\n，实现了DisposableBean接口的bean，在该bean死亡时Spring会帮我们调用接口中的方法。\n\n**设计意义：**\n\n松耦合。\n可以将原来硬编码的依赖，通过Spring这个beanFactory这个工厂来注入依赖，也就是说原来只有依赖方和被依赖方，现在我们引入了第三方——spring这个beanFactory，由它来解决bean之间的依赖问题，达到了松耦合的效果.\n\nbean的额外处理。 通过Spring接口的暴露，在实例化bean的阶段我们可以进行一些额外的处理，这些额外的处理只需要让bean实现对应的接口即可，那么spring就会在bean的生命周期调用我们实现的接口来处理该bean。[非常重要]\n\n### 工厂方法\n\n**实现方式：**\n\nFactoryBean接口。\n\n**实现原理：**\n\n实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()\n方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。\n\n### 单例模式\n\nSpring依赖注入Bean实例默认是单例的。\n\nSpring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。\n\n### 适配器模式\n\n**实现方式：**\n\nSpringMVC中的适配器HandlerAdatper。\n\n**实现原理：**\n\nHandlerAdatper根据Handler规则执行不同的Handler。\n\n**实现过程：**\n\nDispatcherServlet根据HandlerMapping返回的handler，向HandlerAdatper发起请求，处理Handler。\n\nHandlerAdapter根据规则找到对应的Handler并让其执行，执行完毕后Handler会向HandlerAdapter返回一个ModelAndView，最后由HandlerAdapter向DispatchServelet返回一个ModelAndView。\n\n### 装饰器模式\n\n**实现方式：**\n\nSpring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。\n\n**实质：**\n\n动态地给一个对象添加一些额外的职责。\n\n就增加功能来说，Decorator模式相比生成子类更为灵活。\n\n### 代理模式\n\n**实现方式：**\n\nAOP底层，就是动态代理模式的实现。\n\n**动态代理：**\n\n在内存中构建的，不需要手动编写代理类\n\n## spring中properties和yml的加载顺序\n\n相同内容properties和yml的加载顺序是properties优先\n\n## 使用@Autowired注解自动装配的过程是怎样的？\n\n使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，<context:annotation-config />。\n\n在启动spring\nIoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：\n\n- 如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；\n- 如果查询的结果不止一个，那么@Autowired会根据名称来查找；\n- 如果上述查找的结果为空，那么会抛出异常。解决方法是，使用required=false。\n\n## @Autowired和@Resource之间的区别\n\n@Autowired可用于：构造函数、成员变量、Setter方法\n\n@Autowired和@Resource之间的区别\n\n- @Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。\n- @Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。\n\n## Spring中BeanFactory与FactoryBean的区别\n\n### BeanFactory\n\nBeanFactory是一个接口，它是Spring中工厂的顶层规范，是SpringIoc容器的核心接口，它定义了getBean()、containsBean()等管理Bean的通用方法。Spring的容器都是它的具体实现如：\n\n- DefaultListableBeanFactory\n- XmlBeanFactory\n- ApplicationContext\n\n这些实现类又从不同的维度分别有不同的扩展。\n\n### FactoryBean\n\n首先它是一个Bean，但又不仅仅是一个Bean。它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式。它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。\n\nFactoryBean表现的是一个工厂的职责。 即一个Bean A如果实现了FactoryBean接口，那么A就变成了一个工厂，根据A的名称获取到的实际上是工厂调用getObject()\n返回的对象，而不是A本身，如果要获取工厂A自身的实例，那么需要在名称前面加上'&'符号。\n\n- getObject('name')返回工厂中的实例\n- getObject('&name')返回工厂本身的实例\n","slug":"Spring最热点面试题","published":1,"updated":"2024-05-26T14:44:26.083Z","comments":1,"layout":"post","photos":[],"_id":"clwxc4r9u0009b4uh3q5fc1k2","content":"<h1 id=\"spring\"><a href=\"#spring\" class=\"headerlink\" title=\"spring\"></a>spring</h1><h2 id=\"架构图\"><a href=\"#架构图\" class=\"headerlink\" title=\"架构图\"></a>架构图</h2><p><img src=\"/./2024/05/26/Spring%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/1.png\" alt=\"结构图\"></p>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><h3 id=\"Core-Container\"><a href=\"#Core-Container\" class=\"headerlink\" title=\"Core Container\"></a>Core Container</h3><p>核心容器(Core Container)</p>\n<ul>\n<li><code>spring-beans</code> 该模块是依赖注入IoC与DI的最基本实现</li>\n<li><code>spring-core</code> 该模块是Bean工厂与bean的装配</li>\n<li><code>spring-context</code> 该模块构架于核心模块之上，它扩展了 BeanFactory，为它添加了 Bean 生命周期控制、框架事件体系以及资源加载透明化等功能。ApplicationContext 是该模块的核心接口，它的超类是<br>BeanFactory。与BeanFactory 不同，ApplicationContext 容器实例化后会自动对所有的单实例 Bean 进行实例化与依赖关系的装配，使之处于待用状态</li>\n<li><code>spring-context-indexer</code> 该模块是 Spring 的类管理组件和 Classpath 扫描</li>\n<li><code>spring-context-support</code> 该模块是对 Spring IOC 容器的扩展支持，以及 IOC 子容器</li>\n<li><code>spring-expression</code> 该模块是Spring表达式语言块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等</li>\n</ul>\n<h3 id=\"Data-Access-Integration\"><a href=\"#Data-Access-Integration\" class=\"headerlink\" title=\"Data Access&#x2F;Integration\"></a>Data Access&#x2F;Integration</h3><p>数据访问&#x2F;集成</p>\n<ul>\n<li><code>spring-jdbc</code> 该模块提供了 JDBC抽象层，它消除了冗长的 JDBC 编码和对数据库供应商特定错误代码的解析</li>\n<li><code>spring-tx</code> 该模块支持编程式事务和声明式事务，可用于实现了特定接口的类和所有的 POJO 对象。编程式事务需要自己写beginTransaction()、commit()、rollback()<br>等事务管理方法，声明式事务是通过注解或配置由 spring 自动处理，编程式事务粒度更细</li>\n<li><code>spring-orm</code> 该模块提供了对流行的对象关系映射 API的集成，包括 JPA、JDO 和 Hibernate 等。通过此模块可以让这些 ORM 框架和 spring 的其它功能整合，比如前面提及的事务管理</li>\n<li><code>spring-oxm</code> 该模块提供了对 OXM 实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等</li>\n<li><code>spring-jms</code> 该模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了 spring-messaging 模块</li>\n</ul>\n<h3 id=\"Web\"><a href=\"#Web\" class=\"headerlink\" title=\"Web\"></a>Web</h3><p>网络部分</p>\n<ul>\n<li><code>spring-web</code> 该模块为 Spring 提供了最基础 Web 支持，主要建立于核心容器之上，通过 Servlet 或者 Listeners 来初始化 IOC 容器，也包含一些与 Web 相关的支持</li>\n<li><code>spring-webmvc</code> 该模块众所周知是一个的 Web-Servlet 模块，实现了 Spring MVC（model-view-Controller）的 Web 应用</li>\n<li><code>spring-websocket</code> 该模块主要是与 Web 前端的全双工通讯的协议</li>\n<li><code>spring-webflux</code> 该模块是一个新的非堵塞函数式 Reactive Web 框架，可以用来建立异步的，非阻塞，事件驱动的服务，并且扩展性非常好。</li>\n</ul>\n<h3 id=\"面向切面编程-AOP和Aspects\"><a href=\"#面向切面编程-AOP和Aspects\" class=\"headerlink\" title=\"面向切面编程(AOP和Aspects)\"></a>面向切面编程(AOP和Aspects)</h3><ul>\n<li><code>spring-aop</code> 该模块是Spring的另一个核心模块，是 AOP 主要的实现模块</li>\n<li><code>spring-aspects</code> 该模块提供了对 AspectJ 的集成，主要是为 Spring AOP提供多种 AOP 实现方法，如前置方法后置方法等</li>\n</ul>\n<h3 id=\"设备-Instrumentation\"><a href=\"#设备-Instrumentation\" class=\"headerlink\" title=\"设备(Instrumentation)\"></a>设备(Instrumentation)</h3><ul>\n<li><code>spring-instrument</code> 该模块是基于JAVA SE 中的”java.lang.instrument”进行设计的，应该算是 AOP的一个支援模块，主要作用是在 JVM<br>启用时，生成一个代理类，程序员通过代理类在运行时修改类的字节，从而改变一个类的功能，实现 AOP 的功能</li>\n</ul>\n<h3 id=\"消息-Messaging\"><a href=\"#消息-Messaging\" class=\"headerlink\" title=\"消息(Messaging)\"></a>消息(Messaging)</h3><ul>\n<li><code>spring-messaging</code> 是从 Spring4 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用</li>\n</ul>\n<h3 id=\"测试-Test\"><a href=\"#测试-Test\" class=\"headerlink\" title=\"测试(Test)\"></a>测试(Test)</h3><ul>\n<li><code>spring-test</code> 主要为测试提供支持的，通过 JUnit 和 TestNG 组件支持单元测试和集成测试。它提供了一致性地加载和缓存 Spring 上下文，也提供了用于单独测试代码的模拟对象（mock object）</li>\n</ul>\n<h2 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h2><h3 id=\"IOC是什么？\"><a href=\"#IOC是什么？\" class=\"headerlink\" title=\"IOC是什么？\"></a>IOC是什么？</h3><p>控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p>\n<p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>\n<h3 id=\"使用IOC的好处\"><a href=\"#使用IOC的好处\" class=\"headerlink\" title=\"使用IOC的好处\"></a>使用IOC的好处</h3><ul>\n<li>不用自己组装，拿来就用。</li>\n<li>享受单例的好处，效率高，不浪费空间</li>\n<li>便于单元测试，方便切换mock组件</li>\n<li>便于进行AOP操作，对于使用者是透明的</li>\n<li>统一配置，便于修改</li>\n</ul>\n<h2 id=\"BeanFactory-和-ApplicationContext有什么区别\"><a href=\"#BeanFactory-和-ApplicationContext有什么区别\" class=\"headerlink\" title=\"BeanFactory 和 ApplicationContext有什么区别\"></a>BeanFactory 和 ApplicationContext有什么区别</h2><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p>\n<h3 id=\"依赖关系\"><a href=\"#依赖关系\" class=\"headerlink\" title=\"依赖关系\"></a>依赖关系</h3><p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p>\n<p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p>\n<ul>\n<li>继承MessageSource，因此支持国际化。</li>\n<li>统一的资源文件访问方式。</li>\n<li>提供在监听器中注册bean的事件。</li>\n<li>同时加载多个配置文件。</li>\n<li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li>\n</ul>\n<h3 id=\"加载方式\"><a href=\"#加载方式\" class=\"headerlink\" title=\"加载方式\"></a>加载方式</h3><p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())<br>，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p>\n<p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。<br>ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>\n<p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>\n<h3 id=\"创建方式\"><a href=\"#创建方式\" class=\"headerlink\" title=\"创建方式\"></a>创建方式</h3><p>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p>\n<h3 id=\"注册方式\"><a href=\"#注册方式\" class=\"headerlink\" title=\"注册方式\"></a>注册方式</h3><p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>\n<h3 id=\"Spring-IoC的初始化过程\"><a href=\"#Spring-IoC的初始化过程\" class=\"headerlink\" title=\"Spring IoC的初始化过程\"></a>Spring IoC的初始化过程</h3><h4 id=\"IOC粗略总结\"><a href=\"#IOC粗略总结\" class=\"headerlink\" title=\"IOC粗略总结\"></a>IOC粗略总结</h4><ol>\n<li>首先入口是xml或者注解或者其他形式，要实现beanDefinationReader接口，然后 读取的时候，会将他们解析为bean的定义信息；</li>\n<li>beanFactory在加载bean信息实例化（底层用的反射）之前，spring加了一个接口beanFactoryPostProcessor,用作扩展用。</li>\n<li>beanFactory内部实例化bean之后，在要初始化bean对象之前，增加了一个一系列aware接口，将他的容器，以及工厂都暴露出来供使用者做扩展用。</li>\n<li>经过一些列容器以及容器对象的注入之后，在初始化之前，spring又增加了一个接口 beanPostProcessor,该接口是可以作用于所有创建的bean,在初始化前后，均能通过重写该接口获取bean对象进行定制操作。</li>\n<li>经过实现初始化接口完成初始化功能。</li>\n<li>经过实现销毁接口disposableBean结束其生命。</li>\n</ol>\n<h4 id=\"重要的组件\"><a href=\"#重要的组件\" class=\"headerlink\" title=\"重要的组件\"></a>重要的组件</h4><ul>\n<li><code>BeanDefinition</code> 描述bean的属性的接口，例如bean的scope是单例还是多例，构造方法，有哪些property value，依赖等，相当于对这个bean的一份身份描述<ul>\n<li><h2 id=\"Bean配置-–-BeanDefinition-–-Bean对象\"><a href=\"#Bean配置-–-BeanDefinition-–-Bean对象\" class=\"headerlink\" title=\"Bean配置 –&gt; BeanDefinition –&gt; Bean对象\"></a>Bean配置 –&gt; BeanDefinition –&gt; Bean对象</h2>懒加载情况下，refresh只是把BeanDefinition注册到BeanFactory中，而不是把Bean注册到BeanFactory中。在调用上下文的getBean的时候才会去根据BeanDefinition生成具体的bean对象</li>\n</ul>\n</li>\n<li><code>BeanDefinitionMap</code></li>\n<li><code>BeanFactory</code><ul>\n<li>spring的基础bean容器</li>\n<li>相当于存放所有bean的容器</li>\n</ul>\n</li>\n<li><code>ApplicationContext</code><ul>\n<li>BeanFactory 的子接口，在 BeanFactory 的基础上构建，是相对比较高级的 IoC 容器实现。包含 BeanFactory<br>的所有功能，还提供了其他高级的特性，比如：事件发布、国际化信息支持、统一资源加载策略等。正常情况下，我们都是使用的 ApplicationContext</li>\n<li>相当于丰富了beanfactory的功能，这里理解为上下文就好</li>\n</ul>\n</li>\n<li><code>FactoryBean</code></li>\n</ul>\n<h4 id=\"源码解析\"><a href=\"#源码解析\" class=\"headerlink\" title=\"源码解析\"></a>源码解析</h4><p>首先抛开其他组件的启动，我们只需要引入spring-context就可以启动一个容器了</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>而在springboot出来之前最常见的加载bean的方式是读取配置文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[]args)</span>&#123;</span><br><span class=\"line\">        ApplicationContext context=<span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;classpath:applicationfile.xml&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里ApplicationContext是一个接口，主要的实现类有：</p>\n<ul>\n<li>ClassPathXmlApplicationContext 需要一个 xml 配置文件在系统中的路径</li>\n<li>FileSystemXmlApplicationContext 需要一个 xml 配置文件在系统中的路径</li>\n<li>AnnotationConfigApplicationContext 基于注解，大势所趋</li>\n</ul>\n<p>下面的分析都基于 ClassPathXmlApplicationContext 进行分析，因为比较好理解点</p>\n<p>在 resources 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml就可以了,对应的类实现一个：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">default-autowire</span>=<span class=\"string\">&quot;byName&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;messageService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.javadoop.example.MessageServiceImpl&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>main</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">App</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用我们的配置文件来启动一个 ApplicationContext</span></span><br><span class=\"line\">        <span class=\"type\">ApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;classpath:application.xml&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;context 启动成功&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式</span></span><br><span class=\"line\">        <span class=\"type\">MessageService</span> <span class=\"variable\">messageService</span> <span class=\"operator\">=</span> context.getBean(MessageService.class);</span><br><span class=\"line\">        <span class=\"comment\">// 这句将输出: hello world</span></span><br><span class=\"line\">        System.out.println(messageService.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在构造方法中的refresh()方法是启动加载整个容器的关键方法</p>\n<p>方法在springboot容器启动时也会加载,方法为</p>\n<ul>\n<li>org.springframework.boot.SpringApplication#run</li>\n<li>org.springframework.boot.SpringApplication#refreshContext</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span><span class=\"keyword\">throws</span> BeansException,IllegalStateException&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 首先是一个synchronized加锁，当然要加锁，不然你先调一次refresh()然后这次还没处理完又调一次，就会乱套了；</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>.startupShutdownMonitor)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2. 这个方法是做准备工作的，记录容器的启动时间、标记“已启动”状态、处理配置文件中的占位符，可以点进去看看，这里就不多说了。</span></span><br><span class=\"line\">        prepareRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. 这个就很重要了，这一步是把配置文件解析成一个个Bean，并且注册到BeanFactory中，注意这里只是注册进去，并没有初始化。先继续往下看，等会展开这个方法详细解读</span></span><br><span class=\"line\">        ConfigurableListableBeanFactory beanFactory=obtainFreshBeanFactory();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//4. 这个方法的作用是：设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean，这里都是spring里面的特殊处理，然后继续往下看</span></span><br><span class=\"line\">        prepareBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 5. 方法是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化，具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类，来完成一些其他的操作。</span></span><br><span class=\"line\">            postProcessBeanFactory(beanFactory);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 6. 接下来是这个方法是调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法；</span></span><br><span class=\"line\">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 7. 然后这个方法注册 BeanPostProcessor 的实现类，和上面的BeanFactoryPostProcessor 是有区别的，这个方法调用的其实是PostProcessorRegistrationDelegate类的registerBeanPostProcessors方法；</span></span><br><span class=\"line\">            <span class=\"comment\">// 这个类里面有个内部类BeanPostProcessorChecker，BeanPostProcessorChecker里面有两个方法postProcessBeforeInitialization和postProcessAfterInitialization，这两个方法分别在 Bean 初始化之前和初始化之后得到执行。</span></span><br><span class=\"line\">            <span class=\"comment\">// 然后回到refresh()方法中继续往下看</span></span><br><span class=\"line\">            registerBeanPostProcessors(beanFactory);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 8. 方法是初始化当前 ApplicationContext 的 MessageSource，国际化处理，继续往下</span></span><br><span class=\"line\">            initMessageSource();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 9. 方法初始化当前 ApplicationContext 的事件广播器继续往下</span></span><br><span class=\"line\">            initApplicationEventMulticaster();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 10. 方法初始化一些特殊的 Bean（在初始化 singleton beans 之前）；继续往下</span></span><br><span class=\"line\">            onRefresh();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 11. 方法注册事件监听器，监听器需要实现 ApplicationListener 接口；继续往下</span></span><br><span class=\"line\">            registerListeners();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 12. 重点到了 初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说</span></span><br><span class=\"line\">            finishBeanFactoryInitialization(beanFactory);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 13. 方法是最后一步，广播事件，ApplicationContext 初始化完成</span></span><br><span class=\"line\">            finishRefresh();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(BeansException ex)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(logger.isWarnEnabled())&#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">&quot;Exception encountered during context initialization - &quot;</span>+<span class=\"string\">&quot;cancelling refresh attempt: &quot;</span>+ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class=\"line\">            <span class=\"comment\">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class=\"line\">            destroyBeans();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// Reset &#x27;active&#x27; flag.</span></span><br><span class=\"line\">            cancelRefresh(ex);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// Propagate exception to caller.</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class=\"line\">            <span class=\"comment\">// might not ever need metadata for singleton beans anymore...</span></span><br><span class=\"line\">            resetCommonCaches();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Spring-bean的生命周期\"><a href=\"#Spring-bean的生命周期\" class=\"headerlink\" title=\"Spring bean的生命周期\"></a>Spring bean的生命周期</h3><p>Spring Bean的生命周期分为四个阶段和多个扩展点。扩展点又可以分为影响多个Bean和影响单个Bean。整理如下：</p>\n<p>四个阶段</p>\n<ul>\n<li>实例化 Instantiation</li>\n<li>属性赋值 Populate</li>\n<li>初始化 Initialization</li>\n<li>销毁 Destruction</li>\n</ul>\n<p>多个扩展点</p>\n<ul>\n<li>影响多个Bean<ul>\n<li>BeanPostProcessor(作用于初始化阶段的前后)</li>\n<li>InstantiationAwareBeanPostProcessor(作用于实例化阶段的前后)</li>\n</ul>\n</li>\n<li>影响单个Bean<ul>\n<li>Aware(Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源)<ul>\n<li>Aware Group1<ul>\n<li>BeanNameAware</li>\n<li>BeanClassLoaderAware</li>\n<li>BeanFactoryAware</li>\n</ul>\n</li>\n<li>Aware Group2<ul>\n<li>EnvironmentAware</li>\n<li>EmbeddedValueResolverAware(实现该接口能够获取Spring EL解析器，用户的自定义注解需要支持spel表达式的时候可以使用)</li>\n<li>ApplicationContextAware(ResourceLoaderAware\\ApplicationEventPublisherAware\\MessageSourceAware)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>生命周期(实例化和属性赋值都是Spring帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段)<ul>\n<li>InitializingBean</li>\n<li>DisposableBean</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"bean的作用域\"><a href=\"#bean的作用域\" class=\"headerlink\" title=\"bean的作用域\"></a>bean的作用域</h3><p>Spring Bean 中所说的作用域，在配置文件中即是“scope”</p>\n<p>在面向对象程序设计中作用域一般指对象或变量之间的可见范围。</p>\n<p>而在Spring容器中是指其创建的Bean对象相对于其他Bean对象的请求可见范围。</p>\n<p>在Spring 容器当中，一共提供了5种作用域类型，在配置文件中，通过属性scope来设置bean的作用域范围</p>\n<h4 id=\"singleton\"><a href=\"#singleton\" class=\"headerlink\" title=\"singleton\"></a>singleton</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;singleton&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>当Bean的作用域为singleton的时候,Spring容器中只会存在一个共享的Bean实例，所有对Bean的请求只要id与bean的定义相匹配，则只会返回bean的同一实例。单一实例会被存储在单例缓存中，为Spring的缺省作用域。</p>\n<h4 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot; prototype &quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>每次对该Bean请求的时候，Spring IoC都会创建一个新的作用域。</p>\n<p>对于有状态的Bean应该使用prototype，对于无状态的Bean则使用singleton</p>\n<h4 id=\"request\"><a href=\"#request\" class=\"headerlink\" title=\"request\"></a>request</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot; request &quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Request作用域针对的是每次的Http请求，Spring容器会根据相关的Bean的</p>\n<p>定义来创建一个全新的Bean实例。而且该Bean只在当前request内是有效的。</p>\n<h4 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot; session &quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>针对http session起作用，Spring容器会根据该Bean的定义来创建一个全新的Bean的实例。而且该Bean只在当前http session内是有效的。</p>\n<h4 id=\"global-session\"><a href=\"#global-session\" class=\"headerlink\" title=\"global session\"></a>global session</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;globalSession&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>类似标准的http session作用域，不过仅仅在基于portlet的web应用当中才有意义。Portlet规范定义了全局的Session的概念。他被所有构成某个portlet外部应用中的各种不同的portlet所共享。在global<br>session作用域中所定义的bean被限定于全局的portlet session的生命周期范围之内。</p>\n<h3 id=\"循环依赖问题\"><a href=\"#循环依赖问题\" class=\"headerlink\" title=\"循环依赖问题\"></a>循环依赖问题</h3><h4 id=\"三级缓存\"><a href=\"#三级缓存\" class=\"headerlink\" title=\"三级缓存\"></a>三级缓存</h4><p>Spring 解决循环依赖的核心就是提前暴露对象，而提前暴露的对象就是放置于第二级缓存中。下表是三级缓存的说明：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>singletonObjects</td>\n<td>一级缓存，存放完整的 Bean。</td>\n</tr>\n<tr>\n<td>earlySingletonObjects</td>\n<td>二级缓存，存放提前暴露的Bean，Bean 是不完整的，未完成属性注入和执行 init 方法。</td>\n</tr>\n<tr>\n<td>singletonFactories</td>\n<td>三级缓存，存放的是 Bean 工厂，主要是生产 Bean，存放到二级缓存中。</td>\n</tr>\n</tbody></table>\n<p>所有被Spring 管理的 Bean，最终都会存放在 singletonObjects 中，这里面存放的 Bean 是经历了所有生命周期的（除了销毁的生命周期），完整的，可以给用户使用的。</p>\n<p>earlySingletonObjects 存放的是已经被实例化，但是还没有注入属性和执行 init 方法的 Bean。</p>\n<p>singletonFactories 存放的是生产 Bean 的工厂。</p>\n<p>Bean 都已经实例化了，为什么还需要一个生产 Bean 的工厂呢？这里实际上是跟 AOP 有关，如果项目中不需要为 Bean 进行代理，那么这个 Bean 工厂就会直接返回一开始实例化的对象，如果需要使用 AOP 进行代理，那么这个工厂就会发挥重要的作用了，这也是本文需要重点关注的问题之一。</p>\n<h4 id=\"解决循环依赖\"><a href=\"#解决循环依赖\" class=\"headerlink\" title=\"解决循环依赖\"></a>解决循环依赖</h4><p>Spring 是如何通过上面介绍的三级缓存来解决循环依赖的呢？这里只用 A，B 形成的循环依赖来举例：</p>\n<ol>\n<li>实例化 A，此时 A 还未完成属性填充和初始化方法（@PostConstruct）的执行，A 只是一个半成品。</li>\n<li>为 A 创建一个 Bean 工厂，并放入到  singletonFactories 中。</li>\n<li>发现 A 需要注入 B 对象，但是一级、二级、三级缓存均为发现对象 B。</li>\n<li>实例化 B，此时 B 还未完成属性填充和初始化方法（@PostConstruct）的执行，B 只是一个半成品。</li>\n<li>为 B 创建一个 Bean 工厂，并放入到  singletonFactories 中。</li>\n<li>发现 B 需要注入 A 对象，此时在一级、二级未发现对象 A，但是在三级缓存中发现了对象 A，从三级缓存中得到对象 A，并将对象 A 放入二级缓存中，同时删除三级缓存中的对象 A。（注意，此时的 A 还是一个半成品，并没有完成属性填充和执行初始化方法）</li>\n<li>将对象 A 注入到对象 B 中。</li>\n<li>对象 B 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 B。（此时对象 B 已经是一个成品）</li>\n<li>对象 A 得到对象 B，将对象 B 注入到对象 A 中。（对象 A 得到的是一个完整的对象 B）</li>\n<li>对象 A 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 A。</li>\n</ol>\n<h2 id=\"Spring框架中的单例bean是否线程安全\"><a href=\"#Spring框架中的单例bean是否线程安全\" class=\"headerlink\" title=\"Spring框架中的单例bean是否线程安全\"></a>Spring框架中的单例bean是否线程安全</h2><p>Spring框架中的单例bean是线程安全的吗？它是如何处理线程并发问题的?</p>\n<p>不是，Spring框架中的单例bean不是线程安全的。</p>\n<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。实际上大部分 spring bean 是无状态的（比如 dao 类），在某种程度上来说 bean 也是安全的，但如果 bean<br>有状态的话（比如 view model ）就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了， 保证线程安全了。</p>\n<ul>\n<li>有状态就是有数据存储功能。</li>\n<li>无状态就是不会保存数据。</li>\n</ul>\n<p>Spring如何处理线程并发问题?</p>\n<p>一般只有无状态的Bean才可以在多线程下共享，大部分是无状态的Bean。当存有状态的Bean的时候，spring一般是使用ThreadLocal进行处理，解决线程安全问题。</p>\n<p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。<br>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，所以没有相同变量的访问冲突问题。所以在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>\n<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>\n<p>AOP(Aspect-Oriented Programming)<br>，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</p>\n<h3 id=\"AOP原理\"><a href=\"#AOP原理\" class=\"headerlink\" title=\"AOP原理\"></a>AOP原理</h3><p>原理是在IOC过程中，创建bean实例时，最后都会对bean进行处理来实现增强，对于AOP来说就是创建代理类</p>\n<ul>\n<li>底层是动态代理技术<ul>\n<li>JDK动态代理(基于接口)</li>\n<li>CGLib动态代理(基于类)</li>\n<li>在Spring AOP中，如果使用的是单例，推荐使用CGLib代理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h3><p>(一）实现原理</p>\n<p>JDK的动态代理是基于反射实现。JDK通过反射，生成一个代理类，这个代理类实现了原来那个类的全部接口，并对接口中定义的所有方法进行了代理。当我们通过代理对象执行原来那个类的方法时，代理类底层会通过反射机制，回调我们实现的InvocationHandler接口的invoke方法。并且这个代理类是Proxy类的子类（记住这个结论，后面测试要用）。这就是JDK动态代理大致的实现方式。</p>\n<p>（二）优点</p>\n<p>JDK动态代理是JDK原生的，不需要任何依赖即可使用；</p>\n<p>通过反射机制生成代理类的速度要比CGLib操作字节码生成代理类的速度更快；</p>\n<p>（三）缺点</p>\n<p>如果要使用JDK动态代理，被代理的类必须实现了接口，否则无法代理；</p>\n<p>JDK动态代理无法为没有在接口中定义的方法实现代理，假设我们有一个实现了接口的类，我们为它的一个不属于接口中的方法配置了切面，Spring仍然会使用JDK的动态代理，但是由于配置了切面的方法不属于接口，为这个方法配置的切面将不会被织入。</p>\n<p>JDK动态代理执行代理方法时，需要通过反射机制进行回调，此时方法执行的效率比较低；</p>\n<h3 id=\"CGLib动态代理\"><a href=\"#CGLib动态代理\" class=\"headerlink\" title=\"CGLib动态代理\"></a>CGLib动态代理</h3><p>（一）实现原理</p>\n<p>CGLib实现动态代理的原理是，底层采用了ASM字节码生成框架，直接对需要代理的类的字节码进行操作，生成这个类的一个子类，并重写了类的所有可以重写的方法，在重写的过程中，将我们定义的额外的逻辑（简单理解为Spring中的切面）织入到方法中，对方法进行了增强。而通过字节码操作生成的代理类，和我们自己编写并编译后的类没有太大区别。</p>\n<p>（二）优点</p>\n<p>使用CGLib代理的类，不需要实现接口，因为CGLib生成的代理类是直接继承自需要被代理的类；</p>\n<p>CGLib生成的代理类是原来那个类的子类，这就意味着这个代理类可以为原来那个类中，所有能够被子类重写的方法进行代理；</p>\n<p>CGLib生成的代理类，和我们自己编写并编译的类没有太大区别，对方法的调用和直接调用普通类的方式一致，所以CGLib执行代理方法的效率要高于JDK的动态代理；</p>\n<p>（三）缺点</p>\n<p>由于CGLib的代理类使用的是继承，这也就意味着如果需要被代理的类是一个final类，则无法使用CGLib代理；</p>\n<p>由于CGLib实现代理方法的方式是重写父类的方法，所以无法对final方法，或者private方法进行代理，因为子类无法重写这些方法；</p>\n<p>CGLib生成代理类的方式是通过操作字节码，这种方式生成代理类的速度要比JDK通过反射生成代理类的速度更慢；</p>\n<h3 id=\"AOP术语\"><a href=\"#AOP术语\" class=\"headerlink\" title=\"AOP术语\"></a>AOP术语</h3><h4 id=\"连接点-Join-point\"><a href=\"#连接点-Join-point\" class=\"headerlink\" title=\"连接点(Join point)\"></a>连接点(Join point)</h4><p>能够被拦截的地方</p>\n<h4 id=\"切点-Poincut\"><a href=\"#切点-Poincut\" class=\"headerlink\" title=\"切点(Poincut)\"></a>切点(Poincut)</h4><p>具体定位的连接点</p>\n<h4 id=\"增强-通知-Advice\"><a href=\"#增强-通知-Advice\" class=\"headerlink\" title=\"增强&#x2F;通知(Advice)\"></a>增强&#x2F;通知(Advice)</h4><p>表示添加到切点的一段逻辑代码，并定位连接点的方位信息</p>\n<h4 id=\"织入-Weaving\"><a href=\"#织入-Weaving\" class=\"headerlink\" title=\"织入(Weaving)\"></a>织入(Weaving)</h4><p>将增强&#x2F;通知添加到目标类的具体连接点上的过程。</p>\n<h4 id=\"引入-引介-Introduction\"><a href=\"#引入-引介-Introduction\" class=\"headerlink\" title=\"引入&#x2F;引介(Introduction)\"></a>引入&#x2F;引介(Introduction)</h4><p>允许我们向现有的类添加新方法或属性。是一种特殊的增强！</p>\n<h4 id=\"切面-Aspect\"><a href=\"#切面-Aspect\" class=\"headerlink\" title=\"切面(Aspect)\"></a>切面(Aspect)</h4><p>切面由切点和增强&#x2F;通知组成，它既包括了横切逻辑的定义、也包括了连接点的定义</p>\n<h3 id=\"Spring对AOP的支持\"><a href=\"#Spring对AOP的支持\" class=\"headerlink\" title=\"Spring对AOP的支持\"></a>Spring对AOP的支持</h3><ul>\n<li>基于代理的经典SpringAOP：需要实现接口，手动创建代理</li>\n<li>纯POJO切面：使用XML配置，aop命名空间</li>\n<li>@AspectJ注解驱动的切面：使用注解的方式，这是最简洁和最方便的！</li>\n</ul>\n<h2 id=\"怎么定义一个注解\"><a href=\"#怎么定义一个注解\" class=\"headerlink\" title=\"怎么定义一个注解\"></a>怎么定义一个注解</h2><h3 id=\"引入依赖\"><a href=\"#引入依赖\" class=\"headerlink\" title=\"引入依赖\"></a>引入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"定义注解\"><a href=\"#定义注解\" class=\"headerlink\" title=\"定义注解\"></a>定义注解</h3><h4 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h4><p>java.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：</p>\n<ul>\n<li>@Documented – 注解是否将包含在JavaDoc中</li>\n<li>@Retention – 什么时候使用该注解</li>\n<li>@Target – 注解用于什么地方</li>\n<li>@Inherited – 是否允许子类继承该注解</li>\n</ul>\n<h5 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"@Retention\"></a>@Retention</h5><p>定义该注解的生命周期</p>\n<ul>\n<li>RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。</li>\n<li>RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式</li>\n<li>RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</li>\n</ul>\n<h5 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"@Target\"></a>@Target</h5><p>表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType 参数包括</p>\n<ul>\n<li>ElementType.CONSTRUCTOR: 用于描述构造器</li>\n<li>ElementType.FIELD: 成员变量、对象、属性（包括enum实例）</li>\n<li>ElementType.LOCAL_VARIABLE: 用于描述局部变量</li>\n<li>ElementType.METHOD: 用于描述方法</li>\n<li>ElementType.PACKAGE: 用于描述包</li>\n<li>ElementType.PARAMETER: 用于描述参数</li>\n<li>ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明</li>\n</ul>\n<h5 id=\"Documented\"><a href=\"#Documented\" class=\"headerlink\" title=\"@Documented\"></a>@Documented</h5><p>一个简单的Annotations 标记注解，表示是否将注解信息添加在java文档中。</p>\n<h5 id=\"Inherited\"><a href=\"#Inherited\" class=\"headerlink\" title=\"@Inherited\"></a>@Inherited</h5><p>定义该注释和子类的关系</p>\n<p>@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class<br>的子类。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>自定义一个检查是否登录的注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CheckLogin &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Order(1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CheckLoginAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    RedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;execution(* *..controller..*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        <span class=\"type\">CheckLogin</span> <span class=\"variable\">annotation</span> <span class=\"operator\">=</span> method.getAnnotation(CheckLogin.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (annotation == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取类上注解</span></span><br><span class=\"line\">            annotation = joinPoint.getTarget().getClass().getAnnotation(CheckLogin.class);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (annotation != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取到请求的属性</span></span><br><span class=\"line\">            <span class=\"type\">ServletRequestAttributes</span> <span class=\"variable\">attributes</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                    (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class=\"line\">            <span class=\"comment\">//获取到请求对象</span></span><br><span class=\"line\">            <span class=\"type\">HttpServletRequest</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> attributes.getRequest();</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">ssoToken</span> <span class=\"operator\">=</span> HttpUtil.getSsoToken(request);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ssoToken != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">loginUserTokenKey</span> <span class=\"operator\">=</span> AuthRedisKeyUtil.getLoginUserTokenKey(ssoToken);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (redisTemplate.hasKey(loginUserTokenKey)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//通过</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoginException</span>(<span class=\"string\">&quot;登录已过期&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalRequestException</span>(<span class=\"string\">&quot;非法请求&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AccountController</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@CheckLogin</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/query&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> JSONObject <span class=\"title function_\">queryRegulation</span><span class=\"params\">(Integer pageNum, Integer pageSize)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//....业务逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"Spring-支持两种方式的事务管理\"><a href=\"#Spring-支持两种方式的事务管理\" class=\"headerlink\" title=\"Spring 支持两种方式的事务管理\"></a>Spring 支持两种方式的事务管理</h3><h4 id=\"1、编程式事务管理\"><a href=\"#1、编程式事务管理\" class=\"headerlink\" title=\"1、编程式事务管理\"></a>1、编程式事务管理</h4><ul>\n<li>TransactionTemplate</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> TransactionTemplate transactionTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testTransaction</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    transactionTemplate.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">TransactionCallbackWithoutResult</span>()&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doInTransactionWithoutResult</span><span class=\"params\">(TransactionStatus status)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//...业务代码</span></span><br><span class=\"line\">                &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">                    status.setRollbackOnly();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>TransactionManager</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> PlatformTransactionManager transactionManager;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testTransaction2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        TransactionStatus status=transactionManager.getTransaction(<span class=\"keyword\">new</span> <span class=\"title class_\">DefaultTransactionDefinition</span>());</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//...业务代码</span></span><br><span class=\"line\">            transactionManager.commit(status);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">            transactionManager.rollback(status);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、注解\"><a href=\"#2、注解\" class=\"headerlink\" title=\"2、注解\"></a>2、注解</h4><ul>\n<li>@Transactional</li>\n</ul>\n<h3 id=\"事务的传播性-Propagation\"><a href=\"#事务的传播性-Propagation\" class=\"headerlink\" title=\"事务的传播性 Propagation\"></a>事务的传播性 Propagation</h3><p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p>\n<p>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p>\n<p>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p>\n<p>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p>\n<p>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>\n<p>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p>\n<p>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p>\n<h3 id=\"spring事务失效的场景\"><a href=\"#spring事务失效的场景\" class=\"headerlink\" title=\"spring事务失效的场景\"></a>spring事务失效的场景</h3><ol>\n<li><p>非被Spring管理的Bean上的事务： 如果你在一个非被Spring容器管理的Bean（例如通过new关键字直接创建的对象）上使用事务注解，事务将不会生效。Spring的事务管理是基于AOP（面向切面编程）实现的，因此只能在由Spring容器管理的Bean上起作用。</p>\n</li>\n<li><p>未捕获的异常： 如果在事务内发生未捕获的运行时异常，事务将回滚。但是，如果异常被捕获并在方法内处理，事务可能不会回滚。确保在事务边界内处理异常或者允许异常传播到事务管理器以便正确回滚。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">transactionalMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// some code that may throw an exception</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle the exception (not recommended within a transaction)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>嵌套事务问题： Spring事务支持嵌套事务，但是嵌套事务的行为取决于底层事务管理器的支持。如果使用的事务管理器不支持嵌套事务，嵌套事务可能会被忽略，导致事务行为不一致。</p>\n</li>\n<li><p>方法调用问题： Spring事务是通过AOP实现的，它依赖于代理对象来拦截方法调用并处理事务。如果你在同一个类内部调用一个带有事务注解的方法，事务可能不会起作用，因为代理对象无法拦截内部方法的调用。确保事务注解生效，要么调用方法是通过代理对象，要么通过self-invocation，例如通过this关键字。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">outerMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        innerMethod(); <span class=\"comment\">// Transactional annotation may not work here</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.innerMethod(); <span class=\"comment\">// Transactional annotation should work here</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">innerMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// some transactional logic</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>异步方法问题： 如果使用了异步方法（通过@Async注解），事务可能会失效。在异步方法内，事务上下文可能无法正确传播，导致事务不起作用。要在异步方法中使用事务，可以使用TransactionContext传播方式。</p>\n</li>\n</ol>\n<h2 id=\"spring使用的设计模式\"><a href=\"#spring使用的设计模式\" class=\"headerlink\" title=\"spring使用的设计模式\"></a>spring使用的设计模式</h2><h3 id=\"简单工厂\"><a href=\"#简单工厂\" class=\"headerlink\" title=\"简单工厂\"></a>简单工厂</h3><p><strong>实现方式：</strong></p>\n<p>BeanFactory。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</p>\n<p><strong>实现原理：</strong></p>\n<p>bean容器的启动阶段：</p>\n<p>读取bean的xml配置文件,将bean元素分别转换成一个BeanDefinition对象。<br>然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个ConcurrentHashMap中。<br>将BeanDefinition注册到了beanFactory之后，在这里Spring为我们提供了一个扩展的切口，允许我们通过实现接口BeanFactoryPostProcessor<br>在此处来插入我们定义的代码。典型的例子就是：PropertyPlaceholderConfigurer，我们一般在配置数据库的dataSource时使用到的占位符的值，就是它注入进去的。</p>\n<p>容器中bean的实例化阶段：</p>\n<p>实例化阶段主要是通过反射或者CGLIB对bean进行实例化，在这个阶段Spring又给我们暴露了很多的扩展点：</p>\n<p>各种的Aware接口 ，比如 BeanFactoryAware，对于实现了这些Aware接口的bean，在实例化bean时Spring会帮我们注入对应的BeanFactory的实例。 BeanPostProcessor接口<br>，实现了BeanPostProcessor接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 InitializingBean接口<br>，实现了InitializingBean接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 DisposableBean接口<br>，实现了DisposableBean接口的bean，在该bean死亡时Spring会帮我们调用接口中的方法。</p>\n<p><strong>设计意义：</strong></p>\n<p>松耦合。<br>可以将原来硬编码的依赖，通过Spring这个beanFactory这个工厂来注入依赖，也就是说原来只有依赖方和被依赖方，现在我们引入了第三方——spring这个beanFactory，由它来解决bean之间的依赖问题，达到了松耦合的效果.</p>\n<p>bean的额外处理。 通过Spring接口的暴露，在实例化bean的阶段我们可以进行一些额外的处理，这些额外的处理只需要让bean实现对应的接口即可，那么spring就会在bean的生命周期调用我们实现的接口来处理该bean。[非常重要]</p>\n<h3 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h3><p><strong>实现方式：</strong></p>\n<p>FactoryBean接口。</p>\n<p><strong>实现原理：</strong></p>\n<p>实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()<br>方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。</p>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>Spring依赖注入Bean实例默认是单例的。</p>\n<p>Spring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。</p>\n<h3 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h3><p><strong>实现方式：</strong></p>\n<p>SpringMVC中的适配器HandlerAdatper。</p>\n<p><strong>实现原理：</strong></p>\n<p>HandlerAdatper根据Handler规则执行不同的Handler。</p>\n<p><strong>实现过程：</strong></p>\n<p>DispatcherServlet根据HandlerMapping返回的handler，向HandlerAdatper发起请求，处理Handler。</p>\n<p>HandlerAdapter根据规则找到对应的Handler并让其执行，执行完毕后Handler会向HandlerAdapter返回一个ModelAndView，最后由HandlerAdapter向DispatchServelet返回一个ModelAndView。</p>\n<h3 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h3><p><strong>实现方式：</strong></p>\n<p>Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p>\n<p><strong>实质：</strong></p>\n<p>动态地给一个对象添加一些额外的职责。</p>\n<p>就增加功能来说，Decorator模式相比生成子类更为灵活。</p>\n<h3 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h3><p><strong>实现方式：</strong></p>\n<p>AOP底层，就是动态代理模式的实现。</p>\n<p><strong>动态代理：</strong></p>\n<p>在内存中构建的，不需要手动编写代理类</p>\n<h2 id=\"spring中properties和yml的加载顺序\"><a href=\"#spring中properties和yml的加载顺序\" class=\"headerlink\" title=\"spring中properties和yml的加载顺序\"></a>spring中properties和yml的加载顺序</h2><p>相同内容properties和yml的加载顺序是properties优先</p>\n<h2 id=\"使用-Autowired注解自动装配的过程是怎样的？\"><a href=\"#使用-Autowired注解自动装配的过程是怎样的？\" class=\"headerlink\" title=\"使用@Autowired注解自动装配的过程是怎样的？\"></a>使用@Autowired注解自动装配的过程是怎样的？</h2><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config &#x2F;&gt;。</p>\n<p>在启动spring<br>IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p>\n<ul>\n<li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li>\n<li>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</li>\n<li>如果上述查找的结果为空，那么会抛出异常。解决方法是，使用required&#x3D;false。</li>\n</ul>\n<h2 id=\"Autowired和-Resource之间的区别\"><a href=\"#Autowired和-Resource之间的区别\" class=\"headerlink\" title=\"@Autowired和@Resource之间的区别\"></a>@Autowired和@Resource之间的区别</h2><p>@Autowired可用于：构造函数、成员变量、Setter方法</p>\n<p>@Autowired和@Resource之间的区别</p>\n<ul>\n<li>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</li>\n<li>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</li>\n</ul>\n<h2 id=\"Spring中BeanFactory与FactoryBean的区别\"><a href=\"#Spring中BeanFactory与FactoryBean的区别\" class=\"headerlink\" title=\"Spring中BeanFactory与FactoryBean的区别\"></a>Spring中BeanFactory与FactoryBean的区别</h2><h3 id=\"BeanFactory\"><a href=\"#BeanFactory\" class=\"headerlink\" title=\"BeanFactory\"></a>BeanFactory</h3><p>BeanFactory是一个接口，它是Spring中工厂的顶层规范，是SpringIoc容器的核心接口，它定义了getBean()、containsBean()等管理Bean的通用方法。Spring的容器都是它的具体实现如：</p>\n<ul>\n<li>DefaultListableBeanFactory</li>\n<li>XmlBeanFactory</li>\n<li>ApplicationContext</li>\n</ul>\n<p>这些实现类又从不同的维度分别有不同的扩展。</p>\n<h3 id=\"FactoryBean\"><a href=\"#FactoryBean\" class=\"headerlink\" title=\"FactoryBean\"></a>FactoryBean</h3><p>首先它是一个Bean，但又不仅仅是一个Bean。它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式。它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。</p>\n<p>FactoryBean表现的是一个工厂的职责。 即一个Bean A如果实现了FactoryBean接口，那么A就变成了一个工厂，根据A的名称获取到的实际上是工厂调用getObject()<br>返回的对象，而不是A本身，如果要获取工厂A自身的实例，那么需要在名称前面加上’&amp;’符号。</p>\n<ul>\n<li>getObject(‘name’)返回工厂中的实例</li>\n<li>getObject(‘&amp;name’)返回工厂本身的实例</li>\n</ul>\n","cover":"/img/haibian.png","cover_type":"img","excerpt":"","more":"<h1 id=\"spring\"><a href=\"#spring\" class=\"headerlink\" title=\"spring\"></a>spring</h1><h2 id=\"架构图\"><a href=\"#架构图\" class=\"headerlink\" title=\"架构图\"></a>架构图</h2><p><img src=\"/./2024/05/26/Spring%E6%9C%80%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/1.png\" alt=\"结构图\"></p>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><h3 id=\"Core-Container\"><a href=\"#Core-Container\" class=\"headerlink\" title=\"Core Container\"></a>Core Container</h3><p>核心容器(Core Container)</p>\n<ul>\n<li><code>spring-beans</code> 该模块是依赖注入IoC与DI的最基本实现</li>\n<li><code>spring-core</code> 该模块是Bean工厂与bean的装配</li>\n<li><code>spring-context</code> 该模块构架于核心模块之上，它扩展了 BeanFactory，为它添加了 Bean 生命周期控制、框架事件体系以及资源加载透明化等功能。ApplicationContext 是该模块的核心接口，它的超类是<br>BeanFactory。与BeanFactory 不同，ApplicationContext 容器实例化后会自动对所有的单实例 Bean 进行实例化与依赖关系的装配，使之处于待用状态</li>\n<li><code>spring-context-indexer</code> 该模块是 Spring 的类管理组件和 Classpath 扫描</li>\n<li><code>spring-context-support</code> 该模块是对 Spring IOC 容器的扩展支持，以及 IOC 子容器</li>\n<li><code>spring-expression</code> 该模块是Spring表达式语言块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等</li>\n</ul>\n<h3 id=\"Data-Access-Integration\"><a href=\"#Data-Access-Integration\" class=\"headerlink\" title=\"Data Access&#x2F;Integration\"></a>Data Access&#x2F;Integration</h3><p>数据访问&#x2F;集成</p>\n<ul>\n<li><code>spring-jdbc</code> 该模块提供了 JDBC抽象层，它消除了冗长的 JDBC 编码和对数据库供应商特定错误代码的解析</li>\n<li><code>spring-tx</code> 该模块支持编程式事务和声明式事务，可用于实现了特定接口的类和所有的 POJO 对象。编程式事务需要自己写beginTransaction()、commit()、rollback()<br>等事务管理方法，声明式事务是通过注解或配置由 spring 自动处理，编程式事务粒度更细</li>\n<li><code>spring-orm</code> 该模块提供了对流行的对象关系映射 API的集成，包括 JPA、JDO 和 Hibernate 等。通过此模块可以让这些 ORM 框架和 spring 的其它功能整合，比如前面提及的事务管理</li>\n<li><code>spring-oxm</code> 该模块提供了对 OXM 实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等</li>\n<li><code>spring-jms</code> 该模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了 spring-messaging 模块</li>\n</ul>\n<h3 id=\"Web\"><a href=\"#Web\" class=\"headerlink\" title=\"Web\"></a>Web</h3><p>网络部分</p>\n<ul>\n<li><code>spring-web</code> 该模块为 Spring 提供了最基础 Web 支持，主要建立于核心容器之上，通过 Servlet 或者 Listeners 来初始化 IOC 容器，也包含一些与 Web 相关的支持</li>\n<li><code>spring-webmvc</code> 该模块众所周知是一个的 Web-Servlet 模块，实现了 Spring MVC（model-view-Controller）的 Web 应用</li>\n<li><code>spring-websocket</code> 该模块主要是与 Web 前端的全双工通讯的协议</li>\n<li><code>spring-webflux</code> 该模块是一个新的非堵塞函数式 Reactive Web 框架，可以用来建立异步的，非阻塞，事件驱动的服务，并且扩展性非常好。</li>\n</ul>\n<h3 id=\"面向切面编程-AOP和Aspects\"><a href=\"#面向切面编程-AOP和Aspects\" class=\"headerlink\" title=\"面向切面编程(AOP和Aspects)\"></a>面向切面编程(AOP和Aspects)</h3><ul>\n<li><code>spring-aop</code> 该模块是Spring的另一个核心模块，是 AOP 主要的实现模块</li>\n<li><code>spring-aspects</code> 该模块提供了对 AspectJ 的集成，主要是为 Spring AOP提供多种 AOP 实现方法，如前置方法后置方法等</li>\n</ul>\n<h3 id=\"设备-Instrumentation\"><a href=\"#设备-Instrumentation\" class=\"headerlink\" title=\"设备(Instrumentation)\"></a>设备(Instrumentation)</h3><ul>\n<li><code>spring-instrument</code> 该模块是基于JAVA SE 中的”java.lang.instrument”进行设计的，应该算是 AOP的一个支援模块，主要作用是在 JVM<br>启用时，生成一个代理类，程序员通过代理类在运行时修改类的字节，从而改变一个类的功能，实现 AOP 的功能</li>\n</ul>\n<h3 id=\"消息-Messaging\"><a href=\"#消息-Messaging\" class=\"headerlink\" title=\"消息(Messaging)\"></a>消息(Messaging)</h3><ul>\n<li><code>spring-messaging</code> 是从 Spring4 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用</li>\n</ul>\n<h3 id=\"测试-Test\"><a href=\"#测试-Test\" class=\"headerlink\" title=\"测试(Test)\"></a>测试(Test)</h3><ul>\n<li><code>spring-test</code> 主要为测试提供支持的，通过 JUnit 和 TestNG 组件支持单元测试和集成测试。它提供了一致性地加载和缓存 Spring 上下文，也提供了用于单独测试代码的模拟对象（mock object）</li>\n</ul>\n<h2 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h2><h3 id=\"IOC是什么？\"><a href=\"#IOC是什么？\" class=\"headerlink\" title=\"IOC是什么？\"></a>IOC是什么？</h3><p>控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p>\n<p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>\n<h3 id=\"使用IOC的好处\"><a href=\"#使用IOC的好处\" class=\"headerlink\" title=\"使用IOC的好处\"></a>使用IOC的好处</h3><ul>\n<li>不用自己组装，拿来就用。</li>\n<li>享受单例的好处，效率高，不浪费空间</li>\n<li>便于单元测试，方便切换mock组件</li>\n<li>便于进行AOP操作，对于使用者是透明的</li>\n<li>统一配置，便于修改</li>\n</ul>\n<h2 id=\"BeanFactory-和-ApplicationContext有什么区别\"><a href=\"#BeanFactory-和-ApplicationContext有什么区别\" class=\"headerlink\" title=\"BeanFactory 和 ApplicationContext有什么区别\"></a>BeanFactory 和 ApplicationContext有什么区别</h2><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p>\n<h3 id=\"依赖关系\"><a href=\"#依赖关系\" class=\"headerlink\" title=\"依赖关系\"></a>依赖关系</h3><p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p>\n<p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p>\n<ul>\n<li>继承MessageSource，因此支持国际化。</li>\n<li>统一的资源文件访问方式。</li>\n<li>提供在监听器中注册bean的事件。</li>\n<li>同时加载多个配置文件。</li>\n<li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li>\n</ul>\n<h3 id=\"加载方式\"><a href=\"#加载方式\" class=\"headerlink\" title=\"加载方式\"></a>加载方式</h3><p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())<br>，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p>\n<p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。<br>ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>\n<p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>\n<h3 id=\"创建方式\"><a href=\"#创建方式\" class=\"headerlink\" title=\"创建方式\"></a>创建方式</h3><p>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p>\n<h3 id=\"注册方式\"><a href=\"#注册方式\" class=\"headerlink\" title=\"注册方式\"></a>注册方式</h3><p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>\n<h3 id=\"Spring-IoC的初始化过程\"><a href=\"#Spring-IoC的初始化过程\" class=\"headerlink\" title=\"Spring IoC的初始化过程\"></a>Spring IoC的初始化过程</h3><h4 id=\"IOC粗略总结\"><a href=\"#IOC粗略总结\" class=\"headerlink\" title=\"IOC粗略总结\"></a>IOC粗略总结</h4><ol>\n<li>首先入口是xml或者注解或者其他形式，要实现beanDefinationReader接口，然后 读取的时候，会将他们解析为bean的定义信息；</li>\n<li>beanFactory在加载bean信息实例化（底层用的反射）之前，spring加了一个接口beanFactoryPostProcessor,用作扩展用。</li>\n<li>beanFactory内部实例化bean之后，在要初始化bean对象之前，增加了一个一系列aware接口，将他的容器，以及工厂都暴露出来供使用者做扩展用。</li>\n<li>经过一些列容器以及容器对象的注入之后，在初始化之前，spring又增加了一个接口 beanPostProcessor,该接口是可以作用于所有创建的bean,在初始化前后，均能通过重写该接口获取bean对象进行定制操作。</li>\n<li>经过实现初始化接口完成初始化功能。</li>\n<li>经过实现销毁接口disposableBean结束其生命。</li>\n</ol>\n<h4 id=\"重要的组件\"><a href=\"#重要的组件\" class=\"headerlink\" title=\"重要的组件\"></a>重要的组件</h4><ul>\n<li><code>BeanDefinition</code> 描述bean的属性的接口，例如bean的scope是单例还是多例，构造方法，有哪些property value，依赖等，相当于对这个bean的一份身份描述<ul>\n<li><h2 id=\"Bean配置-–-BeanDefinition-–-Bean对象\"><a href=\"#Bean配置-–-BeanDefinition-–-Bean对象\" class=\"headerlink\" title=\"Bean配置 –&gt; BeanDefinition –&gt; Bean对象\"></a>Bean配置 –&gt; BeanDefinition –&gt; Bean对象</h2>懒加载情况下，refresh只是把BeanDefinition注册到BeanFactory中，而不是把Bean注册到BeanFactory中。在调用上下文的getBean的时候才会去根据BeanDefinition生成具体的bean对象</li>\n</ul>\n</li>\n<li><code>BeanDefinitionMap</code></li>\n<li><code>BeanFactory</code><ul>\n<li>spring的基础bean容器</li>\n<li>相当于存放所有bean的容器</li>\n</ul>\n</li>\n<li><code>ApplicationContext</code><ul>\n<li>BeanFactory 的子接口，在 BeanFactory 的基础上构建，是相对比较高级的 IoC 容器实现。包含 BeanFactory<br>的所有功能，还提供了其他高级的特性，比如：事件发布、国际化信息支持、统一资源加载策略等。正常情况下，我们都是使用的 ApplicationContext</li>\n<li>相当于丰富了beanfactory的功能，这里理解为上下文就好</li>\n</ul>\n</li>\n<li><code>FactoryBean</code></li>\n</ul>\n<h4 id=\"源码解析\"><a href=\"#源码解析\" class=\"headerlink\" title=\"源码解析\"></a>源码解析</h4><p>首先抛开其他组件的启动，我们只需要引入spring-context就可以启动一个容器了</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>而在springboot出来之前最常见的加载bean的方式是读取配置文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[]args)</span>&#123;</span><br><span class=\"line\">        ApplicationContext context=<span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;classpath:applicationfile.xml&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里ApplicationContext是一个接口，主要的实现类有：</p>\n<ul>\n<li>ClassPathXmlApplicationContext 需要一个 xml 配置文件在系统中的路径</li>\n<li>FileSystemXmlApplicationContext 需要一个 xml 配置文件在系统中的路径</li>\n<li>AnnotationConfigApplicationContext 基于注解，大势所趋</li>\n</ul>\n<p>下面的分析都基于 ClassPathXmlApplicationContext 进行分析，因为比较好理解点</p>\n<p>在 resources 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml就可以了,对应的类实现一个：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">default-autowire</span>=<span class=\"string\">&quot;byName&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;messageService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.javadoop.example.MessageServiceImpl&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>main</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">App</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用我们的配置文件来启动一个 ApplicationContext</span></span><br><span class=\"line\">        <span class=\"type\">ApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;classpath:application.xml&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;context 启动成功&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式</span></span><br><span class=\"line\">        <span class=\"type\">MessageService</span> <span class=\"variable\">messageService</span> <span class=\"operator\">=</span> context.getBean(MessageService.class);</span><br><span class=\"line\">        <span class=\"comment\">// 这句将输出: hello world</span></span><br><span class=\"line\">        System.out.println(messageService.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在构造方法中的refresh()方法是启动加载整个容器的关键方法</p>\n<p>方法在springboot容器启动时也会加载,方法为</p>\n<ul>\n<li>org.springframework.boot.SpringApplication#run</li>\n<li>org.springframework.boot.SpringApplication#refreshContext</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refresh</span><span class=\"params\">()</span><span class=\"keyword\">throws</span> BeansException,IllegalStateException&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 首先是一个synchronized加锁，当然要加锁，不然你先调一次refresh()然后这次还没处理完又调一次，就会乱套了；</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>.startupShutdownMonitor)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2. 这个方法是做准备工作的，记录容器的启动时间、标记“已启动”状态、处理配置文件中的占位符，可以点进去看看，这里就不多说了。</span></span><br><span class=\"line\">        prepareRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. 这个就很重要了，这一步是把配置文件解析成一个个Bean，并且注册到BeanFactory中，注意这里只是注册进去，并没有初始化。先继续往下看，等会展开这个方法详细解读</span></span><br><span class=\"line\">        ConfigurableListableBeanFactory beanFactory=obtainFreshBeanFactory();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//4. 这个方法的作用是：设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean，这里都是spring里面的特殊处理，然后继续往下看</span></span><br><span class=\"line\">        prepareBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 5. 方法是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化，具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类，来完成一些其他的操作。</span></span><br><span class=\"line\">            postProcessBeanFactory(beanFactory);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 6. 接下来是这个方法是调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法；</span></span><br><span class=\"line\">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 7. 然后这个方法注册 BeanPostProcessor 的实现类，和上面的BeanFactoryPostProcessor 是有区别的，这个方法调用的其实是PostProcessorRegistrationDelegate类的registerBeanPostProcessors方法；</span></span><br><span class=\"line\">            <span class=\"comment\">// 这个类里面有个内部类BeanPostProcessorChecker，BeanPostProcessorChecker里面有两个方法postProcessBeforeInitialization和postProcessAfterInitialization，这两个方法分别在 Bean 初始化之前和初始化之后得到执行。</span></span><br><span class=\"line\">            <span class=\"comment\">// 然后回到refresh()方法中继续往下看</span></span><br><span class=\"line\">            registerBeanPostProcessors(beanFactory);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 8. 方法是初始化当前 ApplicationContext 的 MessageSource，国际化处理，继续往下</span></span><br><span class=\"line\">            initMessageSource();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 9. 方法初始化当前 ApplicationContext 的事件广播器继续往下</span></span><br><span class=\"line\">            initApplicationEventMulticaster();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 10. 方法初始化一些特殊的 Bean（在初始化 singleton beans 之前）；继续往下</span></span><br><span class=\"line\">            onRefresh();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 11. 方法注册事件监听器，监听器需要实现 ApplicationListener 接口；继续往下</span></span><br><span class=\"line\">            registerListeners();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 12. 重点到了 初始化所有的 singleton beans（单例bean），懒加载（non-lazy-init）的除外，这个方法也是等会细说</span></span><br><span class=\"line\">            finishBeanFactoryInitialization(beanFactory);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// 13. 方法是最后一步，广播事件，ApplicationContext 初始化完成</span></span><br><span class=\"line\">            finishRefresh();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(BeansException ex)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(logger.isWarnEnabled())&#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">&quot;Exception encountered during context initialization - &quot;</span>+<span class=\"string\">&quot;cancelling refresh attempt: &quot;</span>+ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class=\"line\">            <span class=\"comment\">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class=\"line\">            destroyBeans();</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// Reset &#x27;active&#x27; flag.</span></span><br><span class=\"line\">            cancelRefresh(ex);</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"comment\">// Propagate exception to caller.</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class=\"line\">            <span class=\"comment\">// might not ever need metadata for singleton beans anymore...</span></span><br><span class=\"line\">            resetCommonCaches();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Spring-bean的生命周期\"><a href=\"#Spring-bean的生命周期\" class=\"headerlink\" title=\"Spring bean的生命周期\"></a>Spring bean的生命周期</h3><p>Spring Bean的生命周期分为四个阶段和多个扩展点。扩展点又可以分为影响多个Bean和影响单个Bean。整理如下：</p>\n<p>四个阶段</p>\n<ul>\n<li>实例化 Instantiation</li>\n<li>属性赋值 Populate</li>\n<li>初始化 Initialization</li>\n<li>销毁 Destruction</li>\n</ul>\n<p>多个扩展点</p>\n<ul>\n<li>影响多个Bean<ul>\n<li>BeanPostProcessor(作用于初始化阶段的前后)</li>\n<li>InstantiationAwareBeanPostProcessor(作用于实例化阶段的前后)</li>\n</ul>\n</li>\n<li>影响单个Bean<ul>\n<li>Aware(Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源)<ul>\n<li>Aware Group1<ul>\n<li>BeanNameAware</li>\n<li>BeanClassLoaderAware</li>\n<li>BeanFactoryAware</li>\n</ul>\n</li>\n<li>Aware Group2<ul>\n<li>EnvironmentAware</li>\n<li>EmbeddedValueResolverAware(实现该接口能够获取Spring EL解析器，用户的自定义注解需要支持spel表达式的时候可以使用)</li>\n<li>ApplicationContextAware(ResourceLoaderAware\\ApplicationEventPublisherAware\\MessageSourceAware)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>生命周期(实例化和属性赋值都是Spring帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段)<ul>\n<li>InitializingBean</li>\n<li>DisposableBean</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"bean的作用域\"><a href=\"#bean的作用域\" class=\"headerlink\" title=\"bean的作用域\"></a>bean的作用域</h3><p>Spring Bean 中所说的作用域，在配置文件中即是“scope”</p>\n<p>在面向对象程序设计中作用域一般指对象或变量之间的可见范围。</p>\n<p>而在Spring容器中是指其创建的Bean对象相对于其他Bean对象的请求可见范围。</p>\n<p>在Spring 容器当中，一共提供了5种作用域类型，在配置文件中，通过属性scope来设置bean的作用域范围</p>\n<h4 id=\"singleton\"><a href=\"#singleton\" class=\"headerlink\" title=\"singleton\"></a>singleton</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;singleton&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>当Bean的作用域为singleton的时候,Spring容器中只会存在一个共享的Bean实例，所有对Bean的请求只要id与bean的定义相匹配，则只会返回bean的同一实例。单一实例会被存储在单例缓存中，为Spring的缺省作用域。</p>\n<h4 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot; prototype &quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>每次对该Bean请求的时候，Spring IoC都会创建一个新的作用域。</p>\n<p>对于有状态的Bean应该使用prototype，对于无状态的Bean则使用singleton</p>\n<h4 id=\"request\"><a href=\"#request\" class=\"headerlink\" title=\"request\"></a>request</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot; request &quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Request作用域针对的是每次的Http请求，Spring容器会根据相关的Bean的</p>\n<p>定义来创建一个全新的Bean实例。而且该Bean只在当前request内是有效的。</p>\n<h4 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot; session &quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>针对http session起作用，Spring容器会根据该Bean的定义来创建一个全新的Bean的实例。而且该Bean只在当前http session内是有效的。</p>\n<h4 id=\"global-session\"><a href=\"#global-session\" class=\"headerlink\" title=\"global session\"></a>global session</h4><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userInfo&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;cn.lovepi.UserInfo&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;globalSession&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>类似标准的http session作用域，不过仅仅在基于portlet的web应用当中才有意义。Portlet规范定义了全局的Session的概念。他被所有构成某个portlet外部应用中的各种不同的portlet所共享。在global<br>session作用域中所定义的bean被限定于全局的portlet session的生命周期范围之内。</p>\n<h3 id=\"循环依赖问题\"><a href=\"#循环依赖问题\" class=\"headerlink\" title=\"循环依赖问题\"></a>循环依赖问题</h3><h4 id=\"三级缓存\"><a href=\"#三级缓存\" class=\"headerlink\" title=\"三级缓存\"></a>三级缓存</h4><p>Spring 解决循环依赖的核心就是提前暴露对象，而提前暴露的对象就是放置于第二级缓存中。下表是三级缓存的说明：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>singletonObjects</td>\n<td>一级缓存，存放完整的 Bean。</td>\n</tr>\n<tr>\n<td>earlySingletonObjects</td>\n<td>二级缓存，存放提前暴露的Bean，Bean 是不完整的，未完成属性注入和执行 init 方法。</td>\n</tr>\n<tr>\n<td>singletonFactories</td>\n<td>三级缓存，存放的是 Bean 工厂，主要是生产 Bean，存放到二级缓存中。</td>\n</tr>\n</tbody></table>\n<p>所有被Spring 管理的 Bean，最终都会存放在 singletonObjects 中，这里面存放的 Bean 是经历了所有生命周期的（除了销毁的生命周期），完整的，可以给用户使用的。</p>\n<p>earlySingletonObjects 存放的是已经被实例化，但是还没有注入属性和执行 init 方法的 Bean。</p>\n<p>singletonFactories 存放的是生产 Bean 的工厂。</p>\n<p>Bean 都已经实例化了，为什么还需要一个生产 Bean 的工厂呢？这里实际上是跟 AOP 有关，如果项目中不需要为 Bean 进行代理，那么这个 Bean 工厂就会直接返回一开始实例化的对象，如果需要使用 AOP 进行代理，那么这个工厂就会发挥重要的作用了，这也是本文需要重点关注的问题之一。</p>\n<h4 id=\"解决循环依赖\"><a href=\"#解决循环依赖\" class=\"headerlink\" title=\"解决循环依赖\"></a>解决循环依赖</h4><p>Spring 是如何通过上面介绍的三级缓存来解决循环依赖的呢？这里只用 A，B 形成的循环依赖来举例：</p>\n<ol>\n<li>实例化 A，此时 A 还未完成属性填充和初始化方法（@PostConstruct）的执行，A 只是一个半成品。</li>\n<li>为 A 创建一个 Bean 工厂，并放入到  singletonFactories 中。</li>\n<li>发现 A 需要注入 B 对象，但是一级、二级、三级缓存均为发现对象 B。</li>\n<li>实例化 B，此时 B 还未完成属性填充和初始化方法（@PostConstruct）的执行，B 只是一个半成品。</li>\n<li>为 B 创建一个 Bean 工厂，并放入到  singletonFactories 中。</li>\n<li>发现 B 需要注入 A 对象，此时在一级、二级未发现对象 A，但是在三级缓存中发现了对象 A，从三级缓存中得到对象 A，并将对象 A 放入二级缓存中，同时删除三级缓存中的对象 A。（注意，此时的 A 还是一个半成品，并没有完成属性填充和执行初始化方法）</li>\n<li>将对象 A 注入到对象 B 中。</li>\n<li>对象 B 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 B。（此时对象 B 已经是一个成品）</li>\n<li>对象 A 得到对象 B，将对象 B 注入到对象 A 中。（对象 A 得到的是一个完整的对象 B）</li>\n<li>对象 A 完成属性填充，执行初始化方法，并放入到一级缓存中，同时删除二级缓存中的对象 A。</li>\n</ol>\n<h2 id=\"Spring框架中的单例bean是否线程安全\"><a href=\"#Spring框架中的单例bean是否线程安全\" class=\"headerlink\" title=\"Spring框架中的单例bean是否线程安全\"></a>Spring框架中的单例bean是否线程安全</h2><p>Spring框架中的单例bean是线程安全的吗？它是如何处理线程并发问题的?</p>\n<p>不是，Spring框架中的单例bean不是线程安全的。</p>\n<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。实际上大部分 spring bean 是无状态的（比如 dao 类），在某种程度上来说 bean 也是安全的，但如果 bean<br>有状态的话（比如 view model ）就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了， 保证线程安全了。</p>\n<ul>\n<li>有状态就是有数据存储功能。</li>\n<li>无状态就是不会保存数据。</li>\n</ul>\n<p>Spring如何处理线程并发问题?</p>\n<p>一般只有无状态的Bean才可以在多线程下共享，大部分是无状态的Bean。当存有状态的Bean的时候，spring一般是使用ThreadLocal进行处理，解决线程安全问题。</p>\n<p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。<br>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，所以没有相同变量的访问冲突问题。所以在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>\n<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>\n<p>AOP(Aspect-Oriented Programming)<br>，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</p>\n<h3 id=\"AOP原理\"><a href=\"#AOP原理\" class=\"headerlink\" title=\"AOP原理\"></a>AOP原理</h3><p>原理是在IOC过程中，创建bean实例时，最后都会对bean进行处理来实现增强，对于AOP来说就是创建代理类</p>\n<ul>\n<li>底层是动态代理技术<ul>\n<li>JDK动态代理(基于接口)</li>\n<li>CGLib动态代理(基于类)</li>\n<li>在Spring AOP中，如果使用的是单例，推荐使用CGLib代理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h3><p>(一）实现原理</p>\n<p>JDK的动态代理是基于反射实现。JDK通过反射，生成一个代理类，这个代理类实现了原来那个类的全部接口，并对接口中定义的所有方法进行了代理。当我们通过代理对象执行原来那个类的方法时，代理类底层会通过反射机制，回调我们实现的InvocationHandler接口的invoke方法。并且这个代理类是Proxy类的子类（记住这个结论，后面测试要用）。这就是JDK动态代理大致的实现方式。</p>\n<p>（二）优点</p>\n<p>JDK动态代理是JDK原生的，不需要任何依赖即可使用；</p>\n<p>通过反射机制生成代理类的速度要比CGLib操作字节码生成代理类的速度更快；</p>\n<p>（三）缺点</p>\n<p>如果要使用JDK动态代理，被代理的类必须实现了接口，否则无法代理；</p>\n<p>JDK动态代理无法为没有在接口中定义的方法实现代理，假设我们有一个实现了接口的类，我们为它的一个不属于接口中的方法配置了切面，Spring仍然会使用JDK的动态代理，但是由于配置了切面的方法不属于接口，为这个方法配置的切面将不会被织入。</p>\n<p>JDK动态代理执行代理方法时，需要通过反射机制进行回调，此时方法执行的效率比较低；</p>\n<h3 id=\"CGLib动态代理\"><a href=\"#CGLib动态代理\" class=\"headerlink\" title=\"CGLib动态代理\"></a>CGLib动态代理</h3><p>（一）实现原理</p>\n<p>CGLib实现动态代理的原理是，底层采用了ASM字节码生成框架，直接对需要代理的类的字节码进行操作，生成这个类的一个子类，并重写了类的所有可以重写的方法，在重写的过程中，将我们定义的额外的逻辑（简单理解为Spring中的切面）织入到方法中，对方法进行了增强。而通过字节码操作生成的代理类，和我们自己编写并编译后的类没有太大区别。</p>\n<p>（二）优点</p>\n<p>使用CGLib代理的类，不需要实现接口，因为CGLib生成的代理类是直接继承自需要被代理的类；</p>\n<p>CGLib生成的代理类是原来那个类的子类，这就意味着这个代理类可以为原来那个类中，所有能够被子类重写的方法进行代理；</p>\n<p>CGLib生成的代理类，和我们自己编写并编译的类没有太大区别，对方法的调用和直接调用普通类的方式一致，所以CGLib执行代理方法的效率要高于JDK的动态代理；</p>\n<p>（三）缺点</p>\n<p>由于CGLib的代理类使用的是继承，这也就意味着如果需要被代理的类是一个final类，则无法使用CGLib代理；</p>\n<p>由于CGLib实现代理方法的方式是重写父类的方法，所以无法对final方法，或者private方法进行代理，因为子类无法重写这些方法；</p>\n<p>CGLib生成代理类的方式是通过操作字节码，这种方式生成代理类的速度要比JDK通过反射生成代理类的速度更慢；</p>\n<h3 id=\"AOP术语\"><a href=\"#AOP术语\" class=\"headerlink\" title=\"AOP术语\"></a>AOP术语</h3><h4 id=\"连接点-Join-point\"><a href=\"#连接点-Join-point\" class=\"headerlink\" title=\"连接点(Join point)\"></a>连接点(Join point)</h4><p>能够被拦截的地方</p>\n<h4 id=\"切点-Poincut\"><a href=\"#切点-Poincut\" class=\"headerlink\" title=\"切点(Poincut)\"></a>切点(Poincut)</h4><p>具体定位的连接点</p>\n<h4 id=\"增强-通知-Advice\"><a href=\"#增强-通知-Advice\" class=\"headerlink\" title=\"增强&#x2F;通知(Advice)\"></a>增强&#x2F;通知(Advice)</h4><p>表示添加到切点的一段逻辑代码，并定位连接点的方位信息</p>\n<h4 id=\"织入-Weaving\"><a href=\"#织入-Weaving\" class=\"headerlink\" title=\"织入(Weaving)\"></a>织入(Weaving)</h4><p>将增强&#x2F;通知添加到目标类的具体连接点上的过程。</p>\n<h4 id=\"引入-引介-Introduction\"><a href=\"#引入-引介-Introduction\" class=\"headerlink\" title=\"引入&#x2F;引介(Introduction)\"></a>引入&#x2F;引介(Introduction)</h4><p>允许我们向现有的类添加新方法或属性。是一种特殊的增强！</p>\n<h4 id=\"切面-Aspect\"><a href=\"#切面-Aspect\" class=\"headerlink\" title=\"切面(Aspect)\"></a>切面(Aspect)</h4><p>切面由切点和增强&#x2F;通知组成，它既包括了横切逻辑的定义、也包括了连接点的定义</p>\n<h3 id=\"Spring对AOP的支持\"><a href=\"#Spring对AOP的支持\" class=\"headerlink\" title=\"Spring对AOP的支持\"></a>Spring对AOP的支持</h3><ul>\n<li>基于代理的经典SpringAOP：需要实现接口，手动创建代理</li>\n<li>纯POJO切面：使用XML配置，aop命名空间</li>\n<li>@AspectJ注解驱动的切面：使用注解的方式，这是最简洁和最方便的！</li>\n</ul>\n<h2 id=\"怎么定义一个注解\"><a href=\"#怎么定义一个注解\" class=\"headerlink\" title=\"怎么定义一个注解\"></a>怎么定义一个注解</h2><h3 id=\"引入依赖\"><a href=\"#引入依赖\" class=\"headerlink\" title=\"引入依赖\"></a>引入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"定义注解\"><a href=\"#定义注解\" class=\"headerlink\" title=\"定义注解\"></a>定义注解</h3><h4 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h4><p>java.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：</p>\n<ul>\n<li>@Documented – 注解是否将包含在JavaDoc中</li>\n<li>@Retention – 什么时候使用该注解</li>\n<li>@Target – 注解用于什么地方</li>\n<li>@Inherited – 是否允许子类继承该注解</li>\n</ul>\n<h5 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"@Retention\"></a>@Retention</h5><p>定义该注解的生命周期</p>\n<ul>\n<li>RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。</li>\n<li>RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式</li>\n<li>RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</li>\n</ul>\n<h5 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"@Target\"></a>@Target</h5><p>表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType 参数包括</p>\n<ul>\n<li>ElementType.CONSTRUCTOR: 用于描述构造器</li>\n<li>ElementType.FIELD: 成员变量、对象、属性（包括enum实例）</li>\n<li>ElementType.LOCAL_VARIABLE: 用于描述局部变量</li>\n<li>ElementType.METHOD: 用于描述方法</li>\n<li>ElementType.PACKAGE: 用于描述包</li>\n<li>ElementType.PARAMETER: 用于描述参数</li>\n<li>ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明</li>\n</ul>\n<h5 id=\"Documented\"><a href=\"#Documented\" class=\"headerlink\" title=\"@Documented\"></a>@Documented</h5><p>一个简单的Annotations 标记注解，表示是否将注解信息添加在java文档中。</p>\n<h5 id=\"Inherited\"><a href=\"#Inherited\" class=\"headerlink\" title=\"@Inherited\"></a>@Inherited</h5><p>定义该注释和子类的关系</p>\n<p>@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class<br>的子类。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>自定义一个检查是否登录的注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CheckLogin &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@Order(1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CheckLoginAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    RedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;execution(* *..controller..*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodSignature</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> signature.getMethod();</span><br><span class=\"line\">        <span class=\"type\">CheckLogin</span> <span class=\"variable\">annotation</span> <span class=\"operator\">=</span> method.getAnnotation(CheckLogin.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (annotation == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取类上注解</span></span><br><span class=\"line\">            annotation = joinPoint.getTarget().getClass().getAnnotation(CheckLogin.class);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (annotation != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取到请求的属性</span></span><br><span class=\"line\">            <span class=\"type\">ServletRequestAttributes</span> <span class=\"variable\">attributes</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                    (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class=\"line\">            <span class=\"comment\">//获取到请求对象</span></span><br><span class=\"line\">            <span class=\"type\">HttpServletRequest</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> attributes.getRequest();</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">ssoToken</span> <span class=\"operator\">=</span> HttpUtil.getSsoToken(request);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ssoToken != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">loginUserTokenKey</span> <span class=\"operator\">=</span> AuthRedisKeyUtil.getLoginUserTokenKey(ssoToken);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (redisTemplate.hasKey(loginUserTokenKey)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//通过</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoginException</span>(<span class=\"string\">&quot;登录已过期&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalRequestException</span>(<span class=\"string\">&quot;非法请求&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AccountController</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@CheckLogin</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/query&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> JSONObject <span class=\"title function_\">queryRegulation</span><span class=\"params\">(Integer pageNum, Integer pageSize)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//....业务逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"Spring-支持两种方式的事务管理\"><a href=\"#Spring-支持两种方式的事务管理\" class=\"headerlink\" title=\"Spring 支持两种方式的事务管理\"></a>Spring 支持两种方式的事务管理</h3><h4 id=\"1、编程式事务管理\"><a href=\"#1、编程式事务管理\" class=\"headerlink\" title=\"1、编程式事务管理\"></a>1、编程式事务管理</h4><ul>\n<li>TransactionTemplate</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> TransactionTemplate transactionTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testTransaction</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    transactionTemplate.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">TransactionCallbackWithoutResult</span>()&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doInTransactionWithoutResult</span><span class=\"params\">(TransactionStatus status)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//...业务代码</span></span><br><span class=\"line\">                &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">                    status.setRollbackOnly();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>TransactionManager</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> PlatformTransactionManager transactionManager;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testTransaction2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        TransactionStatus status=transactionManager.getTransaction(<span class=\"keyword\">new</span> <span class=\"title class_\">DefaultTransactionDefinition</span>());</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//...业务代码</span></span><br><span class=\"line\">            transactionManager.commit(status);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">            transactionManager.rollback(status);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、注解\"><a href=\"#2、注解\" class=\"headerlink\" title=\"2、注解\"></a>2、注解</h4><ul>\n<li>@Transactional</li>\n</ul>\n<h3 id=\"事务的传播性-Propagation\"><a href=\"#事务的传播性-Propagation\" class=\"headerlink\" title=\"事务的传播性 Propagation\"></a>事务的传播性 Propagation</h3><p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p>\n<p>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p>\n<p>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p>\n<p>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p>\n<p>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>\n<p>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p>\n<p>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p>\n<h3 id=\"spring事务失效的场景\"><a href=\"#spring事务失效的场景\" class=\"headerlink\" title=\"spring事务失效的场景\"></a>spring事务失效的场景</h3><ol>\n<li><p>非被Spring管理的Bean上的事务： 如果你在一个非被Spring容器管理的Bean（例如通过new关键字直接创建的对象）上使用事务注解，事务将不会生效。Spring的事务管理是基于AOP（面向切面编程）实现的，因此只能在由Spring容器管理的Bean上起作用。</p>\n</li>\n<li><p>未捕获的异常： 如果在事务内发生未捕获的运行时异常，事务将回滚。但是，如果异常被捕获并在方法内处理，事务可能不会回滚。确保在事务边界内处理异常或者允许异常传播到事务管理器以便正确回滚。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">transactionalMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// some code that may throw an exception</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle the exception (not recommended within a transaction)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>嵌套事务问题： Spring事务支持嵌套事务，但是嵌套事务的行为取决于底层事务管理器的支持。如果使用的事务管理器不支持嵌套事务，嵌套事务可能会被忽略，导致事务行为不一致。</p>\n</li>\n<li><p>方法调用问题： Spring事务是通过AOP实现的，它依赖于代理对象来拦截方法调用并处理事务。如果你在同一个类内部调用一个带有事务注解的方法，事务可能不会起作用，因为代理对象无法拦截内部方法的调用。确保事务注解生效，要么调用方法是通过代理对象，要么通过self-invocation，例如通过this关键字。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">outerMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        innerMethod(); <span class=\"comment\">// Transactional annotation may not work here</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.innerMethod(); <span class=\"comment\">// Transactional annotation should work here</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">innerMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// some transactional logic</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>异步方法问题： 如果使用了异步方法（通过@Async注解），事务可能会失效。在异步方法内，事务上下文可能无法正确传播，导致事务不起作用。要在异步方法中使用事务，可以使用TransactionContext传播方式。</p>\n</li>\n</ol>\n<h2 id=\"spring使用的设计模式\"><a href=\"#spring使用的设计模式\" class=\"headerlink\" title=\"spring使用的设计模式\"></a>spring使用的设计模式</h2><h3 id=\"简单工厂\"><a href=\"#简单工厂\" class=\"headerlink\" title=\"简单工厂\"></a>简单工厂</h3><p><strong>实现方式：</strong></p>\n<p>BeanFactory。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</p>\n<p><strong>实现原理：</strong></p>\n<p>bean容器的启动阶段：</p>\n<p>读取bean的xml配置文件,将bean元素分别转换成一个BeanDefinition对象。<br>然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个ConcurrentHashMap中。<br>将BeanDefinition注册到了beanFactory之后，在这里Spring为我们提供了一个扩展的切口，允许我们通过实现接口BeanFactoryPostProcessor<br>在此处来插入我们定义的代码。典型的例子就是：PropertyPlaceholderConfigurer，我们一般在配置数据库的dataSource时使用到的占位符的值，就是它注入进去的。</p>\n<p>容器中bean的实例化阶段：</p>\n<p>实例化阶段主要是通过反射或者CGLIB对bean进行实例化，在这个阶段Spring又给我们暴露了很多的扩展点：</p>\n<p>各种的Aware接口 ，比如 BeanFactoryAware，对于实现了这些Aware接口的bean，在实例化bean时Spring会帮我们注入对应的BeanFactory的实例。 BeanPostProcessor接口<br>，实现了BeanPostProcessor接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 InitializingBean接口<br>，实现了InitializingBean接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。 DisposableBean接口<br>，实现了DisposableBean接口的bean，在该bean死亡时Spring会帮我们调用接口中的方法。</p>\n<p><strong>设计意义：</strong></p>\n<p>松耦合。<br>可以将原来硬编码的依赖，通过Spring这个beanFactory这个工厂来注入依赖，也就是说原来只有依赖方和被依赖方，现在我们引入了第三方——spring这个beanFactory，由它来解决bean之间的依赖问题，达到了松耦合的效果.</p>\n<p>bean的额外处理。 通过Spring接口的暴露，在实例化bean的阶段我们可以进行一些额外的处理，这些额外的处理只需要让bean实现对应的接口即可，那么spring就会在bean的生命周期调用我们实现的接口来处理该bean。[非常重要]</p>\n<h3 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h3><p><strong>实现方式：</strong></p>\n<p>FactoryBean接口。</p>\n<p><strong>实现原理：</strong></p>\n<p>实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()<br>方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。</p>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>Spring依赖注入Bean实例默认是单例的。</p>\n<p>Spring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。</p>\n<h3 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h3><p><strong>实现方式：</strong></p>\n<p>SpringMVC中的适配器HandlerAdatper。</p>\n<p><strong>实现原理：</strong></p>\n<p>HandlerAdatper根据Handler规则执行不同的Handler。</p>\n<p><strong>实现过程：</strong></p>\n<p>DispatcherServlet根据HandlerMapping返回的handler，向HandlerAdatper发起请求，处理Handler。</p>\n<p>HandlerAdapter根据规则找到对应的Handler并让其执行，执行完毕后Handler会向HandlerAdapter返回一个ModelAndView，最后由HandlerAdapter向DispatchServelet返回一个ModelAndView。</p>\n<h3 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h3><p><strong>实现方式：</strong></p>\n<p>Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p>\n<p><strong>实质：</strong></p>\n<p>动态地给一个对象添加一些额外的职责。</p>\n<p>就增加功能来说，Decorator模式相比生成子类更为灵活。</p>\n<h3 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h3><p><strong>实现方式：</strong></p>\n<p>AOP底层，就是动态代理模式的实现。</p>\n<p><strong>动态代理：</strong></p>\n<p>在内存中构建的，不需要手动编写代理类</p>\n<h2 id=\"spring中properties和yml的加载顺序\"><a href=\"#spring中properties和yml的加载顺序\" class=\"headerlink\" title=\"spring中properties和yml的加载顺序\"></a>spring中properties和yml的加载顺序</h2><p>相同内容properties和yml的加载顺序是properties优先</p>\n<h2 id=\"使用-Autowired注解自动装配的过程是怎样的？\"><a href=\"#使用-Autowired注解自动装配的过程是怎样的？\" class=\"headerlink\" title=\"使用@Autowired注解自动装配的过程是怎样的？\"></a>使用@Autowired注解自动装配的过程是怎样的？</h2><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config &#x2F;&gt;。</p>\n<p>在启动spring<br>IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p>\n<ul>\n<li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li>\n<li>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</li>\n<li>如果上述查找的结果为空，那么会抛出异常。解决方法是，使用required&#x3D;false。</li>\n</ul>\n<h2 id=\"Autowired和-Resource之间的区别\"><a href=\"#Autowired和-Resource之间的区别\" class=\"headerlink\" title=\"@Autowired和@Resource之间的区别\"></a>@Autowired和@Resource之间的区别</h2><p>@Autowired可用于：构造函数、成员变量、Setter方法</p>\n<p>@Autowired和@Resource之间的区别</p>\n<ul>\n<li>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</li>\n<li>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</li>\n</ul>\n<h2 id=\"Spring中BeanFactory与FactoryBean的区别\"><a href=\"#Spring中BeanFactory与FactoryBean的区别\" class=\"headerlink\" title=\"Spring中BeanFactory与FactoryBean的区别\"></a>Spring中BeanFactory与FactoryBean的区别</h2><h3 id=\"BeanFactory\"><a href=\"#BeanFactory\" class=\"headerlink\" title=\"BeanFactory\"></a>BeanFactory</h3><p>BeanFactory是一个接口，它是Spring中工厂的顶层规范，是SpringIoc容器的核心接口，它定义了getBean()、containsBean()等管理Bean的通用方法。Spring的容器都是它的具体实现如：</p>\n<ul>\n<li>DefaultListableBeanFactory</li>\n<li>XmlBeanFactory</li>\n<li>ApplicationContext</li>\n</ul>\n<p>这些实现类又从不同的维度分别有不同的扩展。</p>\n<h3 id=\"FactoryBean\"><a href=\"#FactoryBean\" class=\"headerlink\" title=\"FactoryBean\"></a>FactoryBean</h3><p>首先它是一个Bean，但又不仅仅是一个Bean。它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式。它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。</p>\n<p>FactoryBean表现的是一个工厂的职责。 即一个Bean A如果实现了FactoryBean接口，那么A就变成了一个工厂，根据A的名称获取到的实际上是工厂调用getObject()<br>返回的对象，而不是A本身，如果要获取工厂A自身的实例，那么需要在名称前面加上’&amp;’符号。</p>\n<ul>\n<li>getObject(‘name’)返回工厂中的实例</li>\n<li>getObject(‘&amp;name’)返回工厂本身的实例</li>\n</ul>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2024-05-26T06:43:04.717Z","updated":"1985-10-26T08:15:00.000Z","comments":1,"layout":"post","photos":[],"_id":"clwxc4r9v000db4uh5em7hjq3","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","cover":"/img/haibian.png","cover_type":"img","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"写代码神器","date":"2024-05-26T04:45:07.000Z","_content":"\nCursor是一个基于人工智能的编程辅助工具，它可以帮助你快速地生成、修改、优化和测试代码。Cursor使用了最先进的自然语言处理技术，能够理解你的编程意图和需求，并根据你的上下文和目标，生成符合你期望的代码。Cursor不仅可以生成代码，还可以检测和修复代码中的错误，提高代码的质量和效率。Cursor还可以根据你的代码生成相应的文档、注释和测试用例，让你的编程过程更加轻松和高效。\n\n![首页](./2024/05/26/写代码神器/1.png)\n\nCursor的用途和优势\n\nCursor可以应用于多种编程场景和语言，无论你是一个新手还是一个专家，Cursor都可以为你提供强大的编程支持。Cursor的主要用途和优势有：\n\n代码生成：Cursor可以根据你的自然语言描述或者部分代码，生成完整的代码片段或者函数。你可以使用Cursor来快速实现你的编程想法，或者填补你的代码空缺。Cursor支持多种编程语言，如Python, Java, C++, JavaScript等，你可以根据你的需要选择合适的语言。\n\n代码修改：Cursor可以根据你的修改意图和需求，对你的代码进行修改和优化。你可以使用Cursor来修改你的代码逻辑、参数、变量名等，或者对你的代码进行重构、简化和美化。Cursor可以保证修改后的代码的正确性和一致性，避免引入新的错误。\n\n代码测试：Cursor可以根据你的代码，生成相应的测试用例和测试代码。你可以使用Cursor来测试你的代码的功能、性能、安全性等，或者对你的代码进行覆盖率、静态分析等检查。Cursor可以帮助你提高你的代码的可靠性和稳定性，发现和解决潜在的问题。\n\n代码文档：Cursor可以根据你的代码，生成相应的文档和注释。你可以使用Cursor来生成你的代码的说明、用法、参数、返回值等，或者对你的代码添加有意义的注释。Cursor可以帮助你提高你的代码的可读性和可维护性，方便你和他人理解和使用你的代码。\n\n![编辑页](./2024/05/26/写代码神器/2.png)\n\nCursor的使用方法\n\nCursor的使用方法非常简单和方便，你只需要在你的编程环境中安装Cursor的插件，然后就可以通过自然语言或者部分代码来引导Cursor为你生成、修改、测试或者文档化你的代码。Cursor的使用方法如下：\n\n代码生成：你可以在你的代码编辑器中输入你的自然语言描述或者部分代码，然后按下Ctrl+Enter键，Cursor就会为你生成相应的代码。例如，你可以输入“定义一个Python函数，计算两个数的最大公约数”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的代码：\n\n\nPython\nAI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.\n\n\ndef gcd(a, b):\n# 使用辗转相除法计算两个数的最大公约数\nwhile b != 0:\na, b = b, a % b\nreturn a\n代码修改：你可以在你的代码编辑器中选中你想要修改的代码，然后输入你的修改意图或者需求，然后按下Ctrl+Enter键，Cursor就会为你修改相应的代码。例如，你可以选中上面的代码，然后输入“使用递归的方式实现”，然后按下Ctrl+Enter键，Cursor就会为你修改如下的代码：\n\n\nPython\nAI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.\n\n\ndef gcd(a, b):\n# 使用递归的方式计算两个数的最大公约数\nif b == 0:\nreturn a\nelse:\nreturn gcd(b, a % b)\n代码测试：你可以在你的代码编辑器中选中你想要测试的代码，然后输入你的测试目标或者条件，然后按下Ctrl+Enter键，Cursor就会为你生成相应的测试用例和测试代码。例如，你可以选中上面的代码，然后输入“测试函数的正确性和性能”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的测试用例和测试代码：\n\n\nPython\nAI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.\n\n\nimport unittest\nimport timeit\n\nclass TestGcd(unittest.TestCase):\n# 测试gcd函数的正确性和性能\n\ndef test_correctness(self):\n# 测试gcd函数的正确性\nself.assertEqual(gcd(12, 18), 6)\nself.assertEqual(gcd(24, 36), 12)\nself.assertEqual(gcd(17, 23), 1)\n\ndef test_performance(self):\n# 测试gcd函数的性能\nt = timeit.timeit(\"gcd(123456789, 987654321)\", setup=\"from __main__ import gcd\", number=1000)\nprint(f\"Average time for 1000 calls: {t/1000:.6f} seconds\")\n\nif __name__ == \"__main__\":\nunittest.main()\n代码文档：你可以在你的代码编辑器中选中你想要文档化的代码，然后输入你的文档目的或者格式，然后按下Ctrl+Enter键，Cursor就会为你生成相应的文档和注释。例如，你可以选中上面的代码，然后输入“生成Markdown格式的文档”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的文档和注释：\n\n\nPython\nAI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.\n\n\n# gcd函数\n\n## 功能\n\ngcd函数用于计算两个数的最大公约数。\n\n## 参数\n\n- a: 第一个数，必须是整数。\n- b: 第二个数，必须是整数。\n\n## 返回值\n\n返回两个数的最大公约数，是一个整数。\n\n## 示例\n\n```python\n>>> gcd(12, 18)\n6\n>>> gcd(24, 36)\n12\n>>> gcd(17, 23)\n1\n\n```\ngcd函数使用了递归的方式实现，如果两个数较大，可能会导致栈溢出的风险。可以考虑使用循环的方式改进。\n\n\n\nCursor的优势和特点\n\nCursor的优势和特点有：\n\n- 基于人工智能：Cursor使用了最先进的自然语言处理技术，能够理解你的编程意图和需求，并根据你的上下文和目标，生成符合你期望的代码。Cursor不仅可以生成代码，还可以检测和修复代码中的错误，提高代码的质量和效率。Cursor还可以根据你的代码生成相应的文档、注释和测试用例，让你的编程过程更加轻松和高效。\n- 基于文本：Cursor使用了基于文本的交互方式，你只需要通过自然语言或者部分代码来引导Cursor为你生成、修改、测试或者文档化你的代码。你不需要学习任何复杂的语法或者命令，只需要用你熟悉的语言来表达你的编程想法和需求，Cursor就可以为你完成你的编程任务。\n- 基于插件：Cursor使用了基于插件的集成方式，你只需要在你的编程环境中安装Cursor的插件，然后就可以在你的代码编辑器中直接使用Cursor的功能。你不需要切换到任何其他的平台或者工具，只需要在你的代码编辑器中按下Ctrl+Enter键，Cursor就可以为你生成、修改、测试或者文档化你的代码。\n\n![搜索页](./2024/05/26/写代码神器/2.png)\n\n\n\nCursor的未来展望\n\nCursor是一个基于人工智能的编程辅助工具，它可以帮助你快速地生成、修改、优化和测试代码。Cursor使用了最先进的自然语言\n","source":"_posts/写代码神器.md","raw":"---\ntitle: 写代码神器\ndate: 2024-05-26 12:45:07\ntags: 开发神器\ncategories: 工具\n---\n\nCursor是一个基于人工智能的编程辅助工具，它可以帮助你快速地生成、修改、优化和测试代码。Cursor使用了最先进的自然语言处理技术，能够理解你的编程意图和需求，并根据你的上下文和目标，生成符合你期望的代码。Cursor不仅可以生成代码，还可以检测和修复代码中的错误，提高代码的质量和效率。Cursor还可以根据你的代码生成相应的文档、注释和测试用例，让你的编程过程更加轻松和高效。\n\n![首页](./2024/05/26/写代码神器/1.png)\n\nCursor的用途和优势\n\nCursor可以应用于多种编程场景和语言，无论你是一个新手还是一个专家，Cursor都可以为你提供强大的编程支持。Cursor的主要用途和优势有：\n\n代码生成：Cursor可以根据你的自然语言描述或者部分代码，生成完整的代码片段或者函数。你可以使用Cursor来快速实现你的编程想法，或者填补你的代码空缺。Cursor支持多种编程语言，如Python, Java, C++, JavaScript等，你可以根据你的需要选择合适的语言。\n\n代码修改：Cursor可以根据你的修改意图和需求，对你的代码进行修改和优化。你可以使用Cursor来修改你的代码逻辑、参数、变量名等，或者对你的代码进行重构、简化和美化。Cursor可以保证修改后的代码的正确性和一致性，避免引入新的错误。\n\n代码测试：Cursor可以根据你的代码，生成相应的测试用例和测试代码。你可以使用Cursor来测试你的代码的功能、性能、安全性等，或者对你的代码进行覆盖率、静态分析等检查。Cursor可以帮助你提高你的代码的可靠性和稳定性，发现和解决潜在的问题。\n\n代码文档：Cursor可以根据你的代码，生成相应的文档和注释。你可以使用Cursor来生成你的代码的说明、用法、参数、返回值等，或者对你的代码添加有意义的注释。Cursor可以帮助你提高你的代码的可读性和可维护性，方便你和他人理解和使用你的代码。\n\n![编辑页](./2024/05/26/写代码神器/2.png)\n\nCursor的使用方法\n\nCursor的使用方法非常简单和方便，你只需要在你的编程环境中安装Cursor的插件，然后就可以通过自然语言或者部分代码来引导Cursor为你生成、修改、测试或者文档化你的代码。Cursor的使用方法如下：\n\n代码生成：你可以在你的代码编辑器中输入你的自然语言描述或者部分代码，然后按下Ctrl+Enter键，Cursor就会为你生成相应的代码。例如，你可以输入“定义一个Python函数，计算两个数的最大公约数”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的代码：\n\n\nPython\nAI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.\n\n\ndef gcd(a, b):\n# 使用辗转相除法计算两个数的最大公约数\nwhile b != 0:\na, b = b, a % b\nreturn a\n代码修改：你可以在你的代码编辑器中选中你想要修改的代码，然后输入你的修改意图或者需求，然后按下Ctrl+Enter键，Cursor就会为你修改相应的代码。例如，你可以选中上面的代码，然后输入“使用递归的方式实现”，然后按下Ctrl+Enter键，Cursor就会为你修改如下的代码：\n\n\nPython\nAI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.\n\n\ndef gcd(a, b):\n# 使用递归的方式计算两个数的最大公约数\nif b == 0:\nreturn a\nelse:\nreturn gcd(b, a % b)\n代码测试：你可以在你的代码编辑器中选中你想要测试的代码，然后输入你的测试目标或者条件，然后按下Ctrl+Enter键，Cursor就会为你生成相应的测试用例和测试代码。例如，你可以选中上面的代码，然后输入“测试函数的正确性和性能”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的测试用例和测试代码：\n\n\nPython\nAI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.\n\n\nimport unittest\nimport timeit\n\nclass TestGcd(unittest.TestCase):\n# 测试gcd函数的正确性和性能\n\ndef test_correctness(self):\n# 测试gcd函数的正确性\nself.assertEqual(gcd(12, 18), 6)\nself.assertEqual(gcd(24, 36), 12)\nself.assertEqual(gcd(17, 23), 1)\n\ndef test_performance(self):\n# 测试gcd函数的性能\nt = timeit.timeit(\"gcd(123456789, 987654321)\", setup=\"from __main__ import gcd\", number=1000)\nprint(f\"Average time for 1000 calls: {t/1000:.6f} seconds\")\n\nif __name__ == \"__main__\":\nunittest.main()\n代码文档：你可以在你的代码编辑器中选中你想要文档化的代码，然后输入你的文档目的或者格式，然后按下Ctrl+Enter键，Cursor就会为你生成相应的文档和注释。例如，你可以选中上面的代码，然后输入“生成Markdown格式的文档”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的文档和注释：\n\n\nPython\nAI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.\n\n\n# gcd函数\n\n## 功能\n\ngcd函数用于计算两个数的最大公约数。\n\n## 参数\n\n- a: 第一个数，必须是整数。\n- b: 第二个数，必须是整数。\n\n## 返回值\n\n返回两个数的最大公约数，是一个整数。\n\n## 示例\n\n```python\n>>> gcd(12, 18)\n6\n>>> gcd(24, 36)\n12\n>>> gcd(17, 23)\n1\n\n```\ngcd函数使用了递归的方式实现，如果两个数较大，可能会导致栈溢出的风险。可以考虑使用循环的方式改进。\n\n\n\nCursor的优势和特点\n\nCursor的优势和特点有：\n\n- 基于人工智能：Cursor使用了最先进的自然语言处理技术，能够理解你的编程意图和需求，并根据你的上下文和目标，生成符合你期望的代码。Cursor不仅可以生成代码，还可以检测和修复代码中的错误，提高代码的质量和效率。Cursor还可以根据你的代码生成相应的文档、注释和测试用例，让你的编程过程更加轻松和高效。\n- 基于文本：Cursor使用了基于文本的交互方式，你只需要通过自然语言或者部分代码来引导Cursor为你生成、修改、测试或者文档化你的代码。你不需要学习任何复杂的语法或者命令，只需要用你熟悉的语言来表达你的编程想法和需求，Cursor就可以为你完成你的编程任务。\n- 基于插件：Cursor使用了基于插件的集成方式，你只需要在你的编程环境中安装Cursor的插件，然后就可以在你的代码编辑器中直接使用Cursor的功能。你不需要切换到任何其他的平台或者工具，只需要在你的代码编辑器中按下Ctrl+Enter键，Cursor就可以为你生成、修改、测试或者文档化你的代码。\n\n![搜索页](./2024/05/26/写代码神器/2.png)\n\n\n\nCursor的未来展望\n\nCursor是一个基于人工智能的编程辅助工具，它可以帮助你快速地生成、修改、优化和测试代码。Cursor使用了最先进的自然语言\n","slug":"写代码神器","published":1,"updated":"2024-05-26T14:20:47.814Z","comments":1,"layout":"post","photos":[],"_id":"clwxc4r9w000eb4uhhe7m2l6c","content":"<p>Cursor是一个基于人工智能的编程辅助工具，它可以帮助你快速地生成、修改、优化和测试代码。Cursor使用了最先进的自然语言处理技术，能够理解你的编程意图和需求，并根据你的上下文和目标，生成符合你期望的代码。Cursor不仅可以生成代码，还可以检测和修复代码中的错误，提高代码的质量和效率。Cursor还可以根据你的代码生成相应的文档、注释和测试用例，让你的编程过程更加轻松和高效。</p>\n<p><img src=\"/./2024/05/26/%E5%86%99%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8/1.png\" alt=\"首页\"></p>\n<p>Cursor的用途和优势</p>\n<p>Cursor可以应用于多种编程场景和语言，无论你是一个新手还是一个专家，Cursor都可以为你提供强大的编程支持。Cursor的主要用途和优势有：</p>\n<p>代码生成：Cursor可以根据你的自然语言描述或者部分代码，生成完整的代码片段或者函数。你可以使用Cursor来快速实现你的编程想法，或者填补你的代码空缺。Cursor支持多种编程语言，如Python, Java, C++, JavaScript等，你可以根据你的需要选择合适的语言。</p>\n<p>代码修改：Cursor可以根据你的修改意图和需求，对你的代码进行修改和优化。你可以使用Cursor来修改你的代码逻辑、参数、变量名等，或者对你的代码进行重构、简化和美化。Cursor可以保证修改后的代码的正确性和一致性，避免引入新的错误。</p>\n<p>代码测试：Cursor可以根据你的代码，生成相应的测试用例和测试代码。你可以使用Cursor来测试你的代码的功能、性能、安全性等，或者对你的代码进行覆盖率、静态分析等检查。Cursor可以帮助你提高你的代码的可靠性和稳定性，发现和解决潜在的问题。</p>\n<p>代码文档：Cursor可以根据你的代码，生成相应的文档和注释。你可以使用Cursor来生成你的代码的说明、用法、参数、返回值等，或者对你的代码添加有意义的注释。Cursor可以帮助你提高你的代码的可读性和可维护性，方便你和他人理解和使用你的代码。</p>\n<p><img src=\"/./2024/05/26/%E5%86%99%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8/2.png\" alt=\"编辑页\"></p>\n<p>Cursor的使用方法</p>\n<p>Cursor的使用方法非常简单和方便，你只需要在你的编程环境中安装Cursor的插件，然后就可以通过自然语言或者部分代码来引导Cursor为你生成、修改、测试或者文档化你的代码。Cursor的使用方法如下：</p>\n<p>代码生成：你可以在你的代码编辑器中输入你的自然语言描述或者部分代码，然后按下Ctrl+Enter键，Cursor就会为你生成相应的代码。例如，你可以输入“定义一个Python函数，计算两个数的最大公约数”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的代码：</p>\n<p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p>\n<p>def gcd(a, b):</p>\n<h1 id=\"使用辗转相除法计算两个数的最大公约数\"><a href=\"#使用辗转相除法计算两个数的最大公约数\" class=\"headerlink\" title=\"使用辗转相除法计算两个数的最大公约数\"></a>使用辗转相除法计算两个数的最大公约数</h1><p>while b !&#x3D; 0:<br>a, b &#x3D; b, a % b<br>return a<br>代码修改：你可以在你的代码编辑器中选中你想要修改的代码，然后输入你的修改意图或者需求，然后按下Ctrl+Enter键，Cursor就会为你修改相应的代码。例如，你可以选中上面的代码，然后输入“使用递归的方式实现”，然后按下Ctrl+Enter键，Cursor就会为你修改如下的代码：</p>\n<p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p>\n<p>def gcd(a, b):</p>\n<h1 id=\"使用递归的方式计算两个数的最大公约数\"><a href=\"#使用递归的方式计算两个数的最大公约数\" class=\"headerlink\" title=\"使用递归的方式计算两个数的最大公约数\"></a>使用递归的方式计算两个数的最大公约数</h1><p>if b &#x3D;&#x3D; 0:<br>return a<br>else:<br>return gcd(b, a % b)<br>代码测试：你可以在你的代码编辑器中选中你想要测试的代码，然后输入你的测试目标或者条件，然后按下Ctrl+Enter键，Cursor就会为你生成相应的测试用例和测试代码。例如，你可以选中上面的代码，然后输入“测试函数的正确性和性能”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的测试用例和测试代码：</p>\n<p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p>\n<p>import unittest<br>import timeit</p>\n<p>class TestGcd(unittest.TestCase):</p>\n<h1 id=\"测试gcd函数的正确性和性能\"><a href=\"#测试gcd函数的正确性和性能\" class=\"headerlink\" title=\"测试gcd函数的正确性和性能\"></a>测试gcd函数的正确性和性能</h1><p>def test_correctness(self):</p>\n<h1 id=\"测试gcd函数的正确性\"><a href=\"#测试gcd函数的正确性\" class=\"headerlink\" title=\"测试gcd函数的正确性\"></a>测试gcd函数的正确性</h1><p>self.assertEqual(gcd(12, 18), 6)<br>self.assertEqual(gcd(24, 36), 12)<br>self.assertEqual(gcd(17, 23), 1)</p>\n<p>def test_performance(self):</p>\n<h1 id=\"测试gcd函数的性能\"><a href=\"#测试gcd函数的性能\" class=\"headerlink\" title=\"测试gcd函数的性能\"></a>测试gcd函数的性能</h1><p>t &#x3D; timeit.timeit(“gcd(123456789, 987654321)”, setup&#x3D;”from <strong>main</strong> import gcd”, number&#x3D;1000)<br>print(f”Average time for 1000 calls: {t&#x2F;1000:.6f} seconds”)</p>\n<p>if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>unittest.main()<br>代码文档：你可以在你的代码编辑器中选中你想要文档化的代码，然后输入你的文档目的或者格式，然后按下Ctrl+Enter键，Cursor就会为你生成相应的文档和注释。例如，你可以选中上面的代码，然后输入“生成Markdown格式的文档”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的文档和注释：</p>\n<p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p>\n<h1 id=\"gcd函数\"><a href=\"#gcd函数\" class=\"headerlink\" title=\"gcd函数\"></a>gcd函数</h1><h2 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h2><p>gcd函数用于计算两个数的最大公约数。</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><ul>\n<li>a: 第一个数，必须是整数。</li>\n<li>b: 第二个数，必须是整数。</li>\n</ul>\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p>返回两个数的最大公约数，是一个整数。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>gcd(<span class=\"number\">12</span>, <span class=\"number\">18</span>)</span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>gcd(<span class=\"number\">24</span>, <span class=\"number\">36</span>)</span><br><span class=\"line\"><span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>gcd(<span class=\"number\">17</span>, <span class=\"number\">23</span>)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>gcd函数使用了递归的方式实现，如果两个数较大，可能会导致栈溢出的风险。可以考虑使用循环的方式改进。</p>\n<p>Cursor的优势和特点</p>\n<p>Cursor的优势和特点有：</p>\n<ul>\n<li>基于人工智能：Cursor使用了最先进的自然语言处理技术，能够理解你的编程意图和需求，并根据你的上下文和目标，生成符合你期望的代码。Cursor不仅可以生成代码，还可以检测和修复代码中的错误，提高代码的质量和效率。Cursor还可以根据你的代码生成相应的文档、注释和测试用例，让你的编程过程更加轻松和高效。</li>\n<li>基于文本：Cursor使用了基于文本的交互方式，你只需要通过自然语言或者部分代码来引导Cursor为你生成、修改、测试或者文档化你的代码。你不需要学习任何复杂的语法或者命令，只需要用你熟悉的语言来表达你的编程想法和需求，Cursor就可以为你完成你的编程任务。</li>\n<li>基于插件：Cursor使用了基于插件的集成方式，你只需要在你的编程环境中安装Cursor的插件，然后就可以在你的代码编辑器中直接使用Cursor的功能。你不需要切换到任何其他的平台或者工具，只需要在你的代码编辑器中按下Ctrl+Enter键，Cursor就可以为你生成、修改、测试或者文档化你的代码。</li>\n</ul>\n<p><img src=\"/./2024/05/26/%E5%86%99%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8/2.png\" alt=\"搜索页\"></p>\n<p>Cursor的未来展望</p>\n<p>Cursor是一个基于人工智能的编程辅助工具，它可以帮助你快速地生成、修改、优化和测试代码。Cursor使用了最先进的自然语言</p>\n","cover":"/img/hubian.png","cover_type":"img","excerpt":"","more":"<p>Cursor是一个基于人工智能的编程辅助工具，它可以帮助你快速地生成、修改、优化和测试代码。Cursor使用了最先进的自然语言处理技术，能够理解你的编程意图和需求，并根据你的上下文和目标，生成符合你期望的代码。Cursor不仅可以生成代码，还可以检测和修复代码中的错误，提高代码的质量和效率。Cursor还可以根据你的代码生成相应的文档、注释和测试用例，让你的编程过程更加轻松和高效。</p>\n<p><img src=\"/./2024/05/26/%E5%86%99%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8/1.png\" alt=\"首页\"></p>\n<p>Cursor的用途和优势</p>\n<p>Cursor可以应用于多种编程场景和语言，无论你是一个新手还是一个专家，Cursor都可以为你提供强大的编程支持。Cursor的主要用途和优势有：</p>\n<p>代码生成：Cursor可以根据你的自然语言描述或者部分代码，生成完整的代码片段或者函数。你可以使用Cursor来快速实现你的编程想法，或者填补你的代码空缺。Cursor支持多种编程语言，如Python, Java, C++, JavaScript等，你可以根据你的需要选择合适的语言。</p>\n<p>代码修改：Cursor可以根据你的修改意图和需求，对你的代码进行修改和优化。你可以使用Cursor来修改你的代码逻辑、参数、变量名等，或者对你的代码进行重构、简化和美化。Cursor可以保证修改后的代码的正确性和一致性，避免引入新的错误。</p>\n<p>代码测试：Cursor可以根据你的代码，生成相应的测试用例和测试代码。你可以使用Cursor来测试你的代码的功能、性能、安全性等，或者对你的代码进行覆盖率、静态分析等检查。Cursor可以帮助你提高你的代码的可靠性和稳定性，发现和解决潜在的问题。</p>\n<p>代码文档：Cursor可以根据你的代码，生成相应的文档和注释。你可以使用Cursor来生成你的代码的说明、用法、参数、返回值等，或者对你的代码添加有意义的注释。Cursor可以帮助你提高你的代码的可读性和可维护性，方便你和他人理解和使用你的代码。</p>\n<p><img src=\"/./2024/05/26/%E5%86%99%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8/2.png\" alt=\"编辑页\"></p>\n<p>Cursor的使用方法</p>\n<p>Cursor的使用方法非常简单和方便，你只需要在你的编程环境中安装Cursor的插件，然后就可以通过自然语言或者部分代码来引导Cursor为你生成、修改、测试或者文档化你的代码。Cursor的使用方法如下：</p>\n<p>代码生成：你可以在你的代码编辑器中输入你的自然语言描述或者部分代码，然后按下Ctrl+Enter键，Cursor就会为你生成相应的代码。例如，你可以输入“定义一个Python函数，计算两个数的最大公约数”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的代码：</p>\n<p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p>\n<p>def gcd(a, b):</p>\n<h1 id=\"使用辗转相除法计算两个数的最大公约数\"><a href=\"#使用辗转相除法计算两个数的最大公约数\" class=\"headerlink\" title=\"使用辗转相除法计算两个数的最大公约数\"></a>使用辗转相除法计算两个数的最大公约数</h1><p>while b !&#x3D; 0:<br>a, b &#x3D; b, a % b<br>return a<br>代码修改：你可以在你的代码编辑器中选中你想要修改的代码，然后输入你的修改意图或者需求，然后按下Ctrl+Enter键，Cursor就会为你修改相应的代码。例如，你可以选中上面的代码，然后输入“使用递归的方式实现”，然后按下Ctrl+Enter键，Cursor就会为你修改如下的代码：</p>\n<p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p>\n<p>def gcd(a, b):</p>\n<h1 id=\"使用递归的方式计算两个数的最大公约数\"><a href=\"#使用递归的方式计算两个数的最大公约数\" class=\"headerlink\" title=\"使用递归的方式计算两个数的最大公约数\"></a>使用递归的方式计算两个数的最大公约数</h1><p>if b &#x3D;&#x3D; 0:<br>return a<br>else:<br>return gcd(b, a % b)<br>代码测试：你可以在你的代码编辑器中选中你想要测试的代码，然后输入你的测试目标或者条件，然后按下Ctrl+Enter键，Cursor就会为你生成相应的测试用例和测试代码。例如，你可以选中上面的代码，然后输入“测试函数的正确性和性能”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的测试用例和测试代码：</p>\n<p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p>\n<p>import unittest<br>import timeit</p>\n<p>class TestGcd(unittest.TestCase):</p>\n<h1 id=\"测试gcd函数的正确性和性能\"><a href=\"#测试gcd函数的正确性和性能\" class=\"headerlink\" title=\"测试gcd函数的正确性和性能\"></a>测试gcd函数的正确性和性能</h1><p>def test_correctness(self):</p>\n<h1 id=\"测试gcd函数的正确性\"><a href=\"#测试gcd函数的正确性\" class=\"headerlink\" title=\"测试gcd函数的正确性\"></a>测试gcd函数的正确性</h1><p>self.assertEqual(gcd(12, 18), 6)<br>self.assertEqual(gcd(24, 36), 12)<br>self.assertEqual(gcd(17, 23), 1)</p>\n<p>def test_performance(self):</p>\n<h1 id=\"测试gcd函数的性能\"><a href=\"#测试gcd函数的性能\" class=\"headerlink\" title=\"测试gcd函数的性能\"></a>测试gcd函数的性能</h1><p>t &#x3D; timeit.timeit(“gcd(123456789, 987654321)”, setup&#x3D;”from <strong>main</strong> import gcd”, number&#x3D;1000)<br>print(f”Average time for 1000 calls: {t&#x2F;1000:.6f} seconds”)</p>\n<p>if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>unittest.main()<br>代码文档：你可以在你的代码编辑器中选中你想要文档化的代码，然后输入你的文档目的或者格式，然后按下Ctrl+Enter键，Cursor就会为你生成相应的文档和注释。例如，你可以选中上面的代码，然后输入“生成Markdown格式的文档”，然后按下Ctrl+Enter键，Cursor就会为你生成如下的文档和注释：</p>\n<p>Python<br>AI 生成的代码。仔细查看和使用。 有关常见问题解答的详细信息.</p>\n<h1 id=\"gcd函数\"><a href=\"#gcd函数\" class=\"headerlink\" title=\"gcd函数\"></a>gcd函数</h1><h2 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h2><p>gcd函数用于计算两个数的最大公约数。</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><ul>\n<li>a: 第一个数，必须是整数。</li>\n<li>b: 第二个数，必须是整数。</li>\n</ul>\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p>返回两个数的最大公约数，是一个整数。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>gcd(<span class=\"number\">12</span>, <span class=\"number\">18</span>)</span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>gcd(<span class=\"number\">24</span>, <span class=\"number\">36</span>)</span><br><span class=\"line\"><span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>gcd(<span class=\"number\">17</span>, <span class=\"number\">23</span>)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>gcd函数使用了递归的方式实现，如果两个数较大，可能会导致栈溢出的风险。可以考虑使用循环的方式改进。</p>\n<p>Cursor的优势和特点</p>\n<p>Cursor的优势和特点有：</p>\n<ul>\n<li>基于人工智能：Cursor使用了最先进的自然语言处理技术，能够理解你的编程意图和需求，并根据你的上下文和目标，生成符合你期望的代码。Cursor不仅可以生成代码，还可以检测和修复代码中的错误，提高代码的质量和效率。Cursor还可以根据你的代码生成相应的文档、注释和测试用例，让你的编程过程更加轻松和高效。</li>\n<li>基于文本：Cursor使用了基于文本的交互方式，你只需要通过自然语言或者部分代码来引导Cursor为你生成、修改、测试或者文档化你的代码。你不需要学习任何复杂的语法或者命令，只需要用你熟悉的语言来表达你的编程想法和需求，Cursor就可以为你完成你的编程任务。</li>\n<li>基于插件：Cursor使用了基于插件的集成方式，你只需要在你的编程环境中安装Cursor的插件，然后就可以在你的代码编辑器中直接使用Cursor的功能。你不需要切换到任何其他的平台或者工具，只需要在你的代码编辑器中按下Ctrl+Enter键，Cursor就可以为你生成、修改、测试或者文档化你的代码。</li>\n</ul>\n<p><img src=\"/./2024/05/26/%E5%86%99%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8/2.png\" alt=\"搜索页\"></p>\n<p>Cursor的未来展望</p>\n<p>Cursor是一个基于人工智能的编程辅助工具，它可以帮助你快速地生成、修改、优化和测试代码。Cursor使用了最先进的自然语言</p>\n"},{"title":"场景设计面试题","date":"2024-05-26T15:11:48.000Z","_content":"\n\n\n\n## 有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号+姓名，而B文件存放学号+分数，要求生成文件C，存放姓名和分数。怎么实现？\n- hash(学号)%1000，A到a0....a1000,B到b0~b1000\n- 学号相同的人一定hash到相同序号的小文件\n- 加载序号相同的小文件（比如：读取a2和b2）用map储存再按姓名+分数写入C即可\n## 秒杀系统怎么设计\n### 秒杀存在的问题\n- 高并发、瞬间请求量极大\n- 黄牛、黑客恶意请求\n- 链接暴露问题\n- 数据库压力问题\n- 库存不足和超卖问题\n### 如何解决这些问题\n- 页面静态化\n    - 秒杀活动的页面，大多数内容都是固定不变的，如商品名称，商品图片等等，可以对活动页面做静态化处理，减少访问服务端的请求。秒杀用户会分布在全国各地，有的在上海，有的在深圳，地域相差很远，网速也各不相同。为了让用户最快访问到活动页面，可以使用CDN（Content Delivery Network，内容分发网络）。CDN可以让用户就近获取所需内容。\n- 按钮至灰控制\n    - 秒杀活动开始前，按钮一般需要置灰的。只有时间到了，才能变得可以点击。这是防止，秒杀用户在时间快到的前几秒，疯狂请求服务器，然后秒杀时间点还没到，服务器就自己挂了。\n- 服务单一职责\n    - 我们都知道微服务设计思想，也就是把各个功能模块拆分，功能那个类似的放一起，再用分布式的部署方式。\n    - 如用户登录相关的，就设计个用户服务，订单相关的就搞个订单服务，再到礼物相关的就搞个礼物服务等等。那么，秒杀相关的业务逻辑也可以放到一起，搞个秒杀服务，单独给它搞个秒杀数据库。\n    - 服务单一职责有个好处：如果秒杀没抗住高并发的压力，秒杀库崩了，服务挂了，也不会影响到系统的其他服务。\n- 秒杀链接加盐\n    - 链接如果明文暴露的话，会有人获取到请求Url，提前秒杀了。因此，需要给秒杀链接加盐。可以把URL动态化，如通过MD5加密算法加密随机的字符串去做url。\n- 限流\n    - 一般有两种方式限流：nginx限流和redis限流。\n    - 为了防止某个用户请求过于频繁，我们可以对同一用户限流；\n    - 为了防止黄牛模拟几个用户请求，我们可以对某个IP进行限流；\n    - 为了防止有人使用代理，每次请求都更换IP请求，我们可以对接口进行限流。\n    - 为了防止瞬时过大的流量压垮系统，还可以使用阿里的Sentinel、Hystrix组件进行限流。\n- 分布式锁\n    - 可以使用redis分布式锁解决超卖问题。\n    - 使用Redis的SET EX PX NX + 校验唯一随机值,再删除释放锁。\n    - 为了更严谨，一般也是用lua脚本代替。lua脚本如下：\n- MQ异步处理\n    - 如果瞬间流量特别大，可以使用消息队列削峰，异步处理。用户请求过来的时候，先放到消息队列，再拿出来消费。\n- 限流&降级&熔断\n    - 限流，就是限制请求，防止过大的请求压垮服务器；\n    - 降级，就是秒杀服务有问题了，就降级处理，不要影响别的服务；\n    - 熔断，服务有问题就熔断，一般熔断降级是一起出现。\n## 产品上线出问题怎么定位错误\n- 复现问题\n- top jstack\n## 大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案\n读写分离\n## 海量日志数据，提取出某日访问百度次数最多的那个IP。\n- 可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址\n- 对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址\n- 可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；\n## 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？\n### 方案1\n- 遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,...,a999）中。这样每个小文件的大约为300M。\n- 遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,...,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,...,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。\n- 求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。\n### 方案2\n如果允许有一定的误差，使用布隆过滤器\n## 一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash(x)%1000分为小文件再分别加载小文件到内存中处理即可\n\n## 如何保证接口的幂等性\n\n### 什么是幂等性\n幂等性是系统服务对外一种承诺，承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。\n\n### 什么情况下需要幂等\n\n以SQL为例：\n\n- SELECT col1 FROM tab1 WHER col2=2，无论执行多少次都不会改变状态，是天然的幂等。\n- UPDATE tab1 SET col1=1 WHERE col2=2，无论执行成功多少次状态都是一致的，因此也是幂等操作。\n- UPDATE tab1 SET col1=col1+1 WHERE col2=2，每次执行的结果都会发生变化，这种不是幂等的。\n- insert into user(userid,name) values(1,'a') 如userid为唯一主键，即重复操作上面的业务，只会插入一条用户数据，具备幂等性。\n    - 如userid不是主键，可以重复，那上面业务多次操作，数据都会新增多条，不具备幂等性。\n- delete from user where userid=1，多次操作，结果一样，具备幂等性\n\n### 如何保证幂等\n\n#### 1、token机制\n- 服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，服务器会把token保存到redis中。\n- 然后调用业务接口请求时，把token携带过去，一般放在请求头部。\n- 服务器判断token是否存在redis中，存在表示第一次请求，然后删除token,继续执行业务。\n- 如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不被重复执行。\n\n**关键点 先删除token，还是后删除token。**\n\n后删除token：如果进行业务处理成功后，删除redis中的token失败了，这样就导致了有可能会发生重复请求，因为token没有被删除。这个问题其实是数据库和缓存redis数据不一致问题，后续会写文章进行讲解。\n\n先删除token：如果系统出现问题导致业务处理出现异常，业务处理没有成功，接口调用方也没有获取到明确的结果，然后进行重试，但token已经删除掉了，服务端判断token不存在，认为是重复请求，就直接返回了，无法进行业务处理了。\n\n先删除token可以保证不会因为重复请求，业务数据出现问题。出现业务异常，可以让调用方配合处理一下，重新获取新的token，再次由业务调用方发起重试请求就ok了。\n\n**token机制缺点**\n\n业务请求每次请求，都会有额外的请求（一次获取token请求、判断token是否存在的业务）。其实真实的生产环境中，1万请求也许只会存在10个左右的请求会发生重试，为了这10个请求，我们让9990个请求都发生了额外的请求。\n\n#### 2、乐观锁机制\n\n- 这种方法适合在更新的场景中，update t_goods set count = count -1 , version = version + 1 where good_id=2 and version = 1\n- 根据version版本，也就是在操作库存前先获取当前商品的version版本号，然后操作的时候带上此version号。我们梳理下，我们第一次操作库存时，得到version为1，调用库存服务version变成了2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传如的version还是1，再执行上面的sql语句时，就不会执行；因为version已经变为2了，where条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。\n- 乐观锁主要使用于处理读多写少的问题\n\n#### 3、唯一主键\n\n这个机制是利用了数据库的主键唯一约束的特性，解决了在insert场景时幂等问题。但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。\n\n如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关\n\n#### 4、防重表\n\n使用订单号orderNo做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。\n\n#### 5、唯一ID\n\n调用接口时，生成一个唯一id，redis将数据保存到集合中（去重），存在即处理过。\n\n## 缓存和数据库不一致问题\n### 更新缓存和更新数据库\n大部分观点认为，做缓存不应该是去更新缓存，而是应该删除缓存，然后由下个请求去去缓存，发现不存在后再读取数据库，写入缓存。观点引用：《分布式之数据库和缓存双写一致性方案解析》孤独烟\n\n原因一：线程安全角度同时有请求A和请求B进行更新操作，那么会出现（1）线程A更新了数据库（2）线程B更新了数据库（3）线程B更新了缓存（4）线程A更新了缓存这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。\n\n原因二：业务场景角度有如下两点：\n1. 如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。\n2. 如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。\n\n### 删缓存和更新数据库\n#### 先删缓存，再更新数据库\n该方案会导致请求数据不一致同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:\n1. 请求A进行写操作，删除缓存\n2. 请求B查询发现缓存不存在\n3. 请求B去数据库查询得到旧值\n4. 请求B将旧值写入缓存\n5. 请求A将新值写入数据库上述情况就会导致不一致的情形出现。\n   而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。\n#### 先更新数据库，再删缓存\n这种情况不存在并发问题么？不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生\n1. 缓存刚好失效\n2. 请求A查询数据库，得一个旧值\n3. 请求B将新值写入数据库\n4. 请求B删除缓存\n5. 请求A将查到的旧值写入缓存ok，如果发生上述情况，确实是会发生脏数据。 然而，发生这种情况的概率又有多少呢？发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。\n\n先更新数据库，再删缓存依然会有问题，不过，问题出现的可能性会因为上面说的原因，变得比较低！(补充说明：我用了“先更新数据库，再删缓存”且不设过期时间策略，会不会有问题呢？由于先缓存和更新数据库不是原子的，如果更新了数据库，程序歇逼，就没删缓存，由于没有过期策略，就永远脏数据了。)所以，如果你想实现基础的缓存数据库双写一致的逻辑，那么在大多数情况下，在不想做过多设计，增加太大工作量的情况下，请先更新数据库，再删缓存!\n### 数据库和缓存数据强一致怎么办\n没有办法做到绝对的一致性，这是由CAP理论决定的，缓存系统适用的场景就是非强一致性的场景，所以它属于CAP中的AP。所以，我们得委曲求全，可以去做到BASE理论中说的最终一致性。\n\n大佬们给出了到达最终一致性的解决思路，主要是针对上面两种双写策略（先删缓存，再更新数据库/先更新数据库，再删缓存）导致的脏数据问题，进行相应的处理，来保证最终一致性。\n\n#### 缓存延时双删\n步骤\n1. 先删除缓存\n2. 再写数据库\n3. 休眠500毫秒（根据具体的业务时间来定）\n4. 再次删除缓存。\n\n#### 那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？\n\n针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。\n\n\n#### 如果你用了mysql的读写分离架构怎么办？\n\nok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。\n1. 请求A进行写操作，删除缓存\n2. 请求A将数据写入数据库了，\n3. 请求B查询缓存发现，缓存没有值\n4. 请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值\n5. 请求B将旧值写入缓存\n6. 数据库完成主从同步，从库变为新值上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。\n\n#### 采用这种同步淘汰策略，吞吐量降低怎么办？\n\nok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。\n\n#### 删缓存失败了怎么办：重试机制\n看似问题都已经解决了，但其实，还有一个问题没有考虑到，那就是删除缓存的操作，失败了怎么办？比如延时双删的时候，第二次缓存删除失败了，那不还是没有清除脏数据吗？解决方案就是再加上一个重试机制，保证删除缓存成功\n\n流程如下所示\n1. 更新数据库数据；\n2. 缓存因为种种问题删除失败\n3. 将需要删除的key发送至消息队列\n4. 自己消费消息，获得需要删除的key\n5. 继续重试删除操作，直到成功然而，\n\n该方案有一个缺点，对业务线代码造成大量的侵入。\n\n于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作\n\n#### binlog\n流程如下所示\n1. 更新数据库数据\n2. 数据库会将操作信息写入binlog日志当中\n3. 订阅程序提取出所需要的数据以及key\n4. 另起一段非业务代码，获得该信息\n5. 尝试删除缓存操作，发现删除失败\n6. 将这些信息发送至消息队列\n7. 重新从消息队列中获得该数据，重试操作。\n\n## 什么是SPI\nSPI 全称为 (Service Provider Interface) ，是JDK内置的一种服务提供发现机制\n\n### SPI 实践\n接下来我们来如何来利用 SPI 实现刚才提到的可拔插 IOC 容器。\n\n既然刚才都提到了 SPI 的本质就是面向接口编程，所以自然我们首先需要定义一个接口：\n\n![SPI图](./2024/05/26/场景设计面试题/1.png)\n\n其中包含了一些 Bean 容器所必须的操作：注册、获取、释放 bean。\n\n为了让其他人也能实现自己的 IOC 容器，所以我们将这个接口单独放到一个 Module 中，可供他人引入实现。\n\n![](./2024/05/26/场景设计面试题/2.png)\n\n所以当我要实现一个单例的 IOC 容器时，我只需要新建一个 Module 然后引入刚才的模块并实现 CicadaBeanFactory 接口即可。\n\n当然其中最重要的则是需要在 resources 目录下新建一个 META-INF/services/top.crossoverjie.cicada.base.bean.CicadaBeanFactory 文件，文件名必须得是我们之前定义接口的全限定名（SPI 规范）。\n![](./2024/05/26/场景设计面试题/3.png)\n\n其中的内容便是我们自己实现类的全限定名：\n```shell\ntop.crossoverjie.cicada.bean.ioc.CicadaIoc\n```\n可以想象最终会通过这里的全限定名来反射创建对象。\n\n只不过这个过程 Java 已经提供 API 屏蔽掉了：\n```java\npublic static CicadaBeanFactory getCicadaBeanFactory() {\n    ServiceLoader<CicadaBeanFactory> cicadaBeanFactories = ServiceLoader.load(CicadaBeanFactory.class);\n    if (cicadaBeanFactories.iterator().hasNext()){\n        return cicadaBeanFactories.iterator().next() ;\n    }\n    return new CicadaDefaultBean();\n}\n```\n当 classpath 中存在我们刚才的实现类（引入实现类的 jar 包），便可以通过 java.util.ServiceLoader 工具类来找到所有的实现类（可以有多个实现类同时存在，只不过通常我们只需要一个）。\n\n一些都准备好之后，使用自然就非常简单了。\n```xml\n<dependency>\n    <groupId>top.crossoverjie.opensource</groupId>\n    <artifactId>cicada-ioc</artifactId>\n    <version>2.0.4</version>\n</dependency>\n```\n我们只需要引入这个依赖便能使用它的实现，当我们想换一种实现方式时只需要更换一个依赖即可。\n\n这样就做到了不修改一行代码灵活的可拔插选择 IOC 容器了。\n\nSPI 的一些其他应用\n\nMySQL 的驱动包也是利用 SPI 来实现自己的连接逻辑。\n\n![](./2024/05/26/场景设计面试题/4.png)\n\n总结来说：\n\n- 提供一个接口\n- 在resource下新建META-INF/services目录，在目录下新建接口的全限定名文件\n- 服务方实现接口\n- 调用ServiceLoad.load()\n\n## 什么是RPC？\nRPC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务\n\n1. 首先客户端需要告诉服务器，需要调用的函数，这里函数和进程ID存在一个映射，客户端远程调用时，需要查一下函数，找到对应的ID，然后执行函数的代码。\n2. 客户端需要把本地参数传给远程函数，本地调用的过程中，直接压栈即可，但是在远程调用过程中不再同一个内存里，无法直接传递函数的参数，因此需要客户端把参数转换成字节流，传给服务端，然后服务端将字节流转换成自身能读取的格式，是一个序列化和反序列化的过程。\n3. 数据准备好了之后，如何进行传输？网络传输层需要把调用的ID和序列化后的参数传给服务端，然后把计算好的结果序列化传给客户端，因此TCP层即可完成上述过程，gRPC中采用的是HTTP2协议。\n\n总结一下：\n```text\n// Client端 \n//    Student student = Call(ServerAddr, addAge, student)\n1. 将这个调用映射为Call ID。\n2. 将Call ID，student（params）序列化，以二进制形式打包\n3. 把2中得到的数据包发送给ServerAddr，这需要使用网络传输层\n4. 等待服务器返回结果\n5. 如果服务器调用成功，那么就将结果反序列化，并赋给student，年龄更新\n\n// Server端\n1. 在本地维护一个Call ID到函数指针的映射call_id_map，可以用Map<String, Method> callIdMap\n2. 等待客户端请求\n3. 得到一个请求后，将其数据包反序列化，得到Call ID\n4. 通过在callIdMap中查找，得到相应的函数指针\n5. 将student（params）反序列化后，在本地调用addAge()函数，得到结果\n6. 将student结果序列化后通过网络返回给Client\n```\n\n- 在微服务的设计中，一个服务A如果访问另一个Module下的服务B，可以采用HTTP REST传输数据，并在两个服务之间进行序列化和反序列化操作，服务B把执行结果返回过来。\n- 由于HTTP在应用层中完成，整个通信的代价较高，远程过程调用中直接基于TCP进行远程调用，数据传输在传输层TCP层完成，更适合对效率要求比较高的场景，RPC主要依赖于客户端和服务端之间建立Socket链接进行，底层实现比REST更复杂。\n\n### RPC demo\n客户端\n```java\npublic class RPCClient<T> {\n    public static <T> T getRemoteProxyObj(final Class<?> serviceInterface, final InetSocketAddress addr) {\n        // 1.将本地的接口调用转换成JDK的动态代理，在动态代理中实现接口的远程调用\n        return (T) Proxy.newProxyInstance(serviceInterface.getClassLoader(), new Class<?>[]{serviceInterface},\n                new InvocationHandler() {\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        Socket socket = null;\n                        ObjectOutputStream output = null;\n                        ObjectInputStream input = null;\n                        try{\n                            // 2.创建Socket客户端，根据指定地址连接远程服务提供者\n                            socket = new Socket();\n                            socket.connect(addr);\n\n                            // 3.将远程服务调用所需的接口类、方法名、参数列表等编码后发送给服务提供者\n                            output = new ObjectOutputStream(socket.getOutputStream());\n                            output.writeUTF(serviceInterface.getName());\n                            output.writeUTF(method.getName());\n                            output.writeObject(method.getParameterTypes());\n                            output.writeObject(args);\n\n                            // 4.同步阻塞等待服务器返回应答，获取应答后返回\n                            input = new ObjectInputStream(socket.getInputStream());\n                            return input.readObject();\n                        }finally {\n                            if (socket != null){\n                                socket.close();\n                            }\n                            if (output != null){\n                                output.close();\n                            }\n                            if (input != null){\n                                input.close();\n                            }\n                        }\n                    }\n                });\n    }\n}\n```\n服务端\n```java\npublic class ServiceCenter implements Server {\n\n    private static ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());\n\n    private static final HashMap<String, Class> serviceRegistry = new HashMap<String, Class>();\n\n    private static boolean isRunning = false;\n\n    private static int port;\n\n\n    public ServiceCenter(int port){\n        ServiceCenter.port = port;\n    }\n\n\n    @Override\n    public void start() throws IOException {\n        ServerSocket server = new ServerSocket();\n        server.bind(new InetSocketAddress(port));\n        System.out.println(\"Server Start .....\");\n        try{\n            while(true){\n                executor.execute(new ServiceTask(server.accept()));\n            }\n        }finally {\n            server.close();\n        }\n    }\n\n    @Override\n    public void register(Class serviceInterface, Class impl) {\n        serviceRegistry.put(serviceInterface.getName(), impl);\n    }\n\n    @Override\n    public boolean isRunning() {\n        return isRunning;\n    }\n\n    @Override\n    public int getPort() {\n        return port;\n    }\n\n    @Override\n    public void stop() {\n        isRunning = false;\n        executor.shutdown();\n    }\n   private static class ServiceTask implements Runnable {\n        Socket client = null;\n\n        public ServiceTask(Socket client) {\n            this.client = client;\n        }\n\n        @Override\n        public void run() {\n            ObjectInputStream input = null;\n            ObjectOutputStream output = null;\n            try{\n                input = new ObjectInputStream(client.getInputStream());\n                String serviceName = input.readUTF();\n                String methodName = input.readUTF();\n                Class<?>[] parameterTypes = (Class<?>[]) input.readObject();\n                Object[] arguments = (Object[]) input.readObject();\n                Class serviceClass = serviceRegistry.get(serviceName);\n                if(serviceClass == null){\n                    throw new ClassNotFoundException(serviceName + \"not found!\");\n                }\n                Method method = serviceClass.getMethod(methodName, parameterTypes);\n                Object result = method.invoke(serviceClass.newInstance(), arguments);\n\n                output = new ObjectOutputStream(client.getOutputStream());\n                output.writeObject(result);\n            }catch (Exception e){\n                e.printStackTrace();\n            }finally {\n                if(output!=null){\n                    try{\n                        output.close();\n                    }catch (IOException e){\n                        e.printStackTrace();\n                    }\n                }\n                if (input != null) {\n                    try {\n                        input.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                if (client != null) {\n                    try {\n                        client.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}\n\npublic class ServiceProducerImpl implements ServiceProducer{\n    @Override\n    public String sendData(String data) {\n        return \"I am service producer!!!, the data is \"+ data;\n    }\n}\n\npublic class RPCTest {\n    public static void main(String[] args) throws IOException {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Server serviceServer = new ServiceCenter(8088);\n                    serviceServer.register(ServiceProducer.class, ServiceProducerImpl.class);\n                    serviceServer.start();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n        ServiceProducer service = RPCClient.getRemoteProxyObj(ServiceProducer.class, new InetSocketAddress(\"localhost\", 8088));\n        System.out.println(service.sendData(\"test\"));\n    }\n}\n```\n\n## gRPC\n### gRPC与REST\n- REST通常以业务为导向，将业务对象上执行的操作映射到HTTP动词，格式非常简单，可以使用浏览器进行扩展和传输，通过JSON数据完成客户端和服务端之间的消息通信，直接支持请求/响应方式的通信。不需要中间的代理，简化了系统的架构，不同系统之间只需要对JSON进行解析和序列化即可完成数据的传递。\n- 但是REST也存在一些弊端，比如只支持请求/响应这种单一的通信方式，对象和字符串之间的序列化操作也会影响消息传递速度，客户端需要通过服务发现的方式，知道服务实例的位置，在单个请求获取多个资源时存在着挑战，而且有时候很难将所有的动作都映射到HTTP动词。\n- 正是因为REST面临一些问题，因此可以采用gRPC作为一种替代方案，gRPC 是一种基于二进制流的消息协议，可以采用基于Protocol Buffer的IDL定义grpc API,这是Google公司用于序列化结构化数据提供的一套语言中立的序列化机制，客户端和服务端使用HTTP/2以Protocol Buffer格式交换二进制消息。\n- gRPC的优势是，设计复杂更新操作的API非常简单，具有高效紧凑的进程通信机制，在交换大量消息时效率高，远程过程调用和消息传递时可以采用双向的流式消息方式，同时客户端和服务端支持多种语言编写，互操作性强；不过gRPC的缺点是不方便与JavaScript集成，某些防火墙不支持该协议。\n- 注册中心：当项目中有很多服务时，可以把所有的服务在启动的时候注册到一个注册中心里面，用于维护服务和服务器之间的列表，当注册中心接收到客户端请求时，去找到该服务是否远程可以调用，如果可以调用需要提供服务地址返回给客户端，客户端根据返回的地址和端口，去调用远程服务端的方法，执行完成之后将结果返回给客户端。这样在服务端加新功能的时候，客户端不需要直接感知服务端的方法，服务端将更新之后的结果在注册中心注册即可，而且当修改了服务端某些方法的时候，或者服务降级服务多机部署想实现负载均衡的时候，我们只需要更新注册中心的服务群即可。\n  ![](./2024/05/26/场景设计面试题/5.png)\n\n### demo\n这里使用SpringBoot+gRPC的形式实现RPC调用过程 项目结构分为三部分：client、grpc、server\n#### grpc\n![](./2024/05/26/场景设计面试题/6.png)\n```xml\n<dependency>\n      <groupId>io.grpc</groupId>\n      <artifactId>grpc-all</artifactId>\n       <version>1.12.0</version>\n </dependency>\n```\n```xml\n<build>\n        <extensions>\n            <extension>\n                <groupId>kr.motd.maven</groupId>\n                <artifactId>os-maven-plugin</artifactId>\n                <version>1.4.1.Final</version>\n            </extension>\n        </extensions>\n        <plugins>\n            <plugin>\n                <groupId>org.xolstice.maven.plugins</groupId>\n                <artifactId>protobuf-maven-plugin</artifactId>\n                <version>0.5.0</version>\n                <configuration>\n                    <pluginId>grpc-java</pluginId>\n                    <protocArtifact>com.google.protobuf:protoc:3.0.2:exe:${os.detected.classifier}</protocArtifact>\n                    <pluginArtifact>io.grpc:protoc-gen-grpc-java:1.2.0:exe:${os.detected.classifier}</pluginArtifact>\n                </configuration>\n                <executions>\n                    <execution>\n                        <goals>\n                            <goal>compile</goal>\n                            <goal>compile-custom</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n```\n创建.proto文件\n```protobuf\nsyntax = \"proto3\";   // 语法版本\n\n// stub选项\noption java_package = \"com.shgx.grpc.api\";\noption java_outer_classname = \"RPCDateServiceApi\";\noption java_multiple_files = true;\n\n// 定义包名\npackage com.shgx.grpc.api;\n\n// 服务接口定义，服务端和客户端都要遵守该接口进行通信\nservice RPCDateService {\n    rpc getDate (RPCDateRequest) returns (RPCDateResponse) {}\n}\n\n// 定义消息（请求）\nmessage RPCDateRequest {\n    string userName = 1;\n}\n\n// 定义消息（响应）\nmessage RPCDateResponse {\n    string serverDate = 1;\n}\n\n```\nmvn complie\n\n生成代码：\n![](./2024/05/26/场景设计面试题/7.png)\n\n#### client\n![](./2024/05/26/场景设计面试题/8.png)\n\n根据gRPC中的项目配置在client和server两个Module的pom.xml添加依赖\n```xml\n        <dependency>\n            <groupId>com.shgx</groupId>\n            <artifactId>grpc</artifactId>\n            <version>0.0.1-SNAPSHOT</version>\n            <scope>compile</scope>\n        </dependency>\n```\n编写GRPCClient\n```java\npublic class GRPCClient {\n    private static final String host = \"localhost\";\n    private static final int serverPort = 9999;\n\n    public static void main( String[] args ) throws Exception {\n        ManagedChannel managedChannel = ManagedChannelBuilder.forAddress( host, serverPort ).usePlaintext().build();\n        try {\n            RPCDateServiceGrpc.RPCDateServiceBlockingStub rpcDateService = RPCDateServiceGrpc.newBlockingStub( managedChannel );\n            RPCDateRequest rpcDateRequest = RPCDateRequest\n                    .newBuilder()\n                    .setUserName(\"shgx\")\n                    .build();\n            RPCDateResponse rpcDateResponse = rpcDateService.getDate( rpcDateRequest );\n            System.out.println( rpcDateResponse.getServerDate() );\n        } finally {\n            managedChannel.shutdown();\n        }\n    }\n}\n\n```\n#### server\n![](./2024/05/26/场景设计面试题/9.png)\n\n按照2.2.3 client的方式添加依赖\n\n创建RPCDateServiceImpl\n```java\npublic class RPCDateServiceImpl extends RPCDateServiceGrpc.RPCDateServiceImplBase{\n    @Override\n    public void getDate(RPCDateRequest request, StreamObserver<RPCDateResponse> responseObserver) {\n        RPCDateResponse rpcDateResponse = null;\n        Date now=new Date();\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"今天是\"+\"yyyy年MM月dd日 E kk点mm分\");\n        String nowTime = simpleDateFormat.format( now );\n        try {\n            rpcDateResponse = RPCDateResponse\n                    .newBuilder()\n                    .setServerDate( \"Welcome \" + request.getUserName()  + \", \" + nowTime )\n                    .build();\n        } catch (Exception e) {\n            responseObserver.onError(e);\n        } finally {\n            responseObserver.onNext( rpcDateResponse );\n        }\n        responseObserver.onCompleted();\n    }\n}\n```\n创建GRPCServer\n```java\npublic class GRPCServer {\n    private static final int port = 9999;\n    public static void main( String[] args ) throws Exception {\n        Server server = ServerBuilder.\n                forPort(port)\n                .addService( new RPCDateServiceImpl() )\n                .build().start();\n        System.out.println( \"grpc服务端启动成功, 端口=\" + port );\n        server.awaitTermination();\n    }\n}\n```\n## 一个优秀的RPC框架需要考虑的问题\n1. `微服务化`应用都基于微服务化，实现资源调用离不开远程调用\n2. `多实例问题` 一个服务可能有多个实例，你在调用时，要如何获取这些实例的地址呢？--- 这时候就需要一个服务注册中心，从服务注册中心获取服务的实例列表，再从中选择一个进行调用。\n3. `负载均衡` 选哪个调用好呢？这时候就需要负载均衡了，于是又得考虑如何实现复杂均衡\n4. `缓存` 总不能每次调用时都去注册中心查询实例列表吧，这样效率多低呀，于是又有了缓存，有了缓存，就要考虑缓存的更新问题\n5. `异步调用` 客户端总不能每次调用完都干等着服务端返回数据吧,于是就要支持异步调用;\n    - Future实现\n6. `版本控制` 服务端的接口修改了，老的接口还有人在用，怎么办？总不能让他们都改了吧？这就需要版本控制了；\n7. `线程池` 服务端总不能每次接到请求都马上启动一个线程去处理吧？于是就需要线程池；\n8. `未处理完的请求` 服务端关闭时，还没处理完的请求怎么办？是直接结束呢，还是等全部请求处理完再关闭呢？\n\n## 什么是DDD？\n### MVC\n要说DDD，不得不先看看MVC，我相信基本上99%的java开发读者，不管你是计科专业出身还是跨专业，初学spring或者springboot的时候，接触到的代码分层都是MVC\n这说明了MVC有它自身独有的优势：\n- 开发人员可以只关注整个结构中的其中某一层；\n- 可以很容易的用新的实现来替换原有层次的实现；\n- 可以降低层与层之间的依赖；\n- 有利于标准化；\n- 利于各层逻辑的复用。\n\n但是真实情况是这样吗？随着你系统功能迭代，业务逻辑越来越复杂之后。MVC三层中，V层作为数据载体，C层作为逻辑路由都是很薄的一层，大量的代码都堆积在了M层（模型层）。一个service的类，动辄几百上千行，大的甚至几万行，逻辑嵌套复杂，主业务逻辑不清晰。service做的稍微轻量化一点的，代码就像是胶水，把数据库执行逻辑与控制返回给前端的逻辑胶在一起，主次不清晰。\n一看你的工程，类啊，代码量啊都不少，你甚至不知道如何入手去修改“屎山”一样的代码。\n\n### 那么DDD为什么可以去解决以上的问题呢？\n\nDDD核心思想是什么呢？解耦！让业务不是像炒大锅饭一样混在一起，而是一道道工序复杂的美食，都有他们自己独立的做法。\n\nDDD的价值观里面，任何业务都是某个业务领域模型的职责体现。A领域只会去做A领域的事情，A领域想去修改B领域，需要找中介（防腐层）去对B领域完成操作。我想完成一个很长的业务逻辑动作，在划分好业务边界之后，交给业务服务的编排者（应用服务）去组织业务模型（聚合）完成逻辑。\n\n这样，每个服务（领域）只会做自己业务边界内的事情，最小细粒度的去定义需求的实现。原先空空的贫血模型摇身一变变成了充血模型。原理冗长的service里面类似到处set，get值这种与业务逻辑无关的数据载体包装代码，都会被去除，进到应用服务层，你的代码就是你的业务逻辑。逻辑清晰，可维护性高！\n\n### 什么样的系统适配DDD\n中小规模的系统，本身业务体量小，功能单一，选择mvc架构无疑是最好的。 项目化交付的系统，研发周期短，一天到晚按照甲方的需求定制功能。\n\n中大规模系统，产品化模式，业务可持续迭代，可预见的业务逻辑复杂性的系统。\n\n### DDD的代码怎么做\n\n// TODO\n\n## Java实现生产者消费者\n### wait()和notify()方法的实现\n```java\npublic class Test1 {\n    private static Integer count = 0;\n    private static final Integer FULL = 10;\n    private static String LOCK = \"lock\";\n    \n    public static void main(String[] args) {\n        Test1 test1 = new Test1();\n        new Thread(test1.new Producer()).start();\n        new Thread(test1.new Consumer()).start();\n        new Thread(test1.new Producer()).start();\n        new Thread(test1.new Consumer()).start();\n        new Thread(test1.new Producer()).start();\n        new Thread(test1.new Consumer()).start();\n        new Thread(test1.new Producer()).start();\n        new Thread(test1.new Consumer()).start();\n    }\n    class Producer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                synchronized (LOCK) {\n                    while (count == FULL) {\n                        try {\n                            LOCK.wait();\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    count++;\n                    System.out.println(Thread.currentThread().getName() + \"生产者生产，目前总共有\" + count);\n                    LOCK.notifyAll();\n                }\n            }\n        }\n    }\n    class Consumer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                synchronized (LOCK) {\n                    while (count == 0) {\n                        try {\n                            LOCK.wait();\n                        } catch (Exception e) {\n                        }\n                    }\n                    count--;\n                    System.out.println(Thread.currentThread().getName() + \"消费者消费，目前总共有\" + count);\n                    LOCK.notifyAll();\n                }\n            }\n        }\n    }\n}\n```\n### 可重入锁ReentrantLock的实现\n```java\npublic class Test2 {\n    private static Integer count = 0;\n    private static final Integer FULL = 10;\n    //创建一个锁对象\n    private Lock lock = new ReentrantLock();\n    //创建两个条件变量，一个为缓冲区非满，一个为缓冲区非空\n    private final Condition notFull = lock.newCondition();\n    private final Condition notEmpty = lock.newCondition();\n    public static void main(String[] args) {\n        Test2 test2 = new Test2();\n        new Thread(test2.new Producer()).start();\n        new Thread(test2.new Consumer()).start();\n        new Thread(test2.new Producer()).start();\n        new Thread(test2.new Consumer()).start();\n        new Thread(test2.new Producer()).start();\n        new Thread(test2.new Consumer()).start();\n        new Thread(test2.new Producer()).start();\n        new Thread(test2.new Consumer()).start();\n    }\n    class Producer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                //获取锁\n                lock.lock();\n                try {\n                    while (count == FULL) {\n                        try {\n                            notFull.await();\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    count++;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"生产者生产，目前总共有\" + count);\n                    //唤醒消费者\n                    notEmpty.signal();\n                } finally {\n                    //释放锁\n                    lock.unlock();\n                }\n            }\n        }\n    }\n    class Consumer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e1) {\n                    e1.printStackTrace();\n                }\n                lock.lock();\n                try {\n                    while (count == 0) {\n                        try {\n                            notEmpty.await();\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    count--;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"消费者消费，目前总共有\" + count);\n                    notFull.signal();\n                } finally {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n}\n```\n#### 阻塞队列BlockingQueue的实现\n```java\npublic class Test3 {\n    private static Integer count = 0;\n    //创建一个阻塞队列\n    final BlockingQueue blockingQueue = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args) {\n        Test3 test3 = new Test3();\n        new Thread(test3.new Producer()).start();\n        new Thread(test3.new Consumer()).start();\n        new Thread(test3.new Producer()).start();\n        new Thread(test3.new Consumer()).start();\n        new Thread(test3.new Producer()).start();\n        new Thread(test3.new Consumer()).start();\n        new Thread(test3.new Producer()).start();\n        new Thread(test3.new Consumer()).start();\n    }\n    class Producer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                try {\n                    blockingQueue.put(1);\n                    count++;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"生产者生产，目前总共有\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n    class Consumer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e1) {\n                    e1.printStackTrace();\n                }\n                try {\n                    blockingQueue.take();\n                    count--;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"消费者消费，目前总共有\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n#### 信号量Semaphore的实现\n```java\npublic class Test4 {\n    private static Integer count = 0;\n    //创建三个信号量\n    final Semaphore notFull = new Semaphore(10);\n    final Semaphore notEmpty = new Semaphore(0);\n    final Semaphore mutex = new Semaphore(1);\n    public static void main(String[] args) {\n        Test4 test4 = new Test4();\n        new Thread(test4.new Producer()).start();\n        new Thread(test4.new Consumer()).start();\n        new Thread(test4.new Producer()).start();\n        new Thread(test4.new Consumer()).start();\n        new Thread(test4.new Producer()).start();\n        new Thread(test4.new Consumer()).start();\n        new Thread(test4.new Producer()).start();\n        new Thread(test4.new Consumer()).start();\n    }\n    class Producer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                try {\n                    notFull.acquire();\n                    mutex.acquire();\n                    count++;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"生产者生产，目前总共有\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    mutex.release();\n                    notEmpty.release();\n                }\n            }\n        }\n    }\n    class Consumer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e1) {\n                    e1.printStackTrace();\n                }\n                try {\n                    notEmpty.acquire();\n                    mutex.acquire();\n                    count--;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"消费者消费，目前总共有\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    mutex.release();\n                    notFull.release();\n                }\n            }\n        }\n    }\n}\n\n```\n## Java实现BlockQueue\n```java\npublic class BlockingQueue<E> {\n\n    /**\n     * 有界队列内部固定长度，因此可以用数组实现\n     */\n    private Object[] elements;\n\n    /**\n     * 队列的头和尾下标\n     */\n    private int head = 0, tail = 0;\n\n    /**\n     * 队列目前的长度\n     */\n    private int size;\n    private ReentrantLock lock = new ReentrantLock();\n    private Condition notEmpty = lock.newCondition();\n    private Condition notFull = lock.newCondition();\n\n    public BlockingQueue(int capacity) {\n        this.elements = new Object[capacity];\n    }\n\n    public void put(E e) {\n        lock.lock();\n        try {\n            while (size == elements.length)\n                notFull.await();\n            elements[tail] = e;\n            if (++tail == elements.length) {\n                tail = 0;\n            }\n            size++;\n            notEmpty.signal();\n\n        } catch (InterruptedException ex) {\n            ex.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public E take() {\n        lock.lock();\n        E e = null;\n        try {\n            while (size == 0) {\n                notEmpty.await();\n            }\n            e = (E) elements[head];\n            elements[head] = null;\n            if (++head == elements.length)\n                head = 0;\n            size--;\n            notFull.signal();\n\n        } catch (InterruptedException ex) {\n            ex.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n        return e;\n    }\n\n    public int size() {\n        lock.lock();\n        try {\n            return size;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n## 解决哈希冲突的方法\n### 开放定址法\n从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。\n\n在开放定址法中解决冲突的方法有：线行探查法、平方探查法、双散列函数探查法。\n\n开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。\n\n#### 线行探查法\n线行探查法是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。\n\n可以参考csdn上flash对该方法的演示：\nhttp://student.zjzk.cn/course_ware/data_structure/web/flash/cz/kfdzh.swf\n\n#### 平方探查法\n平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²…直到找到空闲单元。\n\n在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。\n\n#### 双散列函数探查法\n这种方法使用两个散列函数hl和h2。其中hl和前面的h一样，以关键字为自变量，产生一个0至m—l之间的数作为散列地址；h2也以关键字为自变量，产生一个l至m—1之间的、并和m互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)，探查序列的步长值是固定值l；对于平方探查法，探查序列的步长值是探查次数i的两倍减l；对于双散列函数探查法，其探查序列的步长值是同一关键字的另一散列函数的值。\n\n### 链地址法（拉链法）\n链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。\n\n如下一组数字,(32、40、36、53、16、46、71、27、42、24、49、64)哈希表长度为13，哈希函数为H(key)=key%13,则链表法结果如下：\n```java\n0       \n1  -> 40 -> 27 -> 53 \n2\n3  -> 16 -> 42\n4\n5\n6  -> 32 -> 71\n7  -> 46\n8\n9\n10 -> 36 -> 49\n11 -> 24\n12 -> 64\n```\n注：在java中，链接地址法也是HashMap解决哈希冲突的方法之一，jdk1.7完全采用单链表来存储同义词，jdk1.8则采用了一种混合模式，对于链表长度大于8的，会转换为红黑树存储。\n\n### 再哈希法\n就是同时构造多个不同的哈希函数：\n\nHi = RHi(key)   i= 1,2,3 … k;\n\n当H1 = RH1(key)  发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。\n\n### 建立公共溢出区\n将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。\n\n## 排行榜设计\n### 基于数据库\n基于MySQL，order by\n\n缺点：\n- 速度慢\n### 基于Redis\n主要考察sort set 也就是zset\n\nzadd添加数据后，zrevrange获取排序后的排名\n\n### 类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样\nkey的设计比较重要，比如aa用户和bb用户\n```shell\nzadd step:aa 1000 小明\nzadd step:bb 1000 小明\n```\n\n同理时间也可以通过key的设计解决\n```shell\nzadd step:aa:20210929 1000 小明\nzadd step:aa:20210929 1000 小明\n```\n\n但是上述设计会导致每个用户都有一个排行榜，存储的数据巨大，其实可以考虑只在用户查询时通过好友关系去生成\n\n那朋友圈排行榜的：微信头像、点赞数 怎么获取呢\n- 可以使用hmset hash储存对象，需要时通过zset储存的key去查询即可\n\n### 最近七天排行榜怎么弄\n前面我们说的都是每日排行榜。\n\n假设面试官要求我们提供一个最近七天、上一周、上一月、上个季度、这一年排行榜啥的，又该怎么搞呢？\n\n其实这还是在考察你对于 Redis 有序集合 API 的掌握程度。\n\n也就是这个 API：\n- zinterstore/zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max] 获取交集/并集\n    - zinterstore/zunionstore其实就是交集/并集\n    - destination 将交集/并集的结果保存到这个键中\n    - numkeys 需要做交集/并集的集合的个数\n    - key [key ...] 具体参与交集/并集的集合\n    - weights weight [weight ...] 每个参与计算的集合的权重。在做交集/并集计算时，每个集合中的 member 会把自己的 score 乘以这个权重，默认为 1。\n    - aggregate sum|min|max 对于各个集合中的相同元素是 sum(求和)、min(取最小值)还是max(取最大值)，默认为 sum。\n\n比如现在有一些数据\n```shell\nzadd sport:ranking:why:20210222 43243 why 2341 mx 8764 les 42321 skr\nzadd sport:ranking:why:20210223 57632 why 24354 mx 4231 les 43512 skr 5341 jay\nzadd sport:ranking:why:20210224 10026 why 12344 mx 54312 les 34531 skr 43512 jay\nzadd sport:ranking:why:20210225 54312 why 32451 mx 23412 les 21341 skr 56321 jay\nzadd sport:ranking:why:20210226 3212 why 63421 mx 53652 les 45621 skr 5723 jay\nzadd sport:ranking:why:20210227 5462 why 10158 mx 30169 les 48858 skr 66079 jay\nzadd sport:ranking:why:20210228 43553 why 4451 mx 7431 les 9563 skr 8232 jay\n```\n![](./2024/05/26/场景设计面试题/10.png)\n\n现在我们要求出最近 7 天的排行榜，就用下面这行命令，命令有点复杂，但是对着命令格式看，还是很清晰的：\n```shell\nzunionstore sport:ranking:why:last_seven_day 7 sport:ranking:why:20210222 sport:ranking:why:20210223 sport:ranking:why:20210224 sport:ranking:why:20210225 sport:ranking:why:20210226 sport:ranking:why:20210227 sport:ranking:why:20210228 weights 1 1 1 1 1 1 1 aggregate sum\n```\n![](./2024/05/26/场景设计面试题/11.png)\n\n上面用的是并集，如果我们的要求是对最近 7 天，每天都上传运动数据的人进行排序，就用交集来算。\n\n命令和上面的一致，只是把 zunionstore 修改为 zinterstore 即可。\n\n另外为了有对比，合并之后的队列名称也修改一下，命令如下：\n```shell\nzinterstore sport:ranking:why:last_seven_day_zinterstore 7 sport:ranking:why:20210222 sport:ranking:why:20210223 sport:ranking:why:20210224 sport:ranking:why:20210225 sport:ranking:why:20210226 sport:ranking:why:20210227 sport:ranking:why:20210228 weights 1 1 1 1 1 1 1 aggregate sum\n```\n![](./2024/05/26/场景设计面试题/12.png)\n\n知道最近 7 天的做法了，我们又有每一天数据，上一周、上一月、上个季度、这一年排行榜啥的不都是这个套路吗\n\n### 亿级用户排行榜\n\n#### 按段位分桶\n由于数据量比较大，所以需要类似于分成一个个小文件的思想去统计每一部分的数据\n\n比如游戏里的段位，统计国服前100，可以把王者、大师、砖石、铂金、黄金、白银、青铜 分为不同的桶，每个分段的人在不同的桶里(假设还是用zset存储用户的段位)\n那计算全服排名即可先计算在某个段位桶的排名x,再获取这个段位桶前的所有桶的大小y1,y2...yn，排名就计算出来了x+y1+y2....yn\n##### 计算top100\n分桶后，直接在段位最大的桶里计算top100即可\n#### 按积分分桶\n[0-5000] [5001-10000] .....[10000000-x]\n\n这种可能会出现热点问题，比如处于0-5000区间的人会非常多（可能很多人都是没有打排位）用户的落点其实并不是均匀的，那就需要通过其他预测算法去预估每个区间的人数了\n\n\n\n","source":"_posts/场景设计面试题.md","raw":"---\ntitle: 场景设计面试题\ndate: 2024-05-26 23:11:48\ntags: 场景设计\ncategories: 面试\n---\n\n\n\n\n## 有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号+姓名，而B文件存放学号+分数，要求生成文件C，存放姓名和分数。怎么实现？\n- hash(学号)%1000，A到a0....a1000,B到b0~b1000\n- 学号相同的人一定hash到相同序号的小文件\n- 加载序号相同的小文件（比如：读取a2和b2）用map储存再按姓名+分数写入C即可\n## 秒杀系统怎么设计\n### 秒杀存在的问题\n- 高并发、瞬间请求量极大\n- 黄牛、黑客恶意请求\n- 链接暴露问题\n- 数据库压力问题\n- 库存不足和超卖问题\n### 如何解决这些问题\n- 页面静态化\n    - 秒杀活动的页面，大多数内容都是固定不变的，如商品名称，商品图片等等，可以对活动页面做静态化处理，减少访问服务端的请求。秒杀用户会分布在全国各地，有的在上海，有的在深圳，地域相差很远，网速也各不相同。为了让用户最快访问到活动页面，可以使用CDN（Content Delivery Network，内容分发网络）。CDN可以让用户就近获取所需内容。\n- 按钮至灰控制\n    - 秒杀活动开始前，按钮一般需要置灰的。只有时间到了，才能变得可以点击。这是防止，秒杀用户在时间快到的前几秒，疯狂请求服务器，然后秒杀时间点还没到，服务器就自己挂了。\n- 服务单一职责\n    - 我们都知道微服务设计思想，也就是把各个功能模块拆分，功能那个类似的放一起，再用分布式的部署方式。\n    - 如用户登录相关的，就设计个用户服务，订单相关的就搞个订单服务，再到礼物相关的就搞个礼物服务等等。那么，秒杀相关的业务逻辑也可以放到一起，搞个秒杀服务，单独给它搞个秒杀数据库。\n    - 服务单一职责有个好处：如果秒杀没抗住高并发的压力，秒杀库崩了，服务挂了，也不会影响到系统的其他服务。\n- 秒杀链接加盐\n    - 链接如果明文暴露的话，会有人获取到请求Url，提前秒杀了。因此，需要给秒杀链接加盐。可以把URL动态化，如通过MD5加密算法加密随机的字符串去做url。\n- 限流\n    - 一般有两种方式限流：nginx限流和redis限流。\n    - 为了防止某个用户请求过于频繁，我们可以对同一用户限流；\n    - 为了防止黄牛模拟几个用户请求，我们可以对某个IP进行限流；\n    - 为了防止有人使用代理，每次请求都更换IP请求，我们可以对接口进行限流。\n    - 为了防止瞬时过大的流量压垮系统，还可以使用阿里的Sentinel、Hystrix组件进行限流。\n- 分布式锁\n    - 可以使用redis分布式锁解决超卖问题。\n    - 使用Redis的SET EX PX NX + 校验唯一随机值,再删除释放锁。\n    - 为了更严谨，一般也是用lua脚本代替。lua脚本如下：\n- MQ异步处理\n    - 如果瞬间流量特别大，可以使用消息队列削峰，异步处理。用户请求过来的时候，先放到消息队列，再拿出来消费。\n- 限流&降级&熔断\n    - 限流，就是限制请求，防止过大的请求压垮服务器；\n    - 降级，就是秒杀服务有问题了，就降级处理，不要影响别的服务；\n    - 熔断，服务有问题就熔断，一般熔断降级是一起出现。\n## 产品上线出问题怎么定位错误\n- 复现问题\n- top jstack\n## 大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案\n读写分离\n## 海量日志数据，提取出某日访问百度次数最多的那个IP。\n- 可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址\n- 对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址\n- 可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；\n## 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？\n### 方案1\n- 遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,...,a999）中。这样每个小文件的大约为300M。\n- 遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,...,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,...,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。\n- 求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。\n### 方案2\n如果允许有一定的误差，使用布隆过滤器\n## 一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash(x)%1000分为小文件再分别加载小文件到内存中处理即可\n\n## 如何保证接口的幂等性\n\n### 什么是幂等性\n幂等性是系统服务对外一种承诺，承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。\n\n### 什么情况下需要幂等\n\n以SQL为例：\n\n- SELECT col1 FROM tab1 WHER col2=2，无论执行多少次都不会改变状态，是天然的幂等。\n- UPDATE tab1 SET col1=1 WHERE col2=2，无论执行成功多少次状态都是一致的，因此也是幂等操作。\n- UPDATE tab1 SET col1=col1+1 WHERE col2=2，每次执行的结果都会发生变化，这种不是幂等的。\n- insert into user(userid,name) values(1,'a') 如userid为唯一主键，即重复操作上面的业务，只会插入一条用户数据，具备幂等性。\n    - 如userid不是主键，可以重复，那上面业务多次操作，数据都会新增多条，不具备幂等性。\n- delete from user where userid=1，多次操作，结果一样，具备幂等性\n\n### 如何保证幂等\n\n#### 1、token机制\n- 服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，服务器会把token保存到redis中。\n- 然后调用业务接口请求时，把token携带过去，一般放在请求头部。\n- 服务器判断token是否存在redis中，存在表示第一次请求，然后删除token,继续执行业务。\n- 如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不被重复执行。\n\n**关键点 先删除token，还是后删除token。**\n\n后删除token：如果进行业务处理成功后，删除redis中的token失败了，这样就导致了有可能会发生重复请求，因为token没有被删除。这个问题其实是数据库和缓存redis数据不一致问题，后续会写文章进行讲解。\n\n先删除token：如果系统出现问题导致业务处理出现异常，业务处理没有成功，接口调用方也没有获取到明确的结果，然后进行重试，但token已经删除掉了，服务端判断token不存在，认为是重复请求，就直接返回了，无法进行业务处理了。\n\n先删除token可以保证不会因为重复请求，业务数据出现问题。出现业务异常，可以让调用方配合处理一下，重新获取新的token，再次由业务调用方发起重试请求就ok了。\n\n**token机制缺点**\n\n业务请求每次请求，都会有额外的请求（一次获取token请求、判断token是否存在的业务）。其实真实的生产环境中，1万请求也许只会存在10个左右的请求会发生重试，为了这10个请求，我们让9990个请求都发生了额外的请求。\n\n#### 2、乐观锁机制\n\n- 这种方法适合在更新的场景中，update t_goods set count = count -1 , version = version + 1 where good_id=2 and version = 1\n- 根据version版本，也就是在操作库存前先获取当前商品的version版本号，然后操作的时候带上此version号。我们梳理下，我们第一次操作库存时，得到version为1，调用库存服务version变成了2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传如的version还是1，再执行上面的sql语句时，就不会执行；因为version已经变为2了，where条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。\n- 乐观锁主要使用于处理读多写少的问题\n\n#### 3、唯一主键\n\n这个机制是利用了数据库的主键唯一约束的特性，解决了在insert场景时幂等问题。但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。\n\n如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关\n\n#### 4、防重表\n\n使用订单号orderNo做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。\n\n#### 5、唯一ID\n\n调用接口时，生成一个唯一id，redis将数据保存到集合中（去重），存在即处理过。\n\n## 缓存和数据库不一致问题\n### 更新缓存和更新数据库\n大部分观点认为，做缓存不应该是去更新缓存，而是应该删除缓存，然后由下个请求去去缓存，发现不存在后再读取数据库，写入缓存。观点引用：《分布式之数据库和缓存双写一致性方案解析》孤独烟\n\n原因一：线程安全角度同时有请求A和请求B进行更新操作，那么会出现（1）线程A更新了数据库（2）线程B更新了数据库（3）线程B更新了缓存（4）线程A更新了缓存这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。\n\n原因二：业务场景角度有如下两点：\n1. 如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。\n2. 如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。\n\n### 删缓存和更新数据库\n#### 先删缓存，再更新数据库\n该方案会导致请求数据不一致同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:\n1. 请求A进行写操作，删除缓存\n2. 请求B查询发现缓存不存在\n3. 请求B去数据库查询得到旧值\n4. 请求B将旧值写入缓存\n5. 请求A将新值写入数据库上述情况就会导致不一致的情形出现。\n   而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。\n#### 先更新数据库，再删缓存\n这种情况不存在并发问题么？不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生\n1. 缓存刚好失效\n2. 请求A查询数据库，得一个旧值\n3. 请求B将新值写入数据库\n4. 请求B删除缓存\n5. 请求A将查到的旧值写入缓存ok，如果发生上述情况，确实是会发生脏数据。 然而，发生这种情况的概率又有多少呢？发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。\n\n先更新数据库，再删缓存依然会有问题，不过，问题出现的可能性会因为上面说的原因，变得比较低！(补充说明：我用了“先更新数据库，再删缓存”且不设过期时间策略，会不会有问题呢？由于先缓存和更新数据库不是原子的，如果更新了数据库，程序歇逼，就没删缓存，由于没有过期策略，就永远脏数据了。)所以，如果你想实现基础的缓存数据库双写一致的逻辑，那么在大多数情况下，在不想做过多设计，增加太大工作量的情况下，请先更新数据库，再删缓存!\n### 数据库和缓存数据强一致怎么办\n没有办法做到绝对的一致性，这是由CAP理论决定的，缓存系统适用的场景就是非强一致性的场景，所以它属于CAP中的AP。所以，我们得委曲求全，可以去做到BASE理论中说的最终一致性。\n\n大佬们给出了到达最终一致性的解决思路，主要是针对上面两种双写策略（先删缓存，再更新数据库/先更新数据库，再删缓存）导致的脏数据问题，进行相应的处理，来保证最终一致性。\n\n#### 缓存延时双删\n步骤\n1. 先删除缓存\n2. 再写数据库\n3. 休眠500毫秒（根据具体的业务时间来定）\n4. 再次删除缓存。\n\n#### 那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？\n\n针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。\n\n\n#### 如果你用了mysql的读写分离架构怎么办？\n\nok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。\n1. 请求A进行写操作，删除缓存\n2. 请求A将数据写入数据库了，\n3. 请求B查询缓存发现，缓存没有值\n4. 请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值\n5. 请求B将旧值写入缓存\n6. 数据库完成主从同步，从库变为新值上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。\n\n#### 采用这种同步淘汰策略，吞吐量降低怎么办？\n\nok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。\n\n#### 删缓存失败了怎么办：重试机制\n看似问题都已经解决了，但其实，还有一个问题没有考虑到，那就是删除缓存的操作，失败了怎么办？比如延时双删的时候，第二次缓存删除失败了，那不还是没有清除脏数据吗？解决方案就是再加上一个重试机制，保证删除缓存成功\n\n流程如下所示\n1. 更新数据库数据；\n2. 缓存因为种种问题删除失败\n3. 将需要删除的key发送至消息队列\n4. 自己消费消息，获得需要删除的key\n5. 继续重试删除操作，直到成功然而，\n\n该方案有一个缺点，对业务线代码造成大量的侵入。\n\n于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作\n\n#### binlog\n流程如下所示\n1. 更新数据库数据\n2. 数据库会将操作信息写入binlog日志当中\n3. 订阅程序提取出所需要的数据以及key\n4. 另起一段非业务代码，获得该信息\n5. 尝试删除缓存操作，发现删除失败\n6. 将这些信息发送至消息队列\n7. 重新从消息队列中获得该数据，重试操作。\n\n## 什么是SPI\nSPI 全称为 (Service Provider Interface) ，是JDK内置的一种服务提供发现机制\n\n### SPI 实践\n接下来我们来如何来利用 SPI 实现刚才提到的可拔插 IOC 容器。\n\n既然刚才都提到了 SPI 的本质就是面向接口编程，所以自然我们首先需要定义一个接口：\n\n![SPI图](./2024/05/26/场景设计面试题/1.png)\n\n其中包含了一些 Bean 容器所必须的操作：注册、获取、释放 bean。\n\n为了让其他人也能实现自己的 IOC 容器，所以我们将这个接口单独放到一个 Module 中，可供他人引入实现。\n\n![](./2024/05/26/场景设计面试题/2.png)\n\n所以当我要实现一个单例的 IOC 容器时，我只需要新建一个 Module 然后引入刚才的模块并实现 CicadaBeanFactory 接口即可。\n\n当然其中最重要的则是需要在 resources 目录下新建一个 META-INF/services/top.crossoverjie.cicada.base.bean.CicadaBeanFactory 文件，文件名必须得是我们之前定义接口的全限定名（SPI 规范）。\n![](./2024/05/26/场景设计面试题/3.png)\n\n其中的内容便是我们自己实现类的全限定名：\n```shell\ntop.crossoverjie.cicada.bean.ioc.CicadaIoc\n```\n可以想象最终会通过这里的全限定名来反射创建对象。\n\n只不过这个过程 Java 已经提供 API 屏蔽掉了：\n```java\npublic static CicadaBeanFactory getCicadaBeanFactory() {\n    ServiceLoader<CicadaBeanFactory> cicadaBeanFactories = ServiceLoader.load(CicadaBeanFactory.class);\n    if (cicadaBeanFactories.iterator().hasNext()){\n        return cicadaBeanFactories.iterator().next() ;\n    }\n    return new CicadaDefaultBean();\n}\n```\n当 classpath 中存在我们刚才的实现类（引入实现类的 jar 包），便可以通过 java.util.ServiceLoader 工具类来找到所有的实现类（可以有多个实现类同时存在，只不过通常我们只需要一个）。\n\n一些都准备好之后，使用自然就非常简单了。\n```xml\n<dependency>\n    <groupId>top.crossoverjie.opensource</groupId>\n    <artifactId>cicada-ioc</artifactId>\n    <version>2.0.4</version>\n</dependency>\n```\n我们只需要引入这个依赖便能使用它的实现，当我们想换一种实现方式时只需要更换一个依赖即可。\n\n这样就做到了不修改一行代码灵活的可拔插选择 IOC 容器了。\n\nSPI 的一些其他应用\n\nMySQL 的驱动包也是利用 SPI 来实现自己的连接逻辑。\n\n![](./2024/05/26/场景设计面试题/4.png)\n\n总结来说：\n\n- 提供一个接口\n- 在resource下新建META-INF/services目录，在目录下新建接口的全限定名文件\n- 服务方实现接口\n- 调用ServiceLoad.load()\n\n## 什么是RPC？\nRPC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务\n\n1. 首先客户端需要告诉服务器，需要调用的函数，这里函数和进程ID存在一个映射，客户端远程调用时，需要查一下函数，找到对应的ID，然后执行函数的代码。\n2. 客户端需要把本地参数传给远程函数，本地调用的过程中，直接压栈即可，但是在远程调用过程中不再同一个内存里，无法直接传递函数的参数，因此需要客户端把参数转换成字节流，传给服务端，然后服务端将字节流转换成自身能读取的格式，是一个序列化和反序列化的过程。\n3. 数据准备好了之后，如何进行传输？网络传输层需要把调用的ID和序列化后的参数传给服务端，然后把计算好的结果序列化传给客户端，因此TCP层即可完成上述过程，gRPC中采用的是HTTP2协议。\n\n总结一下：\n```text\n// Client端 \n//    Student student = Call(ServerAddr, addAge, student)\n1. 将这个调用映射为Call ID。\n2. 将Call ID，student（params）序列化，以二进制形式打包\n3. 把2中得到的数据包发送给ServerAddr，这需要使用网络传输层\n4. 等待服务器返回结果\n5. 如果服务器调用成功，那么就将结果反序列化，并赋给student，年龄更新\n\n// Server端\n1. 在本地维护一个Call ID到函数指针的映射call_id_map，可以用Map<String, Method> callIdMap\n2. 等待客户端请求\n3. 得到一个请求后，将其数据包反序列化，得到Call ID\n4. 通过在callIdMap中查找，得到相应的函数指针\n5. 将student（params）反序列化后，在本地调用addAge()函数，得到结果\n6. 将student结果序列化后通过网络返回给Client\n```\n\n- 在微服务的设计中，一个服务A如果访问另一个Module下的服务B，可以采用HTTP REST传输数据，并在两个服务之间进行序列化和反序列化操作，服务B把执行结果返回过来。\n- 由于HTTP在应用层中完成，整个通信的代价较高，远程过程调用中直接基于TCP进行远程调用，数据传输在传输层TCP层完成，更适合对效率要求比较高的场景，RPC主要依赖于客户端和服务端之间建立Socket链接进行，底层实现比REST更复杂。\n\n### RPC demo\n客户端\n```java\npublic class RPCClient<T> {\n    public static <T> T getRemoteProxyObj(final Class<?> serviceInterface, final InetSocketAddress addr) {\n        // 1.将本地的接口调用转换成JDK的动态代理，在动态代理中实现接口的远程调用\n        return (T) Proxy.newProxyInstance(serviceInterface.getClassLoader(), new Class<?>[]{serviceInterface},\n                new InvocationHandler() {\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        Socket socket = null;\n                        ObjectOutputStream output = null;\n                        ObjectInputStream input = null;\n                        try{\n                            // 2.创建Socket客户端，根据指定地址连接远程服务提供者\n                            socket = new Socket();\n                            socket.connect(addr);\n\n                            // 3.将远程服务调用所需的接口类、方法名、参数列表等编码后发送给服务提供者\n                            output = new ObjectOutputStream(socket.getOutputStream());\n                            output.writeUTF(serviceInterface.getName());\n                            output.writeUTF(method.getName());\n                            output.writeObject(method.getParameterTypes());\n                            output.writeObject(args);\n\n                            // 4.同步阻塞等待服务器返回应答，获取应答后返回\n                            input = new ObjectInputStream(socket.getInputStream());\n                            return input.readObject();\n                        }finally {\n                            if (socket != null){\n                                socket.close();\n                            }\n                            if (output != null){\n                                output.close();\n                            }\n                            if (input != null){\n                                input.close();\n                            }\n                        }\n                    }\n                });\n    }\n}\n```\n服务端\n```java\npublic class ServiceCenter implements Server {\n\n    private static ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());\n\n    private static final HashMap<String, Class> serviceRegistry = new HashMap<String, Class>();\n\n    private static boolean isRunning = false;\n\n    private static int port;\n\n\n    public ServiceCenter(int port){\n        ServiceCenter.port = port;\n    }\n\n\n    @Override\n    public void start() throws IOException {\n        ServerSocket server = new ServerSocket();\n        server.bind(new InetSocketAddress(port));\n        System.out.println(\"Server Start .....\");\n        try{\n            while(true){\n                executor.execute(new ServiceTask(server.accept()));\n            }\n        }finally {\n            server.close();\n        }\n    }\n\n    @Override\n    public void register(Class serviceInterface, Class impl) {\n        serviceRegistry.put(serviceInterface.getName(), impl);\n    }\n\n    @Override\n    public boolean isRunning() {\n        return isRunning;\n    }\n\n    @Override\n    public int getPort() {\n        return port;\n    }\n\n    @Override\n    public void stop() {\n        isRunning = false;\n        executor.shutdown();\n    }\n   private static class ServiceTask implements Runnable {\n        Socket client = null;\n\n        public ServiceTask(Socket client) {\n            this.client = client;\n        }\n\n        @Override\n        public void run() {\n            ObjectInputStream input = null;\n            ObjectOutputStream output = null;\n            try{\n                input = new ObjectInputStream(client.getInputStream());\n                String serviceName = input.readUTF();\n                String methodName = input.readUTF();\n                Class<?>[] parameterTypes = (Class<?>[]) input.readObject();\n                Object[] arguments = (Object[]) input.readObject();\n                Class serviceClass = serviceRegistry.get(serviceName);\n                if(serviceClass == null){\n                    throw new ClassNotFoundException(serviceName + \"not found!\");\n                }\n                Method method = serviceClass.getMethod(methodName, parameterTypes);\n                Object result = method.invoke(serviceClass.newInstance(), arguments);\n\n                output = new ObjectOutputStream(client.getOutputStream());\n                output.writeObject(result);\n            }catch (Exception e){\n                e.printStackTrace();\n            }finally {\n                if(output!=null){\n                    try{\n                        output.close();\n                    }catch (IOException e){\n                        e.printStackTrace();\n                    }\n                }\n                if (input != null) {\n                    try {\n                        input.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                if (client != null) {\n                    try {\n                        client.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}\n\npublic class ServiceProducerImpl implements ServiceProducer{\n    @Override\n    public String sendData(String data) {\n        return \"I am service producer!!!, the data is \"+ data;\n    }\n}\n\npublic class RPCTest {\n    public static void main(String[] args) throws IOException {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Server serviceServer = new ServiceCenter(8088);\n                    serviceServer.register(ServiceProducer.class, ServiceProducerImpl.class);\n                    serviceServer.start();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n        ServiceProducer service = RPCClient.getRemoteProxyObj(ServiceProducer.class, new InetSocketAddress(\"localhost\", 8088));\n        System.out.println(service.sendData(\"test\"));\n    }\n}\n```\n\n## gRPC\n### gRPC与REST\n- REST通常以业务为导向，将业务对象上执行的操作映射到HTTP动词，格式非常简单，可以使用浏览器进行扩展和传输，通过JSON数据完成客户端和服务端之间的消息通信，直接支持请求/响应方式的通信。不需要中间的代理，简化了系统的架构，不同系统之间只需要对JSON进行解析和序列化即可完成数据的传递。\n- 但是REST也存在一些弊端，比如只支持请求/响应这种单一的通信方式，对象和字符串之间的序列化操作也会影响消息传递速度，客户端需要通过服务发现的方式，知道服务实例的位置，在单个请求获取多个资源时存在着挑战，而且有时候很难将所有的动作都映射到HTTP动词。\n- 正是因为REST面临一些问题，因此可以采用gRPC作为一种替代方案，gRPC 是一种基于二进制流的消息协议，可以采用基于Protocol Buffer的IDL定义grpc API,这是Google公司用于序列化结构化数据提供的一套语言中立的序列化机制，客户端和服务端使用HTTP/2以Protocol Buffer格式交换二进制消息。\n- gRPC的优势是，设计复杂更新操作的API非常简单，具有高效紧凑的进程通信机制，在交换大量消息时效率高，远程过程调用和消息传递时可以采用双向的流式消息方式，同时客户端和服务端支持多种语言编写，互操作性强；不过gRPC的缺点是不方便与JavaScript集成，某些防火墙不支持该协议。\n- 注册中心：当项目中有很多服务时，可以把所有的服务在启动的时候注册到一个注册中心里面，用于维护服务和服务器之间的列表，当注册中心接收到客户端请求时，去找到该服务是否远程可以调用，如果可以调用需要提供服务地址返回给客户端，客户端根据返回的地址和端口，去调用远程服务端的方法，执行完成之后将结果返回给客户端。这样在服务端加新功能的时候，客户端不需要直接感知服务端的方法，服务端将更新之后的结果在注册中心注册即可，而且当修改了服务端某些方法的时候，或者服务降级服务多机部署想实现负载均衡的时候，我们只需要更新注册中心的服务群即可。\n  ![](./2024/05/26/场景设计面试题/5.png)\n\n### demo\n这里使用SpringBoot+gRPC的形式实现RPC调用过程 项目结构分为三部分：client、grpc、server\n#### grpc\n![](./2024/05/26/场景设计面试题/6.png)\n```xml\n<dependency>\n      <groupId>io.grpc</groupId>\n      <artifactId>grpc-all</artifactId>\n       <version>1.12.0</version>\n </dependency>\n```\n```xml\n<build>\n        <extensions>\n            <extension>\n                <groupId>kr.motd.maven</groupId>\n                <artifactId>os-maven-plugin</artifactId>\n                <version>1.4.1.Final</version>\n            </extension>\n        </extensions>\n        <plugins>\n            <plugin>\n                <groupId>org.xolstice.maven.plugins</groupId>\n                <artifactId>protobuf-maven-plugin</artifactId>\n                <version>0.5.0</version>\n                <configuration>\n                    <pluginId>grpc-java</pluginId>\n                    <protocArtifact>com.google.protobuf:protoc:3.0.2:exe:${os.detected.classifier}</protocArtifact>\n                    <pluginArtifact>io.grpc:protoc-gen-grpc-java:1.2.0:exe:${os.detected.classifier}</pluginArtifact>\n                </configuration>\n                <executions>\n                    <execution>\n                        <goals>\n                            <goal>compile</goal>\n                            <goal>compile-custom</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n```\n创建.proto文件\n```protobuf\nsyntax = \"proto3\";   // 语法版本\n\n// stub选项\noption java_package = \"com.shgx.grpc.api\";\noption java_outer_classname = \"RPCDateServiceApi\";\noption java_multiple_files = true;\n\n// 定义包名\npackage com.shgx.grpc.api;\n\n// 服务接口定义，服务端和客户端都要遵守该接口进行通信\nservice RPCDateService {\n    rpc getDate (RPCDateRequest) returns (RPCDateResponse) {}\n}\n\n// 定义消息（请求）\nmessage RPCDateRequest {\n    string userName = 1;\n}\n\n// 定义消息（响应）\nmessage RPCDateResponse {\n    string serverDate = 1;\n}\n\n```\nmvn complie\n\n生成代码：\n![](./2024/05/26/场景设计面试题/7.png)\n\n#### client\n![](./2024/05/26/场景设计面试题/8.png)\n\n根据gRPC中的项目配置在client和server两个Module的pom.xml添加依赖\n```xml\n        <dependency>\n            <groupId>com.shgx</groupId>\n            <artifactId>grpc</artifactId>\n            <version>0.0.1-SNAPSHOT</version>\n            <scope>compile</scope>\n        </dependency>\n```\n编写GRPCClient\n```java\npublic class GRPCClient {\n    private static final String host = \"localhost\";\n    private static final int serverPort = 9999;\n\n    public static void main( String[] args ) throws Exception {\n        ManagedChannel managedChannel = ManagedChannelBuilder.forAddress( host, serverPort ).usePlaintext().build();\n        try {\n            RPCDateServiceGrpc.RPCDateServiceBlockingStub rpcDateService = RPCDateServiceGrpc.newBlockingStub( managedChannel );\n            RPCDateRequest rpcDateRequest = RPCDateRequest\n                    .newBuilder()\n                    .setUserName(\"shgx\")\n                    .build();\n            RPCDateResponse rpcDateResponse = rpcDateService.getDate( rpcDateRequest );\n            System.out.println( rpcDateResponse.getServerDate() );\n        } finally {\n            managedChannel.shutdown();\n        }\n    }\n}\n\n```\n#### server\n![](./2024/05/26/场景设计面试题/9.png)\n\n按照2.2.3 client的方式添加依赖\n\n创建RPCDateServiceImpl\n```java\npublic class RPCDateServiceImpl extends RPCDateServiceGrpc.RPCDateServiceImplBase{\n    @Override\n    public void getDate(RPCDateRequest request, StreamObserver<RPCDateResponse> responseObserver) {\n        RPCDateResponse rpcDateResponse = null;\n        Date now=new Date();\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"今天是\"+\"yyyy年MM月dd日 E kk点mm分\");\n        String nowTime = simpleDateFormat.format( now );\n        try {\n            rpcDateResponse = RPCDateResponse\n                    .newBuilder()\n                    .setServerDate( \"Welcome \" + request.getUserName()  + \", \" + nowTime )\n                    .build();\n        } catch (Exception e) {\n            responseObserver.onError(e);\n        } finally {\n            responseObserver.onNext( rpcDateResponse );\n        }\n        responseObserver.onCompleted();\n    }\n}\n```\n创建GRPCServer\n```java\npublic class GRPCServer {\n    private static final int port = 9999;\n    public static void main( String[] args ) throws Exception {\n        Server server = ServerBuilder.\n                forPort(port)\n                .addService( new RPCDateServiceImpl() )\n                .build().start();\n        System.out.println( \"grpc服务端启动成功, 端口=\" + port );\n        server.awaitTermination();\n    }\n}\n```\n## 一个优秀的RPC框架需要考虑的问题\n1. `微服务化`应用都基于微服务化，实现资源调用离不开远程调用\n2. `多实例问题` 一个服务可能有多个实例，你在调用时，要如何获取这些实例的地址呢？--- 这时候就需要一个服务注册中心，从服务注册中心获取服务的实例列表，再从中选择一个进行调用。\n3. `负载均衡` 选哪个调用好呢？这时候就需要负载均衡了，于是又得考虑如何实现复杂均衡\n4. `缓存` 总不能每次调用时都去注册中心查询实例列表吧，这样效率多低呀，于是又有了缓存，有了缓存，就要考虑缓存的更新问题\n5. `异步调用` 客户端总不能每次调用完都干等着服务端返回数据吧,于是就要支持异步调用;\n    - Future实现\n6. `版本控制` 服务端的接口修改了，老的接口还有人在用，怎么办？总不能让他们都改了吧？这就需要版本控制了；\n7. `线程池` 服务端总不能每次接到请求都马上启动一个线程去处理吧？于是就需要线程池；\n8. `未处理完的请求` 服务端关闭时，还没处理完的请求怎么办？是直接结束呢，还是等全部请求处理完再关闭呢？\n\n## 什么是DDD？\n### MVC\n要说DDD，不得不先看看MVC，我相信基本上99%的java开发读者，不管你是计科专业出身还是跨专业，初学spring或者springboot的时候，接触到的代码分层都是MVC\n这说明了MVC有它自身独有的优势：\n- 开发人员可以只关注整个结构中的其中某一层；\n- 可以很容易的用新的实现来替换原有层次的实现；\n- 可以降低层与层之间的依赖；\n- 有利于标准化；\n- 利于各层逻辑的复用。\n\n但是真实情况是这样吗？随着你系统功能迭代，业务逻辑越来越复杂之后。MVC三层中，V层作为数据载体，C层作为逻辑路由都是很薄的一层，大量的代码都堆积在了M层（模型层）。一个service的类，动辄几百上千行，大的甚至几万行，逻辑嵌套复杂，主业务逻辑不清晰。service做的稍微轻量化一点的，代码就像是胶水，把数据库执行逻辑与控制返回给前端的逻辑胶在一起，主次不清晰。\n一看你的工程，类啊，代码量啊都不少，你甚至不知道如何入手去修改“屎山”一样的代码。\n\n### 那么DDD为什么可以去解决以上的问题呢？\n\nDDD核心思想是什么呢？解耦！让业务不是像炒大锅饭一样混在一起，而是一道道工序复杂的美食，都有他们自己独立的做法。\n\nDDD的价值观里面，任何业务都是某个业务领域模型的职责体现。A领域只会去做A领域的事情，A领域想去修改B领域，需要找中介（防腐层）去对B领域完成操作。我想完成一个很长的业务逻辑动作，在划分好业务边界之后，交给业务服务的编排者（应用服务）去组织业务模型（聚合）完成逻辑。\n\n这样，每个服务（领域）只会做自己业务边界内的事情，最小细粒度的去定义需求的实现。原先空空的贫血模型摇身一变变成了充血模型。原理冗长的service里面类似到处set，get值这种与业务逻辑无关的数据载体包装代码，都会被去除，进到应用服务层，你的代码就是你的业务逻辑。逻辑清晰，可维护性高！\n\n### 什么样的系统适配DDD\n中小规模的系统，本身业务体量小，功能单一，选择mvc架构无疑是最好的。 项目化交付的系统，研发周期短，一天到晚按照甲方的需求定制功能。\n\n中大规模系统，产品化模式，业务可持续迭代，可预见的业务逻辑复杂性的系统。\n\n### DDD的代码怎么做\n\n// TODO\n\n## Java实现生产者消费者\n### wait()和notify()方法的实现\n```java\npublic class Test1 {\n    private static Integer count = 0;\n    private static final Integer FULL = 10;\n    private static String LOCK = \"lock\";\n    \n    public static void main(String[] args) {\n        Test1 test1 = new Test1();\n        new Thread(test1.new Producer()).start();\n        new Thread(test1.new Consumer()).start();\n        new Thread(test1.new Producer()).start();\n        new Thread(test1.new Consumer()).start();\n        new Thread(test1.new Producer()).start();\n        new Thread(test1.new Consumer()).start();\n        new Thread(test1.new Producer()).start();\n        new Thread(test1.new Consumer()).start();\n    }\n    class Producer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                synchronized (LOCK) {\n                    while (count == FULL) {\n                        try {\n                            LOCK.wait();\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    count++;\n                    System.out.println(Thread.currentThread().getName() + \"生产者生产，目前总共有\" + count);\n                    LOCK.notifyAll();\n                }\n            }\n        }\n    }\n    class Consumer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                synchronized (LOCK) {\n                    while (count == 0) {\n                        try {\n                            LOCK.wait();\n                        } catch (Exception e) {\n                        }\n                    }\n                    count--;\n                    System.out.println(Thread.currentThread().getName() + \"消费者消费，目前总共有\" + count);\n                    LOCK.notifyAll();\n                }\n            }\n        }\n    }\n}\n```\n### 可重入锁ReentrantLock的实现\n```java\npublic class Test2 {\n    private static Integer count = 0;\n    private static final Integer FULL = 10;\n    //创建一个锁对象\n    private Lock lock = new ReentrantLock();\n    //创建两个条件变量，一个为缓冲区非满，一个为缓冲区非空\n    private final Condition notFull = lock.newCondition();\n    private final Condition notEmpty = lock.newCondition();\n    public static void main(String[] args) {\n        Test2 test2 = new Test2();\n        new Thread(test2.new Producer()).start();\n        new Thread(test2.new Consumer()).start();\n        new Thread(test2.new Producer()).start();\n        new Thread(test2.new Consumer()).start();\n        new Thread(test2.new Producer()).start();\n        new Thread(test2.new Consumer()).start();\n        new Thread(test2.new Producer()).start();\n        new Thread(test2.new Consumer()).start();\n    }\n    class Producer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                //获取锁\n                lock.lock();\n                try {\n                    while (count == FULL) {\n                        try {\n                            notFull.await();\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    count++;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"生产者生产，目前总共有\" + count);\n                    //唤醒消费者\n                    notEmpty.signal();\n                } finally {\n                    //释放锁\n                    lock.unlock();\n                }\n            }\n        }\n    }\n    class Consumer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e1) {\n                    e1.printStackTrace();\n                }\n                lock.lock();\n                try {\n                    while (count == 0) {\n                        try {\n                            notEmpty.await();\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    count--;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"消费者消费，目前总共有\" + count);\n                    notFull.signal();\n                } finally {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n}\n```\n#### 阻塞队列BlockingQueue的实现\n```java\npublic class Test3 {\n    private static Integer count = 0;\n    //创建一个阻塞队列\n    final BlockingQueue blockingQueue = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args) {\n        Test3 test3 = new Test3();\n        new Thread(test3.new Producer()).start();\n        new Thread(test3.new Consumer()).start();\n        new Thread(test3.new Producer()).start();\n        new Thread(test3.new Consumer()).start();\n        new Thread(test3.new Producer()).start();\n        new Thread(test3.new Consumer()).start();\n        new Thread(test3.new Producer()).start();\n        new Thread(test3.new Consumer()).start();\n    }\n    class Producer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                try {\n                    blockingQueue.put(1);\n                    count++;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"生产者生产，目前总共有\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n    class Consumer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e1) {\n                    e1.printStackTrace();\n                }\n                try {\n                    blockingQueue.take();\n                    count--;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"消费者消费，目前总共有\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n#### 信号量Semaphore的实现\n```java\npublic class Test4 {\n    private static Integer count = 0;\n    //创建三个信号量\n    final Semaphore notFull = new Semaphore(10);\n    final Semaphore notEmpty = new Semaphore(0);\n    final Semaphore mutex = new Semaphore(1);\n    public static void main(String[] args) {\n        Test4 test4 = new Test4();\n        new Thread(test4.new Producer()).start();\n        new Thread(test4.new Consumer()).start();\n        new Thread(test4.new Producer()).start();\n        new Thread(test4.new Consumer()).start();\n        new Thread(test4.new Producer()).start();\n        new Thread(test4.new Consumer()).start();\n        new Thread(test4.new Producer()).start();\n        new Thread(test4.new Consumer()).start();\n    }\n    class Producer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                try {\n                    notFull.acquire();\n                    mutex.acquire();\n                    count++;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"生产者生产，目前总共有\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    mutex.release();\n                    notEmpty.release();\n                }\n            }\n        }\n    }\n    class Consumer implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e1) {\n                    e1.printStackTrace();\n                }\n                try {\n                    notEmpty.acquire();\n                    mutex.acquire();\n                    count--;\n                    System.out.println(Thread.currentThread().getName()\n                            + \"消费者消费，目前总共有\" + count);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    mutex.release();\n                    notFull.release();\n                }\n            }\n        }\n    }\n}\n\n```\n## Java实现BlockQueue\n```java\npublic class BlockingQueue<E> {\n\n    /**\n     * 有界队列内部固定长度，因此可以用数组实现\n     */\n    private Object[] elements;\n\n    /**\n     * 队列的头和尾下标\n     */\n    private int head = 0, tail = 0;\n\n    /**\n     * 队列目前的长度\n     */\n    private int size;\n    private ReentrantLock lock = new ReentrantLock();\n    private Condition notEmpty = lock.newCondition();\n    private Condition notFull = lock.newCondition();\n\n    public BlockingQueue(int capacity) {\n        this.elements = new Object[capacity];\n    }\n\n    public void put(E e) {\n        lock.lock();\n        try {\n            while (size == elements.length)\n                notFull.await();\n            elements[tail] = e;\n            if (++tail == elements.length) {\n                tail = 0;\n            }\n            size++;\n            notEmpty.signal();\n\n        } catch (InterruptedException ex) {\n            ex.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public E take() {\n        lock.lock();\n        E e = null;\n        try {\n            while (size == 0) {\n                notEmpty.await();\n            }\n            e = (E) elements[head];\n            elements[head] = null;\n            if (++head == elements.length)\n                head = 0;\n            size--;\n            notFull.signal();\n\n        } catch (InterruptedException ex) {\n            ex.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n        return e;\n    }\n\n    public int size() {\n        lock.lock();\n        try {\n            return size;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n## 解决哈希冲突的方法\n### 开放定址法\n从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。\n\n在开放定址法中解决冲突的方法有：线行探查法、平方探查法、双散列函数探查法。\n\n开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。\n\n#### 线行探查法\n线行探查法是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。\n\n可以参考csdn上flash对该方法的演示：\nhttp://student.zjzk.cn/course_ware/data_structure/web/flash/cz/kfdzh.swf\n\n#### 平方探查法\n平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²…直到找到空闲单元。\n\n在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。\n\n#### 双散列函数探查法\n这种方法使用两个散列函数hl和h2。其中hl和前面的h一样，以关键字为自变量，产生一个0至m—l之间的数作为散列地址；h2也以关键字为自变量，产生一个l至m—1之间的、并和m互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)，探查序列的步长值是固定值l；对于平方探查法，探查序列的步长值是探查次数i的两倍减l；对于双散列函数探查法，其探查序列的步长值是同一关键字的另一散列函数的值。\n\n### 链地址法（拉链法）\n链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。\n\n如下一组数字,(32、40、36、53、16、46、71、27、42、24、49、64)哈希表长度为13，哈希函数为H(key)=key%13,则链表法结果如下：\n```java\n0       \n1  -> 40 -> 27 -> 53 \n2\n3  -> 16 -> 42\n4\n5\n6  -> 32 -> 71\n7  -> 46\n8\n9\n10 -> 36 -> 49\n11 -> 24\n12 -> 64\n```\n注：在java中，链接地址法也是HashMap解决哈希冲突的方法之一，jdk1.7完全采用单链表来存储同义词，jdk1.8则采用了一种混合模式，对于链表长度大于8的，会转换为红黑树存储。\n\n### 再哈希法\n就是同时构造多个不同的哈希函数：\n\nHi = RHi(key)   i= 1,2,3 … k;\n\n当H1 = RH1(key)  发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。\n\n### 建立公共溢出区\n将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。\n\n## 排行榜设计\n### 基于数据库\n基于MySQL，order by\n\n缺点：\n- 速度慢\n### 基于Redis\n主要考察sort set 也就是zset\n\nzadd添加数据后，zrevrange获取排序后的排名\n\n### 类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样\nkey的设计比较重要，比如aa用户和bb用户\n```shell\nzadd step:aa 1000 小明\nzadd step:bb 1000 小明\n```\n\n同理时间也可以通过key的设计解决\n```shell\nzadd step:aa:20210929 1000 小明\nzadd step:aa:20210929 1000 小明\n```\n\n但是上述设计会导致每个用户都有一个排行榜，存储的数据巨大，其实可以考虑只在用户查询时通过好友关系去生成\n\n那朋友圈排行榜的：微信头像、点赞数 怎么获取呢\n- 可以使用hmset hash储存对象，需要时通过zset储存的key去查询即可\n\n### 最近七天排行榜怎么弄\n前面我们说的都是每日排行榜。\n\n假设面试官要求我们提供一个最近七天、上一周、上一月、上个季度、这一年排行榜啥的，又该怎么搞呢？\n\n其实这还是在考察你对于 Redis 有序集合 API 的掌握程度。\n\n也就是这个 API：\n- zinterstore/zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max] 获取交集/并集\n    - zinterstore/zunionstore其实就是交集/并集\n    - destination 将交集/并集的结果保存到这个键中\n    - numkeys 需要做交集/并集的集合的个数\n    - key [key ...] 具体参与交集/并集的集合\n    - weights weight [weight ...] 每个参与计算的集合的权重。在做交集/并集计算时，每个集合中的 member 会把自己的 score 乘以这个权重，默认为 1。\n    - aggregate sum|min|max 对于各个集合中的相同元素是 sum(求和)、min(取最小值)还是max(取最大值)，默认为 sum。\n\n比如现在有一些数据\n```shell\nzadd sport:ranking:why:20210222 43243 why 2341 mx 8764 les 42321 skr\nzadd sport:ranking:why:20210223 57632 why 24354 mx 4231 les 43512 skr 5341 jay\nzadd sport:ranking:why:20210224 10026 why 12344 mx 54312 les 34531 skr 43512 jay\nzadd sport:ranking:why:20210225 54312 why 32451 mx 23412 les 21341 skr 56321 jay\nzadd sport:ranking:why:20210226 3212 why 63421 mx 53652 les 45621 skr 5723 jay\nzadd sport:ranking:why:20210227 5462 why 10158 mx 30169 les 48858 skr 66079 jay\nzadd sport:ranking:why:20210228 43553 why 4451 mx 7431 les 9563 skr 8232 jay\n```\n![](./2024/05/26/场景设计面试题/10.png)\n\n现在我们要求出最近 7 天的排行榜，就用下面这行命令，命令有点复杂，但是对着命令格式看，还是很清晰的：\n```shell\nzunionstore sport:ranking:why:last_seven_day 7 sport:ranking:why:20210222 sport:ranking:why:20210223 sport:ranking:why:20210224 sport:ranking:why:20210225 sport:ranking:why:20210226 sport:ranking:why:20210227 sport:ranking:why:20210228 weights 1 1 1 1 1 1 1 aggregate sum\n```\n![](./2024/05/26/场景设计面试题/11.png)\n\n上面用的是并集，如果我们的要求是对最近 7 天，每天都上传运动数据的人进行排序，就用交集来算。\n\n命令和上面的一致，只是把 zunionstore 修改为 zinterstore 即可。\n\n另外为了有对比，合并之后的队列名称也修改一下，命令如下：\n```shell\nzinterstore sport:ranking:why:last_seven_day_zinterstore 7 sport:ranking:why:20210222 sport:ranking:why:20210223 sport:ranking:why:20210224 sport:ranking:why:20210225 sport:ranking:why:20210226 sport:ranking:why:20210227 sport:ranking:why:20210228 weights 1 1 1 1 1 1 1 aggregate sum\n```\n![](./2024/05/26/场景设计面试题/12.png)\n\n知道最近 7 天的做法了，我们又有每一天数据，上一周、上一月、上个季度、这一年排行榜啥的不都是这个套路吗\n\n### 亿级用户排行榜\n\n#### 按段位分桶\n由于数据量比较大，所以需要类似于分成一个个小文件的思想去统计每一部分的数据\n\n比如游戏里的段位，统计国服前100，可以把王者、大师、砖石、铂金、黄金、白银、青铜 分为不同的桶，每个分段的人在不同的桶里(假设还是用zset存储用户的段位)\n那计算全服排名即可先计算在某个段位桶的排名x,再获取这个段位桶前的所有桶的大小y1,y2...yn，排名就计算出来了x+y1+y2....yn\n##### 计算top100\n分桶后，直接在段位最大的桶里计算top100即可\n#### 按积分分桶\n[0-5000] [5001-10000] .....[10000000-x]\n\n这种可能会出现热点问题，比如处于0-5000区间的人会非常多（可能很多人都是没有打排位）用户的落点其实并不是均匀的，那就需要通过其他预测算法去预估每个区间的人数了\n\n\n\n","slug":"场景设计面试题","published":1,"updated":"2024-05-26T15:19:59.123Z","comments":1,"layout":"post","photos":[],"_id":"clwxc4r9y000ib4uh2hod2ysy","content":"<h2 id=\"有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号-姓名，而B文件存放学号-分数，要求生成文件C，存放姓名和分数。怎么实现？\"><a href=\"#有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号-姓名，而B文件存放学号-分数，要求生成文件C，存放姓名和分数。怎么实现？\" class=\"headerlink\" title=\"有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号+姓名，而B文件存放学号+分数，要求生成文件C，存放姓名和分数。怎么实现？\"></a>有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号+姓名，而B文件存放学号+分数，要求生成文件C，存放姓名和分数。怎么实现？</h2><ul>\n<li>hash(学号)%1000，A到a0….a1000,B到b0~b1000</li>\n<li>学号相同的人一定hash到相同序号的小文件</li>\n<li>加载序号相同的小文件（比如：读取a2和b2）用map储存再按姓名+分数写入C即可</li>\n</ul>\n<h2 id=\"秒杀系统怎么设计\"><a href=\"#秒杀系统怎么设计\" class=\"headerlink\" title=\"秒杀系统怎么设计\"></a>秒杀系统怎么设计</h2><h3 id=\"秒杀存在的问题\"><a href=\"#秒杀存在的问题\" class=\"headerlink\" title=\"秒杀存在的问题\"></a>秒杀存在的问题</h3><ul>\n<li>高并发、瞬间请求量极大</li>\n<li>黄牛、黑客恶意请求</li>\n<li>链接暴露问题</li>\n<li>数据库压力问题</li>\n<li>库存不足和超卖问题</li>\n</ul>\n<h3 id=\"如何解决这些问题\"><a href=\"#如何解决这些问题\" class=\"headerlink\" title=\"如何解决这些问题\"></a>如何解决这些问题</h3><ul>\n<li>页面静态化<ul>\n<li>秒杀活动的页面，大多数内容都是固定不变的，如商品名称，商品图片等等，可以对活动页面做静态化处理，减少访问服务端的请求。秒杀用户会分布在全国各地，有的在上海，有的在深圳，地域相差很远，网速也各不相同。为了让用户最快访问到活动页面，可以使用CDN（Content Delivery Network，内容分发网络）。CDN可以让用户就近获取所需内容。</li>\n</ul>\n</li>\n<li>按钮至灰控制<ul>\n<li>秒杀活动开始前，按钮一般需要置灰的。只有时间到了，才能变得可以点击。这是防止，秒杀用户在时间快到的前几秒，疯狂请求服务器，然后秒杀时间点还没到，服务器就自己挂了。</li>\n</ul>\n</li>\n<li>服务单一职责<ul>\n<li>我们都知道微服务设计思想，也就是把各个功能模块拆分，功能那个类似的放一起，再用分布式的部署方式。</li>\n<li>如用户登录相关的，就设计个用户服务，订单相关的就搞个订单服务，再到礼物相关的就搞个礼物服务等等。那么，秒杀相关的业务逻辑也可以放到一起，搞个秒杀服务，单独给它搞个秒杀数据库。</li>\n<li>服务单一职责有个好处：如果秒杀没抗住高并发的压力，秒杀库崩了，服务挂了，也不会影响到系统的其他服务。</li>\n</ul>\n</li>\n<li>秒杀链接加盐<ul>\n<li>链接如果明文暴露的话，会有人获取到请求Url，提前秒杀了。因此，需要给秒杀链接加盐。可以把URL动态化，如通过MD5加密算法加密随机的字符串去做url。</li>\n</ul>\n</li>\n<li>限流<ul>\n<li>一般有两种方式限流：nginx限流和redis限流。</li>\n<li>为了防止某个用户请求过于频繁，我们可以对同一用户限流；</li>\n<li>为了防止黄牛模拟几个用户请求，我们可以对某个IP进行限流；</li>\n<li>为了防止有人使用代理，每次请求都更换IP请求，我们可以对接口进行限流。</li>\n<li>为了防止瞬时过大的流量压垮系统，还可以使用阿里的Sentinel、Hystrix组件进行限流。</li>\n</ul>\n</li>\n<li>分布式锁<ul>\n<li>可以使用redis分布式锁解决超卖问题。</li>\n<li>使用Redis的SET EX PX NX + 校验唯一随机值,再删除释放锁。</li>\n<li>为了更严谨，一般也是用lua脚本代替。lua脚本如下：</li>\n</ul>\n</li>\n<li>MQ异步处理<ul>\n<li>如果瞬间流量特别大，可以使用消息队列削峰，异步处理。用户请求过来的时候，先放到消息队列，再拿出来消费。</li>\n</ul>\n</li>\n<li>限流&amp;降级&amp;熔断<ul>\n<li>限流，就是限制请求，防止过大的请求压垮服务器；</li>\n<li>降级，就是秒杀服务有问题了，就降级处理，不要影响别的服务；</li>\n<li>熔断，服务有问题就熔断，一般熔断降级是一起出现。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"产品上线出问题怎么定位错误\"><a href=\"#产品上线出问题怎么定位错误\" class=\"headerlink\" title=\"产品上线出问题怎么定位错误\"></a>产品上线出问题怎么定位错误</h2><ul>\n<li>复现问题</li>\n<li>top jstack</li>\n</ul>\n<h2 id=\"大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案\"><a href=\"#大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案\" class=\"headerlink\" title=\"大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案\"></a>大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案</h2><p>读写分离</p>\n<h2 id=\"海量日志数据，提取出某日访问百度次数最多的那个IP。\"><a href=\"#海量日志数据，提取出某日访问百度次数最多的那个IP。\" class=\"headerlink\" title=\"海量日志数据，提取出某日访问百度次数最多的那个IP。\"></a>海量日志数据，提取出某日访问百度次数最多的那个IP。</h2><ul>\n<li>可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址</li>\n<li>对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址</li>\n<li>可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；</li>\n</ul>\n<h2 id=\"给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？\"><a href=\"#给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？\" class=\"headerlink\" title=\"给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？\"></a>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</h2><h3 id=\"方案1\"><a href=\"#方案1\" class=\"headerlink\" title=\"方案1\"></a>方案1</h3><ul>\n<li>遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。</li>\n<li>遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</li>\n<li>求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</li>\n</ul>\n<h3 id=\"方案2\"><a href=\"#方案2\" class=\"headerlink\" title=\"方案2\"></a>方案2</h3><p>如果允许有一定的误差，使用布隆过滤器</p>\n<h2 id=\"一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash-x-1000分为小文件再分别加载小文件到内存中处理即可\"><a href=\"#一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash-x-1000分为小文件再分别加载小文件到内存中处理即可\" class=\"headerlink\" title=\"一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash(x)%1000分为小文件再分别加载小文件到内存中处理即可\"></a>一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash(x)%1000分为小文件再分别加载小文件到内存中处理即可</h2><h2 id=\"如何保证接口的幂等性\"><a href=\"#如何保证接口的幂等性\" class=\"headerlink\" title=\"如何保证接口的幂等性\"></a>如何保证接口的幂等性</h2><h3 id=\"什么是幂等性\"><a href=\"#什么是幂等性\" class=\"headerlink\" title=\"什么是幂等性\"></a>什么是幂等性</h3><p>幂等性是系统服务对外一种承诺，承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。</p>\n<h3 id=\"什么情况下需要幂等\"><a href=\"#什么情况下需要幂等\" class=\"headerlink\" title=\"什么情况下需要幂等\"></a>什么情况下需要幂等</h3><p>以SQL为例：</p>\n<ul>\n<li>SELECT col1 FROM tab1 WHER col2&#x3D;2，无论执行多少次都不会改变状态，是天然的幂等。</li>\n<li>UPDATE tab1 SET col1&#x3D;1 WHERE col2&#x3D;2，无论执行成功多少次状态都是一致的，因此也是幂等操作。</li>\n<li>UPDATE tab1 SET col1&#x3D;col1+1 WHERE col2&#x3D;2，每次执行的结果都会发生变化，这种不是幂等的。</li>\n<li>insert into user(userid,name) values(1,’a’) 如userid为唯一主键，即重复操作上面的业务，只会插入一条用户数据，具备幂等性。<ul>\n<li>如userid不是主键，可以重复，那上面业务多次操作，数据都会新增多条，不具备幂等性。</li>\n</ul>\n</li>\n<li>delete from user where userid&#x3D;1，多次操作，结果一样，具备幂等性</li>\n</ul>\n<h3 id=\"如何保证幂等\"><a href=\"#如何保证幂等\" class=\"headerlink\" title=\"如何保证幂等\"></a>如何保证幂等</h3><h4 id=\"1、token机制\"><a href=\"#1、token机制\" class=\"headerlink\" title=\"1、token机制\"></a>1、token机制</h4><ul>\n<li>服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，服务器会把token保存到redis中。</li>\n<li>然后调用业务接口请求时，把token携带过去，一般放在请求头部。</li>\n<li>服务器判断token是否存在redis中，存在表示第一次请求，然后删除token,继续执行业务。</li>\n<li>如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不被重复执行。</li>\n</ul>\n<p><strong>关键点 先删除token，还是后删除token。</strong></p>\n<p>后删除token：如果进行业务处理成功后，删除redis中的token失败了，这样就导致了有可能会发生重复请求，因为token没有被删除。这个问题其实是数据库和缓存redis数据不一致问题，后续会写文章进行讲解。</p>\n<p>先删除token：如果系统出现问题导致业务处理出现异常，业务处理没有成功，接口调用方也没有获取到明确的结果，然后进行重试，但token已经删除掉了，服务端判断token不存在，认为是重复请求，就直接返回了，无法进行业务处理了。</p>\n<p>先删除token可以保证不会因为重复请求，业务数据出现问题。出现业务异常，可以让调用方配合处理一下，重新获取新的token，再次由业务调用方发起重试请求就ok了。</p>\n<p><strong>token机制缺点</strong></p>\n<p>业务请求每次请求，都会有额外的请求（一次获取token请求、判断token是否存在的业务）。其实真实的生产环境中，1万请求也许只会存在10个左右的请求会发生重试，为了这10个请求，我们让9990个请求都发生了额外的请求。</p>\n<h4 id=\"2、乐观锁机制\"><a href=\"#2、乐观锁机制\" class=\"headerlink\" title=\"2、乐观锁机制\"></a>2、乐观锁机制</h4><ul>\n<li>这种方法适合在更新的场景中，update t_goods set count &#x3D; count -1 , version &#x3D; version + 1 where good_id&#x3D;2 and version &#x3D; 1</li>\n<li>根据version版本，也就是在操作库存前先获取当前商品的version版本号，然后操作的时候带上此version号。我们梳理下，我们第一次操作库存时，得到version为1，调用库存服务version变成了2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传如的version还是1，再执行上面的sql语句时，就不会执行；因为version已经变为2了，where条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。</li>\n<li>乐观锁主要使用于处理读多写少的问题</li>\n</ul>\n<h4 id=\"3、唯一主键\"><a href=\"#3、唯一主键\" class=\"headerlink\" title=\"3、唯一主键\"></a>3、唯一主键</h4><p>这个机制是利用了数据库的主键唯一约束的特性，解决了在insert场景时幂等问题。但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。</p>\n<p>如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关</p>\n<h4 id=\"4、防重表\"><a href=\"#4、防重表\" class=\"headerlink\" title=\"4、防重表\"></a>4、防重表</h4><p>使用订单号orderNo做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。</p>\n<h4 id=\"5、唯一ID\"><a href=\"#5、唯一ID\" class=\"headerlink\" title=\"5、唯一ID\"></a>5、唯一ID</h4><p>调用接口时，生成一个唯一id，redis将数据保存到集合中（去重），存在即处理过。</p>\n<h2 id=\"缓存和数据库不一致问题\"><a href=\"#缓存和数据库不一致问题\" class=\"headerlink\" title=\"缓存和数据库不一致问题\"></a>缓存和数据库不一致问题</h2><h3 id=\"更新缓存和更新数据库\"><a href=\"#更新缓存和更新数据库\" class=\"headerlink\" title=\"更新缓存和更新数据库\"></a>更新缓存和更新数据库</h3><p>大部分观点认为，做缓存不应该是去更新缓存，而是应该删除缓存，然后由下个请求去去缓存，发现不存在后再读取数据库，写入缓存。观点引用：《分布式之数据库和缓存双写一致性方案解析》孤独烟</p>\n<p>原因一：线程安全角度同时有请求A和请求B进行更新操作，那么会出现（1）线程A更新了数据库（2）线程B更新了数据库（3）线程B更新了缓存（4）线程A更新了缓存这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p>\n<p>原因二：业务场景角度有如下两点：</p>\n<ol>\n<li>如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。</li>\n<li>如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</li>\n</ol>\n<h3 id=\"删缓存和更新数据库\"><a href=\"#删缓存和更新数据库\" class=\"headerlink\" title=\"删缓存和更新数据库\"></a>删缓存和更新数据库</h3><h4 id=\"先删缓存，再更新数据库\"><a href=\"#先删缓存，再更新数据库\" class=\"headerlink\" title=\"先删缓存，再更新数据库\"></a>先删缓存，再更新数据库</h4><p>该方案会导致请求数据不一致同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p>\n<ol>\n<li>请求A进行写操作，删除缓存</li>\n<li>请求B查询发现缓存不存在</li>\n<li>请求B去数据库查询得到旧值</li>\n<li>请求B将旧值写入缓存</li>\n<li>请求A将新值写入数据库上述情况就会导致不一致的情形出现。<br>而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</li>\n</ol>\n<h4 id=\"先更新数据库，再删缓存\"><a href=\"#先更新数据库，再删缓存\" class=\"headerlink\" title=\"先更新数据库，再删缓存\"></a>先更新数据库，再删缓存</h4><p>这种情况不存在并发问题么？不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p>\n<ol>\n<li>缓存刚好失效</li>\n<li>请求A查询数据库，得一个旧值</li>\n<li>请求B将新值写入数据库</li>\n<li>请求B删除缓存</li>\n<li>请求A将查到的旧值写入缓存ok，如果发生上述情况，确实是会发生脏数据。 然而，发生这种情况的概率又有多少呢？发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。</li>\n</ol>\n<p>先更新数据库，再删缓存依然会有问题，不过，问题出现的可能性会因为上面说的原因，变得比较低！(补充说明：我用了“先更新数据库，再删缓存”且不设过期时间策略，会不会有问题呢？由于先缓存和更新数据库不是原子的，如果更新了数据库，程序歇逼，就没删缓存，由于没有过期策略，就永远脏数据了。)所以，如果你想实现基础的缓存数据库双写一致的逻辑，那么在大多数情况下，在不想做过多设计，增加太大工作量的情况下，请先更新数据库，再删缓存!</p>\n<h3 id=\"数据库和缓存数据强一致怎么办\"><a href=\"#数据库和缓存数据强一致怎么办\" class=\"headerlink\" title=\"数据库和缓存数据强一致怎么办\"></a>数据库和缓存数据强一致怎么办</h3><p>没有办法做到绝对的一致性，这是由CAP理论决定的，缓存系统适用的场景就是非强一致性的场景，所以它属于CAP中的AP。所以，我们得委曲求全，可以去做到BASE理论中说的最终一致性。</p>\n<p>大佬们给出了到达最终一致性的解决思路，主要是针对上面两种双写策略（先删缓存，再更新数据库&#x2F;先更新数据库，再删缓存）导致的脏数据问题，进行相应的处理，来保证最终一致性。</p>\n<h4 id=\"缓存延时双删\"><a href=\"#缓存延时双删\" class=\"headerlink\" title=\"缓存延时双删\"></a>缓存延时双删</h4><p>步骤</p>\n<ol>\n<li>先删除缓存</li>\n<li>再写数据库</li>\n<li>休眠500毫秒（根据具体的业务时间来定）</li>\n<li>再次删除缓存。</li>\n</ol>\n<h4 id=\"那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？\"><a href=\"#那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？\" class=\"headerlink\" title=\"那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？\"></a>那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？</h4><p>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>\n<h4 id=\"如果你用了mysql的读写分离架构怎么办？\"><a href=\"#如果你用了mysql的读写分离架构怎么办？\" class=\"headerlink\" title=\"如果你用了mysql的读写分离架构怎么办？\"></a>如果你用了mysql的读写分离架构怎么办？</h4><p>ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。</p>\n<ol>\n<li>请求A进行写操作，删除缓存</li>\n<li>请求A将数据写入数据库了，</li>\n<li>请求B查询缓存发现，缓存没有值</li>\n<li>请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</li>\n<li>请求B将旧值写入缓存</li>\n<li>数据库完成主从同步，从库变为新值上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。</li>\n</ol>\n<h4 id=\"采用这种同步淘汰策略，吞吐量降低怎么办？\"><a href=\"#采用这种同步淘汰策略，吞吐量降低怎么办？\" class=\"headerlink\" title=\"采用这种同步淘汰策略，吞吐量降低怎么办？\"></a>采用这种同步淘汰策略，吞吐量降低怎么办？</h4><p>ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。</p>\n<h4 id=\"删缓存失败了怎么办：重试机制\"><a href=\"#删缓存失败了怎么办：重试机制\" class=\"headerlink\" title=\"删缓存失败了怎么办：重试机制\"></a>删缓存失败了怎么办：重试机制</h4><p>看似问题都已经解决了，但其实，还有一个问题没有考虑到，那就是删除缓存的操作，失败了怎么办？比如延时双删的时候，第二次缓存删除失败了，那不还是没有清除脏数据吗？解决方案就是再加上一个重试机制，保证删除缓存成功</p>\n<p>流程如下所示</p>\n<ol>\n<li>更新数据库数据；</li>\n<li>缓存因为种种问题删除失败</li>\n<li>将需要删除的key发送至消息队列</li>\n<li>自己消费消息，获得需要删除的key</li>\n<li>继续重试删除操作，直到成功然而，</li>\n</ol>\n<p>该方案有一个缺点，对业务线代码造成大量的侵入。</p>\n<p>于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作</p>\n<h4 id=\"binlog\"><a href=\"#binlog\" class=\"headerlink\" title=\"binlog\"></a>binlog</h4><p>流程如下所示</p>\n<ol>\n<li>更新数据库数据</li>\n<li>数据库会将操作信息写入binlog日志当中</li>\n<li>订阅程序提取出所需要的数据以及key</li>\n<li>另起一段非业务代码，获得该信息</li>\n<li>尝试删除缓存操作，发现删除失败</li>\n<li>将这些信息发送至消息队列</li>\n<li>重新从消息队列中获得该数据，重试操作。</li>\n</ol>\n<h2 id=\"什么是SPI\"><a href=\"#什么是SPI\" class=\"headerlink\" title=\"什么是SPI\"></a>什么是SPI</h2><p>SPI 全称为 (Service Provider Interface) ，是JDK内置的一种服务提供发现机制</p>\n<h3 id=\"SPI-实践\"><a href=\"#SPI-实践\" class=\"headerlink\" title=\"SPI 实践\"></a>SPI 实践</h3><p>接下来我们来如何来利用 SPI 实现刚才提到的可拔插 IOC 容器。</p>\n<p>既然刚才都提到了 SPI 的本质就是面向接口编程，所以自然我们首先需要定义一个接口：</p>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/1.png\" alt=\"SPI图\"></p>\n<p>其中包含了一些 Bean 容器所必须的操作：注册、获取、释放 bean。</p>\n<p>为了让其他人也能实现自己的 IOC 容器，所以我们将这个接口单独放到一个 Module 中，可供他人引入实现。</p>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/2.png\"></p>\n<p>所以当我要实现一个单例的 IOC 容器时，我只需要新建一个 Module 然后引入刚才的模块并实现 CicadaBeanFactory 接口即可。</p>\n<p>当然其中最重要的则是需要在 resources 目录下新建一个 META-INF&#x2F;services&#x2F;top.crossoverjie.cicada.base.bean.CicadaBeanFactory 文件，文件名必须得是我们之前定义接口的全限定名（SPI 规范）。<br><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/3.png\"></p>\n<p>其中的内容便是我们自己实现类的全限定名：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">top.crossoverjie.cicada.bean.ioc.CicadaIoc</span><br></pre></td></tr></table></figure>\n<p>可以想象最终会通过这里的全限定名来反射创建对象。</p>\n<p>只不过这个过程 Java 已经提供 API 屏蔽掉了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CicadaBeanFactory <span class=\"title function_\">getCicadaBeanFactory</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    ServiceLoader&lt;CicadaBeanFactory&gt; cicadaBeanFactories = ServiceLoader.load(CicadaBeanFactory.class);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cicadaBeanFactories.iterator().hasNext())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cicadaBeanFactories.iterator().next() ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CicadaDefaultBean</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 classpath 中存在我们刚才的实现类（引入实现类的 jar 包），便可以通过 java.util.ServiceLoader 工具类来找到所有的实现类（可以有多个实现类同时存在，只不过通常我们只需要一个）。</p>\n<p>一些都准备好之后，使用自然就非常简单了。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>top.crossoverjie.opensource<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>cicada-ioc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我们只需要引入这个依赖便能使用它的实现，当我们想换一种实现方式时只需要更换一个依赖即可。</p>\n<p>这样就做到了不修改一行代码灵活的可拔插选择 IOC 容器了。</p>\n<p>SPI 的一些其他应用</p>\n<p>MySQL 的驱动包也是利用 SPI 来实现自己的连接逻辑。</p>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/4.png\"></p>\n<p>总结来说：</p>\n<ul>\n<li>提供一个接口</li>\n<li>在resource下新建META-INF&#x2F;services目录，在目录下新建接口的全限定名文件</li>\n<li>服务方实现接口</li>\n<li>调用ServiceLoad.load()</li>\n</ul>\n<h2 id=\"什么是RPC？\"><a href=\"#什么是RPC？\" class=\"headerlink\" title=\"什么是RPC？\"></a>什么是RPC？</h2><p>RPC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务</p>\n<ol>\n<li>首先客户端需要告诉服务器，需要调用的函数，这里函数和进程ID存在一个映射，客户端远程调用时，需要查一下函数，找到对应的ID，然后执行函数的代码。</li>\n<li>客户端需要把本地参数传给远程函数，本地调用的过程中，直接压栈即可，但是在远程调用过程中不再同一个内存里，无法直接传递函数的参数，因此需要客户端把参数转换成字节流，传给服务端，然后服务端将字节流转换成自身能读取的格式，是一个序列化和反序列化的过程。</li>\n<li>数据准备好了之后，如何进行传输？网络传输层需要把调用的ID和序列化后的参数传给服务端，然后把计算好的结果序列化传给客户端，因此TCP层即可完成上述过程，gRPC中采用的是HTTP2协议。</li>\n</ol>\n<p>总结一下：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">// Client端 </span><br><span class=\"line\">//    Student student = Call(ServerAddr, addAge, student)</span><br><span class=\"line\">1. 将这个调用映射为Call ID。</span><br><span class=\"line\">2. 将Call ID，student（params）序列化，以二进制形式打包</span><br><span class=\"line\">3. 把2中得到的数据包发送给ServerAddr，这需要使用网络传输层</span><br><span class=\"line\">4. 等待服务器返回结果</span><br><span class=\"line\">5. 如果服务器调用成功，那么就将结果反序列化，并赋给student，年龄更新</span><br><span class=\"line\"></span><br><span class=\"line\">// Server端</span><br><span class=\"line\">1. 在本地维护一个Call ID到函数指针的映射call_id_map，可以用Map&lt;String, Method&gt; callIdMap</span><br><span class=\"line\">2. 等待客户端请求</span><br><span class=\"line\">3. 得到一个请求后，将其数据包反序列化，得到Call ID</span><br><span class=\"line\">4. 通过在callIdMap中查找，得到相应的函数指针</span><br><span class=\"line\">5. 将student（params）反序列化后，在本地调用addAge()函数，得到结果</span><br><span class=\"line\">6. 将student结果序列化后通过网络返回给Client</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在微服务的设计中，一个服务A如果访问另一个Module下的服务B，可以采用HTTP REST传输数据，并在两个服务之间进行序列化和反序列化操作，服务B把执行结果返回过来。</li>\n<li>由于HTTP在应用层中完成，整个通信的代价较高，远程过程调用中直接基于TCP进行远程调用，数据传输在传输层TCP层完成，更适合对效率要求比较高的场景，RPC主要依赖于客户端和服务端之间建立Socket链接进行，底层实现比REST更复杂。</li>\n</ul>\n<h3 id=\"RPC-demo\"><a href=\"#RPC-demo\" class=\"headerlink\" title=\"RPC demo\"></a>RPC demo</h3><p>客户端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RPCClient</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T <span class=\"title function_\">getRemoteProxyObj</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;?&gt; serviceInterface, <span class=\"keyword\">final</span> InetSocketAddress addr)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.将本地的接口调用转换成JDK的动态代理，在动态代理中实现接口的远程调用</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(serviceInterface.getClassLoader(), <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[]&#123;serviceInterface&#125;,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                        <span class=\"type\">Socket</span> <span class=\"variable\">socket</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">output</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">input</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 2.创建Socket客户端，根据指定地址连接远程服务提供者</span></span><br><span class=\"line\">                            socket = <span class=\"keyword\">new</span> <span class=\"title class_\">Socket</span>();</span><br><span class=\"line\">                            socket.connect(addr);</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"comment\">// 3.将远程服务调用所需的接口类、方法名、参数列表等编码后发送给服务提供者</span></span><br><span class=\"line\">                            output = <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(socket.getOutputStream());</span><br><span class=\"line\">                            output.writeUTF(serviceInterface.getName());</span><br><span class=\"line\">                            output.writeUTF(method.getName());</span><br><span class=\"line\">                            output.writeObject(method.getParameterTypes());</span><br><span class=\"line\">                            output.writeObject(args);</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"comment\">// 4.同步阻塞等待服务器返回应答，获取应答后返回</span></span><br><span class=\"line\">                            input = <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(socket.getInputStream());</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> input.readObject();</span><br><span class=\"line\">                        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (socket != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                                socket.close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (output != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                                output.close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (input != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                                input.close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>服务端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceCenter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Server</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">ExecutorService</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HashMap&lt;String, Class&gt; serviceRegistry = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, Class&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"variable\">isRunning</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ServiceCenter</span><span class=\"params\">(<span class=\"type\">int</span> port)</span>&#123;</span><br><span class=\"line\">        ServiceCenter.port = port;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">ServerSocket</span> <span class=\"variable\">server</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerSocket</span>();</span><br><span class=\"line\">        server.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(port));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Server Start .....&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">                executor.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">ServiceTask</span>(server.accept()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            server.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(Class serviceInterface, Class impl)</span> &#123;</span><br><span class=\"line\">        serviceRegistry.put(serviceInterface.getName(), impl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isRunning</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isRunning;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getPort</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> port;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        isRunning = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        executor.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceTask</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Socket</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">ServiceTask</span><span class=\"params\">(Socket client)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.client = client;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">input</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">output</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                input = <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(client.getInputStream());</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">serviceName</span> <span class=\"operator\">=</span> input.readUTF();</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">methodName</span> <span class=\"operator\">=</span> input.readUTF();</span><br><span class=\"line\">                Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[]) input.readObject();</span><br><span class=\"line\">                Object[] arguments = (Object[]) input.readObject();</span><br><span class=\"line\">                <span class=\"type\">Class</span> <span class=\"variable\">serviceClass</span> <span class=\"operator\">=</span> serviceRegistry.get(serviceName);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(serviceClass == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassNotFoundException</span>(serviceName + <span class=\"string\">&quot;not found!&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> serviceClass.getMethod(methodName, parameterTypes);</span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(serviceClass.newInstance(), arguments);</span><br><span class=\"line\"></span><br><span class=\"line\">                output = <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(client.getOutputStream());</span><br><span class=\"line\">                output.writeObject(result);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(output!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                        output.close();</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (input != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        input.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (client != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        client.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceProducerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ServiceProducer</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">sendData</span><span class=\"params\">(String data)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;I am service producer!!!, the data is &quot;</span>+ data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RPCTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">Server</span> <span class=\"variable\">serviceServer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceCenter</span>(<span class=\"number\">8088</span>);</span><br><span class=\"line\">                    serviceServer.register(ServiceProducer.class, ServiceProducerImpl.class);</span><br><span class=\"line\">                    serviceServer.start();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        <span class=\"type\">ServiceProducer</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> RPCClient.getRemoteProxyObj(ServiceProducer.class, <span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8088</span>));</span><br><span class=\"line\">        System.out.println(service.sendData(<span class=\"string\">&quot;test&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h2><h3 id=\"gRPC与REST\"><a href=\"#gRPC与REST\" class=\"headerlink\" title=\"gRPC与REST\"></a>gRPC与REST</h3><ul>\n<li>REST通常以业务为导向，将业务对象上执行的操作映射到HTTP动词，格式非常简单，可以使用浏览器进行扩展和传输，通过JSON数据完成客户端和服务端之间的消息通信，直接支持请求&#x2F;响应方式的通信。不需要中间的代理，简化了系统的架构，不同系统之间只需要对JSON进行解析和序列化即可完成数据的传递。</li>\n<li>但是REST也存在一些弊端，比如只支持请求&#x2F;响应这种单一的通信方式，对象和字符串之间的序列化操作也会影响消息传递速度，客户端需要通过服务发现的方式，知道服务实例的位置，在单个请求获取多个资源时存在着挑战，而且有时候很难将所有的动作都映射到HTTP动词。</li>\n<li>正是因为REST面临一些问题，因此可以采用gRPC作为一种替代方案，gRPC 是一种基于二进制流的消息协议，可以采用基于Protocol Buffer的IDL定义grpc API,这是Google公司用于序列化结构化数据提供的一套语言中立的序列化机制，客户端和服务端使用HTTP&#x2F;2以Protocol Buffer格式交换二进制消息。</li>\n<li>gRPC的优势是，设计复杂更新操作的API非常简单，具有高效紧凑的进程通信机制，在交换大量消息时效率高，远程过程调用和消息传递时可以采用双向的流式消息方式，同时客户端和服务端支持多种语言编写，互操作性强；不过gRPC的缺点是不方便与JavaScript集成，某些防火墙不支持该协议。</li>\n<li>注册中心：当项目中有很多服务时，可以把所有的服务在启动的时候注册到一个注册中心里面，用于维护服务和服务器之间的列表，当注册中心接收到客户端请求时，去找到该服务是否远程可以调用，如果可以调用需要提供服务地址返回给客户端，客户端根据返回的地址和端口，去调用远程服务端的方法，执行完成之后将结果返回给客户端。这样在服务端加新功能的时候，客户端不需要直接感知服务端的方法，服务端将更新之后的结果在注册中心注册即可，而且当修改了服务端某些方法的时候，或者服务降级服务多机部署想实现负载均衡的时候，我们只需要更新注册中心的服务群即可。<br><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/5.png\"></li>\n</ul>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><p>这里使用SpringBoot+gRPC的形式实现RPC调用过程 项目结构分为三部分：client、grpc、server</p>\n<h4 id=\"grpc\"><a href=\"#grpc\" class=\"headerlink\" title=\"grpc\"></a>grpc</h4><p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/6.png\"></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>io.grpc<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>grpc-all<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">extensions</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">extension</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>kr.motd.maven<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>os-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.4.1.Final<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">extension</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">extensions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>protobuf-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.5.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">pluginId</span>&gt;</span>grpc-java<span class=\"tag\">&lt;/<span class=\"name\">pluginId</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.0.2:exe:$&#123;os.detected.classifier&#125;<span class=\"tag\">&lt;/<span class=\"name\">protocArtifact</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:1.2.0:exe:$&#123;os.detected.classifier&#125;<span class=\"tag\">&lt;/<span class=\"name\">pluginArtifact</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>compile-custom<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>创建.proto文件</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">&quot;proto3&quot;</span>;   <span class=\"comment\">// 语法版本</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// stub选项</span></span><br><span class=\"line\"><span class=\"keyword\">option</span> java_package = <span class=\"string\">&quot;com.shgx.grpc.api&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">option</span> java_outer_classname = <span class=\"string\">&quot;RPCDateServiceApi&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">option</span> java_multiple_files = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义包名</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.shgx.grpc.api;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 服务接口定义，服务端和客户端都要遵守该接口进行通信</span></span><br><span class=\"line\"><span class=\"keyword\">service </span><span class=\"title class_\">RPCDateService</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">rpc</span> getDate (RPCDateRequest) <span class=\"keyword\">returns</span> (RPCDateResponse) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义消息（请求）</span></span><br><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">RPCDateRequest</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">string</span> userName = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义消息（响应）</span></span><br><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">RPCDateResponse</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">string</span> serverDate = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mvn complie</p>\n<p>生成代码：<br><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/7.png\"></p>\n<h4 id=\"client\"><a href=\"#client\" class=\"headerlink\" title=\"client\"></a>client</h4><p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/8.png\"></p>\n<p>根据gRPC中的项目配置在client和server两个Module的pom.xml添加依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.shgx<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>grpc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>编写GRPCClient</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GRPCClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">host</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;localhost&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">serverPort</span> <span class=\"operator\">=</span> <span class=\"number\">9999</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">( String[] args )</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">ManagedChannel</span> <span class=\"variable\">managedChannel</span> <span class=\"operator\">=</span> ManagedChannelBuilder.forAddress( host, serverPort ).usePlaintext().build();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            RPCDateServiceGrpc.<span class=\"type\">RPCDateServiceBlockingStub</span> <span class=\"variable\">rpcDateService</span> <span class=\"operator\">=</span> RPCDateServiceGrpc.newBlockingStub( managedChannel );</span><br><span class=\"line\">            <span class=\"type\">RPCDateRequest</span> <span class=\"variable\">rpcDateRequest</span> <span class=\"operator\">=</span> RPCDateRequest</span><br><span class=\"line\">                    .newBuilder()</span><br><span class=\"line\">                    .setUserName(<span class=\"string\">&quot;shgx&quot;</span>)</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">            <span class=\"type\">RPCDateResponse</span> <span class=\"variable\">rpcDateResponse</span> <span class=\"operator\">=</span> rpcDateService.getDate( rpcDateRequest );</span><br><span class=\"line\">            System.out.println( rpcDateResponse.getServerDate() );</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            managedChannel.shutdown();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"server\"><a href=\"#server\" class=\"headerlink\" title=\"server\"></a>server</h4><p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/9.png\"></p>\n<p>按照2.2.3 client的方式添加依赖</p>\n<p>创建RPCDateServiceImpl</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RPCDateServiceImpl</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">RPCDateServiceGrpc</span>.RPCDateServiceImplBase&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getDate</span><span class=\"params\">(RPCDateRequest request, StreamObserver&lt;RPCDateResponse&gt; responseObserver)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RPCDateResponse</span> <span class=\"variable\">rpcDateResponse</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        Date now=<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\">        <span class=\"type\">SimpleDateFormat</span> <span class=\"variable\">simpleDateFormat</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleDateFormat</span>(<span class=\"string\">&quot;今天是&quot;</span>+<span class=\"string\">&quot;yyyy年MM月dd日 E kk点mm分&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">nowTime</span> <span class=\"operator\">=</span> simpleDateFormat.format( now );</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            rpcDateResponse = RPCDateResponse</span><br><span class=\"line\">                    .newBuilder()</span><br><span class=\"line\">                    .setServerDate( <span class=\"string\">&quot;Welcome &quot;</span> + request.getUserName()  + <span class=\"string\">&quot;, &quot;</span> + nowTime )</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            responseObserver.onError(e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            responseObserver.onNext( rpcDateResponse );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        responseObserver.onCompleted();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建GRPCServer</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GRPCServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">port</span> <span class=\"operator\">=</span> <span class=\"number\">9999</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">( String[] args )</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Server</span> <span class=\"variable\">server</span> <span class=\"operator\">=</span> ServerBuilder.</span><br><span class=\"line\">                forPort(port)</span><br><span class=\"line\">                .addService( <span class=\"keyword\">new</span> <span class=\"title class_\">RPCDateServiceImpl</span>() )</span><br><span class=\"line\">                .build().start();</span><br><span class=\"line\">        System.out.println( <span class=\"string\">&quot;grpc服务端启动成功, 端口=&quot;</span> + port );</span><br><span class=\"line\">        server.awaitTermination();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"一个优秀的RPC框架需要考虑的问题\"><a href=\"#一个优秀的RPC框架需要考虑的问题\" class=\"headerlink\" title=\"一个优秀的RPC框架需要考虑的问题\"></a>一个优秀的RPC框架需要考虑的问题</h2><ol>\n<li><code>微服务化</code>应用都基于微服务化，实现资源调用离不开远程调用</li>\n<li><code>多实例问题</code> 一个服务可能有多个实例，你在调用时，要如何获取这些实例的地址呢？— 这时候就需要一个服务注册中心，从服务注册中心获取服务的实例列表，再从中选择一个进行调用。</li>\n<li><code>负载均衡</code> 选哪个调用好呢？这时候就需要负载均衡了，于是又得考虑如何实现复杂均衡</li>\n<li><code>缓存</code> 总不能每次调用时都去注册中心查询实例列表吧，这样效率多低呀，于是又有了缓存，有了缓存，就要考虑缓存的更新问题</li>\n<li><code>异步调用</code> 客户端总不能每次调用完都干等着服务端返回数据吧,于是就要支持异步调用;<ul>\n<li>Future实现</li>\n</ul>\n</li>\n<li><code>版本控制</code> 服务端的接口修改了，老的接口还有人在用，怎么办？总不能让他们都改了吧？这就需要版本控制了；</li>\n<li><code>线程池</code> 服务端总不能每次接到请求都马上启动一个线程去处理吧？于是就需要线程池；</li>\n<li><code>未处理完的请求</code> 服务端关闭时，还没处理完的请求怎么办？是直接结束呢，还是等全部请求处理完再关闭呢？</li>\n</ol>\n<h2 id=\"什么是DDD？\"><a href=\"#什么是DDD？\" class=\"headerlink\" title=\"什么是DDD？\"></a>什么是DDD？</h2><h3 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h3><p>要说DDD，不得不先看看MVC，我相信基本上99%的java开发读者，不管你是计科专业出身还是跨专业，初学spring或者springboot的时候，接触到的代码分层都是MVC<br>这说明了MVC有它自身独有的优势：</p>\n<ul>\n<li>开发人员可以只关注整个结构中的其中某一层；</li>\n<li>可以很容易的用新的实现来替换原有层次的实现；</li>\n<li>可以降低层与层之间的依赖；</li>\n<li>有利于标准化；</li>\n<li>利于各层逻辑的复用。</li>\n</ul>\n<p>但是真实情况是这样吗？随着你系统功能迭代，业务逻辑越来越复杂之后。MVC三层中，V层作为数据载体，C层作为逻辑路由都是很薄的一层，大量的代码都堆积在了M层（模型层）。一个service的类，动辄几百上千行，大的甚至几万行，逻辑嵌套复杂，主业务逻辑不清晰。service做的稍微轻量化一点的，代码就像是胶水，把数据库执行逻辑与控制返回给前端的逻辑胶在一起，主次不清晰。<br>一看你的工程，类啊，代码量啊都不少，你甚至不知道如何入手去修改“屎山”一样的代码。</p>\n<h3 id=\"那么DDD为什么可以去解决以上的问题呢？\"><a href=\"#那么DDD为什么可以去解决以上的问题呢？\" class=\"headerlink\" title=\"那么DDD为什么可以去解决以上的问题呢？\"></a>那么DDD为什么可以去解决以上的问题呢？</h3><p>DDD核心思想是什么呢？解耦！让业务不是像炒大锅饭一样混在一起，而是一道道工序复杂的美食，都有他们自己独立的做法。</p>\n<p>DDD的价值观里面，任何业务都是某个业务领域模型的职责体现。A领域只会去做A领域的事情，A领域想去修改B领域，需要找中介（防腐层）去对B领域完成操作。我想完成一个很长的业务逻辑动作，在划分好业务边界之后，交给业务服务的编排者（应用服务）去组织业务模型（聚合）完成逻辑。</p>\n<p>这样，每个服务（领域）只会做自己业务边界内的事情，最小细粒度的去定义需求的实现。原先空空的贫血模型摇身一变变成了充血模型。原理冗长的service里面类似到处set，get值这种与业务逻辑无关的数据载体包装代码，都会被去除，进到应用服务层，你的代码就是你的业务逻辑。逻辑清晰，可维护性高！</p>\n<h3 id=\"什么样的系统适配DDD\"><a href=\"#什么样的系统适配DDD\" class=\"headerlink\" title=\"什么样的系统适配DDD\"></a>什么样的系统适配DDD</h3><p>中小规模的系统，本身业务体量小，功能单一，选择mvc架构无疑是最好的。 项目化交付的系统，研发周期短，一天到晚按照甲方的需求定制功能。</p>\n<p>中大规模系统，产品化模式，业务可持续迭代，可预见的业务逻辑复杂性的系统。</p>\n<h3 id=\"DDD的代码怎么做\"><a href=\"#DDD的代码怎么做\" class=\"headerlink\" title=\"DDD的代码怎么做\"></a>DDD的代码怎么做</h3><p>&#x2F;&#x2F; TODO</p>\n<h2 id=\"Java实现生产者消费者\"><a href=\"#Java实现生产者消费者\" class=\"headerlink\" title=\"Java实现生产者消费者\"></a>Java实现生产者消费者</h2><h3 id=\"wait-和notify-方法的实现\"><a href=\"#wait-和notify-方法的实现\" class=\"headerlink\" title=\"wait()和notify()方法的实现\"></a>wait()和notify()方法的实现</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test1</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Integer</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Integer</span> <span class=\"variable\">FULL</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">LOCK</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;lock&quot;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Test1</span> <span class=\"variable\">test1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test1</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (LOCK) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (count == FULL) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            LOCK.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                    LOCK.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (LOCK) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            LOCK.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    count--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                    LOCK.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"可重入锁ReentrantLock的实现\"><a href=\"#可重入锁ReentrantLock的实现\" class=\"headerlink\" title=\"可重入锁ReentrantLock的实现\"></a>可重入锁ReentrantLock的实现</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Integer</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Integer</span> <span class=\"variable\">FULL</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个锁对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">    <span class=\"comment\">//创建两个条件变量，一个为缓冲区非满，一个为缓冲区非空</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Condition</span> <span class=\"variable\">notFull</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Condition</span> <span class=\"variable\">notEmpty</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Test2</span> <span class=\"variable\">test2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test2</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//获取锁</span></span><br><span class=\"line\">                lock.lock();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (count == FULL) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            notFull.await();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                    <span class=\"comment\">//唤醒消费者</span></span><br><span class=\"line\">                    notEmpty.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//释放锁</span></span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e1) &#123;</span><br><span class=\"line\">                    e1.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                lock.lock();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            notEmpty.await();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    count--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                    notFull.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"阻塞队列BlockingQueue的实现\"><a href=\"#阻塞队列BlockingQueue的实现\" class=\"headerlink\" title=\"阻塞队列BlockingQueue的实现\"></a>阻塞队列BlockingQueue的实现</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test3</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Integer</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个阻塞队列</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">BlockingQueue</span> <span class=\"variable\">blockingQueue</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayBlockingQueue</span>&lt;&gt;(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Test3</span> <span class=\"variable\">test3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test3</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    blockingQueue.put(<span class=\"number\">1</span>);</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e1) &#123;</span><br><span class=\"line\">                    e1.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    blockingQueue.take();</span><br><span class=\"line\">                    count--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"信号量Semaphore的实现\"><a href=\"#信号量Semaphore的实现\" class=\"headerlink\" title=\"信号量Semaphore的实现\"></a>信号量Semaphore的实现</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test4</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Integer</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建三个信号量</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Semaphore</span> <span class=\"variable\">notFull</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Semaphore</span> <span class=\"variable\">notEmpty</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Semaphore</span> <span class=\"variable\">mutex</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Test4</span> <span class=\"variable\">test4</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test4</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    notFull.acquire();</span><br><span class=\"line\">                    mutex.acquire();</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    mutex.release();</span><br><span class=\"line\">                    notEmpty.release();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e1) &#123;</span><br><span class=\"line\">                    e1.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    notEmpty.acquire();</span><br><span class=\"line\">                    mutex.acquire();</span><br><span class=\"line\">                    count--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    mutex.release();</span><br><span class=\"line\">                    notFull.release();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Java实现BlockQueue\"><a href=\"#Java实现BlockQueue\" class=\"headerlink\" title=\"Java实现BlockQueue\"></a>Java实现BlockQueue</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BlockingQueue</span>&lt;E&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 有界队列内部固定长度，因此可以用数组实现</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object[] elements;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 队列的头和尾下标</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, tail = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 队列目前的长度</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">notEmpty</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">notFull</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">BlockingQueue</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.elements = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[capacity];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (size == elements.length)</span><br><span class=\"line\">                notFull.await();</span><br><span class=\"line\">            elements[tail] = e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++tail == elements.length) &#123;</span><br><span class=\"line\">                tail = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            size++;</span><br><span class=\"line\">            notEmpty.signal();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException ex) &#123;</span><br><span class=\"line\">            ex.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">take</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"type\">E</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                notEmpty.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            e = (E) elements[head];</span><br><span class=\"line\">            elements[head] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++head == elements.length)</span><br><span class=\"line\">                head = <span class=\"number\">0</span>;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">            notFull.signal();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException ex) &#123;</span><br><span class=\"line\">            ex.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">size</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解决哈希冲突的方法\"><a href=\"#解决哈希冲突的方法\" class=\"headerlink\" title=\"解决哈希冲突的方法\"></a>解决哈希冲突的方法</h2><h3 id=\"开放定址法\"><a href=\"#开放定址法\" class=\"headerlink\" title=\"开放定址法\"></a>开放定址法</h3><p>从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。</p>\n<p>在开放定址法中解决冲突的方法有：线行探查法、平方探查法、双散列函数探查法。</p>\n<p>开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。</p>\n<h4 id=\"线行探查法\"><a href=\"#线行探查法\" class=\"headerlink\" title=\"线行探查法\"></a>线行探查法</h4><p>线行探查法是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。</p>\n<p>可以参考csdn上flash对该方法的演示：<br><a href=\"http://student.zjzk.cn/course_ware/data_structure/web/flash/cz/kfdzh.swf\">http://student.zjzk.cn/course_ware/data_structure/web/flash/cz/kfdzh.swf</a></p>\n<h4 id=\"平方探查法\"><a href=\"#平方探查法\" class=\"headerlink\" title=\"平方探查法\"></a>平方探查法</h4><p>平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²…直到找到空闲单元。</p>\n<p>在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。</p>\n<h4 id=\"双散列函数探查法\"><a href=\"#双散列函数探查法\" class=\"headerlink\" title=\"双散列函数探查法\"></a>双散列函数探查法</h4><p>这种方法使用两个散列函数hl和h2。其中hl和前面的h一样，以关键字为自变量，产生一个0至m—l之间的数作为散列地址；h2也以关键字为自变量，产生一个l至m—1之间的、并和m互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)，探查序列的步长值是固定值l；对于平方探查法，探查序列的步长值是探查次数i的两倍减l；对于双散列函数探查法，其探查序列的步长值是同一关键字的另一散列函数的值。</p>\n<h3 id=\"链地址法（拉链法）\"><a href=\"#链地址法（拉链法）\" class=\"headerlink\" title=\"链地址法（拉链法）\"></a>链地址法（拉链法）</h3><p>链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。</p>\n<p>如下一组数字,(32、40、36、53、16、46、71、27、42、24、49、64)哈希表长度为13，哈希函数为H(key)&#x3D;key%13,则链表法结果如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>       </span><br><span class=\"line\"><span class=\"number\">1</span>  -&gt; <span class=\"number\">40</span> -&gt; <span class=\"number\">27</span> -&gt; <span class=\"number\">53</span> </span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span>  -&gt; <span class=\"number\">16</span> -&gt; <span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span>  -&gt; <span class=\"number\">32</span> -&gt; <span class=\"number\">71</span></span><br><span class=\"line\"><span class=\"number\">7</span>  -&gt; <span class=\"number\">46</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">10</span> -&gt; <span class=\"number\">36</span> -&gt; <span class=\"number\">49</span></span><br><span class=\"line\"><span class=\"number\">11</span> -&gt; <span class=\"number\">24</span></span><br><span class=\"line\"><span class=\"number\">12</span> -&gt; <span class=\"number\">64</span></span><br></pre></td></tr></table></figure>\n<p>注：在java中，链接地址法也是HashMap解决哈希冲突的方法之一，jdk1.7完全采用单链表来存储同义词，jdk1.8则采用了一种混合模式，对于链表长度大于8的，会转换为红黑树存储。</p>\n<h3 id=\"再哈希法\"><a href=\"#再哈希法\" class=\"headerlink\" title=\"再哈希法\"></a>再哈希法</h3><p>就是同时构造多个不同的哈希函数：</p>\n<p>Hi &#x3D; RHi(key)   i&#x3D; 1,2,3 … k;</p>\n<p>当H1 &#x3D; RH1(key)  发生冲突时，再用H2 &#x3D; RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。</p>\n<h3 id=\"建立公共溢出区\"><a href=\"#建立公共溢出区\" class=\"headerlink\" title=\"建立公共溢出区\"></a>建立公共溢出区</h3><p>将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>\n<h2 id=\"排行榜设计\"><a href=\"#排行榜设计\" class=\"headerlink\" title=\"排行榜设计\"></a>排行榜设计</h2><h3 id=\"基于数据库\"><a href=\"#基于数据库\" class=\"headerlink\" title=\"基于数据库\"></a>基于数据库</h3><p>基于MySQL，order by</p>\n<p>缺点：</p>\n<ul>\n<li>速度慢</li>\n</ul>\n<h3 id=\"基于Redis\"><a href=\"#基于Redis\" class=\"headerlink\" title=\"基于Redis\"></a>基于Redis</h3><p>主要考察sort set 也就是zset</p>\n<p>zadd添加数据后，zrevrange获取排序后的排名</p>\n<h3 id=\"类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样\"><a href=\"#类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样\" class=\"headerlink\" title=\"类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样\"></a>类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样</h3><p>key的设计比较重要，比如aa用户和bb用户</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zadd step:aa 1000 小明</span><br><span class=\"line\">zadd step:bb 1000 小明</span><br></pre></td></tr></table></figure>\n\n<p>同理时间也可以通过key的设计解决</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zadd step:aa:20210929 1000 小明</span><br><span class=\"line\">zadd step:aa:20210929 1000 小明</span><br></pre></td></tr></table></figure>\n\n<p>但是上述设计会导致每个用户都有一个排行榜，存储的数据巨大，其实可以考虑只在用户查询时通过好友关系去生成</p>\n<p>那朋友圈排行榜的：微信头像、点赞数 怎么获取呢</p>\n<ul>\n<li>可以使用hmset hash储存对象，需要时通过zset储存的key去查询即可</li>\n</ul>\n<h3 id=\"最近七天排行榜怎么弄\"><a href=\"#最近七天排行榜怎么弄\" class=\"headerlink\" title=\"最近七天排行榜怎么弄\"></a>最近七天排行榜怎么弄</h3><p>前面我们说的都是每日排行榜。</p>\n<p>假设面试官要求我们提供一个最近七天、上一周、上一月、上个季度、这一年排行榜啥的，又该怎么搞呢？</p>\n<p>其实这还是在考察你对于 Redis 有序集合 API 的掌握程度。</p>\n<p>也就是这个 API：</p>\n<ul>\n<li>zinterstore&#x2F;zunionstore destination numkeys key [key …] [weights weight [weight …]] [aggregate sum|min|max] 获取交集&#x2F;并集<ul>\n<li>zinterstore&#x2F;zunionstore其实就是交集&#x2F;并集</li>\n<li>destination 将交集&#x2F;并集的结果保存到这个键中</li>\n<li>numkeys 需要做交集&#x2F;并集的集合的个数</li>\n<li>key [key …] 具体参与交集&#x2F;并集的集合</li>\n<li>weights weight [weight …] 每个参与计算的集合的权重。在做交集&#x2F;并集计算时，每个集合中的 member 会把自己的 score 乘以这个权重，默认为 1。</li>\n<li>aggregate sum|min|max 对于各个集合中的相同元素是 sum(求和)、min(取最小值)还是max(取最大值)，默认为 sum。</li>\n</ul>\n</li>\n</ul>\n<p>比如现在有一些数据</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zadd sport:ranking:why:20210222 43243 why 2341 mx 8764 les 42321 skr</span><br><span class=\"line\">zadd sport:ranking:why:20210223 57632 why 24354 mx 4231 les 43512 skr 5341 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210224 10026 why 12344 mx 54312 les 34531 skr 43512 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210225 54312 why 32451 mx 23412 les 21341 skr 56321 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210226 3212 why 63421 mx 53652 les 45621 skr 5723 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210227 5462 why 10158 mx 30169 les 48858 skr 66079 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210228 43553 why 4451 mx 7431 les 9563 skr 8232 jay</span><br></pre></td></tr></table></figure>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/10.png\"></p>\n<p>现在我们要求出最近 7 天的排行榜，就用下面这行命令，命令有点复杂，但是对着命令格式看，还是很清晰的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zunionstore sport:ranking:why:last_seven_day 7 sport:ranking:why:20210222 sport:ranking:why:20210223 sport:ranking:why:20210224 sport:ranking:why:20210225 sport:ranking:why:20210226 sport:ranking:why:20210227 sport:ranking:why:20210228 weights 1 1 1 1 1 1 1 aggregate sum</span><br></pre></td></tr></table></figure>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/11.png\"></p>\n<p>上面用的是并集，如果我们的要求是对最近 7 天，每天都上传运动数据的人进行排序，就用交集来算。</p>\n<p>命令和上面的一致，只是把 zunionstore 修改为 zinterstore 即可。</p>\n<p>另外为了有对比，合并之后的队列名称也修改一下，命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zinterstore sport:ranking:why:last_seven_day_zinterstore 7 sport:ranking:why:20210222 sport:ranking:why:20210223 sport:ranking:why:20210224 sport:ranking:why:20210225 sport:ranking:why:20210226 sport:ranking:why:20210227 sport:ranking:why:20210228 weights 1 1 1 1 1 1 1 aggregate sum</span><br></pre></td></tr></table></figure>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/12.png\"></p>\n<p>知道最近 7 天的做法了，我们又有每一天数据，上一周、上一月、上个季度、这一年排行榜啥的不都是这个套路吗</p>\n<h3 id=\"亿级用户排行榜\"><a href=\"#亿级用户排行榜\" class=\"headerlink\" title=\"亿级用户排行榜\"></a>亿级用户排行榜</h3><h4 id=\"按段位分桶\"><a href=\"#按段位分桶\" class=\"headerlink\" title=\"按段位分桶\"></a>按段位分桶</h4><p>由于数据量比较大，所以需要类似于分成一个个小文件的思想去统计每一部分的数据</p>\n<p>比如游戏里的段位，统计国服前100，可以把王者、大师、砖石、铂金、黄金、白银、青铜 分为不同的桶，每个分段的人在不同的桶里(假设还是用zset存储用户的段位)<br>那计算全服排名即可先计算在某个段位桶的排名x,再获取这个段位桶前的所有桶的大小y1,y2…yn，排名就计算出来了x+y1+y2….yn</p>\n<h5 id=\"计算top100\"><a href=\"#计算top100\" class=\"headerlink\" title=\"计算top100\"></a>计算top100</h5><p>分桶后，直接在段位最大的桶里计算top100即可</p>\n<h4 id=\"按积分分桶\"><a href=\"#按积分分桶\" class=\"headerlink\" title=\"按积分分桶\"></a>按积分分桶</h4><p>[0-5000] [5001-10000] …..[10000000-x]</p>\n<p>这种可能会出现热点问题，比如处于0-5000区间的人会非常多（可能很多人都是没有打排位）用户的落点其实并不是均匀的，那就需要通过其他预测算法去预估每个区间的人数了</p>\n","cover":"/img/haibian.png","cover_type":"img","excerpt":"","more":"<h2 id=\"有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号-姓名，而B文件存放学号-分数，要求生成文件C，存放姓名和分数。怎么实现？\"><a href=\"#有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号-姓名，而B文件存放学号-分数，要求生成文件C，存放姓名和分数。怎么实现？\" class=\"headerlink\" title=\"有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号+姓名，而B文件存放学号+分数，要求生成文件C，存放姓名和分数。怎么实现？\"></a>有A、B两个大文件，每个文件几十G，而内存只有4G，其中A文件存放学号+姓名，而B文件存放学号+分数，要求生成文件C，存放姓名和分数。怎么实现？</h2><ul>\n<li>hash(学号)%1000，A到a0….a1000,B到b0~b1000</li>\n<li>学号相同的人一定hash到相同序号的小文件</li>\n<li>加载序号相同的小文件（比如：读取a2和b2）用map储存再按姓名+分数写入C即可</li>\n</ul>\n<h2 id=\"秒杀系统怎么设计\"><a href=\"#秒杀系统怎么设计\" class=\"headerlink\" title=\"秒杀系统怎么设计\"></a>秒杀系统怎么设计</h2><h3 id=\"秒杀存在的问题\"><a href=\"#秒杀存在的问题\" class=\"headerlink\" title=\"秒杀存在的问题\"></a>秒杀存在的问题</h3><ul>\n<li>高并发、瞬间请求量极大</li>\n<li>黄牛、黑客恶意请求</li>\n<li>链接暴露问题</li>\n<li>数据库压力问题</li>\n<li>库存不足和超卖问题</li>\n</ul>\n<h3 id=\"如何解决这些问题\"><a href=\"#如何解决这些问题\" class=\"headerlink\" title=\"如何解决这些问题\"></a>如何解决这些问题</h3><ul>\n<li>页面静态化<ul>\n<li>秒杀活动的页面，大多数内容都是固定不变的，如商品名称，商品图片等等，可以对活动页面做静态化处理，减少访问服务端的请求。秒杀用户会分布在全国各地，有的在上海，有的在深圳，地域相差很远，网速也各不相同。为了让用户最快访问到活动页面，可以使用CDN（Content Delivery Network，内容分发网络）。CDN可以让用户就近获取所需内容。</li>\n</ul>\n</li>\n<li>按钮至灰控制<ul>\n<li>秒杀活动开始前，按钮一般需要置灰的。只有时间到了，才能变得可以点击。这是防止，秒杀用户在时间快到的前几秒，疯狂请求服务器，然后秒杀时间点还没到，服务器就自己挂了。</li>\n</ul>\n</li>\n<li>服务单一职责<ul>\n<li>我们都知道微服务设计思想，也就是把各个功能模块拆分，功能那个类似的放一起，再用分布式的部署方式。</li>\n<li>如用户登录相关的，就设计个用户服务，订单相关的就搞个订单服务，再到礼物相关的就搞个礼物服务等等。那么，秒杀相关的业务逻辑也可以放到一起，搞个秒杀服务，单独给它搞个秒杀数据库。</li>\n<li>服务单一职责有个好处：如果秒杀没抗住高并发的压力，秒杀库崩了，服务挂了，也不会影响到系统的其他服务。</li>\n</ul>\n</li>\n<li>秒杀链接加盐<ul>\n<li>链接如果明文暴露的话，会有人获取到请求Url，提前秒杀了。因此，需要给秒杀链接加盐。可以把URL动态化，如通过MD5加密算法加密随机的字符串去做url。</li>\n</ul>\n</li>\n<li>限流<ul>\n<li>一般有两种方式限流：nginx限流和redis限流。</li>\n<li>为了防止某个用户请求过于频繁，我们可以对同一用户限流；</li>\n<li>为了防止黄牛模拟几个用户请求，我们可以对某个IP进行限流；</li>\n<li>为了防止有人使用代理，每次请求都更换IP请求，我们可以对接口进行限流。</li>\n<li>为了防止瞬时过大的流量压垮系统，还可以使用阿里的Sentinel、Hystrix组件进行限流。</li>\n</ul>\n</li>\n<li>分布式锁<ul>\n<li>可以使用redis分布式锁解决超卖问题。</li>\n<li>使用Redis的SET EX PX NX + 校验唯一随机值,再删除释放锁。</li>\n<li>为了更严谨，一般也是用lua脚本代替。lua脚本如下：</li>\n</ul>\n</li>\n<li>MQ异步处理<ul>\n<li>如果瞬间流量特别大，可以使用消息队列削峰，异步处理。用户请求过来的时候，先放到消息队列，再拿出来消费。</li>\n</ul>\n</li>\n<li>限流&amp;降级&amp;熔断<ul>\n<li>限流，就是限制请求，防止过大的请求压垮服务器；</li>\n<li>降级，就是秒杀服务有问题了，就降级处理，不要影响别的服务；</li>\n<li>熔断，服务有问题就熔断，一般熔断降级是一起出现。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"产品上线出问题怎么定位错误\"><a href=\"#产品上线出问题怎么定位错误\" class=\"headerlink\" title=\"产品上线出问题怎么定位错误\"></a>产品上线出问题怎么定位错误</h2><ul>\n<li>复现问题</li>\n<li>top jstack</li>\n</ul>\n<h2 id=\"大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案\"><a href=\"#大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案\" class=\"headerlink\" title=\"大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案\"></a>大量并发查询用户商品信息，MySQL压力大查询慢，保证速度怎么优化方案</h2><p>读写分离</p>\n<h2 id=\"海量日志数据，提取出某日访问百度次数最多的那个IP。\"><a href=\"#海量日志数据，提取出某日访问百度次数最多的那个IP。\" class=\"headerlink\" title=\"海量日志数据，提取出某日访问百度次数最多的那个IP。\"></a>海量日志数据，提取出某日访问百度次数最多的那个IP。</h2><ul>\n<li>可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址</li>\n<li>对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址</li>\n<li>可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；</li>\n</ul>\n<h2 id=\"给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？\"><a href=\"#给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？\" class=\"headerlink\" title=\"给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？\"></a>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</h2><h3 id=\"方案1\"><a href=\"#方案1\" class=\"headerlink\" title=\"方案1\"></a>方案1</h3><ul>\n<li>遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。</li>\n<li>遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</li>\n<li>求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</li>\n</ul>\n<h3 id=\"方案2\"><a href=\"#方案2\" class=\"headerlink\" title=\"方案2\"></a>方案2</h3><p>如果允许有一定的误差，使用布隆过滤器</p>\n<h2 id=\"一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash-x-1000分为小文件再分别加载小文件到内存中处理即可\"><a href=\"#一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash-x-1000分为小文件再分别加载小文件到内存中处理即可\" class=\"headerlink\" title=\"一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash(x)%1000分为小文件再分别加载小文件到内存中处理即可\"></a>一般内存不足而需要分析的数据又很大的问题都可以使用分治的思想，将数据hash(x)%1000分为小文件再分别加载小文件到内存中处理即可</h2><h2 id=\"如何保证接口的幂等性\"><a href=\"#如何保证接口的幂等性\" class=\"headerlink\" title=\"如何保证接口的幂等性\"></a>如何保证接口的幂等性</h2><h3 id=\"什么是幂等性\"><a href=\"#什么是幂等性\" class=\"headerlink\" title=\"什么是幂等性\"></a>什么是幂等性</h3><p>幂等性是系统服务对外一种承诺，承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。</p>\n<h3 id=\"什么情况下需要幂等\"><a href=\"#什么情况下需要幂等\" class=\"headerlink\" title=\"什么情况下需要幂等\"></a>什么情况下需要幂等</h3><p>以SQL为例：</p>\n<ul>\n<li>SELECT col1 FROM tab1 WHER col2&#x3D;2，无论执行多少次都不会改变状态，是天然的幂等。</li>\n<li>UPDATE tab1 SET col1&#x3D;1 WHERE col2&#x3D;2，无论执行成功多少次状态都是一致的，因此也是幂等操作。</li>\n<li>UPDATE tab1 SET col1&#x3D;col1+1 WHERE col2&#x3D;2，每次执行的结果都会发生变化，这种不是幂等的。</li>\n<li>insert into user(userid,name) values(1,’a’) 如userid为唯一主键，即重复操作上面的业务，只会插入一条用户数据，具备幂等性。<ul>\n<li>如userid不是主键，可以重复，那上面业务多次操作，数据都会新增多条，不具备幂等性。</li>\n</ul>\n</li>\n<li>delete from user where userid&#x3D;1，多次操作，结果一样，具备幂等性</li>\n</ul>\n<h3 id=\"如何保证幂等\"><a href=\"#如何保证幂等\" class=\"headerlink\" title=\"如何保证幂等\"></a>如何保证幂等</h3><h4 id=\"1、token机制\"><a href=\"#1、token机制\" class=\"headerlink\" title=\"1、token机制\"></a>1、token机制</h4><ul>\n<li>服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，服务器会把token保存到redis中。</li>\n<li>然后调用业务接口请求时，把token携带过去，一般放在请求头部。</li>\n<li>服务器判断token是否存在redis中，存在表示第一次请求，然后删除token,继续执行业务。</li>\n<li>如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不被重复执行。</li>\n</ul>\n<p><strong>关键点 先删除token，还是后删除token。</strong></p>\n<p>后删除token：如果进行业务处理成功后，删除redis中的token失败了，这样就导致了有可能会发生重复请求，因为token没有被删除。这个问题其实是数据库和缓存redis数据不一致问题，后续会写文章进行讲解。</p>\n<p>先删除token：如果系统出现问题导致业务处理出现异常，业务处理没有成功，接口调用方也没有获取到明确的结果，然后进行重试，但token已经删除掉了，服务端判断token不存在，认为是重复请求，就直接返回了，无法进行业务处理了。</p>\n<p>先删除token可以保证不会因为重复请求，业务数据出现问题。出现业务异常，可以让调用方配合处理一下，重新获取新的token，再次由业务调用方发起重试请求就ok了。</p>\n<p><strong>token机制缺点</strong></p>\n<p>业务请求每次请求，都会有额外的请求（一次获取token请求、判断token是否存在的业务）。其实真实的生产环境中，1万请求也许只会存在10个左右的请求会发生重试，为了这10个请求，我们让9990个请求都发生了额外的请求。</p>\n<h4 id=\"2、乐观锁机制\"><a href=\"#2、乐观锁机制\" class=\"headerlink\" title=\"2、乐观锁机制\"></a>2、乐观锁机制</h4><ul>\n<li>这种方法适合在更新的场景中，update t_goods set count &#x3D; count -1 , version &#x3D; version + 1 where good_id&#x3D;2 and version &#x3D; 1</li>\n<li>根据version版本，也就是在操作库存前先获取当前商品的version版本号，然后操作的时候带上此version号。我们梳理下，我们第一次操作库存时，得到version为1，调用库存服务version变成了2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传如的version还是1，再执行上面的sql语句时，就不会执行；因为version已经变为2了，where条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。</li>\n<li>乐观锁主要使用于处理读多写少的问题</li>\n</ul>\n<h4 id=\"3、唯一主键\"><a href=\"#3、唯一主键\" class=\"headerlink\" title=\"3、唯一主键\"></a>3、唯一主键</h4><p>这个机制是利用了数据库的主键唯一约束的特性，解决了在insert场景时幂等问题。但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。</p>\n<p>如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关</p>\n<h4 id=\"4、防重表\"><a href=\"#4、防重表\" class=\"headerlink\" title=\"4、防重表\"></a>4、防重表</h4><p>使用订单号orderNo做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。</p>\n<h4 id=\"5、唯一ID\"><a href=\"#5、唯一ID\" class=\"headerlink\" title=\"5、唯一ID\"></a>5、唯一ID</h4><p>调用接口时，生成一个唯一id，redis将数据保存到集合中（去重），存在即处理过。</p>\n<h2 id=\"缓存和数据库不一致问题\"><a href=\"#缓存和数据库不一致问题\" class=\"headerlink\" title=\"缓存和数据库不一致问题\"></a>缓存和数据库不一致问题</h2><h3 id=\"更新缓存和更新数据库\"><a href=\"#更新缓存和更新数据库\" class=\"headerlink\" title=\"更新缓存和更新数据库\"></a>更新缓存和更新数据库</h3><p>大部分观点认为，做缓存不应该是去更新缓存，而是应该删除缓存，然后由下个请求去去缓存，发现不存在后再读取数据库，写入缓存。观点引用：《分布式之数据库和缓存双写一致性方案解析》孤独烟</p>\n<p>原因一：线程安全角度同时有请求A和请求B进行更新操作，那么会出现（1）线程A更新了数据库（2）线程B更新了数据库（3）线程B更新了缓存（4）线程A更新了缓存这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p>\n<p>原因二：业务场景角度有如下两点：</p>\n<ol>\n<li>如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。</li>\n<li>如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</li>\n</ol>\n<h3 id=\"删缓存和更新数据库\"><a href=\"#删缓存和更新数据库\" class=\"headerlink\" title=\"删缓存和更新数据库\"></a>删缓存和更新数据库</h3><h4 id=\"先删缓存，再更新数据库\"><a href=\"#先删缓存，再更新数据库\" class=\"headerlink\" title=\"先删缓存，再更新数据库\"></a>先删缓存，再更新数据库</h4><p>该方案会导致请求数据不一致同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p>\n<ol>\n<li>请求A进行写操作，删除缓存</li>\n<li>请求B查询发现缓存不存在</li>\n<li>请求B去数据库查询得到旧值</li>\n<li>请求B将旧值写入缓存</li>\n<li>请求A将新值写入数据库上述情况就会导致不一致的情形出现。<br>而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</li>\n</ol>\n<h4 id=\"先更新数据库，再删缓存\"><a href=\"#先更新数据库，再删缓存\" class=\"headerlink\" title=\"先更新数据库，再删缓存\"></a>先更新数据库，再删缓存</h4><p>这种情况不存在并发问题么？不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p>\n<ol>\n<li>缓存刚好失效</li>\n<li>请求A查询数据库，得一个旧值</li>\n<li>请求B将新值写入数据库</li>\n<li>请求B删除缓存</li>\n<li>请求A将查到的旧值写入缓存ok，如果发生上述情况，确实是会发生脏数据。 然而，发生这种情况的概率又有多少呢？发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。</li>\n</ol>\n<p>先更新数据库，再删缓存依然会有问题，不过，问题出现的可能性会因为上面说的原因，变得比较低！(补充说明：我用了“先更新数据库，再删缓存”且不设过期时间策略，会不会有问题呢？由于先缓存和更新数据库不是原子的，如果更新了数据库，程序歇逼，就没删缓存，由于没有过期策略，就永远脏数据了。)所以，如果你想实现基础的缓存数据库双写一致的逻辑，那么在大多数情况下，在不想做过多设计，增加太大工作量的情况下，请先更新数据库，再删缓存!</p>\n<h3 id=\"数据库和缓存数据强一致怎么办\"><a href=\"#数据库和缓存数据强一致怎么办\" class=\"headerlink\" title=\"数据库和缓存数据强一致怎么办\"></a>数据库和缓存数据强一致怎么办</h3><p>没有办法做到绝对的一致性，这是由CAP理论决定的，缓存系统适用的场景就是非强一致性的场景，所以它属于CAP中的AP。所以，我们得委曲求全，可以去做到BASE理论中说的最终一致性。</p>\n<p>大佬们给出了到达最终一致性的解决思路，主要是针对上面两种双写策略（先删缓存，再更新数据库&#x2F;先更新数据库，再删缓存）导致的脏数据问题，进行相应的处理，来保证最终一致性。</p>\n<h4 id=\"缓存延时双删\"><a href=\"#缓存延时双删\" class=\"headerlink\" title=\"缓存延时双删\"></a>缓存延时双删</h4><p>步骤</p>\n<ol>\n<li>先删除缓存</li>\n<li>再写数据库</li>\n<li>休眠500毫秒（根据具体的业务时间来定）</li>\n<li>再次删除缓存。</li>\n</ol>\n<h4 id=\"那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？\"><a href=\"#那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？\" class=\"headerlink\" title=\"那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？\"></a>那么，这个休眠500毫秒怎么确定的，具体该休眠多久呢？</h4><p>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>\n<h4 id=\"如果你用了mysql的读写分离架构怎么办？\"><a href=\"#如果你用了mysql的读写分离架构怎么办？\" class=\"headerlink\" title=\"如果你用了mysql的读写分离架构怎么办？\"></a>如果你用了mysql的读写分离架构怎么办？</h4><p>ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。</p>\n<ol>\n<li>请求A进行写操作，删除缓存</li>\n<li>请求A将数据写入数据库了，</li>\n<li>请求B查询缓存发现，缓存没有值</li>\n<li>请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</li>\n<li>请求B将旧值写入缓存</li>\n<li>数据库完成主从同步，从库变为新值上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。</li>\n</ol>\n<h4 id=\"采用这种同步淘汰策略，吞吐量降低怎么办？\"><a href=\"#采用这种同步淘汰策略，吞吐量降低怎么办？\" class=\"headerlink\" title=\"采用这种同步淘汰策略，吞吐量降低怎么办？\"></a>采用这种同步淘汰策略，吞吐量降低怎么办？</h4><p>ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。</p>\n<h4 id=\"删缓存失败了怎么办：重试机制\"><a href=\"#删缓存失败了怎么办：重试机制\" class=\"headerlink\" title=\"删缓存失败了怎么办：重试机制\"></a>删缓存失败了怎么办：重试机制</h4><p>看似问题都已经解决了，但其实，还有一个问题没有考虑到，那就是删除缓存的操作，失败了怎么办？比如延时双删的时候，第二次缓存删除失败了，那不还是没有清除脏数据吗？解决方案就是再加上一个重试机制，保证删除缓存成功</p>\n<p>流程如下所示</p>\n<ol>\n<li>更新数据库数据；</li>\n<li>缓存因为种种问题删除失败</li>\n<li>将需要删除的key发送至消息队列</li>\n<li>自己消费消息，获得需要删除的key</li>\n<li>继续重试删除操作，直到成功然而，</li>\n</ol>\n<p>该方案有一个缺点，对业务线代码造成大量的侵入。</p>\n<p>于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作</p>\n<h4 id=\"binlog\"><a href=\"#binlog\" class=\"headerlink\" title=\"binlog\"></a>binlog</h4><p>流程如下所示</p>\n<ol>\n<li>更新数据库数据</li>\n<li>数据库会将操作信息写入binlog日志当中</li>\n<li>订阅程序提取出所需要的数据以及key</li>\n<li>另起一段非业务代码，获得该信息</li>\n<li>尝试删除缓存操作，发现删除失败</li>\n<li>将这些信息发送至消息队列</li>\n<li>重新从消息队列中获得该数据，重试操作。</li>\n</ol>\n<h2 id=\"什么是SPI\"><a href=\"#什么是SPI\" class=\"headerlink\" title=\"什么是SPI\"></a>什么是SPI</h2><p>SPI 全称为 (Service Provider Interface) ，是JDK内置的一种服务提供发现机制</p>\n<h3 id=\"SPI-实践\"><a href=\"#SPI-实践\" class=\"headerlink\" title=\"SPI 实践\"></a>SPI 实践</h3><p>接下来我们来如何来利用 SPI 实现刚才提到的可拔插 IOC 容器。</p>\n<p>既然刚才都提到了 SPI 的本质就是面向接口编程，所以自然我们首先需要定义一个接口：</p>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/1.png\" alt=\"SPI图\"></p>\n<p>其中包含了一些 Bean 容器所必须的操作：注册、获取、释放 bean。</p>\n<p>为了让其他人也能实现自己的 IOC 容器，所以我们将这个接口单独放到一个 Module 中，可供他人引入实现。</p>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/2.png\"></p>\n<p>所以当我要实现一个单例的 IOC 容器时，我只需要新建一个 Module 然后引入刚才的模块并实现 CicadaBeanFactory 接口即可。</p>\n<p>当然其中最重要的则是需要在 resources 目录下新建一个 META-INF&#x2F;services&#x2F;top.crossoverjie.cicada.base.bean.CicadaBeanFactory 文件，文件名必须得是我们之前定义接口的全限定名（SPI 规范）。<br><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/3.png\"></p>\n<p>其中的内容便是我们自己实现类的全限定名：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">top.crossoverjie.cicada.bean.ioc.CicadaIoc</span><br></pre></td></tr></table></figure>\n<p>可以想象最终会通过这里的全限定名来反射创建对象。</p>\n<p>只不过这个过程 Java 已经提供 API 屏蔽掉了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CicadaBeanFactory <span class=\"title function_\">getCicadaBeanFactory</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    ServiceLoader&lt;CicadaBeanFactory&gt; cicadaBeanFactories = ServiceLoader.load(CicadaBeanFactory.class);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cicadaBeanFactories.iterator().hasNext())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cicadaBeanFactories.iterator().next() ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CicadaDefaultBean</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 classpath 中存在我们刚才的实现类（引入实现类的 jar 包），便可以通过 java.util.ServiceLoader 工具类来找到所有的实现类（可以有多个实现类同时存在，只不过通常我们只需要一个）。</p>\n<p>一些都准备好之后，使用自然就非常简单了。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>top.crossoverjie.opensource<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>cicada-ioc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我们只需要引入这个依赖便能使用它的实现，当我们想换一种实现方式时只需要更换一个依赖即可。</p>\n<p>这样就做到了不修改一行代码灵活的可拔插选择 IOC 容器了。</p>\n<p>SPI 的一些其他应用</p>\n<p>MySQL 的驱动包也是利用 SPI 来实现自己的连接逻辑。</p>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/4.png\"></p>\n<p>总结来说：</p>\n<ul>\n<li>提供一个接口</li>\n<li>在resource下新建META-INF&#x2F;services目录，在目录下新建接口的全限定名文件</li>\n<li>服务方实现接口</li>\n<li>调用ServiceLoad.load()</li>\n</ul>\n<h2 id=\"什么是RPC？\"><a href=\"#什么是RPC？\" class=\"headerlink\" title=\"什么是RPC？\"></a>什么是RPC？</h2><p>RPC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务</p>\n<ol>\n<li>首先客户端需要告诉服务器，需要调用的函数，这里函数和进程ID存在一个映射，客户端远程调用时，需要查一下函数，找到对应的ID，然后执行函数的代码。</li>\n<li>客户端需要把本地参数传给远程函数，本地调用的过程中，直接压栈即可，但是在远程调用过程中不再同一个内存里，无法直接传递函数的参数，因此需要客户端把参数转换成字节流，传给服务端，然后服务端将字节流转换成自身能读取的格式，是一个序列化和反序列化的过程。</li>\n<li>数据准备好了之后，如何进行传输？网络传输层需要把调用的ID和序列化后的参数传给服务端，然后把计算好的结果序列化传给客户端，因此TCP层即可完成上述过程，gRPC中采用的是HTTP2协议。</li>\n</ol>\n<p>总结一下：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">// Client端 </span><br><span class=\"line\">//    Student student = Call(ServerAddr, addAge, student)</span><br><span class=\"line\">1. 将这个调用映射为Call ID。</span><br><span class=\"line\">2. 将Call ID，student（params）序列化，以二进制形式打包</span><br><span class=\"line\">3. 把2中得到的数据包发送给ServerAddr，这需要使用网络传输层</span><br><span class=\"line\">4. 等待服务器返回结果</span><br><span class=\"line\">5. 如果服务器调用成功，那么就将结果反序列化，并赋给student，年龄更新</span><br><span class=\"line\"></span><br><span class=\"line\">// Server端</span><br><span class=\"line\">1. 在本地维护一个Call ID到函数指针的映射call_id_map，可以用Map&lt;String, Method&gt; callIdMap</span><br><span class=\"line\">2. 等待客户端请求</span><br><span class=\"line\">3. 得到一个请求后，将其数据包反序列化，得到Call ID</span><br><span class=\"line\">4. 通过在callIdMap中查找，得到相应的函数指针</span><br><span class=\"line\">5. 将student（params）反序列化后，在本地调用addAge()函数，得到结果</span><br><span class=\"line\">6. 将student结果序列化后通过网络返回给Client</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在微服务的设计中，一个服务A如果访问另一个Module下的服务B，可以采用HTTP REST传输数据，并在两个服务之间进行序列化和反序列化操作，服务B把执行结果返回过来。</li>\n<li>由于HTTP在应用层中完成，整个通信的代价较高，远程过程调用中直接基于TCP进行远程调用，数据传输在传输层TCP层完成，更适合对效率要求比较高的场景，RPC主要依赖于客户端和服务端之间建立Socket链接进行，底层实现比REST更复杂。</li>\n</ul>\n<h3 id=\"RPC-demo\"><a href=\"#RPC-demo\" class=\"headerlink\" title=\"RPC demo\"></a>RPC demo</h3><p>客户端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RPCClient</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T <span class=\"title function_\">getRemoteProxyObj</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;?&gt; serviceInterface, <span class=\"keyword\">final</span> InetSocketAddress addr)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.将本地的接口调用转换成JDK的动态代理，在动态代理中实现接口的远程调用</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(serviceInterface.getClassLoader(), <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>&lt;?&gt;[]&#123;serviceInterface&#125;,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                        <span class=\"type\">Socket</span> <span class=\"variable\">socket</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">output</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">input</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 2.创建Socket客户端，根据指定地址连接远程服务提供者</span></span><br><span class=\"line\">                            socket = <span class=\"keyword\">new</span> <span class=\"title class_\">Socket</span>();</span><br><span class=\"line\">                            socket.connect(addr);</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"comment\">// 3.将远程服务调用所需的接口类、方法名、参数列表等编码后发送给服务提供者</span></span><br><span class=\"line\">                            output = <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(socket.getOutputStream());</span><br><span class=\"line\">                            output.writeUTF(serviceInterface.getName());</span><br><span class=\"line\">                            output.writeUTF(method.getName());</span><br><span class=\"line\">                            output.writeObject(method.getParameterTypes());</span><br><span class=\"line\">                            output.writeObject(args);</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"comment\">// 4.同步阻塞等待服务器返回应答，获取应答后返回</span></span><br><span class=\"line\">                            input = <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(socket.getInputStream());</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> input.readObject();</span><br><span class=\"line\">                        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (socket != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                                socket.close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (output != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                                output.close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (input != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                                input.close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>服务端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceCenter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Server</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">ExecutorService</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HashMap&lt;String, Class&gt; serviceRegistry = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, Class&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"variable\">isRunning</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ServiceCenter</span><span class=\"params\">(<span class=\"type\">int</span> port)</span>&#123;</span><br><span class=\"line\">        ServiceCenter.port = port;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">ServerSocket</span> <span class=\"variable\">server</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerSocket</span>();</span><br><span class=\"line\">        server.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(port));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Server Start .....&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">                executor.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">ServiceTask</span>(server.accept()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            server.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(Class serviceInterface, Class impl)</span> &#123;</span><br><span class=\"line\">        serviceRegistry.put(serviceInterface.getName(), impl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isRunning</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isRunning;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getPort</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> port;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        isRunning = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        executor.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceTask</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Socket</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">ServiceTask</span><span class=\"params\">(Socket client)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.client = client;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">input</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">output</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                input = <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(client.getInputStream());</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">serviceName</span> <span class=\"operator\">=</span> input.readUTF();</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">methodName</span> <span class=\"operator\">=</span> input.readUTF();</span><br><span class=\"line\">                Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[]) input.readObject();</span><br><span class=\"line\">                Object[] arguments = (Object[]) input.readObject();</span><br><span class=\"line\">                <span class=\"type\">Class</span> <span class=\"variable\">serviceClass</span> <span class=\"operator\">=</span> serviceRegistry.get(serviceName);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(serviceClass == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassNotFoundException</span>(serviceName + <span class=\"string\">&quot;not found!&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> serviceClass.getMethod(methodName, parameterTypes);</span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(serviceClass.newInstance(), arguments);</span><br><span class=\"line\"></span><br><span class=\"line\">                output = <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(client.getOutputStream());</span><br><span class=\"line\">                output.writeObject(result);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(output!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                        output.close();</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (input != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        input.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (client != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        client.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceProducerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ServiceProducer</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">sendData</span><span class=\"params\">(String data)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;I am service producer!!!, the data is &quot;</span>+ data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RPCTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">Server</span> <span class=\"variable\">serviceServer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceCenter</span>(<span class=\"number\">8088</span>);</span><br><span class=\"line\">                    serviceServer.register(ServiceProducer.class, ServiceProducerImpl.class);</span><br><span class=\"line\">                    serviceServer.start();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        <span class=\"type\">ServiceProducer</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> RPCClient.getRemoteProxyObj(ServiceProducer.class, <span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8088</span>));</span><br><span class=\"line\">        System.out.println(service.sendData(<span class=\"string\">&quot;test&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h2><h3 id=\"gRPC与REST\"><a href=\"#gRPC与REST\" class=\"headerlink\" title=\"gRPC与REST\"></a>gRPC与REST</h3><ul>\n<li>REST通常以业务为导向，将业务对象上执行的操作映射到HTTP动词，格式非常简单，可以使用浏览器进行扩展和传输，通过JSON数据完成客户端和服务端之间的消息通信，直接支持请求&#x2F;响应方式的通信。不需要中间的代理，简化了系统的架构，不同系统之间只需要对JSON进行解析和序列化即可完成数据的传递。</li>\n<li>但是REST也存在一些弊端，比如只支持请求&#x2F;响应这种单一的通信方式，对象和字符串之间的序列化操作也会影响消息传递速度，客户端需要通过服务发现的方式，知道服务实例的位置，在单个请求获取多个资源时存在着挑战，而且有时候很难将所有的动作都映射到HTTP动词。</li>\n<li>正是因为REST面临一些问题，因此可以采用gRPC作为一种替代方案，gRPC 是一种基于二进制流的消息协议，可以采用基于Protocol Buffer的IDL定义grpc API,这是Google公司用于序列化结构化数据提供的一套语言中立的序列化机制，客户端和服务端使用HTTP&#x2F;2以Protocol Buffer格式交换二进制消息。</li>\n<li>gRPC的优势是，设计复杂更新操作的API非常简单，具有高效紧凑的进程通信机制，在交换大量消息时效率高，远程过程调用和消息传递时可以采用双向的流式消息方式，同时客户端和服务端支持多种语言编写，互操作性强；不过gRPC的缺点是不方便与JavaScript集成，某些防火墙不支持该协议。</li>\n<li>注册中心：当项目中有很多服务时，可以把所有的服务在启动的时候注册到一个注册中心里面，用于维护服务和服务器之间的列表，当注册中心接收到客户端请求时，去找到该服务是否远程可以调用，如果可以调用需要提供服务地址返回给客户端，客户端根据返回的地址和端口，去调用远程服务端的方法，执行完成之后将结果返回给客户端。这样在服务端加新功能的时候，客户端不需要直接感知服务端的方法，服务端将更新之后的结果在注册中心注册即可，而且当修改了服务端某些方法的时候，或者服务降级服务多机部署想实现负载均衡的时候，我们只需要更新注册中心的服务群即可。<br><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/5.png\"></li>\n</ul>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><p>这里使用SpringBoot+gRPC的形式实现RPC调用过程 项目结构分为三部分：client、grpc、server</p>\n<h4 id=\"grpc\"><a href=\"#grpc\" class=\"headerlink\" title=\"grpc\"></a>grpc</h4><p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/6.png\"></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>io.grpc<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>grpc-all<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">extensions</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">extension</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>kr.motd.maven<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>os-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.4.1.Final<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">extension</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">extensions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>protobuf-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.5.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">pluginId</span>&gt;</span>grpc-java<span class=\"tag\">&lt;/<span class=\"name\">pluginId</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.0.2:exe:$&#123;os.detected.classifier&#125;<span class=\"tag\">&lt;/<span class=\"name\">protocArtifact</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:1.2.0:exe:$&#123;os.detected.classifier&#125;<span class=\"tag\">&lt;/<span class=\"name\">pluginArtifact</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>compile-custom<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>创建.proto文件</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">&quot;proto3&quot;</span>;   <span class=\"comment\">// 语法版本</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// stub选项</span></span><br><span class=\"line\"><span class=\"keyword\">option</span> java_package = <span class=\"string\">&quot;com.shgx.grpc.api&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">option</span> java_outer_classname = <span class=\"string\">&quot;RPCDateServiceApi&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">option</span> java_multiple_files = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义包名</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.shgx.grpc.api;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 服务接口定义，服务端和客户端都要遵守该接口进行通信</span></span><br><span class=\"line\"><span class=\"keyword\">service </span><span class=\"title class_\">RPCDateService</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">rpc</span> getDate (RPCDateRequest) <span class=\"keyword\">returns</span> (RPCDateResponse) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义消息（请求）</span></span><br><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">RPCDateRequest</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">string</span> userName = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义消息（响应）</span></span><br><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">RPCDateResponse</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">string</span> serverDate = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mvn complie</p>\n<p>生成代码：<br><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/7.png\"></p>\n<h4 id=\"client\"><a href=\"#client\" class=\"headerlink\" title=\"client\"></a>client</h4><p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/8.png\"></p>\n<p>根据gRPC中的项目配置在client和server两个Module的pom.xml添加依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.shgx<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>grpc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>编写GRPCClient</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GRPCClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">host</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;localhost&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">serverPort</span> <span class=\"operator\">=</span> <span class=\"number\">9999</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">( String[] args )</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">ManagedChannel</span> <span class=\"variable\">managedChannel</span> <span class=\"operator\">=</span> ManagedChannelBuilder.forAddress( host, serverPort ).usePlaintext().build();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            RPCDateServiceGrpc.<span class=\"type\">RPCDateServiceBlockingStub</span> <span class=\"variable\">rpcDateService</span> <span class=\"operator\">=</span> RPCDateServiceGrpc.newBlockingStub( managedChannel );</span><br><span class=\"line\">            <span class=\"type\">RPCDateRequest</span> <span class=\"variable\">rpcDateRequest</span> <span class=\"operator\">=</span> RPCDateRequest</span><br><span class=\"line\">                    .newBuilder()</span><br><span class=\"line\">                    .setUserName(<span class=\"string\">&quot;shgx&quot;</span>)</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">            <span class=\"type\">RPCDateResponse</span> <span class=\"variable\">rpcDateResponse</span> <span class=\"operator\">=</span> rpcDateService.getDate( rpcDateRequest );</span><br><span class=\"line\">            System.out.println( rpcDateResponse.getServerDate() );</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            managedChannel.shutdown();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"server\"><a href=\"#server\" class=\"headerlink\" title=\"server\"></a>server</h4><p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/9.png\"></p>\n<p>按照2.2.3 client的方式添加依赖</p>\n<p>创建RPCDateServiceImpl</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RPCDateServiceImpl</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">RPCDateServiceGrpc</span>.RPCDateServiceImplBase&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getDate</span><span class=\"params\">(RPCDateRequest request, StreamObserver&lt;RPCDateResponse&gt; responseObserver)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RPCDateResponse</span> <span class=\"variable\">rpcDateResponse</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        Date now=<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\">        <span class=\"type\">SimpleDateFormat</span> <span class=\"variable\">simpleDateFormat</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleDateFormat</span>(<span class=\"string\">&quot;今天是&quot;</span>+<span class=\"string\">&quot;yyyy年MM月dd日 E kk点mm分&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">nowTime</span> <span class=\"operator\">=</span> simpleDateFormat.format( now );</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            rpcDateResponse = RPCDateResponse</span><br><span class=\"line\">                    .newBuilder()</span><br><span class=\"line\">                    .setServerDate( <span class=\"string\">&quot;Welcome &quot;</span> + request.getUserName()  + <span class=\"string\">&quot;, &quot;</span> + nowTime )</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            responseObserver.onError(e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            responseObserver.onNext( rpcDateResponse );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        responseObserver.onCompleted();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建GRPCServer</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GRPCServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">port</span> <span class=\"operator\">=</span> <span class=\"number\">9999</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">( String[] args )</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Server</span> <span class=\"variable\">server</span> <span class=\"operator\">=</span> ServerBuilder.</span><br><span class=\"line\">                forPort(port)</span><br><span class=\"line\">                .addService( <span class=\"keyword\">new</span> <span class=\"title class_\">RPCDateServiceImpl</span>() )</span><br><span class=\"line\">                .build().start();</span><br><span class=\"line\">        System.out.println( <span class=\"string\">&quot;grpc服务端启动成功, 端口=&quot;</span> + port );</span><br><span class=\"line\">        server.awaitTermination();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"一个优秀的RPC框架需要考虑的问题\"><a href=\"#一个优秀的RPC框架需要考虑的问题\" class=\"headerlink\" title=\"一个优秀的RPC框架需要考虑的问题\"></a>一个优秀的RPC框架需要考虑的问题</h2><ol>\n<li><code>微服务化</code>应用都基于微服务化，实现资源调用离不开远程调用</li>\n<li><code>多实例问题</code> 一个服务可能有多个实例，你在调用时，要如何获取这些实例的地址呢？— 这时候就需要一个服务注册中心，从服务注册中心获取服务的实例列表，再从中选择一个进行调用。</li>\n<li><code>负载均衡</code> 选哪个调用好呢？这时候就需要负载均衡了，于是又得考虑如何实现复杂均衡</li>\n<li><code>缓存</code> 总不能每次调用时都去注册中心查询实例列表吧，这样效率多低呀，于是又有了缓存，有了缓存，就要考虑缓存的更新问题</li>\n<li><code>异步调用</code> 客户端总不能每次调用完都干等着服务端返回数据吧,于是就要支持异步调用;<ul>\n<li>Future实现</li>\n</ul>\n</li>\n<li><code>版本控制</code> 服务端的接口修改了，老的接口还有人在用，怎么办？总不能让他们都改了吧？这就需要版本控制了；</li>\n<li><code>线程池</code> 服务端总不能每次接到请求都马上启动一个线程去处理吧？于是就需要线程池；</li>\n<li><code>未处理完的请求</code> 服务端关闭时，还没处理完的请求怎么办？是直接结束呢，还是等全部请求处理完再关闭呢？</li>\n</ol>\n<h2 id=\"什么是DDD？\"><a href=\"#什么是DDD？\" class=\"headerlink\" title=\"什么是DDD？\"></a>什么是DDD？</h2><h3 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h3><p>要说DDD，不得不先看看MVC，我相信基本上99%的java开发读者，不管你是计科专业出身还是跨专业，初学spring或者springboot的时候，接触到的代码分层都是MVC<br>这说明了MVC有它自身独有的优势：</p>\n<ul>\n<li>开发人员可以只关注整个结构中的其中某一层；</li>\n<li>可以很容易的用新的实现来替换原有层次的实现；</li>\n<li>可以降低层与层之间的依赖；</li>\n<li>有利于标准化；</li>\n<li>利于各层逻辑的复用。</li>\n</ul>\n<p>但是真实情况是这样吗？随着你系统功能迭代，业务逻辑越来越复杂之后。MVC三层中，V层作为数据载体，C层作为逻辑路由都是很薄的一层，大量的代码都堆积在了M层（模型层）。一个service的类，动辄几百上千行，大的甚至几万行，逻辑嵌套复杂，主业务逻辑不清晰。service做的稍微轻量化一点的，代码就像是胶水，把数据库执行逻辑与控制返回给前端的逻辑胶在一起，主次不清晰。<br>一看你的工程，类啊，代码量啊都不少，你甚至不知道如何入手去修改“屎山”一样的代码。</p>\n<h3 id=\"那么DDD为什么可以去解决以上的问题呢？\"><a href=\"#那么DDD为什么可以去解决以上的问题呢？\" class=\"headerlink\" title=\"那么DDD为什么可以去解决以上的问题呢？\"></a>那么DDD为什么可以去解决以上的问题呢？</h3><p>DDD核心思想是什么呢？解耦！让业务不是像炒大锅饭一样混在一起，而是一道道工序复杂的美食，都有他们自己独立的做法。</p>\n<p>DDD的价值观里面，任何业务都是某个业务领域模型的职责体现。A领域只会去做A领域的事情，A领域想去修改B领域，需要找中介（防腐层）去对B领域完成操作。我想完成一个很长的业务逻辑动作，在划分好业务边界之后，交给业务服务的编排者（应用服务）去组织业务模型（聚合）完成逻辑。</p>\n<p>这样，每个服务（领域）只会做自己业务边界内的事情，最小细粒度的去定义需求的实现。原先空空的贫血模型摇身一变变成了充血模型。原理冗长的service里面类似到处set，get值这种与业务逻辑无关的数据载体包装代码，都会被去除，进到应用服务层，你的代码就是你的业务逻辑。逻辑清晰，可维护性高！</p>\n<h3 id=\"什么样的系统适配DDD\"><a href=\"#什么样的系统适配DDD\" class=\"headerlink\" title=\"什么样的系统适配DDD\"></a>什么样的系统适配DDD</h3><p>中小规模的系统，本身业务体量小，功能单一，选择mvc架构无疑是最好的。 项目化交付的系统，研发周期短，一天到晚按照甲方的需求定制功能。</p>\n<p>中大规模系统，产品化模式，业务可持续迭代，可预见的业务逻辑复杂性的系统。</p>\n<h3 id=\"DDD的代码怎么做\"><a href=\"#DDD的代码怎么做\" class=\"headerlink\" title=\"DDD的代码怎么做\"></a>DDD的代码怎么做</h3><p>&#x2F;&#x2F; TODO</p>\n<h2 id=\"Java实现生产者消费者\"><a href=\"#Java实现生产者消费者\" class=\"headerlink\" title=\"Java实现生产者消费者\"></a>Java实现生产者消费者</h2><h3 id=\"wait-和notify-方法的实现\"><a href=\"#wait-和notify-方法的实现\" class=\"headerlink\" title=\"wait()和notify()方法的实现\"></a>wait()和notify()方法的实现</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test1</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Integer</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Integer</span> <span class=\"variable\">FULL</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">LOCK</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;lock&quot;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Test1</span> <span class=\"variable\">test1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test1</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test1.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (LOCK) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (count == FULL) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            LOCK.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                    LOCK.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (LOCK) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            LOCK.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    count--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                    LOCK.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"可重入锁ReentrantLock的实现\"><a href=\"#可重入锁ReentrantLock的实现\" class=\"headerlink\" title=\"可重入锁ReentrantLock的实现\"></a>可重入锁ReentrantLock的实现</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Integer</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Integer</span> <span class=\"variable\">FULL</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个锁对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">    <span class=\"comment\">//创建两个条件变量，一个为缓冲区非满，一个为缓冲区非空</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Condition</span> <span class=\"variable\">notFull</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Condition</span> <span class=\"variable\">notEmpty</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Test2</span> <span class=\"variable\">test2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test2</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test2.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//获取锁</span></span><br><span class=\"line\">                lock.lock();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (count == FULL) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            notFull.await();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                    <span class=\"comment\">//唤醒消费者</span></span><br><span class=\"line\">                    notEmpty.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//释放锁</span></span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e1) &#123;</span><br><span class=\"line\">                    e1.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                lock.lock();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            notEmpty.await();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    count--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                    notFull.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"阻塞队列BlockingQueue的实现\"><a href=\"#阻塞队列BlockingQueue的实现\" class=\"headerlink\" title=\"阻塞队列BlockingQueue的实现\"></a>阻塞队列BlockingQueue的实现</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test3</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Integer</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个阻塞队列</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">BlockingQueue</span> <span class=\"variable\">blockingQueue</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayBlockingQueue</span>&lt;&gt;(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Test3</span> <span class=\"variable\">test3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test3</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test3.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    blockingQueue.put(<span class=\"number\">1</span>);</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e1) &#123;</span><br><span class=\"line\">                    e1.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    blockingQueue.take();</span><br><span class=\"line\">                    count--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"信号量Semaphore的实现\"><a href=\"#信号量Semaphore的实现\" class=\"headerlink\" title=\"信号量Semaphore的实现\"></a>信号量Semaphore的实现</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test4</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Integer</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建三个信号量</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Semaphore</span> <span class=\"variable\">notFull</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Semaphore</span> <span class=\"variable\">notEmpty</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Semaphore</span> <span class=\"variable\">mutex</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Test4</span> <span class=\"variable\">test4</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test4</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Producer</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(test4.<span class=\"keyword\">new</span> <span class=\"title class_\">Consumer</span>()).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    notFull.acquire();</span><br><span class=\"line\">                    mutex.acquire();</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;生产者生产，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    mutex.release();</span><br><span class=\"line\">                    notEmpty.release();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e1) &#123;</span><br><span class=\"line\">                    e1.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    notEmpty.acquire();</span><br><span class=\"line\">                    mutex.acquire();</span><br><span class=\"line\">                    count--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()</span><br><span class=\"line\">                            + <span class=\"string\">&quot;消费者消费，目前总共有&quot;</span> + count);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    mutex.release();</span><br><span class=\"line\">                    notFull.release();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Java实现BlockQueue\"><a href=\"#Java实现BlockQueue\" class=\"headerlink\" title=\"Java实现BlockQueue\"></a>Java实现BlockQueue</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BlockingQueue</span>&lt;E&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 有界队列内部固定长度，因此可以用数组实现</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object[] elements;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 队列的头和尾下标</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, tail = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 队列目前的长度</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">notEmpty</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">notFull</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">BlockingQueue</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.elements = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[capacity];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (size == elements.length)</span><br><span class=\"line\">                notFull.await();</span><br><span class=\"line\">            elements[tail] = e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++tail == elements.length) &#123;</span><br><span class=\"line\">                tail = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            size++;</span><br><span class=\"line\">            notEmpty.signal();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException ex) &#123;</span><br><span class=\"line\">            ex.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">take</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"type\">E</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                notEmpty.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            e = (E) elements[head];</span><br><span class=\"line\">            elements[head] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++head == elements.length)</span><br><span class=\"line\">                head = <span class=\"number\">0</span>;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">            notFull.signal();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException ex) &#123;</span><br><span class=\"line\">            ex.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">size</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解决哈希冲突的方法\"><a href=\"#解决哈希冲突的方法\" class=\"headerlink\" title=\"解决哈希冲突的方法\"></a>解决哈希冲突的方法</h2><h3 id=\"开放定址法\"><a href=\"#开放定址法\" class=\"headerlink\" title=\"开放定址法\"></a>开放定址法</h3><p>从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。</p>\n<p>在开放定址法中解决冲突的方法有：线行探查法、平方探查法、双散列函数探查法。</p>\n<p>开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。</p>\n<h4 id=\"线行探查法\"><a href=\"#线行探查法\" class=\"headerlink\" title=\"线行探查法\"></a>线行探查法</h4><p>线行探查法是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。</p>\n<p>可以参考csdn上flash对该方法的演示：<br><a href=\"http://student.zjzk.cn/course_ware/data_structure/web/flash/cz/kfdzh.swf\">http://student.zjzk.cn/course_ware/data_structure/web/flash/cz/kfdzh.swf</a></p>\n<h4 id=\"平方探查法\"><a href=\"#平方探查法\" class=\"headerlink\" title=\"平方探查法\"></a>平方探查法</h4><p>平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²…直到找到空闲单元。</p>\n<p>在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。</p>\n<h4 id=\"双散列函数探查法\"><a href=\"#双散列函数探查法\" class=\"headerlink\" title=\"双散列函数探查法\"></a>双散列函数探查法</h4><p>这种方法使用两个散列函数hl和h2。其中hl和前面的h一样，以关键字为自变量，产生一个0至m—l之间的数作为散列地址；h2也以关键字为自变量，产生一个l至m—1之间的、并和m互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)，探查序列的步长值是固定值l；对于平方探查法，探查序列的步长值是探查次数i的两倍减l；对于双散列函数探查法，其探查序列的步长值是同一关键字的另一散列函数的值。</p>\n<h3 id=\"链地址法（拉链法）\"><a href=\"#链地址法（拉链法）\" class=\"headerlink\" title=\"链地址法（拉链法）\"></a>链地址法（拉链法）</h3><p>链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。</p>\n<p>如下一组数字,(32、40、36、53、16、46、71、27、42、24、49、64)哈希表长度为13，哈希函数为H(key)&#x3D;key%13,则链表法结果如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>       </span><br><span class=\"line\"><span class=\"number\">1</span>  -&gt; <span class=\"number\">40</span> -&gt; <span class=\"number\">27</span> -&gt; <span class=\"number\">53</span> </span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span>  -&gt; <span class=\"number\">16</span> -&gt; <span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span>  -&gt; <span class=\"number\">32</span> -&gt; <span class=\"number\">71</span></span><br><span class=\"line\"><span class=\"number\">7</span>  -&gt; <span class=\"number\">46</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">10</span> -&gt; <span class=\"number\">36</span> -&gt; <span class=\"number\">49</span></span><br><span class=\"line\"><span class=\"number\">11</span> -&gt; <span class=\"number\">24</span></span><br><span class=\"line\"><span class=\"number\">12</span> -&gt; <span class=\"number\">64</span></span><br></pre></td></tr></table></figure>\n<p>注：在java中，链接地址法也是HashMap解决哈希冲突的方法之一，jdk1.7完全采用单链表来存储同义词，jdk1.8则采用了一种混合模式，对于链表长度大于8的，会转换为红黑树存储。</p>\n<h3 id=\"再哈希法\"><a href=\"#再哈希法\" class=\"headerlink\" title=\"再哈希法\"></a>再哈希法</h3><p>就是同时构造多个不同的哈希函数：</p>\n<p>Hi &#x3D; RHi(key)   i&#x3D; 1,2,3 … k;</p>\n<p>当H1 &#x3D; RH1(key)  发生冲突时，再用H2 &#x3D; RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。</p>\n<h3 id=\"建立公共溢出区\"><a href=\"#建立公共溢出区\" class=\"headerlink\" title=\"建立公共溢出区\"></a>建立公共溢出区</h3><p>将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>\n<h2 id=\"排行榜设计\"><a href=\"#排行榜设计\" class=\"headerlink\" title=\"排行榜设计\"></a>排行榜设计</h2><h3 id=\"基于数据库\"><a href=\"#基于数据库\" class=\"headerlink\" title=\"基于数据库\"></a>基于数据库</h3><p>基于MySQL，order by</p>\n<p>缺点：</p>\n<ul>\n<li>速度慢</li>\n</ul>\n<h3 id=\"基于Redis\"><a href=\"#基于Redis\" class=\"headerlink\" title=\"基于Redis\"></a>基于Redis</h3><p>主要考察sort set 也就是zset</p>\n<p>zadd添加数据后，zrevrange获取排序后的排名</p>\n<h3 id=\"类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样\"><a href=\"#类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样\" class=\"headerlink\" title=\"类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样\"></a>类似于微信计数榜，如何设计不同用户看到的朋友圈的排行榜不一样</h3><p>key的设计比较重要，比如aa用户和bb用户</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zadd step:aa 1000 小明</span><br><span class=\"line\">zadd step:bb 1000 小明</span><br></pre></td></tr></table></figure>\n\n<p>同理时间也可以通过key的设计解决</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zadd step:aa:20210929 1000 小明</span><br><span class=\"line\">zadd step:aa:20210929 1000 小明</span><br></pre></td></tr></table></figure>\n\n<p>但是上述设计会导致每个用户都有一个排行榜，存储的数据巨大，其实可以考虑只在用户查询时通过好友关系去生成</p>\n<p>那朋友圈排行榜的：微信头像、点赞数 怎么获取呢</p>\n<ul>\n<li>可以使用hmset hash储存对象，需要时通过zset储存的key去查询即可</li>\n</ul>\n<h3 id=\"最近七天排行榜怎么弄\"><a href=\"#最近七天排行榜怎么弄\" class=\"headerlink\" title=\"最近七天排行榜怎么弄\"></a>最近七天排行榜怎么弄</h3><p>前面我们说的都是每日排行榜。</p>\n<p>假设面试官要求我们提供一个最近七天、上一周、上一月、上个季度、这一年排行榜啥的，又该怎么搞呢？</p>\n<p>其实这还是在考察你对于 Redis 有序集合 API 的掌握程度。</p>\n<p>也就是这个 API：</p>\n<ul>\n<li>zinterstore&#x2F;zunionstore destination numkeys key [key …] [weights weight [weight …]] [aggregate sum|min|max] 获取交集&#x2F;并集<ul>\n<li>zinterstore&#x2F;zunionstore其实就是交集&#x2F;并集</li>\n<li>destination 将交集&#x2F;并集的结果保存到这个键中</li>\n<li>numkeys 需要做交集&#x2F;并集的集合的个数</li>\n<li>key [key …] 具体参与交集&#x2F;并集的集合</li>\n<li>weights weight [weight …] 每个参与计算的集合的权重。在做交集&#x2F;并集计算时，每个集合中的 member 会把自己的 score 乘以这个权重，默认为 1。</li>\n<li>aggregate sum|min|max 对于各个集合中的相同元素是 sum(求和)、min(取最小值)还是max(取最大值)，默认为 sum。</li>\n</ul>\n</li>\n</ul>\n<p>比如现在有一些数据</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zadd sport:ranking:why:20210222 43243 why 2341 mx 8764 les 42321 skr</span><br><span class=\"line\">zadd sport:ranking:why:20210223 57632 why 24354 mx 4231 les 43512 skr 5341 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210224 10026 why 12344 mx 54312 les 34531 skr 43512 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210225 54312 why 32451 mx 23412 les 21341 skr 56321 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210226 3212 why 63421 mx 53652 les 45621 skr 5723 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210227 5462 why 10158 mx 30169 les 48858 skr 66079 jay</span><br><span class=\"line\">zadd sport:ranking:why:20210228 43553 why 4451 mx 7431 les 9563 skr 8232 jay</span><br></pre></td></tr></table></figure>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/10.png\"></p>\n<p>现在我们要求出最近 7 天的排行榜，就用下面这行命令，命令有点复杂，但是对着命令格式看，还是很清晰的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zunionstore sport:ranking:why:last_seven_day 7 sport:ranking:why:20210222 sport:ranking:why:20210223 sport:ranking:why:20210224 sport:ranking:why:20210225 sport:ranking:why:20210226 sport:ranking:why:20210227 sport:ranking:why:20210228 weights 1 1 1 1 1 1 1 aggregate sum</span><br></pre></td></tr></table></figure>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/11.png\"></p>\n<p>上面用的是并集，如果我们的要求是对最近 7 天，每天都上传运动数据的人进行排序，就用交集来算。</p>\n<p>命令和上面的一致，只是把 zunionstore 修改为 zinterstore 即可。</p>\n<p>另外为了有对比，合并之后的队列名称也修改一下，命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">zinterstore sport:ranking:why:last_seven_day_zinterstore 7 sport:ranking:why:20210222 sport:ranking:why:20210223 sport:ranking:why:20210224 sport:ranking:why:20210225 sport:ranking:why:20210226 sport:ranking:why:20210227 sport:ranking:why:20210228 weights 1 1 1 1 1 1 1 aggregate sum</span><br></pre></td></tr></table></figure>\n<p><img src=\"/./2024/05/26/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/12.png\"></p>\n<p>知道最近 7 天的做法了，我们又有每一天数据，上一周、上一月、上个季度、这一年排行榜啥的不都是这个套路吗</p>\n<h3 id=\"亿级用户排行榜\"><a href=\"#亿级用户排行榜\" class=\"headerlink\" title=\"亿级用户排行榜\"></a>亿级用户排行榜</h3><h4 id=\"按段位分桶\"><a href=\"#按段位分桶\" class=\"headerlink\" title=\"按段位分桶\"></a>按段位分桶</h4><p>由于数据量比较大，所以需要类似于分成一个个小文件的思想去统计每一部分的数据</p>\n<p>比如游戏里的段位，统计国服前100，可以把王者、大师、砖石、铂金、黄金、白银、青铜 分为不同的桶，每个分段的人在不同的桶里(假设还是用zset存储用户的段位)<br>那计算全服排名即可先计算在某个段位桶的排名x,再获取这个段位桶前的所有桶的大小y1,y2…yn，排名就计算出来了x+y1+y2….yn</p>\n<h5 id=\"计算top100\"><a href=\"#计算top100\" class=\"headerlink\" title=\"计算top100\"></a>计算top100</h5><p>分桶后，直接在段位最大的桶里计算top100即可</p>\n<h4 id=\"按积分分桶\"><a href=\"#按积分分桶\" class=\"headerlink\" title=\"按积分分桶\"></a>按积分分桶</h4><p>[0-5000] [5001-10000] …..[10000000-x]</p>\n<p>这种可能会出现热点问题，比如处于0-5000区间的人会非常多（可能很多人都是没有打排位）用户的落点其实并不是均匀的，那就需要通过其他预测算法去预估每个区间的人数了</p>\n"},{"title":"百亿流量红包系统","date":"2024-05-28T12:40:48.000Z","_content":"\n# 百亿流量红包系统，如何架构？（字节面试真题）\n\n\n\n\n## 说在前面\n\n在读者交流群(50+)中，最近有小伙伴拿到了一线互联网企业如得物、阿里、滴滴、极兔、有赞、希音、百度、网易、美团的面试资格，遇到很多很重要的架构类/设计类的场景题：\n\n> 1.如何设计百亿流量高并发红包系统 ，请说出你的方案？\n>\n> 2.听说你会架构设计，请问一下如果让你来设计百亿流量红包系统，说说你的架构设计方案。\n\n最近有小伙伴在面试字节，又遇到了红包架构问题。小伙伴支支吾吾的说了几句，面试挂了。\n\n所以，给大家做一下系统化、体系化的梳理，使得大家内力猛增，可以充分展示一下大家雄厚的 “技术肌肉”，**让面试官爱到 “不能自已、口水直流”**，然后实现”offer直提”。\n\n\n## 本文目录\n\n**\\- 说在前面**\n\n**\\- 本文目录**\n\n- 红包架构背景\n\n#####     -红包系统和秒杀系统的对比\n\n**\\- 红包系统功能分析**\n\n- 功能1：包红包\n\n- 功能2：发红包\n\n- 功能3：抢红包\n\n- 功能4：拆红包\n\n#####     -微信红包的业务特点\n\n#####     -微信红包的技术难点\n\n- 红包系统概要设计\n\n#####     -系统功能说明\n\n**\\- 数据库设计**\n\n#####     -发红包\n\n#####     -抢红包\n\n**\\- 红包系统详细设计**\n\n- 红包整体架构\n\n- 高并发常用解决方案\n\n- 1- 使用内存替代实时的DB\n\n- 2- 使用乐观锁替代悲观锁\n\n#####     -JVM CAS 乐观锁方案\n\n**\\- 微信红包系统的高并发解决方案**\n\n#####     -1- 分而治之：系统架构设计垂直Set化。\n\n#####     -2- 解决DB并发：逻辑Server层将请求排队。\n\n#####     -3- 系统性能稳定性保障：双维度分库分表设计。\n\n#####  - 红包分配算法\n\n#####     -1- 实时拆分\n\n#####     -2- 预先生成\n\n#####     -3- 二倍均值法\n\n**\\- 红包系统高可用架构设计**\n\n#####     -1 - 系统可用性影响因素\n\n#####     -2 - 红包系统可用性设计方向\n\n#####     -3 - 业务逻辑层 - 部署方案设计\n\n#####     -4 - 业务逻辑层 - 异步化设计\n\n#####     -5 - 订单存储层 - 故障自愈\n\n#####     -6 - 订单存储层 - 平行扩容设计\n\n- 总结\n\n\n\n### 红包架构背景\n\n红包是一种 瞬时流量很大的应用， 会在很短的时间内，产生巨大的瞬时流量，\n\n所以，作为架构师来说，这种场景有很大的架构挑战\n\n以2017年除夕为例，微信红包峰值QPS在76w左右，除夕当天收发微信红包的数量为142亿个。\n\n这种百亿级别的数据量、100Wqps级别的超高并发，而且整个系统核心功能和支付相关，需要做好高并发、高可用、高可靠。\n\n> 特别说明：红包架构也是高端面试的核心场景题, 后面也会以视频的形式，对这些架构的一系列的架构场景题目，做系统化的介绍。\n>\n> 架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n#### 红包系统和秒杀系统的对比\n\n我们先了解下微信红包支付的流程。\n\n![](./2024/05/28/百亿流量红包系统/1.png)\n在上面的红包流程中，核心业务包含包红包、发红包、抢红包、拆红包\n\n![](./2024/05/28/百亿流量红包系统/2.png)\n其中最关键的步骤是\n\n*   发红包\n\n*   抢红包。\n\n\n在整个体系中，红包系统 是 支付系统的商户，红包这个商户出售的是钱。\n\n所以，用户发红包在红包系统 使用微信支付购买一份 红包商品，红包系统 将钱发放到相对应的微信群，供参与者领取。\n\n微信群里的用户抢红包，得到的是商品里边的 零钱。\n\n在整个体系中，红包系统 和支付系统 之间的关系是商家和第三方支付平台的关系。\n\n红包的流程，很类似 商品“秒杀”活动。\n\n*   包红包类似秒杀商品管理\n\n*   发红包类似“秒杀”活动的商品上架；\n\n*   抢红包等同于“秒杀”活动中的查询库存；\n\n*   拆红包对应“秒杀”活动中用户的“秒杀”动作。\n\n\n不过除了上面的相同点之外，红包业务 与 “秒杀”活动相比，还具备自身的特点：\n\n首先，抢红包 比 “秒杀”有更海量的并发要求。假设同一时间有 10 万个群里的用户同时在发红包，那就相当于同一时间有 10 万个“秒杀”活动发布出去。10 万个微信群里的用户同时抢红包，将产生海量的并发请求。\n\n其次，微信红包业务要求更严格的安全级别。红包业务本质上是资金交易。资金交易业务比普通商品“秒杀”活动有更高的安全级别要求。\n\n*   **“秒杀”时可以允许存在“超卖”（即实际被抢的商品数量比计划的库存多）、“少卖”（即实际被抢的商户数量比计划的库存少）的情况。**\n\n*   **但是对于 红包，不允许存在“超卖”、“少卖”。**\n\n\n> 特别说明：红包架构也是高端面试的核心场景题, 后面也会以视频的形式，对这些架构的一系列的架构场景题目，做系统化的介绍。\n>\n> 架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n## 红包系统功能分析\n\n接下来，40岁老架构带大家，从架构师视角开始红包系统的功能分析。\n\n微信红包和微信支付之间的交互，与普通商家与微信支付的交互一样，需要经过多个步骤。\n\n*   用户发红包时，进入微信红包下一笔订单，系统记录发红包用户、发红包金额、红包数量和要发送到的用微信群。\n\n*   然后微信红包系统请求微信支付服务器进行下单，用户使用微信支付进行支付。\n\n*   支付成功后，微信支付后台系统通知微信红包后台系统支付成功结果，微信红包后台系统收到通知后推送微信红包消息到微信群。\n\n*   微信群里用户便可抢红包。\n\n*   用户发现红包还有剩余，就可以拆剩下的红包\n\n\n这就是微信红包和微信支付的关系以及交互过程。\n\n\n### 功能1：包红包\n\n系统给每个红包分配一个唯一ID，也就是发红包的订单号，然后将红包发送给用户，红包的个数，红包金额写入到存储。\n\n### 功能2：发红包\n\n用户使用微信支付完成付款，微信红包后台收到微信支付成功的通知。红包系统将红包发送订单状态更新，更新为用户已支付，并写入用户发红包记录表，这样用户可以在钱包中找到用户的发红包流水和收发红包的记录，之后微信红包系统调用微信通知，将微信红包信息发送到微信群。\n\n### 功能3：抢红包\n\n微信群中的用户收到红包消息之后，点开红包，开始抢红包，这个过程微信红包系统会检查红包是否已经被抢完，是否已经过期，是否已经抢过等验证逻辑。\n\n### 功能4：拆红包\n\n拆红包是整个发红包流程最复杂的一个操作，需要查询这个红包的红包订单，判断用户是否可以拆包，计算本次可拆到的红包金额，并记录抢红包流水。\n\n拆红包包括如下步骤：\n\n*   1）查询这个红包发送订单，判断用户是否可拆，然后计算本次可拆到的红包金额；\n\n*   2）然后写入一条抢红包记录。如果把拆红包过程，类比为一个秒杀活动的过程，相当于扣库存与写入秒杀记录的过程；\n\n*   3）更新库存对应于更新红包发送订单，写入秒杀记录对应于写入这个红包的领取红包记录；\n\n*   4）另外，还要写入用户整体的红包领取记录；\n\n*   5）最后请求微信支付系统给拆到红包用户转入零钱，成功后更新抢红包的订单状态为已转账成功。\n\n![](./2024/05/28/百亿流量红包系统/5.png)\n\n拆红包过程类似于一个秒杀活动的过程，需要做好库存扣减和秒杀记录的操作。\n\n更新库存就是更新红包发送的订单，写入秒杀记录就是写入红包领取的信息流水。\n\n还需要以用户为中心记录用户整体的红包领取记录。\n\n最后调用支付系统将拆红包后的金额转入用户零钱中，成功之后更新抢红包的订单状态为转账成功。\n\n> 所以，在看此文之前，最好看看的高并发三部曲的Java高并发核心编程卷3\\*（注意是最新的清华大学出版社出版的加强版），里边有秒杀架构，可以作为知识铺垫。\n\n#### 微信红包的业务特点\n\n微信红包，特别是群红包，业务形态上类似于普通商品的\"秒杀\"活动。\n\n*   包红包类似秒杀商品管理\n\n*   发红包类似“秒杀”活动的商品上架；\n\n*   抢红包等同于“秒杀”活动中的查询库存；\n\n*   拆红包对应“秒杀”活动中用户的“秒杀”动作。\n\n    微信红包在业务形态上和普通商品\"秒杀\"活动相比，还有自身特点：\n\n\n1.  **海量并发请求**：微信红包用户在微信群发一个红包，等同于在网上发布一次商品\"秒杀\"活动，假设同时有10万个群的用户同时发红包，那就相当于同一时间有10万个\"秒杀\"活动发布。10万个微信群的用户同时抢红包，将产生海量并发请求。\n\n2.  **更严格的安全级别**：微信红包业务本质上是资金交易，微信红包是微信支付的一个商户，提供资金流转服务，用户发红包相当于在微信红包这个商户上使用微信支付购买了一笔\"钱\"，且收货地址是微信群。当用户支付成功后，红包\"发货\"到微信群里，群里的用户拆开红包后，微信红包提供了将\"钱\"转入拆红包用户微信零钱的服务。\n\n3.  **订单层南北独立体系**：微信红包系统采用南北独立体系的订单层设计，即数据在南北两个系统中不同步。用户就近接入系统，请求发红包时，系统会根据用户所在地分配订单到南或北的系统，并在订单号上打上南北标识。这种设计有助于分摊流量，降低系统风险。\n\n4.  **流量闭环**：在抢红包、拆红包、查红包详情列表时，接入层会根据红包单号上的南北标识，将流量分别引导到对应的南北系统闭环。这意味着，无论是发红包还是抢红包，用户都能够在就近的系统中完成操作，无需跨城，提高了系统的响应速度和稳定性。\n\n5.  **用户数据处理**：微信红包系统的用户数据采取写多读少、全量保存的策略。用户数据的查询入口在微信钱包中，相对隐藏，访问量不会太大，且被视为可旁路的非关键信息，实时性要求不高。这种设计方式可以减少数据存储的压力，提高系统性能。\n\n6.  **实时计算红包金额**：\n\n    微信红包的金额是在拆红包时实时计算的，而不是预先分配的。系统会在拆红包时取0.01到剩余平均值\\*2之间的数值作为红包金额。\n\n    这种实时计算的方式基于内存进行，不需要额外的存储空间，且计算效率很高。\n\n    同时，为了保证操作的原子性，拆包过程中使用了CAS（Compare-and-Swap）算法，确保每次只有一个并发用户拆包成功。如果拆包CAS失败，系统会自动进行重试，但也可能在重试过程中被其他用户抢得先机而空手而归。\n\n7.  **架构演进**：随着微信红包功能的不断发展和用户量的增长，其系统架构也经历了不断的演进和优化。从最初的数据库硬抗整个流量，到后来的使用缓存（cache）抗流量，再到现在的南北独立体系等设计，都是为了更好地应对高并发、提升系统性能和稳定性。\n\n    资金交易业务比普通商品\"秒杀\"有更高的安全级别要求，普通的商品\"秒杀\"由商户提供，库存是商户预设，\"秒杀\"允许存在超卖和少卖的情况，但对于微信红包，用户发100元的红包绝对不可以拆出101元，以及只被领取99元时，剩下的1元在24小时过期后要精准退还给发红包用户。\n\n    总的来说，微信红包系统架构的设计充分考虑了用户量、并发量、性能要求等因素，通过南北独立体系、流量闭环、用户数据处理、实时计算红包金额以及架构演进等多种手段，保证了系统的稳定运行和良好用户体验。\n\n\n#### 微信红包的技术难点\n\n微信红包系统架构的技术难点主要体现在以下几个方面：\n\n1.  **高并发难点**：\n\n    微信红包在特定时间（如春节、节假日等）会面临极高的并发量，如何有效地处理这些并发请求，保证系统的稳定性和响应速度，是红包系统架构设计的关键挑战之一。\n\n2.  **资金安全难点**：\n\n    红包系统涉及到资金的转移和存储，因此资金安全是系统设计的重中之重。如何确保资金安全，防止被攻击或篡改，是系统架构设计中需要重点考虑的问题。\n\n    红包业务涉及资金交易，所以一定不能出现超卖、少卖的情况。\n\n\n*   超卖：发了 10 块钱，结果抢到了 11 块钱，多的钱只能系统补上，如此为爱发电应用估计早就下架了；\n\n*   少卖：发了 10 块钱，只抢了 9 块，多的钱得原封不动地退还用户，否则第二天就接到法院传单了。\n\n\n4.  **用户体验难点**\n\n    红包系统需要保证良好的用户体验，包括响应速度、公平性（先抢先得）、成功率等。\n\n    如何在高并发场景下保证用户体验，是系统架构设计的重要目标。\n\n    了解下微信红包的用户体验 的4大核心：摇/发/抢/拆。\n\n\n*   摇：摇的流畅\n\n*   快：抢的要快\n\n*   爽：拆的爽\n\n*   稳：能分享出去\n\n\n6.  **数据一致性难点**：\n\n    红包系统需要保证数据的一致性，包括红包库存数据、用户账户数据等。如何在高并发场景下保证数据的一致性，是系统架构设计的重要挑战。\n\n\n*   参与用户越多，并发 DB 请求越大，数据越容易出现事务问题，所以系统得做好**事务一致性**；\n\n*   抢红包系统涉及金钱交易，所以事务级别要求更高，**不能出现脏数据**。\n\n\n8.  **系统扩展性难点**：\n\n    随着用户量和业务量的增长，红包系统需要具备良好的扩展性，能够方便地增加新的功能或提升性能。\n\n    如何设计可扩展的系统架构，是系统架构设计的重要考虑因素。\n\n    为了解决这些技术难点，我们可以采用多种技术手段，如分而治之、负载均衡、读写分离、水平切分、垂直切分等，来提升系统的性能和稳定性。同时，系统还采用了柔性服务、系统降级等策略，来保证在有限资源下满足用户的核心需求。\n\n\n### 红包系统概要设计\n\n#### 系统功能说明\n\n抢红包功能允许用户在群聊中发送任意个数和金额的红包，群成员可以抢到随机金额的红包，但要**保证每个用户的红包金额不小于 0.01 元**。\n\n![](./2024/05/28/百亿流量红包系统/3.png)\n抢红包的详细交互流程如下：\n\n1.  用户接收到抢红包通知，点击通知打开群聊页面；\n\n2.  用户点击抢红包，后台服务验证用户资格，确保用户尚未领取过此红包；\n\n3.  若用户资格验证通过，后台服务分配红包金额并存储领取记录；\n\n4.  用户在微信群中看到领取金额，红包状态更新为“已领取”；\n\n5.  异步调用支付接口，将红包金额更新到钱包里。\n\n\n## 数据库设计\n\n**红包表：redpack**\n\n红包表用来记录用户发了多少红包，以及需要维护的剩余金额，\n\n红包表：redpack的字段如下：\n\n| 字段 | 描述 |\n| --- | --- |\n|id|主键，红包ID。|\n|user_id|发送红包的用户id。|\n|total_amount|红包总金额。|\n|surplus_amount|红包剩余金额。|\n|total|红包总数。|\n|surplus_total|剩余红包总数。|\n\n**红包记录表：redpack\\_record**\n\n| 字段 | 描述 |\n| --- | --- |\n|id|主键，记录id。|\n|redpack_id|红包id。|\n|user_id|用户id。|\n|amount|抢到的金额。|\n\n#### 发红包\n\n设置完红包参数后，微信支付，完成付款，然后收到付款成功通知，红包系统更新红包订单状态，更新为已支付，并写入红包发送记录表。\n\n这样用户可以将用户的红包信息和红包的收发记录发出，红包系统调用微信通知，将红包信息发送到微信群。\n\n发红包的交互步骤如下：\n\n1.  用户设置红包的总金额和个数后，在红包表中增加一条数据，开始发红包；\n\n2.  为了保证实时性和抢红包的效率，在 Redis 中增加一条记录，**存储红包 ID 和总人数 n**；\n\n3.  抢红包消息推送给所有群成员。\n\n\n#### 抢红包\n\n微信群用户收到红包后，点开，红包系统会校验红包是否被抢完，是否过期。\n\n微信红包的抢红包和拆红包是两个分离的服务，用户点击抢红包后需要进行两次操作。\n\n这也是为什么明明有时候抢到了红包，点开后却发现**该红包已经被领取完了**。\n\n抢红包的交互步骤如下：\n\n1.  抢红包：抢操作在 Redis 缓存层完成，通过原子递减的操作来更新红包个数，个数递减为 0 后就说明抢光了。\n\n2.  拆红包：拆红包时，首先会实时计算金额，一般是通过二倍均值法实现（即 0.01 到剩余平均值的 2 倍之间）。\n\n3.  红包记录：用户获取红包金额后，通过数据库的事务操作累加已经领取的个数和金额，并更新红包表和记录表。\n\n4.  转账：为了提升效率，最终的转账为异步操作，这也是为什么在春节期间，红包领取后不能立即在余额中看到的原因。\n\n\n## 红包系统详细设计\n\n### 红包整体架构\n\n如下图所示，是微信红包的系统架构\n\n![](./2024/05/28/百亿流量红包系统/4.png)\n总体是三层架构：\n\n*   首先是微信统一接入层，下面是微信红包系统 API，包括发、抢、拆、查红包详情、查红包用户列表。\n\n*   接入层下面，是封装微信红包关键业务的逻辑服务；\n\n*   业务下面数据存储层，微信红包最主要的数据是订单数据，包括发红包订单和拆红包订单两部分。\n\n\n数据存储层的冷热分离设计：微信红包数据的访问热度，随着时间流逝会急剧降低，也就是数据的访问时间段非常集中，一般红包发出三天后，99% 的用户不会再去点开这个红包了。因此微信红包系统采取按时间做冷热数据分离，降低数据的存储成本，同时提升了热数据的访问性能。\n\n除了在线计算的三层架构，还有离线处理的数据分析。\n\n数据分析平台用于对红包数据的分析计算，比如朋友圈里的文章，统计从 某年 1 月 1 日到 2017 年 1 月一个用户总共抢红包的金额，在全国的排名情况，发红包数最多的城市等。\n\n数据分析平台另外一个作用就是对账，红包的订单和微信支付的订单需要对账，以保证最终资金的一致性；\n\n*   订单的数据和订单的 cache 需要做对账，以保证数据的完整性；\n\n*   订单数据和用户的收发记录需要对账，以保证用户列表完整性。\n\n\n### 高并发常用解决方案\n\n普通商品秒杀系统，解决高并发问题的方案，大致有以下2种：\n\n### 1- 使用内存替代实时的DB\n\n将实时扣库存的行为上移到内存Cache中，内存Cache操作成功直接给Server返回成功，然后异步落DB持久化。\n\n![](./2024/05/28/百亿流量红包系统/8.png)\n这个方案的优缺点如下：\n\n> 优点：用内存操作替代磁盘操作，提高了并发性能。\n>\n> 缺点：在内存操作成功DB持久化失败，或者内存Cache故障的情况下，DB持久化会丢数据，不适合微信红包这种资金交易系统。\n\n### 2- 使用乐观锁替代悲观锁\n\n**什么是悲观锁呢？**\n\n所谓悲观锁，是关系数据库管理系统里的一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。对应于上文分析中的“并发请求抢锁”行为。\n\n**什么是乐观锁呢？**\n\n所谓乐观锁，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。\n\n乐观锁分为DB乐观锁和 JVM CAS 乐观锁。\n\nDB乐观锁的具体应用方法，是在 DB 的“库存”记录中维护一个版本号。\n\n商品“秒杀”系统中，在更新“库存”的操作进行前，先去 DB 获取当前版本号。\n\n在更新库存的事务提交时，检查该版本号是否已被其他事务修改。如果版本没被修改，则提交事务，且版本号加 1；如果版本号已经被其他事务修改，则回滚事务，并给上层报错。\n\nDB乐观锁可以提高DB的并发处理能力，但是如果应用于微信红包系统，则会存在下面三个问题：\n\n1.  如果拆红包采用乐观锁，那么在并发抢到相同版本号的拆红包请求中，只有一个能拆红包成功，其他的请求将事务回滚并返回失败，给用户报错，用户体验完全不可接受。\n\n2.  如果采用乐观锁，将会导致第一时间同时拆红包的用户有一部分直接返回失败，反而那些“手慢”的用户，有可能因为并发减小后拆红包成功，这会带来用户体验上的负面影响。\n\n3.  如果采用乐观锁的方式，会带来大数量的无效更新请求、事务回滚，给 DB 造成不必要的额外压力。\n\n\n#### JVM CAS 乐观锁方案\n\n出于性能原因，微信红包系统使用 JVM CAS 乐观锁，而不是DB乐观锁的方式解决并发抢锁问题。\n\n微信红包的金额是在拆红包时实时计算的，而不是预先分配的。系统会在拆红包时取0.01到剩余平均值\\*2之间的数值作为红包金额。\n\n这种实时计算的方式基于JVM 内存进行，不需要额外的存储空间，且计算效率很高。\n\n同时，为了保证操作的原子性，拆包过程中使用了CAS（Compare-and-Swap）算法，确保每次只有一个并发用户拆包成功。如果拆包CAS失败，系统会自动进行重试，但也可能在重试过程中被其他用户抢得先机而空手而归。\n\n如何保证同一个红包由同一个节点去拆包呢？将同一个红包 ID 的所有请求 stick 到同一台 Server，这个后面介绍。\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n## 微信红包系统的高并发解决方案\n\n综合上面的分析，我们的红包系统针对相应的技术难点，采用如下3个方案，解决高并发问题。\n\n##### 1- 分而治之：系统架构设计垂直Set化。\n\n**什么是Set（单元）化架构呢?**\n\n> 单元化架构是一种将系统划分为多个独立的、自包含的单元的部署架构，每个单元都能够完成所有业务操作，包含所有业务所需的服务以及分配给该单元的数据。这种架构将单元作为部署的基本单位，在全站所有机房中部署多个单元，每个机房内的单元数目不固定，但任一单元均部署系统所需的全部应用。数据则是全量数据按照某种维度划分后的一部分。与传统意义上的SOA（服务化）架构不同，单元化架构下，服务仍然是分层的，但每一层中的任意一个节点都属于且仅属于某一个单元，上层调用下层时，仅会选择本单元内的节点。\n\n**通俗的理解为**：\n\n单元化架构，简单来说，就是把系统拆分成若干个独立的单元，每个单元都包含了完成业务操作所需的所有服务和数据。这些单元可以独立部署、管理和监控，就像一个个小房子，每个房子都有自己的客厅、卧室和厨房（服务），也有自己的食物和水（数据）。\n\n如下图，是一种单元化架构设计。\n\n![](./2024/05/28/百亿流量红包系统/6.png)\n\n微信红包用户发一个红包时，微信红包系统生成一个 ID 作为这个红包的唯一标识。\n\n接下来这个红包的所有发红包、抢红包、拆红包、查询红包详情等操作，都根据这个 ID 关联。\n\n红包系统根据这个红包 ID，按一定的规则（如按 ID 尾号取模等），垂直上下切分。\n\n切分后，一个垂直链条上的逻辑 Server 服务器、DB 统称为一个 SET。\n\n各个 SET 之间相互独立，互相解耦。并且同一个红包 ID 的所有请求，包括发红包、抢红包、拆红包、查详情详情等，垂直 stick 到同一个 SET 内处理，高度内聚。\n\n通过这样的方式，系统将所有红包请求这个巨大的洪流分散为多股小流，互不影响，分而治之，如下图所示。\n\n![](./2024/05/28/百亿流量红包系统/7.png)\n这个方案解决了同时存在海量事务级操作的问题，将**海量化为小量**。\n\n##### 2- 解决DB并发：逻辑Server层将请求排队。\n\n红包系统是资金交易系统，DB 操作的事务性无法避免，所以会存在“并发抢锁”问题。但是如果到达 DB 的事务操作（也即拆红包行为）不是并发的，而是串行的，就不会存在“并发抢锁”的问题了。\n\n按这个思路，为了使拆红包的事务操作串行地进入 DB，只需要将请求在 Server 层以 FIFO（先进先出）的方式排队，就可以达到这个效果。从而问题就集中到 Server 的 FIFO 队列设计上。\n\n红包系统设计了分布式的、轻巧的、灵活的 FIFO 队列方案。其具体实现如下：\n\n**1）将同一个红包 ID 的所有请求 stick 到同一台 Server。**\n\n上面 SET 化方案已经介绍，同个红包 ID 的所有请求，按红包 ID stick 到同个 SET 中。\n\n不过在同个 SET 中，会存在多台 Server 服务器同时连接同一台 DB（基于容灾、性能考虑，需要多台 Server 互备、均衡压力）。\n\n为了使同一个红包 ID 的所有请求，stick 到同一台 Server 服务器上，在 SET 化的设计之外，微信红包系统添加了一层基于红包 ID hash 值的分流，如下图所示。\n\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n**2）设计单机请求排队方案。**\n\n将 stick 到同一台 Server 上的所有请求在被接收进程接收后，按红包 ID 进行排队。\n\n然后串行地进入 worker 进程（执行业务逻辑）进行处理，从而达到排队的效果，如下图所示。\n\n![](./2024/05/28/百亿流量红包系统/9.png)\n**3）增加 Redis缓存 控制并发。**\n\n为了防止 Server 中的请求队列过载导致队列被降级，从而所有请求拥进 DB，系统增加了与 Server 服务器同机部署的 Redis ，用于控制拆同一个红包的请求并发数。\n\n具体来说，利用 Redis 的 CAS 原子累增操作，控制同时进入 DB 执行拆红包事务的请求数，超过预先设定数值则直接拒绝服务。用于 DB 负载升高时的降级体验。\n\n通过以上三个措施，系统有效地控制了 DB 的“并发抢锁”情况。\n\n##### 3- 系统性能稳定性保障：双维度分库分表设计。\n\n红包系统的分库表规则，初期是根据红包 ID 的 hash 值分为多库多表。\n\n随着红包数据量逐渐增大，单表数据量也逐渐增加。而 DB 的性能与单表数据量有一定相关性。当单表数据量达到一定程度时，DB 性能会有大幅度下降，影响系统性能稳定性。\n\n采用冷热分离，将历史冷数据与当前热数据分开存储，可以解决这个问题。\n\n处理微信红包数据的冷热分离时，系统在以红包 ID 维度分库表的基础上，增加了以循环天分表的维度，形成了双维度分库表的特色。\n\n具体来说，就是分库表规则像 db\\_xx.t\\_y\\_dd 设计，其中，xx/y 是红包 ID 的 hash 值后三位，dd 的取值范围在 01~31，代表一个月天数最多 31 天。\n\n通过这种双维度分库表方式，解决了 DB 单表数据量膨胀导致性能下降的问题，保障了系统性能的稳定性。同时，在热冷分离的问题上，又使得数据搬迁变得简单而优雅。\n\n综上所述，微信红包系统在解决高并发问题上的设计，主要采用了 **SET 化分治**、**请求排队**、**双维度分库表**等方案，使得单组 DB 的并发性能大幅度提升，取得了很好的效果。\n\n#### 红包分配算法\n\n抢红包后，我们需要进行拆红包，接下来我们讨论一下红包系统的红包分配算法。\n\n红包金额分配时，由于是随机分配，所以有两种实现方案：**实时拆分和预先生成**\n\n##### 1- 实时拆分\n\n实时拆分，指的是在**抢红包时实时计算**每个红包的金额，以实现红包的拆分过程。\n\n这个对系统性能和拆分算法要求较高，例如拆分过程要一直保证后续待拆分红包的金额不能为空，不容易做到拆分的红包金额服从**正态分布**规律。\n\n##### 2- 预先生成\n\n预先生成，指的是在红包**开抢之前**已经完成了红包的**金额拆分**，抢红包时只是依次取出拆分好的红包金额。\n\n这种方式对拆分算法要求较低，可以拆分出随机性很好的红包金额，但通常需要结合队列使用。\n\n##### 3- 二倍均值法\n\n综合上述优缺点考虑，以及微信群聊中的人数不多（目前最高 500 人），所以我们采用实时拆分的方式，用**二倍均值法**来生成随机红包，只满足随机即可，不需要正态分布。\n\n```\n\n\n使用二倍均值法生成的随机数，每次随机金额会在  0.01 ~ 剩余平均值\\*2 之间。  \n\n\n\n```\n\n假设当前红包剩余金额为 10 元，剩余个数为 5，**10/5 = 2**，则当前用户可以抢到的红包金额为：**0.01 ~ 4** 元之间。\n\n以下是使用Java实现的二倍均值算法，在红包分配场景中。\n\n```\n\n\npublic class RedPacketDistribution {  \n  \n    public static List<BigDecimal> distribute(BigDecimal totalAmount, int totalCount) {  \n        // 校验总金额是否为正  \n        if (totalAmount.compareTo(BigDecimal.ZERO) <= 0) {  \n            throw new IllegalArgumentException(\"Invalid parameter, totalAmount must be positive.\");  \n        }  \n        // 校验红包总数是否至少为1  \n        if (totalCount < 1) {  \n            throw new IllegalArgumentException(\"Invalid parameter, totalCount must be at least 1.\");  \n        }  \n  \n        List<BigDecimal> redPacketList = new ArrayList<>(totalCount);  \n        BigDecimal remainingAmount = totalAmount.multiply(BigDecimal.valueOf(2)); // 初始化为总金额的两倍  \n        ThreadLocalRandom random = ThreadLocalRandom.current(); // 使用线程安全的随机数生成器  \n  \n        for (int i = 0; i < totalCount - 1; i++) {  \n            // 随机获取一个幸运值，范围在\\[0, 当前剩余金额)  \n            BigDecimal luckValue = BigDecimal.valueOf(random.nextDouble()).multiply(remainingAmount);  \n            // 计算并添加实际分配的红包金额（幸运值的一半）  \n            BigDecimal amount = luckValue.divide(BigDecimal.valueOf(2), BigDecimal.ROUND\\_HALF\\_DOWN);  \n            redPacketList.add(amount);  \n            // 更新剩余金额  \n            remainingAmount = remainingAmount.subtract(luckValue);  \n        }  \n  \n        // 最后一个红包直接拿走剩余的全部金额，确保总和正确  \n        redPacketList.add(remainingAmount.divide(BigDecimal.valueOf(2), BigDecimal.ROUND\\_HALF\\_DOWN));  \n  \n        return redPacketList;  \n    }  \n  \n    public static void main(String\\[\\] args) {  \n        BigDecimal totalAmount = new BigDecimal(\"100.00\"); // 红包总金额  \n        int totalCount = 10;      // 红包个数  \n        List<BigDecimal> redPackets = distribute(totalAmount, totalCount);  \n  \n        System.out.println(\"Red packet distribution:\");  \n        for (BigDecimal amount : redPackets) {  \n            System.out.printf(\"%.2f, \", amount);  \n        }  \n    }  \n}  \n\n\n\n```\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n## 红包系统高可用架构设计\n\n红包业务量级的高速发展，对后台系统架构的可用性要求越来越高。在保障微信红包业务体验的前提下，红包后台系统进行了一系列高可用方面的优化设计。\n\n要保障红包系统架构的高可用性，可以从多个方面进行优化和设计。以下是一些详细说明：\n\n1.  **系统架构设计**：\n\n\n*   **信息流、业务流、资金流分离**：红包系统由信息流、业务流、资金流三部分组成，这三部分在组织架构上应由不同的后台团队完成，以提高系统的模块化和可维护性。\n\n*   **微服务架构**：采用微服务架构，将红包系统拆分成多个独立的服务，每个服务负责特定的功能，这样可以提高系统的可扩展性和容错性。\n\n*   **无状态设计**：确保红包系统的服务是无状态的，即服务不需要保存用户的会话信息，这样可以提高系统的并发处理能力和可靠性。\n\n\n3.  **高可用性策略**：\n\n\n*   **冗余部署**：将系统的关键组件部署在多台服务器上，通过搭建主备或者集群的架构来实现冗余。当主服务器出现故障时，备用服务器能够自动接管，保证系统的可用性。\n\n*   **负载均衡**：通过将流量分发到多台服务器上，均衡系统的请求负载，提高系统的可用性和扩展性。负载均衡可以通过硬件（如负载均衡器）或者软件（如Nginx、HAProxy）实现。\n\n*   **服务容器化**：使用容器技术（如Docker、Kubernetes）将应用程序与其依赖项打包为容器，实现快速部署、弹性扩展和自动化管理。容器化可以提高系统的可移植性、弹性和可伸缩性，从而增加系统的高可用性。\n\n\n5.  **数据保障**：\n\n\n*   **数据备份与恢复**：定期对关键数据进行备份，并确保备份的数据可用性。这样，在发生数据丢失或损坏时，可以快速恢复数据，减少系统停机时间。\n\n*   **分布式缓存**：使用多级缓存技术（如Redis、Memcached等），将数据分别存储在内存缓存、本地缓存和分布式缓存中，以提高访问速度和降低数据库压力。\n\n*   **数据一致性**：使用分布式锁技术来保护红包的领取操作，确保每个用户只能领取一次红包。同时，为了保证数据一致性，可以采用消息队列等技术实现请求的异步处理和结果的返回。\n\n\n7.  **监控与告警**：\n\n\n*   **系统监控**：对红包系统的关键指标（如请求量、响应时间、错误率等）进行实时监控，以便及时发现和解决潜在问题。\n\n*   **告警机制**：设置合理的告警阈值，当系统出现异常情况时，及时发送告警通知给相关人员，以便快速响应和处理。\n\n\n9.  **安全性保障**：\n\n    通过以上措施的综合应用，可以大大提高红包系统架构的高可用性，确保系统在高峰时段能够稳定、高效地运行。\n\n\n*   **访问控制**：实施严格的访问控制策略，确保只有授权的用户才能访问红包系统。\n\n*   **数据加密**：对敏感数据进行加密存储和传输，以防止数据泄露和篡改。\n\n*   **安全审计**：定期对红包系统进行安全审计和漏洞扫描，及时修复发现的安全漏洞和隐患。\n\n\n#### 1 - 系统可用性影响因素\n\n**系统的可用性影响因素可分成两类：**\n\n*   一类计划外；\n\n    计划外包含很多因素，系统用到的所有东西都可能产生故障，都可能成功影响可用性的因素。从这个角度上来讲，可以说故障是无法避免的，系统的运作一定会产生故障，尤其是服务器有成千上万个的时候。\n\n*   一类计划内。\n\n    计划内的影响因素，主要有与升级相关、运维相关的操作，以及日常的备份等。这一类影响因素，通过精细地设计方案，是可以避免对可用性造成影响的。\n\n\n#### 2 - 红包系统可用性设计方向\n\n基于上面两个分析结论，可以总结出红包系统的可用性的设计方向。\n\n> 1.在不能避免意外故障的情况下，尽可能降低出现意外故障时对可用性的影响。\n>\n> 2.绝大多数计划内的日常维护可以通过方案的设计避免影响可用性，其中平行扩容特指关于存储层的平行扩容。\n\n下面从降低故障影响和微信红包系统的平行扩容两方面进行分析。\n\n首先是降低意外故障的影响，重点讲解订单存储层在订单 DB 故障的情况下如何降低对红包系统可用性的影响。\n\n#### 3 - 业务逻辑层 - 部署方案设计\n\n首先是业务逻辑层的部署方案。业务逻辑层是无状态的，微信红包系统的业务逻辑层，部署在两个城市，即两地部署，每一个城市部署至少三个园区，即三个 IDC。并且每个服务需要保证三个 IDC 的部署均衡。另外，三个 IDC 总服务能力需要冗余三分之一，当一个 IDC 出现故障时，服务能力仍然足够。从而达到 IDC 故障不会对可用性产生影响。\n\n#### 4 - 业务逻辑层 - 异步化设计\n\n如下图所示，微信红包的某些步骤不实时完成也不会影响用户对红包业务可用性的体验。\n\n比如拆红包，正常的业务流程很长，但关键步骤只有订单相关的几步。\n\n至于转零钱、写红包记录等操作不需要实时。\n\n用户抢到红包时，一般不会实时去钱包查看微信零钱，而是在微信群中点开消息查看本次抢到金额和他人抢红包金额。\n\n所以拆红包时只需要从 cache 查询用户是否拆过红包，然后写入拆红包的订单记录，更新发红包订单，其他的操作都可以异步化。\n\n当然，不是每个业务都可以进行异步化设计，需要进行业务分析，判断是否存在非关键步骤之外的事情可以将其异步化，并通过异步对账保证最终一致。\n\n经过上述分析之后，可以采用如下思路与方案：\n\n> 实现思路：\n>\n> 1.最简关键路径：简化发红包、拆红包核心流程路径，重点关注与订单相关流程。\n>\n> 2.快慢分离：将核心流程与其他非关键步骤分离。\n>\n> 方案：\n>\n> 1.写用户记录、零钱入账使用MQ异步执行\n>\n> 2.增加对帐机制保障最终一致。\n\n![](./2024/05/28/百亿流量红包系统/11.png)\n如上图所示，微信红包的某些步骤不实时完成也不会影响用户对红包业务可用性的体验。\n\n比如拆红包，正常的业务流程很长，但关键步骤只有订单相关的几步。\n\n至于转零钱、写红包记录等操作不需要实时。\n\n用户抢到红包时，一般不会实时去钱包查看微信零钱，而是在微信群中点开消息查看本次抢到金额和他人抢红包金额。\n\n所以拆红包时只需要从 cache 查询用户是否拆过红包，然后写入拆红包的订单记录，更新发红包订单，其他的操作都可以异步化。\n\n当然，不是每个业务都可以进行异步化设计，需要进行业务分析，判断是否存在非关键步骤之外的事情可以将其异步化，并通过异步对账保证最终一致。\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n#### 5 - 订单存储层 - 故障自愈\n\n为解决 DB 间的相互影响，需要将 DB 间相互隔离，订单存储层 SET 化。\n\nSET 化指订单 DB 和订单接入 SERVER 垂直 stick 一起。业务逻辑层访问订单时，根据订单倒数第二、三位数字找到所属订单 SET，一个 SET 的请求不能路由到其他 SET。\n\n通过 SET 化得到的好处是，控制 DB 连接数、隔离故障影响和分流并发。\n\n![](./2024/05/28/百亿流量红包系统/10.png)\n如上图所示，所设尾号 90-99 的 SET 故障时，如果业务逻辑服务后续不再生成属于这个 SET 的订单，那后续的业务就可以逐渐恢复。\n\n也就是在发生故障时，业务逻辑层发布一个版本，屏蔽故障号段的单号生成，就可以恢复业务。\n\n进一步想，除了人为发版本，有没有方法可以让 DB 故障时自动恢复？\n\n在 DB 故障导致业务失败时，业务逻辑层可获取到故障 DB 的号段，在发红包时，将这些故障的号段，换一个可用的号段就可恢复业务。\n\n订单号除了最后三位，前面的部分已能保证该红包唯一性，后面的数字只代表着分库表信息，故障时只需要将最后三位换另外一个 SET 便可自动恢复。\n\n完成这个设计后，即使 DB 出现故障，业务的可用性也不会有影响。\n\n这里还有一点，新的发红包请求可避免 DB 故障的影响，但那些故障之前已发出未被领取的红包，红包消息已发送到微信群，单号已确定，拆红包时还是失败。\n\n对这种情况，由于不会有增量，采用正常的主备切换解决即可。\n\n#### 6 - 订单存储层 - 平行扩容设计\n\n\n红包系统的高可用架构设计，主要包括了部署设计、SET 化设计、异步化设计、DB 故障自愈能力建设、平行扩容设计。\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n### 总结\n\n红包系统是一个高并发的资金交易系统，最大的技术挑战是保障并发性能与资金安全。\n\n这种全新的技术挑战，传统的“秒杀”系统设计方案已不能完全解决。\n\n在分析了业界“秒杀”系统解决方案的基础上，红包系统采用了 SET 化、请求排队串行化、双维度分库表等设计，形成了独特的高并发、资金安全系统解决方案。\n\n## 说在最后：有问题找老架构取经\n\n超高并发红包架构，一定是一个超级牛掰的简历亮点项目，黄金项目，稍微晚点把全量的架构方案和视频进行发布。\n\n这个项目写入简历，面试的时候如果大家能对答如流，如数家珍，基本上 面试官会被你 震惊到、吸引到。\n\n最终，**让面试官爱到 “不能自已、口水直流”**。offer， 也就来了。\n\n\n\n","source":"_posts/百亿流量红包系统.md","raw":"---\ntitle: 百亿流量红包系统\ndate: 2024-05-28 20:40:48\ntags: 架构\ncategories: 面试\n---\n\n# 百亿流量红包系统，如何架构？（字节面试真题）\n\n\n\n\n## 说在前面\n\n在读者交流群(50+)中，最近有小伙伴拿到了一线互联网企业如得物、阿里、滴滴、极兔、有赞、希音、百度、网易、美团的面试资格，遇到很多很重要的架构类/设计类的场景题：\n\n> 1.如何设计百亿流量高并发红包系统 ，请说出你的方案？\n>\n> 2.听说你会架构设计，请问一下如果让你来设计百亿流量红包系统，说说你的架构设计方案。\n\n最近有小伙伴在面试字节，又遇到了红包架构问题。小伙伴支支吾吾的说了几句，面试挂了。\n\n所以，给大家做一下系统化、体系化的梳理，使得大家内力猛增，可以充分展示一下大家雄厚的 “技术肌肉”，**让面试官爱到 “不能自已、口水直流”**，然后实现”offer直提”。\n\n\n## 本文目录\n\n**\\- 说在前面**\n\n**\\- 本文目录**\n\n- 红包架构背景\n\n#####     -红包系统和秒杀系统的对比\n\n**\\- 红包系统功能分析**\n\n- 功能1：包红包\n\n- 功能2：发红包\n\n- 功能3：抢红包\n\n- 功能4：拆红包\n\n#####     -微信红包的业务特点\n\n#####     -微信红包的技术难点\n\n- 红包系统概要设计\n\n#####     -系统功能说明\n\n**\\- 数据库设计**\n\n#####     -发红包\n\n#####     -抢红包\n\n**\\- 红包系统详细设计**\n\n- 红包整体架构\n\n- 高并发常用解决方案\n\n- 1- 使用内存替代实时的DB\n\n- 2- 使用乐观锁替代悲观锁\n\n#####     -JVM CAS 乐观锁方案\n\n**\\- 微信红包系统的高并发解决方案**\n\n#####     -1- 分而治之：系统架构设计垂直Set化。\n\n#####     -2- 解决DB并发：逻辑Server层将请求排队。\n\n#####     -3- 系统性能稳定性保障：双维度分库分表设计。\n\n#####  - 红包分配算法\n\n#####     -1- 实时拆分\n\n#####     -2- 预先生成\n\n#####     -3- 二倍均值法\n\n**\\- 红包系统高可用架构设计**\n\n#####     -1 - 系统可用性影响因素\n\n#####     -2 - 红包系统可用性设计方向\n\n#####     -3 - 业务逻辑层 - 部署方案设计\n\n#####     -4 - 业务逻辑层 - 异步化设计\n\n#####     -5 - 订单存储层 - 故障自愈\n\n#####     -6 - 订单存储层 - 平行扩容设计\n\n- 总结\n\n\n\n### 红包架构背景\n\n红包是一种 瞬时流量很大的应用， 会在很短的时间内，产生巨大的瞬时流量，\n\n所以，作为架构师来说，这种场景有很大的架构挑战\n\n以2017年除夕为例，微信红包峰值QPS在76w左右，除夕当天收发微信红包的数量为142亿个。\n\n这种百亿级别的数据量、100Wqps级别的超高并发，而且整个系统核心功能和支付相关，需要做好高并发、高可用、高可靠。\n\n> 特别说明：红包架构也是高端面试的核心场景题, 后面也会以视频的形式，对这些架构的一系列的架构场景题目，做系统化的介绍。\n>\n> 架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n#### 红包系统和秒杀系统的对比\n\n我们先了解下微信红包支付的流程。\n\n![](./2024/05/28/百亿流量红包系统/1.png)\n在上面的红包流程中，核心业务包含包红包、发红包、抢红包、拆红包\n\n![](./2024/05/28/百亿流量红包系统/2.png)\n其中最关键的步骤是\n\n*   发红包\n\n*   抢红包。\n\n\n在整个体系中，红包系统 是 支付系统的商户，红包这个商户出售的是钱。\n\n所以，用户发红包在红包系统 使用微信支付购买一份 红包商品，红包系统 将钱发放到相对应的微信群，供参与者领取。\n\n微信群里的用户抢红包，得到的是商品里边的 零钱。\n\n在整个体系中，红包系统 和支付系统 之间的关系是商家和第三方支付平台的关系。\n\n红包的流程，很类似 商品“秒杀”活动。\n\n*   包红包类似秒杀商品管理\n\n*   发红包类似“秒杀”活动的商品上架；\n\n*   抢红包等同于“秒杀”活动中的查询库存；\n\n*   拆红包对应“秒杀”活动中用户的“秒杀”动作。\n\n\n不过除了上面的相同点之外，红包业务 与 “秒杀”活动相比，还具备自身的特点：\n\n首先，抢红包 比 “秒杀”有更海量的并发要求。假设同一时间有 10 万个群里的用户同时在发红包，那就相当于同一时间有 10 万个“秒杀”活动发布出去。10 万个微信群里的用户同时抢红包，将产生海量的并发请求。\n\n其次，微信红包业务要求更严格的安全级别。红包业务本质上是资金交易。资金交易业务比普通商品“秒杀”活动有更高的安全级别要求。\n\n*   **“秒杀”时可以允许存在“超卖”（即实际被抢的商品数量比计划的库存多）、“少卖”（即实际被抢的商户数量比计划的库存少）的情况。**\n\n*   **但是对于 红包，不允许存在“超卖”、“少卖”。**\n\n\n> 特别说明：红包架构也是高端面试的核心场景题, 后面也会以视频的形式，对这些架构的一系列的架构场景题目，做系统化的介绍。\n>\n> 架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n## 红包系统功能分析\n\n接下来，40岁老架构带大家，从架构师视角开始红包系统的功能分析。\n\n微信红包和微信支付之间的交互，与普通商家与微信支付的交互一样，需要经过多个步骤。\n\n*   用户发红包时，进入微信红包下一笔订单，系统记录发红包用户、发红包金额、红包数量和要发送到的用微信群。\n\n*   然后微信红包系统请求微信支付服务器进行下单，用户使用微信支付进行支付。\n\n*   支付成功后，微信支付后台系统通知微信红包后台系统支付成功结果，微信红包后台系统收到通知后推送微信红包消息到微信群。\n\n*   微信群里用户便可抢红包。\n\n*   用户发现红包还有剩余，就可以拆剩下的红包\n\n\n这就是微信红包和微信支付的关系以及交互过程。\n\n\n### 功能1：包红包\n\n系统给每个红包分配一个唯一ID，也就是发红包的订单号，然后将红包发送给用户，红包的个数，红包金额写入到存储。\n\n### 功能2：发红包\n\n用户使用微信支付完成付款，微信红包后台收到微信支付成功的通知。红包系统将红包发送订单状态更新，更新为用户已支付，并写入用户发红包记录表，这样用户可以在钱包中找到用户的发红包流水和收发红包的记录，之后微信红包系统调用微信通知，将微信红包信息发送到微信群。\n\n### 功能3：抢红包\n\n微信群中的用户收到红包消息之后，点开红包，开始抢红包，这个过程微信红包系统会检查红包是否已经被抢完，是否已经过期，是否已经抢过等验证逻辑。\n\n### 功能4：拆红包\n\n拆红包是整个发红包流程最复杂的一个操作，需要查询这个红包的红包订单，判断用户是否可以拆包，计算本次可拆到的红包金额，并记录抢红包流水。\n\n拆红包包括如下步骤：\n\n*   1）查询这个红包发送订单，判断用户是否可拆，然后计算本次可拆到的红包金额；\n\n*   2）然后写入一条抢红包记录。如果把拆红包过程，类比为一个秒杀活动的过程，相当于扣库存与写入秒杀记录的过程；\n\n*   3）更新库存对应于更新红包发送订单，写入秒杀记录对应于写入这个红包的领取红包记录；\n\n*   4）另外，还要写入用户整体的红包领取记录；\n\n*   5）最后请求微信支付系统给拆到红包用户转入零钱，成功后更新抢红包的订单状态为已转账成功。\n\n![](./2024/05/28/百亿流量红包系统/5.png)\n\n拆红包过程类似于一个秒杀活动的过程，需要做好库存扣减和秒杀记录的操作。\n\n更新库存就是更新红包发送的订单，写入秒杀记录就是写入红包领取的信息流水。\n\n还需要以用户为中心记录用户整体的红包领取记录。\n\n最后调用支付系统将拆红包后的金额转入用户零钱中，成功之后更新抢红包的订单状态为转账成功。\n\n> 所以，在看此文之前，最好看看的高并发三部曲的Java高并发核心编程卷3\\*（注意是最新的清华大学出版社出版的加强版），里边有秒杀架构，可以作为知识铺垫。\n\n#### 微信红包的业务特点\n\n微信红包，特别是群红包，业务形态上类似于普通商品的\"秒杀\"活动。\n\n*   包红包类似秒杀商品管理\n\n*   发红包类似“秒杀”活动的商品上架；\n\n*   抢红包等同于“秒杀”活动中的查询库存；\n\n*   拆红包对应“秒杀”活动中用户的“秒杀”动作。\n\n    微信红包在业务形态上和普通商品\"秒杀\"活动相比，还有自身特点：\n\n\n1.  **海量并发请求**：微信红包用户在微信群发一个红包，等同于在网上发布一次商品\"秒杀\"活动，假设同时有10万个群的用户同时发红包，那就相当于同一时间有10万个\"秒杀\"活动发布。10万个微信群的用户同时抢红包，将产生海量并发请求。\n\n2.  **更严格的安全级别**：微信红包业务本质上是资金交易，微信红包是微信支付的一个商户，提供资金流转服务，用户发红包相当于在微信红包这个商户上使用微信支付购买了一笔\"钱\"，且收货地址是微信群。当用户支付成功后，红包\"发货\"到微信群里，群里的用户拆开红包后，微信红包提供了将\"钱\"转入拆红包用户微信零钱的服务。\n\n3.  **订单层南北独立体系**：微信红包系统采用南北独立体系的订单层设计，即数据在南北两个系统中不同步。用户就近接入系统，请求发红包时，系统会根据用户所在地分配订单到南或北的系统，并在订单号上打上南北标识。这种设计有助于分摊流量，降低系统风险。\n\n4.  **流量闭环**：在抢红包、拆红包、查红包详情列表时，接入层会根据红包单号上的南北标识，将流量分别引导到对应的南北系统闭环。这意味着，无论是发红包还是抢红包，用户都能够在就近的系统中完成操作，无需跨城，提高了系统的响应速度和稳定性。\n\n5.  **用户数据处理**：微信红包系统的用户数据采取写多读少、全量保存的策略。用户数据的查询入口在微信钱包中，相对隐藏，访问量不会太大，且被视为可旁路的非关键信息，实时性要求不高。这种设计方式可以减少数据存储的压力，提高系统性能。\n\n6.  **实时计算红包金额**：\n\n    微信红包的金额是在拆红包时实时计算的，而不是预先分配的。系统会在拆红包时取0.01到剩余平均值\\*2之间的数值作为红包金额。\n\n    这种实时计算的方式基于内存进行，不需要额外的存储空间，且计算效率很高。\n\n    同时，为了保证操作的原子性，拆包过程中使用了CAS（Compare-and-Swap）算法，确保每次只有一个并发用户拆包成功。如果拆包CAS失败，系统会自动进行重试，但也可能在重试过程中被其他用户抢得先机而空手而归。\n\n7.  **架构演进**：随着微信红包功能的不断发展和用户量的增长，其系统架构也经历了不断的演进和优化。从最初的数据库硬抗整个流量，到后来的使用缓存（cache）抗流量，再到现在的南北独立体系等设计，都是为了更好地应对高并发、提升系统性能和稳定性。\n\n    资金交易业务比普通商品\"秒杀\"有更高的安全级别要求，普通的商品\"秒杀\"由商户提供，库存是商户预设，\"秒杀\"允许存在超卖和少卖的情况，但对于微信红包，用户发100元的红包绝对不可以拆出101元，以及只被领取99元时，剩下的1元在24小时过期后要精准退还给发红包用户。\n\n    总的来说，微信红包系统架构的设计充分考虑了用户量、并发量、性能要求等因素，通过南北独立体系、流量闭环、用户数据处理、实时计算红包金额以及架构演进等多种手段，保证了系统的稳定运行和良好用户体验。\n\n\n#### 微信红包的技术难点\n\n微信红包系统架构的技术难点主要体现在以下几个方面：\n\n1.  **高并发难点**：\n\n    微信红包在特定时间（如春节、节假日等）会面临极高的并发量，如何有效地处理这些并发请求，保证系统的稳定性和响应速度，是红包系统架构设计的关键挑战之一。\n\n2.  **资金安全难点**：\n\n    红包系统涉及到资金的转移和存储，因此资金安全是系统设计的重中之重。如何确保资金安全，防止被攻击或篡改，是系统架构设计中需要重点考虑的问题。\n\n    红包业务涉及资金交易，所以一定不能出现超卖、少卖的情况。\n\n\n*   超卖：发了 10 块钱，结果抢到了 11 块钱，多的钱只能系统补上，如此为爱发电应用估计早就下架了；\n\n*   少卖：发了 10 块钱，只抢了 9 块，多的钱得原封不动地退还用户，否则第二天就接到法院传单了。\n\n\n4.  **用户体验难点**\n\n    红包系统需要保证良好的用户体验，包括响应速度、公平性（先抢先得）、成功率等。\n\n    如何在高并发场景下保证用户体验，是系统架构设计的重要目标。\n\n    了解下微信红包的用户体验 的4大核心：摇/发/抢/拆。\n\n\n*   摇：摇的流畅\n\n*   快：抢的要快\n\n*   爽：拆的爽\n\n*   稳：能分享出去\n\n\n6.  **数据一致性难点**：\n\n    红包系统需要保证数据的一致性，包括红包库存数据、用户账户数据等。如何在高并发场景下保证数据的一致性，是系统架构设计的重要挑战。\n\n\n*   参与用户越多，并发 DB 请求越大，数据越容易出现事务问题，所以系统得做好**事务一致性**；\n\n*   抢红包系统涉及金钱交易，所以事务级别要求更高，**不能出现脏数据**。\n\n\n8.  **系统扩展性难点**：\n\n    随着用户量和业务量的增长，红包系统需要具备良好的扩展性，能够方便地增加新的功能或提升性能。\n\n    如何设计可扩展的系统架构，是系统架构设计的重要考虑因素。\n\n    为了解决这些技术难点，我们可以采用多种技术手段，如分而治之、负载均衡、读写分离、水平切分、垂直切分等，来提升系统的性能和稳定性。同时，系统还采用了柔性服务、系统降级等策略，来保证在有限资源下满足用户的核心需求。\n\n\n### 红包系统概要设计\n\n#### 系统功能说明\n\n抢红包功能允许用户在群聊中发送任意个数和金额的红包，群成员可以抢到随机金额的红包，但要**保证每个用户的红包金额不小于 0.01 元**。\n\n![](./2024/05/28/百亿流量红包系统/3.png)\n抢红包的详细交互流程如下：\n\n1.  用户接收到抢红包通知，点击通知打开群聊页面；\n\n2.  用户点击抢红包，后台服务验证用户资格，确保用户尚未领取过此红包；\n\n3.  若用户资格验证通过，后台服务分配红包金额并存储领取记录；\n\n4.  用户在微信群中看到领取金额，红包状态更新为“已领取”；\n\n5.  异步调用支付接口，将红包金额更新到钱包里。\n\n\n## 数据库设计\n\n**红包表：redpack**\n\n红包表用来记录用户发了多少红包，以及需要维护的剩余金额，\n\n红包表：redpack的字段如下：\n\n| 字段 | 描述 |\n| --- | --- |\n|id|主键，红包ID。|\n|user_id|发送红包的用户id。|\n|total_amount|红包总金额。|\n|surplus_amount|红包剩余金额。|\n|total|红包总数。|\n|surplus_total|剩余红包总数。|\n\n**红包记录表：redpack\\_record**\n\n| 字段 | 描述 |\n| --- | --- |\n|id|主键，记录id。|\n|redpack_id|红包id。|\n|user_id|用户id。|\n|amount|抢到的金额。|\n\n#### 发红包\n\n设置完红包参数后，微信支付，完成付款，然后收到付款成功通知，红包系统更新红包订单状态，更新为已支付，并写入红包发送记录表。\n\n这样用户可以将用户的红包信息和红包的收发记录发出，红包系统调用微信通知，将红包信息发送到微信群。\n\n发红包的交互步骤如下：\n\n1.  用户设置红包的总金额和个数后，在红包表中增加一条数据，开始发红包；\n\n2.  为了保证实时性和抢红包的效率，在 Redis 中增加一条记录，**存储红包 ID 和总人数 n**；\n\n3.  抢红包消息推送给所有群成员。\n\n\n#### 抢红包\n\n微信群用户收到红包后，点开，红包系统会校验红包是否被抢完，是否过期。\n\n微信红包的抢红包和拆红包是两个分离的服务，用户点击抢红包后需要进行两次操作。\n\n这也是为什么明明有时候抢到了红包，点开后却发现**该红包已经被领取完了**。\n\n抢红包的交互步骤如下：\n\n1.  抢红包：抢操作在 Redis 缓存层完成，通过原子递减的操作来更新红包个数，个数递减为 0 后就说明抢光了。\n\n2.  拆红包：拆红包时，首先会实时计算金额，一般是通过二倍均值法实现（即 0.01 到剩余平均值的 2 倍之间）。\n\n3.  红包记录：用户获取红包金额后，通过数据库的事务操作累加已经领取的个数和金额，并更新红包表和记录表。\n\n4.  转账：为了提升效率，最终的转账为异步操作，这也是为什么在春节期间，红包领取后不能立即在余额中看到的原因。\n\n\n## 红包系统详细设计\n\n### 红包整体架构\n\n如下图所示，是微信红包的系统架构\n\n![](./2024/05/28/百亿流量红包系统/4.png)\n总体是三层架构：\n\n*   首先是微信统一接入层，下面是微信红包系统 API，包括发、抢、拆、查红包详情、查红包用户列表。\n\n*   接入层下面，是封装微信红包关键业务的逻辑服务；\n\n*   业务下面数据存储层，微信红包最主要的数据是订单数据，包括发红包订单和拆红包订单两部分。\n\n\n数据存储层的冷热分离设计：微信红包数据的访问热度，随着时间流逝会急剧降低，也就是数据的访问时间段非常集中，一般红包发出三天后，99% 的用户不会再去点开这个红包了。因此微信红包系统采取按时间做冷热数据分离，降低数据的存储成本，同时提升了热数据的访问性能。\n\n除了在线计算的三层架构，还有离线处理的数据分析。\n\n数据分析平台用于对红包数据的分析计算，比如朋友圈里的文章，统计从 某年 1 月 1 日到 2017 年 1 月一个用户总共抢红包的金额，在全国的排名情况，发红包数最多的城市等。\n\n数据分析平台另外一个作用就是对账，红包的订单和微信支付的订单需要对账，以保证最终资金的一致性；\n\n*   订单的数据和订单的 cache 需要做对账，以保证数据的完整性；\n\n*   订单数据和用户的收发记录需要对账，以保证用户列表完整性。\n\n\n### 高并发常用解决方案\n\n普通商品秒杀系统，解决高并发问题的方案，大致有以下2种：\n\n### 1- 使用内存替代实时的DB\n\n将实时扣库存的行为上移到内存Cache中，内存Cache操作成功直接给Server返回成功，然后异步落DB持久化。\n\n![](./2024/05/28/百亿流量红包系统/8.png)\n这个方案的优缺点如下：\n\n> 优点：用内存操作替代磁盘操作，提高了并发性能。\n>\n> 缺点：在内存操作成功DB持久化失败，或者内存Cache故障的情况下，DB持久化会丢数据，不适合微信红包这种资金交易系统。\n\n### 2- 使用乐观锁替代悲观锁\n\n**什么是悲观锁呢？**\n\n所谓悲观锁，是关系数据库管理系统里的一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。对应于上文分析中的“并发请求抢锁”行为。\n\n**什么是乐观锁呢？**\n\n所谓乐观锁，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。\n\n乐观锁分为DB乐观锁和 JVM CAS 乐观锁。\n\nDB乐观锁的具体应用方法，是在 DB 的“库存”记录中维护一个版本号。\n\n商品“秒杀”系统中，在更新“库存”的操作进行前，先去 DB 获取当前版本号。\n\n在更新库存的事务提交时，检查该版本号是否已被其他事务修改。如果版本没被修改，则提交事务，且版本号加 1；如果版本号已经被其他事务修改，则回滚事务，并给上层报错。\n\nDB乐观锁可以提高DB的并发处理能力，但是如果应用于微信红包系统，则会存在下面三个问题：\n\n1.  如果拆红包采用乐观锁，那么在并发抢到相同版本号的拆红包请求中，只有一个能拆红包成功，其他的请求将事务回滚并返回失败，给用户报错，用户体验完全不可接受。\n\n2.  如果采用乐观锁，将会导致第一时间同时拆红包的用户有一部分直接返回失败，反而那些“手慢”的用户，有可能因为并发减小后拆红包成功，这会带来用户体验上的负面影响。\n\n3.  如果采用乐观锁的方式，会带来大数量的无效更新请求、事务回滚，给 DB 造成不必要的额外压力。\n\n\n#### JVM CAS 乐观锁方案\n\n出于性能原因，微信红包系统使用 JVM CAS 乐观锁，而不是DB乐观锁的方式解决并发抢锁问题。\n\n微信红包的金额是在拆红包时实时计算的，而不是预先分配的。系统会在拆红包时取0.01到剩余平均值\\*2之间的数值作为红包金额。\n\n这种实时计算的方式基于JVM 内存进行，不需要额外的存储空间，且计算效率很高。\n\n同时，为了保证操作的原子性，拆包过程中使用了CAS（Compare-and-Swap）算法，确保每次只有一个并发用户拆包成功。如果拆包CAS失败，系统会自动进行重试，但也可能在重试过程中被其他用户抢得先机而空手而归。\n\n如何保证同一个红包由同一个节点去拆包呢？将同一个红包 ID 的所有请求 stick 到同一台 Server，这个后面介绍。\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n## 微信红包系统的高并发解决方案\n\n综合上面的分析，我们的红包系统针对相应的技术难点，采用如下3个方案，解决高并发问题。\n\n##### 1- 分而治之：系统架构设计垂直Set化。\n\n**什么是Set（单元）化架构呢?**\n\n> 单元化架构是一种将系统划分为多个独立的、自包含的单元的部署架构，每个单元都能够完成所有业务操作，包含所有业务所需的服务以及分配给该单元的数据。这种架构将单元作为部署的基本单位，在全站所有机房中部署多个单元，每个机房内的单元数目不固定，但任一单元均部署系统所需的全部应用。数据则是全量数据按照某种维度划分后的一部分。与传统意义上的SOA（服务化）架构不同，单元化架构下，服务仍然是分层的，但每一层中的任意一个节点都属于且仅属于某一个单元，上层调用下层时，仅会选择本单元内的节点。\n\n**通俗的理解为**：\n\n单元化架构，简单来说，就是把系统拆分成若干个独立的单元，每个单元都包含了完成业务操作所需的所有服务和数据。这些单元可以独立部署、管理和监控，就像一个个小房子，每个房子都有自己的客厅、卧室和厨房（服务），也有自己的食物和水（数据）。\n\n如下图，是一种单元化架构设计。\n\n![](./2024/05/28/百亿流量红包系统/6.png)\n\n微信红包用户发一个红包时，微信红包系统生成一个 ID 作为这个红包的唯一标识。\n\n接下来这个红包的所有发红包、抢红包、拆红包、查询红包详情等操作，都根据这个 ID 关联。\n\n红包系统根据这个红包 ID，按一定的规则（如按 ID 尾号取模等），垂直上下切分。\n\n切分后，一个垂直链条上的逻辑 Server 服务器、DB 统称为一个 SET。\n\n各个 SET 之间相互独立，互相解耦。并且同一个红包 ID 的所有请求，包括发红包、抢红包、拆红包、查详情详情等，垂直 stick 到同一个 SET 内处理，高度内聚。\n\n通过这样的方式，系统将所有红包请求这个巨大的洪流分散为多股小流，互不影响，分而治之，如下图所示。\n\n![](./2024/05/28/百亿流量红包系统/7.png)\n这个方案解决了同时存在海量事务级操作的问题，将**海量化为小量**。\n\n##### 2- 解决DB并发：逻辑Server层将请求排队。\n\n红包系统是资金交易系统，DB 操作的事务性无法避免，所以会存在“并发抢锁”问题。但是如果到达 DB 的事务操作（也即拆红包行为）不是并发的，而是串行的，就不会存在“并发抢锁”的问题了。\n\n按这个思路，为了使拆红包的事务操作串行地进入 DB，只需要将请求在 Server 层以 FIFO（先进先出）的方式排队，就可以达到这个效果。从而问题就集中到 Server 的 FIFO 队列设计上。\n\n红包系统设计了分布式的、轻巧的、灵活的 FIFO 队列方案。其具体实现如下：\n\n**1）将同一个红包 ID 的所有请求 stick 到同一台 Server。**\n\n上面 SET 化方案已经介绍，同个红包 ID 的所有请求，按红包 ID stick 到同个 SET 中。\n\n不过在同个 SET 中，会存在多台 Server 服务器同时连接同一台 DB（基于容灾、性能考虑，需要多台 Server 互备、均衡压力）。\n\n为了使同一个红包 ID 的所有请求，stick 到同一台 Server 服务器上，在 SET 化的设计之外，微信红包系统添加了一层基于红包 ID hash 值的分流，如下图所示。\n\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n**2）设计单机请求排队方案。**\n\n将 stick 到同一台 Server 上的所有请求在被接收进程接收后，按红包 ID 进行排队。\n\n然后串行地进入 worker 进程（执行业务逻辑）进行处理，从而达到排队的效果，如下图所示。\n\n![](./2024/05/28/百亿流量红包系统/9.png)\n**3）增加 Redis缓存 控制并发。**\n\n为了防止 Server 中的请求队列过载导致队列被降级，从而所有请求拥进 DB，系统增加了与 Server 服务器同机部署的 Redis ，用于控制拆同一个红包的请求并发数。\n\n具体来说，利用 Redis 的 CAS 原子累增操作，控制同时进入 DB 执行拆红包事务的请求数，超过预先设定数值则直接拒绝服务。用于 DB 负载升高时的降级体验。\n\n通过以上三个措施，系统有效地控制了 DB 的“并发抢锁”情况。\n\n##### 3- 系统性能稳定性保障：双维度分库分表设计。\n\n红包系统的分库表规则，初期是根据红包 ID 的 hash 值分为多库多表。\n\n随着红包数据量逐渐增大，单表数据量也逐渐增加。而 DB 的性能与单表数据量有一定相关性。当单表数据量达到一定程度时，DB 性能会有大幅度下降，影响系统性能稳定性。\n\n采用冷热分离，将历史冷数据与当前热数据分开存储，可以解决这个问题。\n\n处理微信红包数据的冷热分离时，系统在以红包 ID 维度分库表的基础上，增加了以循环天分表的维度，形成了双维度分库表的特色。\n\n具体来说，就是分库表规则像 db\\_xx.t\\_y\\_dd 设计，其中，xx/y 是红包 ID 的 hash 值后三位，dd 的取值范围在 01~31，代表一个月天数最多 31 天。\n\n通过这种双维度分库表方式，解决了 DB 单表数据量膨胀导致性能下降的问题，保障了系统性能的稳定性。同时，在热冷分离的问题上，又使得数据搬迁变得简单而优雅。\n\n综上所述，微信红包系统在解决高并发问题上的设计，主要采用了 **SET 化分治**、**请求排队**、**双维度分库表**等方案，使得单组 DB 的并发性能大幅度提升，取得了很好的效果。\n\n#### 红包分配算法\n\n抢红包后，我们需要进行拆红包，接下来我们讨论一下红包系统的红包分配算法。\n\n红包金额分配时，由于是随机分配，所以有两种实现方案：**实时拆分和预先生成**\n\n##### 1- 实时拆分\n\n实时拆分，指的是在**抢红包时实时计算**每个红包的金额，以实现红包的拆分过程。\n\n这个对系统性能和拆分算法要求较高，例如拆分过程要一直保证后续待拆分红包的金额不能为空，不容易做到拆分的红包金额服从**正态分布**规律。\n\n##### 2- 预先生成\n\n预先生成，指的是在红包**开抢之前**已经完成了红包的**金额拆分**，抢红包时只是依次取出拆分好的红包金额。\n\n这种方式对拆分算法要求较低，可以拆分出随机性很好的红包金额，但通常需要结合队列使用。\n\n##### 3- 二倍均值法\n\n综合上述优缺点考虑，以及微信群聊中的人数不多（目前最高 500 人），所以我们采用实时拆分的方式，用**二倍均值法**来生成随机红包，只满足随机即可，不需要正态分布。\n\n```\n\n\n使用二倍均值法生成的随机数，每次随机金额会在  0.01 ~ 剩余平均值\\*2 之间。  \n\n\n\n```\n\n假设当前红包剩余金额为 10 元，剩余个数为 5，**10/5 = 2**，则当前用户可以抢到的红包金额为：**0.01 ~ 4** 元之间。\n\n以下是使用Java实现的二倍均值算法，在红包分配场景中。\n\n```\n\n\npublic class RedPacketDistribution {  \n  \n    public static List<BigDecimal> distribute(BigDecimal totalAmount, int totalCount) {  \n        // 校验总金额是否为正  \n        if (totalAmount.compareTo(BigDecimal.ZERO) <= 0) {  \n            throw new IllegalArgumentException(\"Invalid parameter, totalAmount must be positive.\");  \n        }  \n        // 校验红包总数是否至少为1  \n        if (totalCount < 1) {  \n            throw new IllegalArgumentException(\"Invalid parameter, totalCount must be at least 1.\");  \n        }  \n  \n        List<BigDecimal> redPacketList = new ArrayList<>(totalCount);  \n        BigDecimal remainingAmount = totalAmount.multiply(BigDecimal.valueOf(2)); // 初始化为总金额的两倍  \n        ThreadLocalRandom random = ThreadLocalRandom.current(); // 使用线程安全的随机数生成器  \n  \n        for (int i = 0; i < totalCount - 1; i++) {  \n            // 随机获取一个幸运值，范围在\\[0, 当前剩余金额)  \n            BigDecimal luckValue = BigDecimal.valueOf(random.nextDouble()).multiply(remainingAmount);  \n            // 计算并添加实际分配的红包金额（幸运值的一半）  \n            BigDecimal amount = luckValue.divide(BigDecimal.valueOf(2), BigDecimal.ROUND\\_HALF\\_DOWN);  \n            redPacketList.add(amount);  \n            // 更新剩余金额  \n            remainingAmount = remainingAmount.subtract(luckValue);  \n        }  \n  \n        // 最后一个红包直接拿走剩余的全部金额，确保总和正确  \n        redPacketList.add(remainingAmount.divide(BigDecimal.valueOf(2), BigDecimal.ROUND\\_HALF\\_DOWN));  \n  \n        return redPacketList;  \n    }  \n  \n    public static void main(String\\[\\] args) {  \n        BigDecimal totalAmount = new BigDecimal(\"100.00\"); // 红包总金额  \n        int totalCount = 10;      // 红包个数  \n        List<BigDecimal> redPackets = distribute(totalAmount, totalCount);  \n  \n        System.out.println(\"Red packet distribution:\");  \n        for (BigDecimal amount : redPackets) {  \n            System.out.printf(\"%.2f, \", amount);  \n        }  \n    }  \n}  \n\n\n\n```\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n## 红包系统高可用架构设计\n\n红包业务量级的高速发展，对后台系统架构的可用性要求越来越高。在保障微信红包业务体验的前提下，红包后台系统进行了一系列高可用方面的优化设计。\n\n要保障红包系统架构的高可用性，可以从多个方面进行优化和设计。以下是一些详细说明：\n\n1.  **系统架构设计**：\n\n\n*   **信息流、业务流、资金流分离**：红包系统由信息流、业务流、资金流三部分组成，这三部分在组织架构上应由不同的后台团队完成，以提高系统的模块化和可维护性。\n\n*   **微服务架构**：采用微服务架构，将红包系统拆分成多个独立的服务，每个服务负责特定的功能，这样可以提高系统的可扩展性和容错性。\n\n*   **无状态设计**：确保红包系统的服务是无状态的，即服务不需要保存用户的会话信息，这样可以提高系统的并发处理能力和可靠性。\n\n\n3.  **高可用性策略**：\n\n\n*   **冗余部署**：将系统的关键组件部署在多台服务器上，通过搭建主备或者集群的架构来实现冗余。当主服务器出现故障时，备用服务器能够自动接管，保证系统的可用性。\n\n*   **负载均衡**：通过将流量分发到多台服务器上，均衡系统的请求负载，提高系统的可用性和扩展性。负载均衡可以通过硬件（如负载均衡器）或者软件（如Nginx、HAProxy）实现。\n\n*   **服务容器化**：使用容器技术（如Docker、Kubernetes）将应用程序与其依赖项打包为容器，实现快速部署、弹性扩展和自动化管理。容器化可以提高系统的可移植性、弹性和可伸缩性，从而增加系统的高可用性。\n\n\n5.  **数据保障**：\n\n\n*   **数据备份与恢复**：定期对关键数据进行备份，并确保备份的数据可用性。这样，在发生数据丢失或损坏时，可以快速恢复数据，减少系统停机时间。\n\n*   **分布式缓存**：使用多级缓存技术（如Redis、Memcached等），将数据分别存储在内存缓存、本地缓存和分布式缓存中，以提高访问速度和降低数据库压力。\n\n*   **数据一致性**：使用分布式锁技术来保护红包的领取操作，确保每个用户只能领取一次红包。同时，为了保证数据一致性，可以采用消息队列等技术实现请求的异步处理和结果的返回。\n\n\n7.  **监控与告警**：\n\n\n*   **系统监控**：对红包系统的关键指标（如请求量、响应时间、错误率等）进行实时监控，以便及时发现和解决潜在问题。\n\n*   **告警机制**：设置合理的告警阈值，当系统出现异常情况时，及时发送告警通知给相关人员，以便快速响应和处理。\n\n\n9.  **安全性保障**：\n\n    通过以上措施的综合应用，可以大大提高红包系统架构的高可用性，确保系统在高峰时段能够稳定、高效地运行。\n\n\n*   **访问控制**：实施严格的访问控制策略，确保只有授权的用户才能访问红包系统。\n\n*   **数据加密**：对敏感数据进行加密存储和传输，以防止数据泄露和篡改。\n\n*   **安全审计**：定期对红包系统进行安全审计和漏洞扫描，及时修复发现的安全漏洞和隐患。\n\n\n#### 1 - 系统可用性影响因素\n\n**系统的可用性影响因素可分成两类：**\n\n*   一类计划外；\n\n    计划外包含很多因素，系统用到的所有东西都可能产生故障，都可能成功影响可用性的因素。从这个角度上来讲，可以说故障是无法避免的，系统的运作一定会产生故障，尤其是服务器有成千上万个的时候。\n\n*   一类计划内。\n\n    计划内的影响因素，主要有与升级相关、运维相关的操作，以及日常的备份等。这一类影响因素，通过精细地设计方案，是可以避免对可用性造成影响的。\n\n\n#### 2 - 红包系统可用性设计方向\n\n基于上面两个分析结论，可以总结出红包系统的可用性的设计方向。\n\n> 1.在不能避免意外故障的情况下，尽可能降低出现意外故障时对可用性的影响。\n>\n> 2.绝大多数计划内的日常维护可以通过方案的设计避免影响可用性，其中平行扩容特指关于存储层的平行扩容。\n\n下面从降低故障影响和微信红包系统的平行扩容两方面进行分析。\n\n首先是降低意外故障的影响，重点讲解订单存储层在订单 DB 故障的情况下如何降低对红包系统可用性的影响。\n\n#### 3 - 业务逻辑层 - 部署方案设计\n\n首先是业务逻辑层的部署方案。业务逻辑层是无状态的，微信红包系统的业务逻辑层，部署在两个城市，即两地部署，每一个城市部署至少三个园区，即三个 IDC。并且每个服务需要保证三个 IDC 的部署均衡。另外，三个 IDC 总服务能力需要冗余三分之一，当一个 IDC 出现故障时，服务能力仍然足够。从而达到 IDC 故障不会对可用性产生影响。\n\n#### 4 - 业务逻辑层 - 异步化设计\n\n如下图所示，微信红包的某些步骤不实时完成也不会影响用户对红包业务可用性的体验。\n\n比如拆红包，正常的业务流程很长，但关键步骤只有订单相关的几步。\n\n至于转零钱、写红包记录等操作不需要实时。\n\n用户抢到红包时，一般不会实时去钱包查看微信零钱，而是在微信群中点开消息查看本次抢到金额和他人抢红包金额。\n\n所以拆红包时只需要从 cache 查询用户是否拆过红包，然后写入拆红包的订单记录，更新发红包订单，其他的操作都可以异步化。\n\n当然，不是每个业务都可以进行异步化设计，需要进行业务分析，判断是否存在非关键步骤之外的事情可以将其异步化，并通过异步对账保证最终一致。\n\n经过上述分析之后，可以采用如下思路与方案：\n\n> 实现思路：\n>\n> 1.最简关键路径：简化发红包、拆红包核心流程路径，重点关注与订单相关流程。\n>\n> 2.快慢分离：将核心流程与其他非关键步骤分离。\n>\n> 方案：\n>\n> 1.写用户记录、零钱入账使用MQ异步执行\n>\n> 2.增加对帐机制保障最终一致。\n\n![](./2024/05/28/百亿流量红包系统/11.png)\n如上图所示，微信红包的某些步骤不实时完成也不会影响用户对红包业务可用性的体验。\n\n比如拆红包，正常的业务流程很长，但关键步骤只有订单相关的几步。\n\n至于转零钱、写红包记录等操作不需要实时。\n\n用户抢到红包时，一般不会实时去钱包查看微信零钱，而是在微信群中点开消息查看本次抢到金额和他人抢红包金额。\n\n所以拆红包时只需要从 cache 查询用户是否拆过红包，然后写入拆红包的订单记录，更新发红包订单，其他的操作都可以异步化。\n\n当然，不是每个业务都可以进行异步化设计，需要进行业务分析，判断是否存在非关键步骤之外的事情可以将其异步化，并通过异步对账保证最终一致。\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n#### 5 - 订单存储层 - 故障自愈\n\n为解决 DB 间的相互影响，需要将 DB 间相互隔离，订单存储层 SET 化。\n\nSET 化指订单 DB 和订单接入 SERVER 垂直 stick 一起。业务逻辑层访问订单时，根据订单倒数第二、三位数字找到所属订单 SET，一个 SET 的请求不能路由到其他 SET。\n\n通过 SET 化得到的好处是，控制 DB 连接数、隔离故障影响和分流并发。\n\n![](./2024/05/28/百亿流量红包系统/10.png)\n如上图所示，所设尾号 90-99 的 SET 故障时，如果业务逻辑服务后续不再生成属于这个 SET 的订单，那后续的业务就可以逐渐恢复。\n\n也就是在发生故障时，业务逻辑层发布一个版本，屏蔽故障号段的单号生成，就可以恢复业务。\n\n进一步想，除了人为发版本，有没有方法可以让 DB 故障时自动恢复？\n\n在 DB 故障导致业务失败时，业务逻辑层可获取到故障 DB 的号段，在发红包时，将这些故障的号段，换一个可用的号段就可恢复业务。\n\n订单号除了最后三位，前面的部分已能保证该红包唯一性，后面的数字只代表着分库表信息，故障时只需要将最后三位换另外一个 SET 便可自动恢复。\n\n完成这个设计后，即使 DB 出现故障，业务的可用性也不会有影响。\n\n这里还有一点，新的发红包请求可避免 DB 故障的影响，但那些故障之前已发出未被领取的红包，红包消息已发送到微信群，单号已确定，拆红包时还是失败。\n\n对这种情况，由于不会有增量，采用正常的主备切换解决即可。\n\n#### 6 - 订单存储层 - 平行扩容设计\n\n\n红包系统的高可用架构设计，主要包括了部署设计、SET 化设计、异步化设计、DB 故障自愈能力建设、平行扩容设计。\n\n> 以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。\n\n### 总结\n\n红包系统是一个高并发的资金交易系统，最大的技术挑战是保障并发性能与资金安全。\n\n这种全新的技术挑战，传统的“秒杀”系统设计方案已不能完全解决。\n\n在分析了业界“秒杀”系统解决方案的基础上，红包系统采用了 SET 化、请求排队串行化、双维度分库表等设计，形成了独特的高并发、资金安全系统解决方案。\n\n## 说在最后：有问题找老架构取经\n\n超高并发红包架构，一定是一个超级牛掰的简历亮点项目，黄金项目，稍微晚点把全量的架构方案和视频进行发布。\n\n这个项目写入简历，面试的时候如果大家能对答如流，如数家珍，基本上 面试官会被你 震惊到、吸引到。\n\n最终，**让面试官爱到 “不能自已、口水直流”**。offer， 也就来了。\n\n\n\n","slug":"百亿流量红包系统","published":1,"updated":"2024-06-01T04:07:08.899Z","comments":1,"layout":"post","photos":[],"_id":"clwxc4ra30012b4uhc8l152if","content":"<h1 id=\"百亿流量红包系统，如何架构？（字节面试真题）\"><a href=\"#百亿流量红包系统，如何架构？（字节面试真题）\" class=\"headerlink\" title=\"百亿流量红包系统，如何架构？（字节面试真题）\"></a>百亿流量红包系统，如何架构？（字节面试真题）</h1><h2 id=\"说在前面\"><a href=\"#说在前面\" class=\"headerlink\" title=\"说在前面\"></a>说在前面</h2><p>在读者交流群(50+)中，最近有小伙伴拿到了一线互联网企业如得物、阿里、滴滴、极兔、有赞、希音、百度、网易、美团的面试资格，遇到很多很重要的架构类&#x2F;设计类的场景题：</p>\n<blockquote>\n<p>1.如何设计百亿流量高并发红包系统 ，请说出你的方案？</p>\n<p>2.听说你会架构设计，请问一下如果让你来设计百亿流量红包系统，说说你的架构设计方案。</p>\n</blockquote>\n<p>最近有小伙伴在面试字节，又遇到了红包架构问题。小伙伴支支吾吾的说了几句，面试挂了。</p>\n<p>所以，给大家做一下系统化、体系化的梳理，使得大家内力猛增，可以充分展示一下大家雄厚的 “技术肌肉”，<strong>让面试官爱到 “不能自已、口水直流”</strong>，然后实现”offer直提”。</p>\n<h2 id=\"本文目录\"><a href=\"#本文目录\" class=\"headerlink\" title=\"本文目录\"></a>本文目录</h2><p><strong>- 说在前面</strong></p>\n<p><strong>- 本文目录</strong></p>\n<p>- 红包架构背景</p>\n<h5 id=\"红包系统和秒杀系统的对比\"><a href=\"#红包系统和秒杀系统的对比\" class=\"headerlink\" title=\"-红包系统和秒杀系统的对比\"></a>-红包系统和秒杀系统的对比</h5><p><strong>- 红包系统功能分析</strong></p>\n<p>- 功能1：包红包</p>\n<p>- 功能2：发红包</p>\n<p>- 功能3：抢红包</p>\n<p>- 功能4：拆红包</p>\n<h5 id=\"微信红包的业务特点\"><a href=\"#微信红包的业务特点\" class=\"headerlink\" title=\"-微信红包的业务特点\"></a>-微信红包的业务特点</h5><h5 id=\"微信红包的技术难点\"><a href=\"#微信红包的技术难点\" class=\"headerlink\" title=\"-微信红包的技术难点\"></a>-微信红包的技术难点</h5><p>- 红包系统概要设计</p>\n<h5 id=\"系统功能说明\"><a href=\"#系统功能说明\" class=\"headerlink\" title=\"-系统功能说明\"></a>-系统功能说明</h5><p><strong>- 数据库设计</strong></p>\n<h5 id=\"发红包\"><a href=\"#发红包\" class=\"headerlink\" title=\"-发红包\"></a>-发红包</h5><h5 id=\"抢红包\"><a href=\"#抢红包\" class=\"headerlink\" title=\"-抢红包\"></a>-抢红包</h5><p><strong>- 红包系统详细设计</strong></p>\n<p>- 红包整体架构</p>\n<p>- 高并发常用解决方案</p>\n<p>- 1- 使用内存替代实时的DB</p>\n<p>- 2- 使用乐观锁替代悲观锁</p>\n<h5 id=\"JVM-CAS-乐观锁方案\"><a href=\"#JVM-CAS-乐观锁方案\" class=\"headerlink\" title=\"-JVM CAS 乐观锁方案\"></a>-JVM CAS 乐观锁方案</h5><p><strong>- 微信红包系统的高并发解决方案</strong></p>\n<h5 id=\"1-分而治之：系统架构设计垂直Set化。\"><a href=\"#1-分而治之：系统架构设计垂直Set化。\" class=\"headerlink\" title=\"-1- 分而治之：系统架构设计垂直Set化。\"></a>-1- 分而治之：系统架构设计垂直Set化。</h5><h5 id=\"2-解决DB并发：逻辑Server层将请求排队。\"><a href=\"#2-解决DB并发：逻辑Server层将请求排队。\" class=\"headerlink\" title=\"-2- 解决DB并发：逻辑Server层将请求排队。\"></a>-2- 解决DB并发：逻辑Server层将请求排队。</h5><h5 id=\"3-系统性能稳定性保障：双维度分库分表设计。\"><a href=\"#3-系统性能稳定性保障：双维度分库分表设计。\" class=\"headerlink\" title=\"-3- 系统性能稳定性保障：双维度分库分表设计。\"></a>-3- 系统性能稳定性保障：双维度分库分表设计。</h5><h5 id=\"红包分配算法\"><a href=\"#红包分配算法\" class=\"headerlink\" title=\"- 红包分配算法\"></a>- 红包分配算法</h5><h5 id=\"1-实时拆分\"><a href=\"#1-实时拆分\" class=\"headerlink\" title=\"-1- 实时拆分\"></a>-1- 实时拆分</h5><h5 id=\"2-预先生成\"><a href=\"#2-预先生成\" class=\"headerlink\" title=\"-2- 预先生成\"></a>-2- 预先生成</h5><h5 id=\"3-二倍均值法\"><a href=\"#3-二倍均值法\" class=\"headerlink\" title=\"-3- 二倍均值法\"></a>-3- 二倍均值法</h5><p><strong>- 红包系统高可用架构设计</strong></p>\n<h5 id=\"1-系统可用性影响因素\"><a href=\"#1-系统可用性影响因素\" class=\"headerlink\" title=\"-1 - 系统可用性影响因素\"></a>-1 - 系统可用性影响因素</h5><h5 id=\"2-红包系统可用性设计方向\"><a href=\"#2-红包系统可用性设计方向\" class=\"headerlink\" title=\"-2 - 红包系统可用性设计方向\"></a>-2 - 红包系统可用性设计方向</h5><h5 id=\"3-业务逻辑层-部署方案设计\"><a href=\"#3-业务逻辑层-部署方案设计\" class=\"headerlink\" title=\"-3 - 业务逻辑层 - 部署方案设计\"></a>-3 - 业务逻辑层 - 部署方案设计</h5><h5 id=\"4-业务逻辑层-异步化设计\"><a href=\"#4-业务逻辑层-异步化设计\" class=\"headerlink\" title=\"-4 - 业务逻辑层 - 异步化设计\"></a>-4 - 业务逻辑层 - 异步化设计</h5><h5 id=\"5-订单存储层-故障自愈\"><a href=\"#5-订单存储层-故障自愈\" class=\"headerlink\" title=\"-5 - 订单存储层 - 故障自愈\"></a>-5 - 订单存储层 - 故障自愈</h5><h5 id=\"6-订单存储层-平行扩容设计\"><a href=\"#6-订单存储层-平行扩容设计\" class=\"headerlink\" title=\"-6 - 订单存储层 - 平行扩容设计\"></a>-6 - 订单存储层 - 平行扩容设计</h5><p>- 总结</p>\n<h3 id=\"红包架构背景\"><a href=\"#红包架构背景\" class=\"headerlink\" title=\"红包架构背景\"></a>红包架构背景</h3><p>红包是一种 瞬时流量很大的应用， 会在很短的时间内，产生巨大的瞬时流量，</p>\n<p>所以，作为架构师来说，这种场景有很大的架构挑战</p>\n<p>以2017年除夕为例，微信红包峰值QPS在76w左右，除夕当天收发微信红包的数量为142亿个。</p>\n<p>这种百亿级别的数据量、100Wqps级别的超高并发，而且整个系统核心功能和支付相关，需要做好高并发、高可用、高可靠。</p>\n<blockquote>\n<p>特别说明：红包架构也是高端面试的核心场景题, 后面也会以视频的形式，对这些架构的一系列的架构场景题目，做系统化的介绍。</p>\n<p>架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h4 id=\"红包系统和秒杀系统的对比-1\"><a href=\"#红包系统和秒杀系统的对比-1\" class=\"headerlink\" title=\"红包系统和秒杀系统的对比\"></a>红包系统和秒杀系统的对比</h4><p>我们先了解下微信红包支付的流程。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/1.png\"><br>在上面的红包流程中，核心业务包含包红包、发红包、抢红包、拆红包</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/2.png\"><br>其中最关键的步骤是</p>\n<ul>\n<li><p>发红包</p>\n</li>\n<li><p>抢红包。</p>\n</li>\n</ul>\n<p>在整个体系中，红包系统 是 支付系统的商户，红包这个商户出售的是钱。</p>\n<p>所以，用户发红包在红包系统 使用微信支付购买一份 红包商品，红包系统 将钱发放到相对应的微信群，供参与者领取。</p>\n<p>微信群里的用户抢红包，得到的是商品里边的 零钱。</p>\n<p>在整个体系中，红包系统 和支付系统 之间的关系是商家和第三方支付平台的关系。</p>\n<p>红包的流程，很类似 商品“秒杀”活动。</p>\n<ul>\n<li><p>包红包类似秒杀商品管理</p>\n</li>\n<li><p>发红包类似“秒杀”活动的商品上架；</p>\n</li>\n<li><p>抢红包等同于“秒杀”活动中的查询库存；</p>\n</li>\n<li><p>拆红包对应“秒杀”活动中用户的“秒杀”动作。</p>\n</li>\n</ul>\n<p>不过除了上面的相同点之外，红包业务 与 “秒杀”活动相比，还具备自身的特点：</p>\n<p>首先，抢红包 比 “秒杀”有更海量的并发要求。假设同一时间有 10 万个群里的用户同时在发红包，那就相当于同一时间有 10 万个“秒杀”活动发布出去。10 万个微信群里的用户同时抢红包，将产生海量的并发请求。</p>\n<p>其次，微信红包业务要求更严格的安全级别。红包业务本质上是资金交易。资金交易业务比普通商品“秒杀”活动有更高的安全级别要求。</p>\n<ul>\n<li><p><strong>“秒杀”时可以允许存在“超卖”（即实际被抢的商品数量比计划的库存多）、“少卖”（即实际被抢的商户数量比计划的库存少）的情况。</strong></p>\n</li>\n<li><p><strong>但是对于 红包，不允许存在“超卖”、“少卖”。</strong></p>\n</li>\n</ul>\n<blockquote>\n<p>特别说明：红包架构也是高端面试的核心场景题, 后面也会以视频的形式，对这些架构的一系列的架构场景题目，做系统化的介绍。</p>\n<p>架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h2 id=\"红包系统功能分析\"><a href=\"#红包系统功能分析\" class=\"headerlink\" title=\"红包系统功能分析\"></a>红包系统功能分析</h2><p>接下来，40岁老架构带大家，从架构师视角开始红包系统的功能分析。</p>\n<p>微信红包和微信支付之间的交互，与普通商家与微信支付的交互一样，需要经过多个步骤。</p>\n<ul>\n<li><p>用户发红包时，进入微信红包下一笔订单，系统记录发红包用户、发红包金额、红包数量和要发送到的用微信群。</p>\n</li>\n<li><p>然后微信红包系统请求微信支付服务器进行下单，用户使用微信支付进行支付。</p>\n</li>\n<li><p>支付成功后，微信支付后台系统通知微信红包后台系统支付成功结果，微信红包后台系统收到通知后推送微信红包消息到微信群。</p>\n</li>\n<li><p>微信群里用户便可抢红包。</p>\n</li>\n<li><p>用户发现红包还有剩余，就可以拆剩下的红包</p>\n</li>\n</ul>\n<p>这就是微信红包和微信支付的关系以及交互过程。</p>\n<h3 id=\"功能1：包红包\"><a href=\"#功能1：包红包\" class=\"headerlink\" title=\"功能1：包红包\"></a>功能1：包红包</h3><p>系统给每个红包分配一个唯一ID，也就是发红包的订单号，然后将红包发送给用户，红包的个数，红包金额写入到存储。</p>\n<h3 id=\"功能2：发红包\"><a href=\"#功能2：发红包\" class=\"headerlink\" title=\"功能2：发红包\"></a>功能2：发红包</h3><p>用户使用微信支付完成付款，微信红包后台收到微信支付成功的通知。红包系统将红包发送订单状态更新，更新为用户已支付，并写入用户发红包记录表，这样用户可以在钱包中找到用户的发红包流水和收发红包的记录，之后微信红包系统调用微信通知，将微信红包信息发送到微信群。</p>\n<h3 id=\"功能3：抢红包\"><a href=\"#功能3：抢红包\" class=\"headerlink\" title=\"功能3：抢红包\"></a>功能3：抢红包</h3><p>微信群中的用户收到红包消息之后，点开红包，开始抢红包，这个过程微信红包系统会检查红包是否已经被抢完，是否已经过期，是否已经抢过等验证逻辑。</p>\n<h3 id=\"功能4：拆红包\"><a href=\"#功能4：拆红包\" class=\"headerlink\" title=\"功能4：拆红包\"></a>功能4：拆红包</h3><p>拆红包是整个发红包流程最复杂的一个操作，需要查询这个红包的红包订单，判断用户是否可以拆包，计算本次可拆到的红包金额，并记录抢红包流水。</p>\n<p>拆红包包括如下步骤：</p>\n<ul>\n<li><p>1）查询这个红包发送订单，判断用户是否可拆，然后计算本次可拆到的红包金额；</p>\n</li>\n<li><p>2）然后写入一条抢红包记录。如果把拆红包过程，类比为一个秒杀活动的过程，相当于扣库存与写入秒杀记录的过程；</p>\n</li>\n<li><p>3）更新库存对应于更新红包发送订单，写入秒杀记录对应于写入这个红包的领取红包记录；</p>\n</li>\n<li><p>4）另外，还要写入用户整体的红包领取记录；</p>\n</li>\n<li><p>5）最后请求微信支付系统给拆到红包用户转入零钱，成功后更新抢红包的订单状态为已转账成功。</p>\n</li>\n</ul>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/5.png\"></p>\n<p>拆红包过程类似于一个秒杀活动的过程，需要做好库存扣减和秒杀记录的操作。</p>\n<p>更新库存就是更新红包发送的订单，写入秒杀记录就是写入红包领取的信息流水。</p>\n<p>还需要以用户为中心记录用户整体的红包领取记录。</p>\n<p>最后调用支付系统将拆红包后的金额转入用户零钱中，成功之后更新抢红包的订单状态为转账成功。</p>\n<blockquote>\n<p>所以，在看此文之前，最好看看的高并发三部曲的Java高并发核心编程卷3*（注意是最新的清华大学出版社出版的加强版），里边有秒杀架构，可以作为知识铺垫。</p>\n</blockquote>\n<h4 id=\"微信红包的业务特点-1\"><a href=\"#微信红包的业务特点-1\" class=\"headerlink\" title=\"微信红包的业务特点\"></a>微信红包的业务特点</h4><p>微信红包，特别是群红包，业务形态上类似于普通商品的”秒杀”活动。</p>\n<ul>\n<li><p>包红包类似秒杀商品管理</p>\n</li>\n<li><p>发红包类似“秒杀”活动的商品上架；</p>\n</li>\n<li><p>抢红包等同于“秒杀”活动中的查询库存；</p>\n</li>\n<li><p>拆红包对应“秒杀”活动中用户的“秒杀”动作。</p>\n<p>微信红包在业务形态上和普通商品”秒杀”活动相比，还有自身特点：</p>\n</li>\n</ul>\n<ol>\n<li><p><strong>海量并发请求</strong>：微信红包用户在微信群发一个红包，等同于在网上发布一次商品”秒杀”活动，假设同时有10万个群的用户同时发红包，那就相当于同一时间有10万个”秒杀”活动发布。10万个微信群的用户同时抢红包，将产生海量并发请求。</p>\n</li>\n<li><p><strong>更严格的安全级别</strong>：微信红包业务本质上是资金交易，微信红包是微信支付的一个商户，提供资金流转服务，用户发红包相当于在微信红包这个商户上使用微信支付购买了一笔”钱”，且收货地址是微信群。当用户支付成功后，红包”发货”到微信群里，群里的用户拆开红包后，微信红包提供了将”钱”转入拆红包用户微信零钱的服务。</p>\n</li>\n<li><p><strong>订单层南北独立体系</strong>：微信红包系统采用南北独立体系的订单层设计，即数据在南北两个系统中不同步。用户就近接入系统，请求发红包时，系统会根据用户所在地分配订单到南或北的系统，并在订单号上打上南北标识。这种设计有助于分摊流量，降低系统风险。</p>\n</li>\n<li><p><strong>流量闭环</strong>：在抢红包、拆红包、查红包详情列表时，接入层会根据红包单号上的南北标识，将流量分别引导到对应的南北系统闭环。这意味着，无论是发红包还是抢红包，用户都能够在就近的系统中完成操作，无需跨城，提高了系统的响应速度和稳定性。</p>\n</li>\n<li><p><strong>用户数据处理</strong>：微信红包系统的用户数据采取写多读少、全量保存的策略。用户数据的查询入口在微信钱包中，相对隐藏，访问量不会太大，且被视为可旁路的非关键信息，实时性要求不高。这种设计方式可以减少数据存储的压力，提高系统性能。</p>\n</li>\n<li><p><strong>实时计算红包金额</strong>：</p>\n<p>微信红包的金额是在拆红包时实时计算的，而不是预先分配的。系统会在拆红包时取0.01到剩余平均值*2之间的数值作为红包金额。</p>\n<p>这种实时计算的方式基于内存进行，不需要额外的存储空间，且计算效率很高。</p>\n<p>同时，为了保证操作的原子性，拆包过程中使用了CAS（Compare-and-Swap）算法，确保每次只有一个并发用户拆包成功。如果拆包CAS失败，系统会自动进行重试，但也可能在重试过程中被其他用户抢得先机而空手而归。</p>\n</li>\n<li><p><strong>架构演进</strong>：随着微信红包功能的不断发展和用户量的增长，其系统架构也经历了不断的演进和优化。从最初的数据库硬抗整个流量，到后来的使用缓存（cache）抗流量，再到现在的南北独立体系等设计，都是为了更好地应对高并发、提升系统性能和稳定性。</p>\n<p>资金交易业务比普通商品”秒杀”有更高的安全级别要求，普通的商品”秒杀”由商户提供，库存是商户预设，”秒杀”允许存在超卖和少卖的情况，但对于微信红包，用户发100元的红包绝对不可以拆出101元，以及只被领取99元时，剩下的1元在24小时过期后要精准退还给发红包用户。</p>\n<p>总的来说，微信红包系统架构的设计充分考虑了用户量、并发量、性能要求等因素，通过南北独立体系、流量闭环、用户数据处理、实时计算红包金额以及架构演进等多种手段，保证了系统的稳定运行和良好用户体验。</p>\n</li>\n</ol>\n<h4 id=\"微信红包的技术难点-1\"><a href=\"#微信红包的技术难点-1\" class=\"headerlink\" title=\"微信红包的技术难点\"></a>微信红包的技术难点</h4><p>微信红包系统架构的技术难点主要体现在以下几个方面：</p>\n<ol>\n<li><p><strong>高并发难点</strong>：</p>\n<p>微信红包在特定时间（如春节、节假日等）会面临极高的并发量，如何有效地处理这些并发请求，保证系统的稳定性和响应速度，是红包系统架构设计的关键挑战之一。</p>\n</li>\n<li><p><strong>资金安全难点</strong>：</p>\n<p>红包系统涉及到资金的转移和存储，因此资金安全是系统设计的重中之重。如何确保资金安全，防止被攻击或篡改，是系统架构设计中需要重点考虑的问题。</p>\n<p>红包业务涉及资金交易，所以一定不能出现超卖、少卖的情况。</p>\n</li>\n</ol>\n<ul>\n<li><p>超卖：发了 10 块钱，结果抢到了 11 块钱，多的钱只能系统补上，如此为爱发电应用估计早就下架了；</p>\n</li>\n<li><p>少卖：发了 10 块钱，只抢了 9 块，多的钱得原封不动地退还用户，否则第二天就接到法院传单了。</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li><p><strong>用户体验难点</strong></p>\n<p>红包系统需要保证良好的用户体验，包括响应速度、公平性（先抢先得）、成功率等。</p>\n<p>如何在高并发场景下保证用户体验，是系统架构设计的重要目标。</p>\n<p>了解下微信红包的用户体验 的4大核心：摇&#x2F;发&#x2F;抢&#x2F;拆。</p>\n</li>\n</ol>\n<ul>\n<li><p>摇：摇的流畅</p>\n</li>\n<li><p>快：抢的要快</p>\n</li>\n<li><p>爽：拆的爽</p>\n</li>\n<li><p>稳：能分享出去</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li><p><strong>数据一致性难点</strong>：</p>\n<p>红包系统需要保证数据的一致性，包括红包库存数据、用户账户数据等。如何在高并发场景下保证数据的一致性，是系统架构设计的重要挑战。</p>\n</li>\n</ol>\n<ul>\n<li><p>参与用户越多，并发 DB 请求越大，数据越容易出现事务问题，所以系统得做好<strong>事务一致性</strong>；</p>\n</li>\n<li><p>抢红包系统涉及金钱交易，所以事务级别要求更高，<strong>不能出现脏数据</strong>。</p>\n</li>\n</ul>\n<ol start=\"8\">\n<li><p><strong>系统扩展性难点</strong>：</p>\n<p>随着用户量和业务量的增长，红包系统需要具备良好的扩展性，能够方便地增加新的功能或提升性能。</p>\n<p>如何设计可扩展的系统架构，是系统架构设计的重要考虑因素。</p>\n<p>为了解决这些技术难点，我们可以采用多种技术手段，如分而治之、负载均衡、读写分离、水平切分、垂直切分等，来提升系统的性能和稳定性。同时，系统还采用了柔性服务、系统降级等策略，来保证在有限资源下满足用户的核心需求。</p>\n</li>\n</ol>\n<h3 id=\"红包系统概要设计\"><a href=\"#红包系统概要设计\" class=\"headerlink\" title=\"红包系统概要设计\"></a>红包系统概要设计</h3><h4 id=\"系统功能说明-1\"><a href=\"#系统功能说明-1\" class=\"headerlink\" title=\"系统功能说明\"></a>系统功能说明</h4><p>抢红包功能允许用户在群聊中发送任意个数和金额的红包，群成员可以抢到随机金额的红包，但要<strong>保证每个用户的红包金额不小于 0.01 元</strong>。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/3.png\"><br>抢红包的详细交互流程如下：</p>\n<ol>\n<li><p>用户接收到抢红包通知，点击通知打开群聊页面；</p>\n</li>\n<li><p>用户点击抢红包，后台服务验证用户资格，确保用户尚未领取过此红包；</p>\n</li>\n<li><p>若用户资格验证通过，后台服务分配红包金额并存储领取记录；</p>\n</li>\n<li><p>用户在微信群中看到领取金额，红包状态更新为“已领取”；</p>\n</li>\n<li><p>异步调用支付接口，将红包金额更新到钱包里。</p>\n</li>\n</ol>\n<h2 id=\"数据库设计\"><a href=\"#数据库设计\" class=\"headerlink\" title=\"数据库设计\"></a>数据库设计</h2><p><strong>红包表：redpack</strong></p>\n<p>红包表用来记录用户发了多少红包，以及需要维护的剩余金额，</p>\n<p>红包表：redpack的字段如下：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>主键，红包ID。</td>\n</tr>\n<tr>\n<td>user_id</td>\n<td>发送红包的用户id。</td>\n</tr>\n<tr>\n<td>total_amount</td>\n<td>红包总金额。</td>\n</tr>\n<tr>\n<td>surplus_amount</td>\n<td>红包剩余金额。</td>\n</tr>\n<tr>\n<td>total</td>\n<td>红包总数。</td>\n</tr>\n<tr>\n<td>surplus_total</td>\n<td>剩余红包总数。</td>\n</tr>\n</tbody></table>\n<p><strong>红包记录表：redpack_record</strong></p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>主键，记录id。</td>\n</tr>\n<tr>\n<td>redpack_id</td>\n<td>红包id。</td>\n</tr>\n<tr>\n<td>user_id</td>\n<td>用户id。</td>\n</tr>\n<tr>\n<td>amount</td>\n<td>抢到的金额。</td>\n</tr>\n</tbody></table>\n<h4 id=\"发红包-1\"><a href=\"#发红包-1\" class=\"headerlink\" title=\"发红包\"></a>发红包</h4><p>设置完红包参数后，微信支付，完成付款，然后收到付款成功通知，红包系统更新红包订单状态，更新为已支付，并写入红包发送记录表。</p>\n<p>这样用户可以将用户的红包信息和红包的收发记录发出，红包系统调用微信通知，将红包信息发送到微信群。</p>\n<p>发红包的交互步骤如下：</p>\n<ol>\n<li><p>用户设置红包的总金额和个数后，在红包表中增加一条数据，开始发红包；</p>\n</li>\n<li><p>为了保证实时性和抢红包的效率，在 Redis 中增加一条记录，<strong>存储红包 ID 和总人数 n</strong>；</p>\n</li>\n<li><p>抢红包消息推送给所有群成员。</p>\n</li>\n</ol>\n<h4 id=\"抢红包-1\"><a href=\"#抢红包-1\" class=\"headerlink\" title=\"抢红包\"></a>抢红包</h4><p>微信群用户收到红包后，点开，红包系统会校验红包是否被抢完，是否过期。</p>\n<p>微信红包的抢红包和拆红包是两个分离的服务，用户点击抢红包后需要进行两次操作。</p>\n<p>这也是为什么明明有时候抢到了红包，点开后却发现<strong>该红包已经被领取完了</strong>。</p>\n<p>抢红包的交互步骤如下：</p>\n<ol>\n<li><p>抢红包：抢操作在 Redis 缓存层完成，通过原子递减的操作来更新红包个数，个数递减为 0 后就说明抢光了。</p>\n</li>\n<li><p>拆红包：拆红包时，首先会实时计算金额，一般是通过二倍均值法实现（即 0.01 到剩余平均值的 2 倍之间）。</p>\n</li>\n<li><p>红包记录：用户获取红包金额后，通过数据库的事务操作累加已经领取的个数和金额，并更新红包表和记录表。</p>\n</li>\n<li><p>转账：为了提升效率，最终的转账为异步操作，这也是为什么在春节期间，红包领取后不能立即在余额中看到的原因。</p>\n</li>\n</ol>\n<h2 id=\"红包系统详细设计\"><a href=\"#红包系统详细设计\" class=\"headerlink\" title=\"红包系统详细设计\"></a>红包系统详细设计</h2><h3 id=\"红包整体架构\"><a href=\"#红包整体架构\" class=\"headerlink\" title=\"红包整体架构\"></a>红包整体架构</h3><p>如下图所示，是微信红包的系统架构</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/4.png\"><br>总体是三层架构：</p>\n<ul>\n<li><p>首先是微信统一接入层，下面是微信红包系统 API，包括发、抢、拆、查红包详情、查红包用户列表。</p>\n</li>\n<li><p>接入层下面，是封装微信红包关键业务的逻辑服务；</p>\n</li>\n<li><p>业务下面数据存储层，微信红包最主要的数据是订单数据，包括发红包订单和拆红包订单两部分。</p>\n</li>\n</ul>\n<p>数据存储层的冷热分离设计：微信红包数据的访问热度，随着时间流逝会急剧降低，也就是数据的访问时间段非常集中，一般红包发出三天后，99% 的用户不会再去点开这个红包了。因此微信红包系统采取按时间做冷热数据分离，降低数据的存储成本，同时提升了热数据的访问性能。</p>\n<p>除了在线计算的三层架构，还有离线处理的数据分析。</p>\n<p>数据分析平台用于对红包数据的分析计算，比如朋友圈里的文章，统计从 某年 1 月 1 日到 2017 年 1 月一个用户总共抢红包的金额，在全国的排名情况，发红包数最多的城市等。</p>\n<p>数据分析平台另外一个作用就是对账，红包的订单和微信支付的订单需要对账，以保证最终资金的一致性；</p>\n<ul>\n<li><p>订单的数据和订单的 cache 需要做对账，以保证数据的完整性；</p>\n</li>\n<li><p>订单数据和用户的收发记录需要对账，以保证用户列表完整性。</p>\n</li>\n</ul>\n<h3 id=\"高并发常用解决方案\"><a href=\"#高并发常用解决方案\" class=\"headerlink\" title=\"高并发常用解决方案\"></a>高并发常用解决方案</h3><p>普通商品秒杀系统，解决高并发问题的方案，大致有以下2种：</p>\n<h3 id=\"1-使用内存替代实时的DB\"><a href=\"#1-使用内存替代实时的DB\" class=\"headerlink\" title=\"1- 使用内存替代实时的DB\"></a>1- 使用内存替代实时的DB</h3><p>将实时扣库存的行为上移到内存Cache中，内存Cache操作成功直接给Server返回成功，然后异步落DB持久化。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/8.png\"><br>这个方案的优缺点如下：</p>\n<blockquote>\n<p>优点：用内存操作替代磁盘操作，提高了并发性能。</p>\n<p>缺点：在内存操作成功DB持久化失败，或者内存Cache故障的情况下，DB持久化会丢数据，不适合微信红包这种资金交易系统。</p>\n</blockquote>\n<h3 id=\"2-使用乐观锁替代悲观锁\"><a href=\"#2-使用乐观锁替代悲观锁\" class=\"headerlink\" title=\"2- 使用乐观锁替代悲观锁\"></a>2- 使用乐观锁替代悲观锁</h3><p><strong>什么是悲观锁呢？</strong></p>\n<p>所谓悲观锁，是关系数据库管理系统里的一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。对应于上文分析中的“并发请求抢锁”行为。</p>\n<p><strong>什么是乐观锁呢？</strong></p>\n<p>所谓乐观锁，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</p>\n<p>乐观锁分为DB乐观锁和 JVM CAS 乐观锁。</p>\n<p>DB乐观锁的具体应用方法，是在 DB 的“库存”记录中维护一个版本号。</p>\n<p>商品“秒杀”系统中，在更新“库存”的操作进行前，先去 DB 获取当前版本号。</p>\n<p>在更新库存的事务提交时，检查该版本号是否已被其他事务修改。如果版本没被修改，则提交事务，且版本号加 1；如果版本号已经被其他事务修改，则回滚事务，并给上层报错。</p>\n<p>DB乐观锁可以提高DB的并发处理能力，但是如果应用于微信红包系统，则会存在下面三个问题：</p>\n<ol>\n<li><p>如果拆红包采用乐观锁，那么在并发抢到相同版本号的拆红包请求中，只有一个能拆红包成功，其他的请求将事务回滚并返回失败，给用户报错，用户体验完全不可接受。</p>\n</li>\n<li><p>如果采用乐观锁，将会导致第一时间同时拆红包的用户有一部分直接返回失败，反而那些“手慢”的用户，有可能因为并发减小后拆红包成功，这会带来用户体验上的负面影响。</p>\n</li>\n<li><p>如果采用乐观锁的方式，会带来大数量的无效更新请求、事务回滚，给 DB 造成不必要的额外压力。</p>\n</li>\n</ol>\n<h4 id=\"JVM-CAS-乐观锁方案-1\"><a href=\"#JVM-CAS-乐观锁方案-1\" class=\"headerlink\" title=\"JVM CAS 乐观锁方案\"></a>JVM CAS 乐观锁方案</h4><p>出于性能原因，微信红包系统使用 JVM CAS 乐观锁，而不是DB乐观锁的方式解决并发抢锁问题。</p>\n<p>微信红包的金额是在拆红包时实时计算的，而不是预先分配的。系统会在拆红包时取0.01到剩余平均值*2之间的数值作为红包金额。</p>\n<p>这种实时计算的方式基于JVM 内存进行，不需要额外的存储空间，且计算效率很高。</p>\n<p>同时，为了保证操作的原子性，拆包过程中使用了CAS（Compare-and-Swap）算法，确保每次只有一个并发用户拆包成功。如果拆包CAS失败，系统会自动进行重试，但也可能在重试过程中被其他用户抢得先机而空手而归。</p>\n<p>如何保证同一个红包由同一个节点去拆包呢？将同一个红包 ID 的所有请求 stick 到同一台 Server，这个后面介绍。</p>\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h2 id=\"微信红包系统的高并发解决方案\"><a href=\"#微信红包系统的高并发解决方案\" class=\"headerlink\" title=\"微信红包系统的高并发解决方案\"></a>微信红包系统的高并发解决方案</h2><p>综合上面的分析，我们的红包系统针对相应的技术难点，采用如下3个方案，解决高并发问题。</p>\n<h5 id=\"1-分而治之：系统架构设计垂直Set化。-1\"><a href=\"#1-分而治之：系统架构设计垂直Set化。-1\" class=\"headerlink\" title=\"1- 分而治之：系统架构设计垂直Set化。\"></a>1- 分而治之：系统架构设计垂直Set化。</h5><p><strong>什么是Set（单元）化架构呢?</strong></p>\n<blockquote>\n<p>单元化架构是一种将系统划分为多个独立的、自包含的单元的部署架构，每个单元都能够完成所有业务操作，包含所有业务所需的服务以及分配给该单元的数据。这种架构将单元作为部署的基本单位，在全站所有机房中部署多个单元，每个机房内的单元数目不固定，但任一单元均部署系统所需的全部应用。数据则是全量数据按照某种维度划分后的一部分。与传统意义上的SOA（服务化）架构不同，单元化架构下，服务仍然是分层的，但每一层中的任意一个节点都属于且仅属于某一个单元，上层调用下层时，仅会选择本单元内的节点。</p>\n</blockquote>\n<p><strong>通俗的理解为</strong>：</p>\n<p>单元化架构，简单来说，就是把系统拆分成若干个独立的单元，每个单元都包含了完成业务操作所需的所有服务和数据。这些单元可以独立部署、管理和监控，就像一个个小房子，每个房子都有自己的客厅、卧室和厨房（服务），也有自己的食物和水（数据）。</p>\n<p>如下图，是一种单元化架构设计。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/6.png\"></p>\n<p>微信红包用户发一个红包时，微信红包系统生成一个 ID 作为这个红包的唯一标识。</p>\n<p>接下来这个红包的所有发红包、抢红包、拆红包、查询红包详情等操作，都根据这个 ID 关联。</p>\n<p>红包系统根据这个红包 ID，按一定的规则（如按 ID 尾号取模等），垂直上下切分。</p>\n<p>切分后，一个垂直链条上的逻辑 Server 服务器、DB 统称为一个 SET。</p>\n<p>各个 SET 之间相互独立，互相解耦。并且同一个红包 ID 的所有请求，包括发红包、抢红包、拆红包、查详情详情等，垂直 stick 到同一个 SET 内处理，高度内聚。</p>\n<p>通过这样的方式，系统将所有红包请求这个巨大的洪流分散为多股小流，互不影响，分而治之，如下图所示。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/7.png\"><br>这个方案解决了同时存在海量事务级操作的问题，将<strong>海量化为小量</strong>。</p>\n<h5 id=\"2-解决DB并发：逻辑Server层将请求排队。-1\"><a href=\"#2-解决DB并发：逻辑Server层将请求排队。-1\" class=\"headerlink\" title=\"2- 解决DB并发：逻辑Server层将请求排队。\"></a>2- 解决DB并发：逻辑Server层将请求排队。</h5><p>红包系统是资金交易系统，DB 操作的事务性无法避免，所以会存在“并发抢锁”问题。但是如果到达 DB 的事务操作（也即拆红包行为）不是并发的，而是串行的，就不会存在“并发抢锁”的问题了。</p>\n<p>按这个思路，为了使拆红包的事务操作串行地进入 DB，只需要将请求在 Server 层以 FIFO（先进先出）的方式排队，就可以达到这个效果。从而问题就集中到 Server 的 FIFO 队列设计上。</p>\n<p>红包系统设计了分布式的、轻巧的、灵活的 FIFO 队列方案。其具体实现如下：</p>\n<p><strong>1）将同一个红包 ID 的所有请求 stick 到同一台 Server。</strong></p>\n<p>上面 SET 化方案已经介绍，同个红包 ID 的所有请求，按红包 ID stick 到同个 SET 中。</p>\n<p>不过在同个 SET 中，会存在多台 Server 服务器同时连接同一台 DB（基于容灾、性能考虑，需要多台 Server 互备、均衡压力）。</p>\n<p>为了使同一个红包 ID 的所有请求，stick 到同一台 Server 服务器上，在 SET 化的设计之外，微信红包系统添加了一层基于红包 ID hash 值的分流，如下图所示。</p>\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<p><strong>2）设计单机请求排队方案。</strong></p>\n<p>将 stick 到同一台 Server 上的所有请求在被接收进程接收后，按红包 ID 进行排队。</p>\n<p>然后串行地进入 worker 进程（执行业务逻辑）进行处理，从而达到排队的效果，如下图所示。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/9.png\"><br><strong>3）增加 Redis缓存 控制并发。</strong></p>\n<p>为了防止 Server 中的请求队列过载导致队列被降级，从而所有请求拥进 DB，系统增加了与 Server 服务器同机部署的 Redis ，用于控制拆同一个红包的请求并发数。</p>\n<p>具体来说，利用 Redis 的 CAS 原子累增操作，控制同时进入 DB 执行拆红包事务的请求数，超过预先设定数值则直接拒绝服务。用于 DB 负载升高时的降级体验。</p>\n<p>通过以上三个措施，系统有效地控制了 DB 的“并发抢锁”情况。</p>\n<h5 id=\"3-系统性能稳定性保障：双维度分库分表设计。-1\"><a href=\"#3-系统性能稳定性保障：双维度分库分表设计。-1\" class=\"headerlink\" title=\"3- 系统性能稳定性保障：双维度分库分表设计。\"></a>3- 系统性能稳定性保障：双维度分库分表设计。</h5><p>红包系统的分库表规则，初期是根据红包 ID 的 hash 值分为多库多表。</p>\n<p>随着红包数据量逐渐增大，单表数据量也逐渐增加。而 DB 的性能与单表数据量有一定相关性。当单表数据量达到一定程度时，DB 性能会有大幅度下降，影响系统性能稳定性。</p>\n<p>采用冷热分离，将历史冷数据与当前热数据分开存储，可以解决这个问题。</p>\n<p>处理微信红包数据的冷热分离时，系统在以红包 ID 维度分库表的基础上，增加了以循环天分表的维度，形成了双维度分库表的特色。</p>\n<p>具体来说，就是分库表规则像 db_xx.t_y_dd 设计，其中，xx&#x2F;y 是红包 ID 的 hash 值后三位，dd 的取值范围在 01~31，代表一个月天数最多 31 天。</p>\n<p>通过这种双维度分库表方式，解决了 DB 单表数据量膨胀导致性能下降的问题，保障了系统性能的稳定性。同时，在热冷分离的问题上，又使得数据搬迁变得简单而优雅。</p>\n<p>综上所述，微信红包系统在解决高并发问题上的设计，主要采用了 <strong>SET 化分治</strong>、<strong>请求排队</strong>、<strong>双维度分库表</strong>等方案，使得单组 DB 的并发性能大幅度提升，取得了很好的效果。</p>\n<h4 id=\"红包分配算法-1\"><a href=\"#红包分配算法-1\" class=\"headerlink\" title=\"红包分配算法\"></a>红包分配算法</h4><p>抢红包后，我们需要进行拆红包，接下来我们讨论一下红包系统的红包分配算法。</p>\n<p>红包金额分配时，由于是随机分配，所以有两种实现方案：<strong>实时拆分和预先生成</strong></p>\n<h5 id=\"1-实时拆分-1\"><a href=\"#1-实时拆分-1\" class=\"headerlink\" title=\"1- 实时拆分\"></a>1- 实时拆分</h5><p>实时拆分，指的是在<strong>抢红包时实时计算</strong>每个红包的金额，以实现红包的拆分过程。</p>\n<p>这个对系统性能和拆分算法要求较高，例如拆分过程要一直保证后续待拆分红包的金额不能为空，不容易做到拆分的红包金额服从<strong>正态分布</strong>规律。</p>\n<h5 id=\"2-预先生成-1\"><a href=\"#2-预先生成-1\" class=\"headerlink\" title=\"2- 预先生成\"></a>2- 预先生成</h5><p>预先生成，指的是在红包<strong>开抢之前</strong>已经完成了红包的<strong>金额拆分</strong>，抢红包时只是依次取出拆分好的红包金额。</p>\n<p>这种方式对拆分算法要求较低，可以拆分出随机性很好的红包金额，但通常需要结合队列使用。</p>\n<h5 id=\"3-二倍均值法-1\"><a href=\"#3-二倍均值法-1\" class=\"headerlink\" title=\"3- 二倍均值法\"></a>3- 二倍均值法</h5><p>综合上述优缺点考虑，以及微信群聊中的人数不多（目前最高 500 人），所以我们采用实时拆分的方式，用<strong>二倍均值法</strong>来生成随机红包，只满足随机即可，不需要正态分布。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">使用二倍均值法生成的随机数，每次随机金额会在  0.01 ~ 剩余平均值\\*2 之间。  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>假设当前红包剩余金额为 10 元，剩余个数为 5，<strong>10&#x2F;5 &#x3D; 2</strong>，则当前用户可以抢到的红包金额为：<strong>0.01 ~ 4</strong> 元之间。</p>\n<p>以下是使用Java实现的二倍均值算法，在红包分配场景中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class RedPacketDistribution &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public static List&lt;BigDecimal&gt; distribute(BigDecimal totalAmount, int totalCount) &#123;  </span><br><span class=\"line\">        // 校验总金额是否为正  </span><br><span class=\"line\">        if (totalAmount.compareTo(BigDecimal.ZERO) &lt;= 0) &#123;  </span><br><span class=\"line\">            throw new IllegalArgumentException(&quot;Invalid parameter, totalAmount must be positive.&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        // 校验红包总数是否至少为1  </span><br><span class=\"line\">        if (totalCount &lt; 1) &#123;  </span><br><span class=\"line\">            throw new IllegalArgumentException(&quot;Invalid parameter, totalCount must be at least 1.&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        List&lt;BigDecimal&gt; redPacketList = new ArrayList&lt;&gt;(totalCount);  </span><br><span class=\"line\">        BigDecimal remainingAmount = totalAmount.multiply(BigDecimal.valueOf(2)); // 初始化为总金额的两倍  </span><br><span class=\"line\">        ThreadLocalRandom random = ThreadLocalRandom.current(); // 使用线程安全的随机数生成器  </span><br><span class=\"line\">  </span><br><span class=\"line\">        for (int i = 0; i &lt; totalCount - 1; i++) &#123;  </span><br><span class=\"line\">            // 随机获取一个幸运值，范围在\\[0, 当前剩余金额)  </span><br><span class=\"line\">            BigDecimal luckValue = BigDecimal.valueOf(random.nextDouble()).multiply(remainingAmount);  </span><br><span class=\"line\">            // 计算并添加实际分配的红包金额（幸运值的一半）  </span><br><span class=\"line\">            BigDecimal amount = luckValue.divide(BigDecimal.valueOf(2), BigDecimal.ROUND\\_HALF\\_DOWN);  </span><br><span class=\"line\">            redPacketList.add(amount);  </span><br><span class=\"line\">            // 更新剩余金额  </span><br><span class=\"line\">            remainingAmount = remainingAmount.subtract(luckValue);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 最后一个红包直接拿走剩余的全部金额，确保总和正确  </span><br><span class=\"line\">        redPacketList.add(remainingAmount.divide(BigDecimal.valueOf(2), BigDecimal.ROUND\\_HALF\\_DOWN));  </span><br><span class=\"line\">  </span><br><span class=\"line\">        return redPacketList;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public static void main(String\\[\\] args) &#123;  </span><br><span class=\"line\">        BigDecimal totalAmount = new BigDecimal(&quot;100.00&quot;); // 红包总金额  </span><br><span class=\"line\">        int totalCount = 10;      // 红包个数  </span><br><span class=\"line\">        List&lt;BigDecimal&gt; redPackets = distribute(totalAmount, totalCount);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        System.out.println(&quot;Red packet distribution:&quot;);  </span><br><span class=\"line\">        for (BigDecimal amount : redPackets) &#123;  </span><br><span class=\"line\">            System.out.printf(&quot;%.2f, &quot;, amount);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h2 id=\"红包系统高可用架构设计\"><a href=\"#红包系统高可用架构设计\" class=\"headerlink\" title=\"红包系统高可用架构设计\"></a>红包系统高可用架构设计</h2><p>红包业务量级的高速发展，对后台系统架构的可用性要求越来越高。在保障微信红包业务体验的前提下，红包后台系统进行了一系列高可用方面的优化设计。</p>\n<p>要保障红包系统架构的高可用性，可以从多个方面进行优化和设计。以下是一些详细说明：</p>\n<ol>\n<li><strong>系统架构设计</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>信息流、业务流、资金流分离</strong>：红包系统由信息流、业务流、资金流三部分组成，这三部分在组织架构上应由不同的后台团队完成，以提高系统的模块化和可维护性。</p>\n</li>\n<li><p><strong>微服务架构</strong>：采用微服务架构，将红包系统拆分成多个独立的服务，每个服务负责特定的功能，这样可以提高系统的可扩展性和容错性。</p>\n</li>\n<li><p><strong>无状态设计</strong>：确保红包系统的服务是无状态的，即服务不需要保存用户的会话信息，这样可以提高系统的并发处理能力和可靠性。</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>高可用性策略</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>冗余部署</strong>：将系统的关键组件部署在多台服务器上，通过搭建主备或者集群的架构来实现冗余。当主服务器出现故障时，备用服务器能够自动接管，保证系统的可用性。</p>\n</li>\n<li><p><strong>负载均衡</strong>：通过将流量分发到多台服务器上，均衡系统的请求负载，提高系统的可用性和扩展性。负载均衡可以通过硬件（如负载均衡器）或者软件（如Nginx、HAProxy）实现。</p>\n</li>\n<li><p><strong>服务容器化</strong>：使用容器技术（如Docker、Kubernetes）将应用程序与其依赖项打包为容器，实现快速部署、弹性扩展和自动化管理。容器化可以提高系统的可移植性、弹性和可伸缩性，从而增加系统的高可用性。</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li><strong>数据保障</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>数据备份与恢复</strong>：定期对关键数据进行备份，并确保备份的数据可用性。这样，在发生数据丢失或损坏时，可以快速恢复数据，减少系统停机时间。</p>\n</li>\n<li><p><strong>分布式缓存</strong>：使用多级缓存技术（如Redis、Memcached等），将数据分别存储在内存缓存、本地缓存和分布式缓存中，以提高访问速度和降低数据库压力。</p>\n</li>\n<li><p><strong>数据一致性</strong>：使用分布式锁技术来保护红包的领取操作，确保每个用户只能领取一次红包。同时，为了保证数据一致性，可以采用消息队列等技术实现请求的异步处理和结果的返回。</p>\n</li>\n</ul>\n<ol start=\"7\">\n<li><strong>监控与告警</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>系统监控</strong>：对红包系统的关键指标（如请求量、响应时间、错误率等）进行实时监控，以便及时发现和解决潜在问题。</p>\n</li>\n<li><p><strong>告警机制</strong>：设置合理的告警阈值，当系统出现异常情况时，及时发送告警通知给相关人员，以便快速响应和处理。</p>\n</li>\n</ul>\n<ol start=\"9\">\n<li><p><strong>安全性保障</strong>：</p>\n<p>通过以上措施的综合应用，可以大大提高红包系统架构的高可用性，确保系统在高峰时段能够稳定、高效地运行。</p>\n</li>\n</ol>\n<ul>\n<li><p><strong>访问控制</strong>：实施严格的访问控制策略，确保只有授权的用户才能访问红包系统。</p>\n</li>\n<li><p><strong>数据加密</strong>：对敏感数据进行加密存储和传输，以防止数据泄露和篡改。</p>\n</li>\n<li><p><strong>安全审计</strong>：定期对红包系统进行安全审计和漏洞扫描，及时修复发现的安全漏洞和隐患。</p>\n</li>\n</ul>\n<h4 id=\"1-系统可用性影响因素-1\"><a href=\"#1-系统可用性影响因素-1\" class=\"headerlink\" title=\"1 - 系统可用性影响因素\"></a>1 - 系统可用性影响因素</h4><p><strong>系统的可用性影响因素可分成两类：</strong></p>\n<ul>\n<li><p>一类计划外；</p>\n<p>计划外包含很多因素，系统用到的所有东西都可能产生故障，都可能成功影响可用性的因素。从这个角度上来讲，可以说故障是无法避免的，系统的运作一定会产生故障，尤其是服务器有成千上万个的时候。</p>\n</li>\n<li><p>一类计划内。</p>\n<p>计划内的影响因素，主要有与升级相关、运维相关的操作，以及日常的备份等。这一类影响因素，通过精细地设计方案，是可以避免对可用性造成影响的。</p>\n</li>\n</ul>\n<h4 id=\"2-红包系统可用性设计方向-1\"><a href=\"#2-红包系统可用性设计方向-1\" class=\"headerlink\" title=\"2 - 红包系统可用性设计方向\"></a>2 - 红包系统可用性设计方向</h4><p>基于上面两个分析结论，可以总结出红包系统的可用性的设计方向。</p>\n<blockquote>\n<p>1.在不能避免意外故障的情况下，尽可能降低出现意外故障时对可用性的影响。</p>\n<p>2.绝大多数计划内的日常维护可以通过方案的设计避免影响可用性，其中平行扩容特指关于存储层的平行扩容。</p>\n</blockquote>\n<p>下面从降低故障影响和微信红包系统的平行扩容两方面进行分析。</p>\n<p>首先是降低意外故障的影响，重点讲解订单存储层在订单 DB 故障的情况下如何降低对红包系统可用性的影响。</p>\n<h4 id=\"3-业务逻辑层-部署方案设计-1\"><a href=\"#3-业务逻辑层-部署方案设计-1\" class=\"headerlink\" title=\"3 - 业务逻辑层 - 部署方案设计\"></a>3 - 业务逻辑层 - 部署方案设计</h4><p>首先是业务逻辑层的部署方案。业务逻辑层是无状态的，微信红包系统的业务逻辑层，部署在两个城市，即两地部署，每一个城市部署至少三个园区，即三个 IDC。并且每个服务需要保证三个 IDC 的部署均衡。另外，三个 IDC 总服务能力需要冗余三分之一，当一个 IDC 出现故障时，服务能力仍然足够。从而达到 IDC 故障不会对可用性产生影响。</p>\n<h4 id=\"4-业务逻辑层-异步化设计-1\"><a href=\"#4-业务逻辑层-异步化设计-1\" class=\"headerlink\" title=\"4 - 业务逻辑层 - 异步化设计\"></a>4 - 业务逻辑层 - 异步化设计</h4><p>如下图所示，微信红包的某些步骤不实时完成也不会影响用户对红包业务可用性的体验。</p>\n<p>比如拆红包，正常的业务流程很长，但关键步骤只有订单相关的几步。</p>\n<p>至于转零钱、写红包记录等操作不需要实时。</p>\n<p>用户抢到红包时，一般不会实时去钱包查看微信零钱，而是在微信群中点开消息查看本次抢到金额和他人抢红包金额。</p>\n<p>所以拆红包时只需要从 cache 查询用户是否拆过红包，然后写入拆红包的订单记录，更新发红包订单，其他的操作都可以异步化。</p>\n<p>当然，不是每个业务都可以进行异步化设计，需要进行业务分析，判断是否存在非关键步骤之外的事情可以将其异步化，并通过异步对账保证最终一致。</p>\n<p>经过上述分析之后，可以采用如下思路与方案：</p>\n<blockquote>\n<p>实现思路：</p>\n<p>1.最简关键路径：简化发红包、拆红包核心流程路径，重点关注与订单相关流程。</p>\n<p>2.快慢分离：将核心流程与其他非关键步骤分离。</p>\n<p>方案：</p>\n<p>1.写用户记录、零钱入账使用MQ异步执行</p>\n<p>2.增加对帐机制保障最终一致。</p>\n</blockquote>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/11.png\"><br>如上图所示，微信红包的某些步骤不实时完成也不会影响用户对红包业务可用性的体验。</p>\n<p>比如拆红包，正常的业务流程很长，但关键步骤只有订单相关的几步。</p>\n<p>至于转零钱、写红包记录等操作不需要实时。</p>\n<p>用户抢到红包时，一般不会实时去钱包查看微信零钱，而是在微信群中点开消息查看本次抢到金额和他人抢红包金额。</p>\n<p>所以拆红包时只需要从 cache 查询用户是否拆过红包，然后写入拆红包的订单记录，更新发红包订单，其他的操作都可以异步化。</p>\n<p>当然，不是每个业务都可以进行异步化设计，需要进行业务分析，判断是否存在非关键步骤之外的事情可以将其异步化，并通过异步对账保证最终一致。</p>\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h4 id=\"5-订单存储层-故障自愈-1\"><a href=\"#5-订单存储层-故障自愈-1\" class=\"headerlink\" title=\"5 - 订单存储层 - 故障自愈\"></a>5 - 订单存储层 - 故障自愈</h4><p>为解决 DB 间的相互影响，需要将 DB 间相互隔离，订单存储层 SET 化。</p>\n<p>SET 化指订单 DB 和订单接入 SERVER 垂直 stick 一起。业务逻辑层访问订单时，根据订单倒数第二、三位数字找到所属订单 SET，一个 SET 的请求不能路由到其他 SET。</p>\n<p>通过 SET 化得到的好处是，控制 DB 连接数、隔离故障影响和分流并发。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/10.png\"><br>如上图所示，所设尾号 90-99 的 SET 故障时，如果业务逻辑服务后续不再生成属于这个 SET 的订单，那后续的业务就可以逐渐恢复。</p>\n<p>也就是在发生故障时，业务逻辑层发布一个版本，屏蔽故障号段的单号生成，就可以恢复业务。</p>\n<p>进一步想，除了人为发版本，有没有方法可以让 DB 故障时自动恢复？</p>\n<p>在 DB 故障导致业务失败时，业务逻辑层可获取到故障 DB 的号段，在发红包时，将这些故障的号段，换一个可用的号段就可恢复业务。</p>\n<p>订单号除了最后三位，前面的部分已能保证该红包唯一性，后面的数字只代表着分库表信息，故障时只需要将最后三位换另外一个 SET 便可自动恢复。</p>\n<p>完成这个设计后，即使 DB 出现故障，业务的可用性也不会有影响。</p>\n<p>这里还有一点，新的发红包请求可避免 DB 故障的影响，但那些故障之前已发出未被领取的红包，红包消息已发送到微信群，单号已确定，拆红包时还是失败。</p>\n<p>对这种情况，由于不会有增量，采用正常的主备切换解决即可。</p>\n<h4 id=\"6-订单存储层-平行扩容设计-1\"><a href=\"#6-订单存储层-平行扩容设计-1\" class=\"headerlink\" title=\"6 - 订单存储层 - 平行扩容设计\"></a>6 - 订单存储层 - 平行扩容设计</h4><p>红包系统的高可用架构设计，主要包括了部署设计、SET 化设计、异步化设计、DB 故障自愈能力建设、平行扩容设计。</p>\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>红包系统是一个高并发的资金交易系统，最大的技术挑战是保障并发性能与资金安全。</p>\n<p>这种全新的技术挑战，传统的“秒杀”系统设计方案已不能完全解决。</p>\n<p>在分析了业界“秒杀”系统解决方案的基础上，红包系统采用了 SET 化、请求排队串行化、双维度分库表等设计，形成了独特的高并发、资金安全系统解决方案。</p>\n<h2 id=\"说在最后：有问题找老架构取经\"><a href=\"#说在最后：有问题找老架构取经\" class=\"headerlink\" title=\"说在最后：有问题找老架构取经\"></a>说在最后：有问题找老架构取经</h2><p>超高并发红包架构，一定是一个超级牛掰的简历亮点项目，黄金项目，稍微晚点把全量的架构方案和视频进行发布。</p>\n<p>这个项目写入简历，面试的时候如果大家能对答如流，如数家珍，基本上 面试官会被你 震惊到、吸引到。</p>\n<p>最终，<strong>让面试官爱到 “不能自已、口水直流”</strong>。offer， 也就来了。</p>\n","cover":"/img/hubian.png","cover_type":"img","excerpt":"","more":"<h1 id=\"百亿流量红包系统，如何架构？（字节面试真题）\"><a href=\"#百亿流量红包系统，如何架构？（字节面试真题）\" class=\"headerlink\" title=\"百亿流量红包系统，如何架构？（字节面试真题）\"></a>百亿流量红包系统，如何架构？（字节面试真题）</h1><h2 id=\"说在前面\"><a href=\"#说在前面\" class=\"headerlink\" title=\"说在前面\"></a>说在前面</h2><p>在读者交流群(50+)中，最近有小伙伴拿到了一线互联网企业如得物、阿里、滴滴、极兔、有赞、希音、百度、网易、美团的面试资格，遇到很多很重要的架构类&#x2F;设计类的场景题：</p>\n<blockquote>\n<p>1.如何设计百亿流量高并发红包系统 ，请说出你的方案？</p>\n<p>2.听说你会架构设计，请问一下如果让你来设计百亿流量红包系统，说说你的架构设计方案。</p>\n</blockquote>\n<p>最近有小伙伴在面试字节，又遇到了红包架构问题。小伙伴支支吾吾的说了几句，面试挂了。</p>\n<p>所以，给大家做一下系统化、体系化的梳理，使得大家内力猛增，可以充分展示一下大家雄厚的 “技术肌肉”，<strong>让面试官爱到 “不能自已、口水直流”</strong>，然后实现”offer直提”。</p>\n<h2 id=\"本文目录\"><a href=\"#本文目录\" class=\"headerlink\" title=\"本文目录\"></a>本文目录</h2><p><strong>- 说在前面</strong></p>\n<p><strong>- 本文目录</strong></p>\n<p>- 红包架构背景</p>\n<h5 id=\"红包系统和秒杀系统的对比\"><a href=\"#红包系统和秒杀系统的对比\" class=\"headerlink\" title=\"-红包系统和秒杀系统的对比\"></a>-红包系统和秒杀系统的对比</h5><p><strong>- 红包系统功能分析</strong></p>\n<p>- 功能1：包红包</p>\n<p>- 功能2：发红包</p>\n<p>- 功能3：抢红包</p>\n<p>- 功能4：拆红包</p>\n<h5 id=\"微信红包的业务特点\"><a href=\"#微信红包的业务特点\" class=\"headerlink\" title=\"-微信红包的业务特点\"></a>-微信红包的业务特点</h5><h5 id=\"微信红包的技术难点\"><a href=\"#微信红包的技术难点\" class=\"headerlink\" title=\"-微信红包的技术难点\"></a>-微信红包的技术难点</h5><p>- 红包系统概要设计</p>\n<h5 id=\"系统功能说明\"><a href=\"#系统功能说明\" class=\"headerlink\" title=\"-系统功能说明\"></a>-系统功能说明</h5><p><strong>- 数据库设计</strong></p>\n<h5 id=\"发红包\"><a href=\"#发红包\" class=\"headerlink\" title=\"-发红包\"></a>-发红包</h5><h5 id=\"抢红包\"><a href=\"#抢红包\" class=\"headerlink\" title=\"-抢红包\"></a>-抢红包</h5><p><strong>- 红包系统详细设计</strong></p>\n<p>- 红包整体架构</p>\n<p>- 高并发常用解决方案</p>\n<p>- 1- 使用内存替代实时的DB</p>\n<p>- 2- 使用乐观锁替代悲观锁</p>\n<h5 id=\"JVM-CAS-乐观锁方案\"><a href=\"#JVM-CAS-乐观锁方案\" class=\"headerlink\" title=\"-JVM CAS 乐观锁方案\"></a>-JVM CAS 乐观锁方案</h5><p><strong>- 微信红包系统的高并发解决方案</strong></p>\n<h5 id=\"1-分而治之：系统架构设计垂直Set化。\"><a href=\"#1-分而治之：系统架构设计垂直Set化。\" class=\"headerlink\" title=\"-1- 分而治之：系统架构设计垂直Set化。\"></a>-1- 分而治之：系统架构设计垂直Set化。</h5><h5 id=\"2-解决DB并发：逻辑Server层将请求排队。\"><a href=\"#2-解决DB并发：逻辑Server层将请求排队。\" class=\"headerlink\" title=\"-2- 解决DB并发：逻辑Server层将请求排队。\"></a>-2- 解决DB并发：逻辑Server层将请求排队。</h5><h5 id=\"3-系统性能稳定性保障：双维度分库分表设计。\"><a href=\"#3-系统性能稳定性保障：双维度分库分表设计。\" class=\"headerlink\" title=\"-3- 系统性能稳定性保障：双维度分库分表设计。\"></a>-3- 系统性能稳定性保障：双维度分库分表设计。</h5><h5 id=\"红包分配算法\"><a href=\"#红包分配算法\" class=\"headerlink\" title=\"- 红包分配算法\"></a>- 红包分配算法</h5><h5 id=\"1-实时拆分\"><a href=\"#1-实时拆分\" class=\"headerlink\" title=\"-1- 实时拆分\"></a>-1- 实时拆分</h5><h5 id=\"2-预先生成\"><a href=\"#2-预先生成\" class=\"headerlink\" title=\"-2- 预先生成\"></a>-2- 预先生成</h5><h5 id=\"3-二倍均值法\"><a href=\"#3-二倍均值法\" class=\"headerlink\" title=\"-3- 二倍均值法\"></a>-3- 二倍均值法</h5><p><strong>- 红包系统高可用架构设计</strong></p>\n<h5 id=\"1-系统可用性影响因素\"><a href=\"#1-系统可用性影响因素\" class=\"headerlink\" title=\"-1 - 系统可用性影响因素\"></a>-1 - 系统可用性影响因素</h5><h5 id=\"2-红包系统可用性设计方向\"><a href=\"#2-红包系统可用性设计方向\" class=\"headerlink\" title=\"-2 - 红包系统可用性设计方向\"></a>-2 - 红包系统可用性设计方向</h5><h5 id=\"3-业务逻辑层-部署方案设计\"><a href=\"#3-业务逻辑层-部署方案设计\" class=\"headerlink\" title=\"-3 - 业务逻辑层 - 部署方案设计\"></a>-3 - 业务逻辑层 - 部署方案设计</h5><h5 id=\"4-业务逻辑层-异步化设计\"><a href=\"#4-业务逻辑层-异步化设计\" class=\"headerlink\" title=\"-4 - 业务逻辑层 - 异步化设计\"></a>-4 - 业务逻辑层 - 异步化设计</h5><h5 id=\"5-订单存储层-故障自愈\"><a href=\"#5-订单存储层-故障自愈\" class=\"headerlink\" title=\"-5 - 订单存储层 - 故障自愈\"></a>-5 - 订单存储层 - 故障自愈</h5><h5 id=\"6-订单存储层-平行扩容设计\"><a href=\"#6-订单存储层-平行扩容设计\" class=\"headerlink\" title=\"-6 - 订单存储层 - 平行扩容设计\"></a>-6 - 订单存储层 - 平行扩容设计</h5><p>- 总结</p>\n<h3 id=\"红包架构背景\"><a href=\"#红包架构背景\" class=\"headerlink\" title=\"红包架构背景\"></a>红包架构背景</h3><p>红包是一种 瞬时流量很大的应用， 会在很短的时间内，产生巨大的瞬时流量，</p>\n<p>所以，作为架构师来说，这种场景有很大的架构挑战</p>\n<p>以2017年除夕为例，微信红包峰值QPS在76w左右，除夕当天收发微信红包的数量为142亿个。</p>\n<p>这种百亿级别的数据量、100Wqps级别的超高并发，而且整个系统核心功能和支付相关，需要做好高并发、高可用、高可靠。</p>\n<blockquote>\n<p>特别说明：红包架构也是高端面试的核心场景题, 后面也会以视频的形式，对这些架构的一系列的架构场景题目，做系统化的介绍。</p>\n<p>架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h4 id=\"红包系统和秒杀系统的对比-1\"><a href=\"#红包系统和秒杀系统的对比-1\" class=\"headerlink\" title=\"红包系统和秒杀系统的对比\"></a>红包系统和秒杀系统的对比</h4><p>我们先了解下微信红包支付的流程。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/1.png\"><br>在上面的红包流程中，核心业务包含包红包、发红包、抢红包、拆红包</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/2.png\"><br>其中最关键的步骤是</p>\n<ul>\n<li><p>发红包</p>\n</li>\n<li><p>抢红包。</p>\n</li>\n</ul>\n<p>在整个体系中，红包系统 是 支付系统的商户，红包这个商户出售的是钱。</p>\n<p>所以，用户发红包在红包系统 使用微信支付购买一份 红包商品，红包系统 将钱发放到相对应的微信群，供参与者领取。</p>\n<p>微信群里的用户抢红包，得到的是商品里边的 零钱。</p>\n<p>在整个体系中，红包系统 和支付系统 之间的关系是商家和第三方支付平台的关系。</p>\n<p>红包的流程，很类似 商品“秒杀”活动。</p>\n<ul>\n<li><p>包红包类似秒杀商品管理</p>\n</li>\n<li><p>发红包类似“秒杀”活动的商品上架；</p>\n</li>\n<li><p>抢红包等同于“秒杀”活动中的查询库存；</p>\n</li>\n<li><p>拆红包对应“秒杀”活动中用户的“秒杀”动作。</p>\n</li>\n</ul>\n<p>不过除了上面的相同点之外，红包业务 与 “秒杀”活动相比，还具备自身的特点：</p>\n<p>首先，抢红包 比 “秒杀”有更海量的并发要求。假设同一时间有 10 万个群里的用户同时在发红包，那就相当于同一时间有 10 万个“秒杀”活动发布出去。10 万个微信群里的用户同时抢红包，将产生海量的并发请求。</p>\n<p>其次，微信红包业务要求更严格的安全级别。红包业务本质上是资金交易。资金交易业务比普通商品“秒杀”活动有更高的安全级别要求。</p>\n<ul>\n<li><p><strong>“秒杀”时可以允许存在“超卖”（即实际被抢的商品数量比计划的库存多）、“少卖”（即实际被抢的商户数量比计划的库存少）的情况。</strong></p>\n</li>\n<li><p><strong>但是对于 红包，不允许存在“超卖”、“少卖”。</strong></p>\n</li>\n</ul>\n<blockquote>\n<p>特别说明：红包架构也是高端面试的核心场景题, 后面也会以视频的形式，对这些架构的一系列的架构场景题目，做系统化的介绍。</p>\n<p>架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h2 id=\"红包系统功能分析\"><a href=\"#红包系统功能分析\" class=\"headerlink\" title=\"红包系统功能分析\"></a>红包系统功能分析</h2><p>接下来，40岁老架构带大家，从架构师视角开始红包系统的功能分析。</p>\n<p>微信红包和微信支付之间的交互，与普通商家与微信支付的交互一样，需要经过多个步骤。</p>\n<ul>\n<li><p>用户发红包时，进入微信红包下一笔订单，系统记录发红包用户、发红包金额、红包数量和要发送到的用微信群。</p>\n</li>\n<li><p>然后微信红包系统请求微信支付服务器进行下单，用户使用微信支付进行支付。</p>\n</li>\n<li><p>支付成功后，微信支付后台系统通知微信红包后台系统支付成功结果，微信红包后台系统收到通知后推送微信红包消息到微信群。</p>\n</li>\n<li><p>微信群里用户便可抢红包。</p>\n</li>\n<li><p>用户发现红包还有剩余，就可以拆剩下的红包</p>\n</li>\n</ul>\n<p>这就是微信红包和微信支付的关系以及交互过程。</p>\n<h3 id=\"功能1：包红包\"><a href=\"#功能1：包红包\" class=\"headerlink\" title=\"功能1：包红包\"></a>功能1：包红包</h3><p>系统给每个红包分配一个唯一ID，也就是发红包的订单号，然后将红包发送给用户，红包的个数，红包金额写入到存储。</p>\n<h3 id=\"功能2：发红包\"><a href=\"#功能2：发红包\" class=\"headerlink\" title=\"功能2：发红包\"></a>功能2：发红包</h3><p>用户使用微信支付完成付款，微信红包后台收到微信支付成功的通知。红包系统将红包发送订单状态更新，更新为用户已支付，并写入用户发红包记录表，这样用户可以在钱包中找到用户的发红包流水和收发红包的记录，之后微信红包系统调用微信通知，将微信红包信息发送到微信群。</p>\n<h3 id=\"功能3：抢红包\"><a href=\"#功能3：抢红包\" class=\"headerlink\" title=\"功能3：抢红包\"></a>功能3：抢红包</h3><p>微信群中的用户收到红包消息之后，点开红包，开始抢红包，这个过程微信红包系统会检查红包是否已经被抢完，是否已经过期，是否已经抢过等验证逻辑。</p>\n<h3 id=\"功能4：拆红包\"><a href=\"#功能4：拆红包\" class=\"headerlink\" title=\"功能4：拆红包\"></a>功能4：拆红包</h3><p>拆红包是整个发红包流程最复杂的一个操作，需要查询这个红包的红包订单，判断用户是否可以拆包，计算本次可拆到的红包金额，并记录抢红包流水。</p>\n<p>拆红包包括如下步骤：</p>\n<ul>\n<li><p>1）查询这个红包发送订单，判断用户是否可拆，然后计算本次可拆到的红包金额；</p>\n</li>\n<li><p>2）然后写入一条抢红包记录。如果把拆红包过程，类比为一个秒杀活动的过程，相当于扣库存与写入秒杀记录的过程；</p>\n</li>\n<li><p>3）更新库存对应于更新红包发送订单，写入秒杀记录对应于写入这个红包的领取红包记录；</p>\n</li>\n<li><p>4）另外，还要写入用户整体的红包领取记录；</p>\n</li>\n<li><p>5）最后请求微信支付系统给拆到红包用户转入零钱，成功后更新抢红包的订单状态为已转账成功。</p>\n</li>\n</ul>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/5.png\"></p>\n<p>拆红包过程类似于一个秒杀活动的过程，需要做好库存扣减和秒杀记录的操作。</p>\n<p>更新库存就是更新红包发送的订单，写入秒杀记录就是写入红包领取的信息流水。</p>\n<p>还需要以用户为中心记录用户整体的红包领取记录。</p>\n<p>最后调用支付系统将拆红包后的金额转入用户零钱中，成功之后更新抢红包的订单状态为转账成功。</p>\n<blockquote>\n<p>所以，在看此文之前，最好看看的高并发三部曲的Java高并发核心编程卷3*（注意是最新的清华大学出版社出版的加强版），里边有秒杀架构，可以作为知识铺垫。</p>\n</blockquote>\n<h4 id=\"微信红包的业务特点-1\"><a href=\"#微信红包的业务特点-1\" class=\"headerlink\" title=\"微信红包的业务特点\"></a>微信红包的业务特点</h4><p>微信红包，特别是群红包，业务形态上类似于普通商品的”秒杀”活动。</p>\n<ul>\n<li><p>包红包类似秒杀商品管理</p>\n</li>\n<li><p>发红包类似“秒杀”活动的商品上架；</p>\n</li>\n<li><p>抢红包等同于“秒杀”活动中的查询库存；</p>\n</li>\n<li><p>拆红包对应“秒杀”活动中用户的“秒杀”动作。</p>\n<p>微信红包在业务形态上和普通商品”秒杀”活动相比，还有自身特点：</p>\n</li>\n</ul>\n<ol>\n<li><p><strong>海量并发请求</strong>：微信红包用户在微信群发一个红包，等同于在网上发布一次商品”秒杀”活动，假设同时有10万个群的用户同时发红包，那就相当于同一时间有10万个”秒杀”活动发布。10万个微信群的用户同时抢红包，将产生海量并发请求。</p>\n</li>\n<li><p><strong>更严格的安全级别</strong>：微信红包业务本质上是资金交易，微信红包是微信支付的一个商户，提供资金流转服务，用户发红包相当于在微信红包这个商户上使用微信支付购买了一笔”钱”，且收货地址是微信群。当用户支付成功后，红包”发货”到微信群里，群里的用户拆开红包后，微信红包提供了将”钱”转入拆红包用户微信零钱的服务。</p>\n</li>\n<li><p><strong>订单层南北独立体系</strong>：微信红包系统采用南北独立体系的订单层设计，即数据在南北两个系统中不同步。用户就近接入系统，请求发红包时，系统会根据用户所在地分配订单到南或北的系统，并在订单号上打上南北标识。这种设计有助于分摊流量，降低系统风险。</p>\n</li>\n<li><p><strong>流量闭环</strong>：在抢红包、拆红包、查红包详情列表时，接入层会根据红包单号上的南北标识，将流量分别引导到对应的南北系统闭环。这意味着，无论是发红包还是抢红包，用户都能够在就近的系统中完成操作，无需跨城，提高了系统的响应速度和稳定性。</p>\n</li>\n<li><p><strong>用户数据处理</strong>：微信红包系统的用户数据采取写多读少、全量保存的策略。用户数据的查询入口在微信钱包中，相对隐藏，访问量不会太大，且被视为可旁路的非关键信息，实时性要求不高。这种设计方式可以减少数据存储的压力，提高系统性能。</p>\n</li>\n<li><p><strong>实时计算红包金额</strong>：</p>\n<p>微信红包的金额是在拆红包时实时计算的，而不是预先分配的。系统会在拆红包时取0.01到剩余平均值*2之间的数值作为红包金额。</p>\n<p>这种实时计算的方式基于内存进行，不需要额外的存储空间，且计算效率很高。</p>\n<p>同时，为了保证操作的原子性，拆包过程中使用了CAS（Compare-and-Swap）算法，确保每次只有一个并发用户拆包成功。如果拆包CAS失败，系统会自动进行重试，但也可能在重试过程中被其他用户抢得先机而空手而归。</p>\n</li>\n<li><p><strong>架构演进</strong>：随着微信红包功能的不断发展和用户量的增长，其系统架构也经历了不断的演进和优化。从最初的数据库硬抗整个流量，到后来的使用缓存（cache）抗流量，再到现在的南北独立体系等设计，都是为了更好地应对高并发、提升系统性能和稳定性。</p>\n<p>资金交易业务比普通商品”秒杀”有更高的安全级别要求，普通的商品”秒杀”由商户提供，库存是商户预设，”秒杀”允许存在超卖和少卖的情况，但对于微信红包，用户发100元的红包绝对不可以拆出101元，以及只被领取99元时，剩下的1元在24小时过期后要精准退还给发红包用户。</p>\n<p>总的来说，微信红包系统架构的设计充分考虑了用户量、并发量、性能要求等因素，通过南北独立体系、流量闭环、用户数据处理、实时计算红包金额以及架构演进等多种手段，保证了系统的稳定运行和良好用户体验。</p>\n</li>\n</ol>\n<h4 id=\"微信红包的技术难点-1\"><a href=\"#微信红包的技术难点-1\" class=\"headerlink\" title=\"微信红包的技术难点\"></a>微信红包的技术难点</h4><p>微信红包系统架构的技术难点主要体现在以下几个方面：</p>\n<ol>\n<li><p><strong>高并发难点</strong>：</p>\n<p>微信红包在特定时间（如春节、节假日等）会面临极高的并发量，如何有效地处理这些并发请求，保证系统的稳定性和响应速度，是红包系统架构设计的关键挑战之一。</p>\n</li>\n<li><p><strong>资金安全难点</strong>：</p>\n<p>红包系统涉及到资金的转移和存储，因此资金安全是系统设计的重中之重。如何确保资金安全，防止被攻击或篡改，是系统架构设计中需要重点考虑的问题。</p>\n<p>红包业务涉及资金交易，所以一定不能出现超卖、少卖的情况。</p>\n</li>\n</ol>\n<ul>\n<li><p>超卖：发了 10 块钱，结果抢到了 11 块钱，多的钱只能系统补上，如此为爱发电应用估计早就下架了；</p>\n</li>\n<li><p>少卖：发了 10 块钱，只抢了 9 块，多的钱得原封不动地退还用户，否则第二天就接到法院传单了。</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li><p><strong>用户体验难点</strong></p>\n<p>红包系统需要保证良好的用户体验，包括响应速度、公平性（先抢先得）、成功率等。</p>\n<p>如何在高并发场景下保证用户体验，是系统架构设计的重要目标。</p>\n<p>了解下微信红包的用户体验 的4大核心：摇&#x2F;发&#x2F;抢&#x2F;拆。</p>\n</li>\n</ol>\n<ul>\n<li><p>摇：摇的流畅</p>\n</li>\n<li><p>快：抢的要快</p>\n</li>\n<li><p>爽：拆的爽</p>\n</li>\n<li><p>稳：能分享出去</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li><p><strong>数据一致性难点</strong>：</p>\n<p>红包系统需要保证数据的一致性，包括红包库存数据、用户账户数据等。如何在高并发场景下保证数据的一致性，是系统架构设计的重要挑战。</p>\n</li>\n</ol>\n<ul>\n<li><p>参与用户越多，并发 DB 请求越大，数据越容易出现事务问题，所以系统得做好<strong>事务一致性</strong>；</p>\n</li>\n<li><p>抢红包系统涉及金钱交易，所以事务级别要求更高，<strong>不能出现脏数据</strong>。</p>\n</li>\n</ul>\n<ol start=\"8\">\n<li><p><strong>系统扩展性难点</strong>：</p>\n<p>随着用户量和业务量的增长，红包系统需要具备良好的扩展性，能够方便地增加新的功能或提升性能。</p>\n<p>如何设计可扩展的系统架构，是系统架构设计的重要考虑因素。</p>\n<p>为了解决这些技术难点，我们可以采用多种技术手段，如分而治之、负载均衡、读写分离、水平切分、垂直切分等，来提升系统的性能和稳定性。同时，系统还采用了柔性服务、系统降级等策略，来保证在有限资源下满足用户的核心需求。</p>\n</li>\n</ol>\n<h3 id=\"红包系统概要设计\"><a href=\"#红包系统概要设计\" class=\"headerlink\" title=\"红包系统概要设计\"></a>红包系统概要设计</h3><h4 id=\"系统功能说明-1\"><a href=\"#系统功能说明-1\" class=\"headerlink\" title=\"系统功能说明\"></a>系统功能说明</h4><p>抢红包功能允许用户在群聊中发送任意个数和金额的红包，群成员可以抢到随机金额的红包，但要<strong>保证每个用户的红包金额不小于 0.01 元</strong>。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/3.png\"><br>抢红包的详细交互流程如下：</p>\n<ol>\n<li><p>用户接收到抢红包通知，点击通知打开群聊页面；</p>\n</li>\n<li><p>用户点击抢红包，后台服务验证用户资格，确保用户尚未领取过此红包；</p>\n</li>\n<li><p>若用户资格验证通过，后台服务分配红包金额并存储领取记录；</p>\n</li>\n<li><p>用户在微信群中看到领取金额，红包状态更新为“已领取”；</p>\n</li>\n<li><p>异步调用支付接口，将红包金额更新到钱包里。</p>\n</li>\n</ol>\n<h2 id=\"数据库设计\"><a href=\"#数据库设计\" class=\"headerlink\" title=\"数据库设计\"></a>数据库设计</h2><p><strong>红包表：redpack</strong></p>\n<p>红包表用来记录用户发了多少红包，以及需要维护的剩余金额，</p>\n<p>红包表：redpack的字段如下：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>主键，红包ID。</td>\n</tr>\n<tr>\n<td>user_id</td>\n<td>发送红包的用户id。</td>\n</tr>\n<tr>\n<td>total_amount</td>\n<td>红包总金额。</td>\n</tr>\n<tr>\n<td>surplus_amount</td>\n<td>红包剩余金额。</td>\n</tr>\n<tr>\n<td>total</td>\n<td>红包总数。</td>\n</tr>\n<tr>\n<td>surplus_total</td>\n<td>剩余红包总数。</td>\n</tr>\n</tbody></table>\n<p><strong>红包记录表：redpack_record</strong></p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>主键，记录id。</td>\n</tr>\n<tr>\n<td>redpack_id</td>\n<td>红包id。</td>\n</tr>\n<tr>\n<td>user_id</td>\n<td>用户id。</td>\n</tr>\n<tr>\n<td>amount</td>\n<td>抢到的金额。</td>\n</tr>\n</tbody></table>\n<h4 id=\"发红包-1\"><a href=\"#发红包-1\" class=\"headerlink\" title=\"发红包\"></a>发红包</h4><p>设置完红包参数后，微信支付，完成付款，然后收到付款成功通知，红包系统更新红包订单状态，更新为已支付，并写入红包发送记录表。</p>\n<p>这样用户可以将用户的红包信息和红包的收发记录发出，红包系统调用微信通知，将红包信息发送到微信群。</p>\n<p>发红包的交互步骤如下：</p>\n<ol>\n<li><p>用户设置红包的总金额和个数后，在红包表中增加一条数据，开始发红包；</p>\n</li>\n<li><p>为了保证实时性和抢红包的效率，在 Redis 中增加一条记录，<strong>存储红包 ID 和总人数 n</strong>；</p>\n</li>\n<li><p>抢红包消息推送给所有群成员。</p>\n</li>\n</ol>\n<h4 id=\"抢红包-1\"><a href=\"#抢红包-1\" class=\"headerlink\" title=\"抢红包\"></a>抢红包</h4><p>微信群用户收到红包后，点开，红包系统会校验红包是否被抢完，是否过期。</p>\n<p>微信红包的抢红包和拆红包是两个分离的服务，用户点击抢红包后需要进行两次操作。</p>\n<p>这也是为什么明明有时候抢到了红包，点开后却发现<strong>该红包已经被领取完了</strong>。</p>\n<p>抢红包的交互步骤如下：</p>\n<ol>\n<li><p>抢红包：抢操作在 Redis 缓存层完成，通过原子递减的操作来更新红包个数，个数递减为 0 后就说明抢光了。</p>\n</li>\n<li><p>拆红包：拆红包时，首先会实时计算金额，一般是通过二倍均值法实现（即 0.01 到剩余平均值的 2 倍之间）。</p>\n</li>\n<li><p>红包记录：用户获取红包金额后，通过数据库的事务操作累加已经领取的个数和金额，并更新红包表和记录表。</p>\n</li>\n<li><p>转账：为了提升效率，最终的转账为异步操作，这也是为什么在春节期间，红包领取后不能立即在余额中看到的原因。</p>\n</li>\n</ol>\n<h2 id=\"红包系统详细设计\"><a href=\"#红包系统详细设计\" class=\"headerlink\" title=\"红包系统详细设计\"></a>红包系统详细设计</h2><h3 id=\"红包整体架构\"><a href=\"#红包整体架构\" class=\"headerlink\" title=\"红包整体架构\"></a>红包整体架构</h3><p>如下图所示，是微信红包的系统架构</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/4.png\"><br>总体是三层架构：</p>\n<ul>\n<li><p>首先是微信统一接入层，下面是微信红包系统 API，包括发、抢、拆、查红包详情、查红包用户列表。</p>\n</li>\n<li><p>接入层下面，是封装微信红包关键业务的逻辑服务；</p>\n</li>\n<li><p>业务下面数据存储层，微信红包最主要的数据是订单数据，包括发红包订单和拆红包订单两部分。</p>\n</li>\n</ul>\n<p>数据存储层的冷热分离设计：微信红包数据的访问热度，随着时间流逝会急剧降低，也就是数据的访问时间段非常集中，一般红包发出三天后，99% 的用户不会再去点开这个红包了。因此微信红包系统采取按时间做冷热数据分离，降低数据的存储成本，同时提升了热数据的访问性能。</p>\n<p>除了在线计算的三层架构，还有离线处理的数据分析。</p>\n<p>数据分析平台用于对红包数据的分析计算，比如朋友圈里的文章，统计从 某年 1 月 1 日到 2017 年 1 月一个用户总共抢红包的金额，在全国的排名情况，发红包数最多的城市等。</p>\n<p>数据分析平台另外一个作用就是对账，红包的订单和微信支付的订单需要对账，以保证最终资金的一致性；</p>\n<ul>\n<li><p>订单的数据和订单的 cache 需要做对账，以保证数据的完整性；</p>\n</li>\n<li><p>订单数据和用户的收发记录需要对账，以保证用户列表完整性。</p>\n</li>\n</ul>\n<h3 id=\"高并发常用解决方案\"><a href=\"#高并发常用解决方案\" class=\"headerlink\" title=\"高并发常用解决方案\"></a>高并发常用解决方案</h3><p>普通商品秒杀系统，解决高并发问题的方案，大致有以下2种：</p>\n<h3 id=\"1-使用内存替代实时的DB\"><a href=\"#1-使用内存替代实时的DB\" class=\"headerlink\" title=\"1- 使用内存替代实时的DB\"></a>1- 使用内存替代实时的DB</h3><p>将实时扣库存的行为上移到内存Cache中，内存Cache操作成功直接给Server返回成功，然后异步落DB持久化。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/8.png\"><br>这个方案的优缺点如下：</p>\n<blockquote>\n<p>优点：用内存操作替代磁盘操作，提高了并发性能。</p>\n<p>缺点：在内存操作成功DB持久化失败，或者内存Cache故障的情况下，DB持久化会丢数据，不适合微信红包这种资金交易系统。</p>\n</blockquote>\n<h3 id=\"2-使用乐观锁替代悲观锁\"><a href=\"#2-使用乐观锁替代悲观锁\" class=\"headerlink\" title=\"2- 使用乐观锁替代悲观锁\"></a>2- 使用乐观锁替代悲观锁</h3><p><strong>什么是悲观锁呢？</strong></p>\n<p>所谓悲观锁，是关系数据库管理系统里的一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。对应于上文分析中的“并发请求抢锁”行为。</p>\n<p><strong>什么是乐观锁呢？</strong></p>\n<p>所谓乐观锁，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</p>\n<p>乐观锁分为DB乐观锁和 JVM CAS 乐观锁。</p>\n<p>DB乐观锁的具体应用方法，是在 DB 的“库存”记录中维护一个版本号。</p>\n<p>商品“秒杀”系统中，在更新“库存”的操作进行前，先去 DB 获取当前版本号。</p>\n<p>在更新库存的事务提交时，检查该版本号是否已被其他事务修改。如果版本没被修改，则提交事务，且版本号加 1；如果版本号已经被其他事务修改，则回滚事务，并给上层报错。</p>\n<p>DB乐观锁可以提高DB的并发处理能力，但是如果应用于微信红包系统，则会存在下面三个问题：</p>\n<ol>\n<li><p>如果拆红包采用乐观锁，那么在并发抢到相同版本号的拆红包请求中，只有一个能拆红包成功，其他的请求将事务回滚并返回失败，给用户报错，用户体验完全不可接受。</p>\n</li>\n<li><p>如果采用乐观锁，将会导致第一时间同时拆红包的用户有一部分直接返回失败，反而那些“手慢”的用户，有可能因为并发减小后拆红包成功，这会带来用户体验上的负面影响。</p>\n</li>\n<li><p>如果采用乐观锁的方式，会带来大数量的无效更新请求、事务回滚，给 DB 造成不必要的额外压力。</p>\n</li>\n</ol>\n<h4 id=\"JVM-CAS-乐观锁方案-1\"><a href=\"#JVM-CAS-乐观锁方案-1\" class=\"headerlink\" title=\"JVM CAS 乐观锁方案\"></a>JVM CAS 乐观锁方案</h4><p>出于性能原因，微信红包系统使用 JVM CAS 乐观锁，而不是DB乐观锁的方式解决并发抢锁问题。</p>\n<p>微信红包的金额是在拆红包时实时计算的，而不是预先分配的。系统会在拆红包时取0.01到剩余平均值*2之间的数值作为红包金额。</p>\n<p>这种实时计算的方式基于JVM 内存进行，不需要额外的存储空间，且计算效率很高。</p>\n<p>同时，为了保证操作的原子性，拆包过程中使用了CAS（Compare-and-Swap）算法，确保每次只有一个并发用户拆包成功。如果拆包CAS失败，系统会自动进行重试，但也可能在重试过程中被其他用户抢得先机而空手而归。</p>\n<p>如何保证同一个红包由同一个节点去拆包呢？将同一个红包 ID 的所有请求 stick 到同一台 Server，这个后面介绍。</p>\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h2 id=\"微信红包系统的高并发解决方案\"><a href=\"#微信红包系统的高并发解决方案\" class=\"headerlink\" title=\"微信红包系统的高并发解决方案\"></a>微信红包系统的高并发解决方案</h2><p>综合上面的分析，我们的红包系统针对相应的技术难点，采用如下3个方案，解决高并发问题。</p>\n<h5 id=\"1-分而治之：系统架构设计垂直Set化。-1\"><a href=\"#1-分而治之：系统架构设计垂直Set化。-1\" class=\"headerlink\" title=\"1- 分而治之：系统架构设计垂直Set化。\"></a>1- 分而治之：系统架构设计垂直Set化。</h5><p><strong>什么是Set（单元）化架构呢?</strong></p>\n<blockquote>\n<p>单元化架构是一种将系统划分为多个独立的、自包含的单元的部署架构，每个单元都能够完成所有业务操作，包含所有业务所需的服务以及分配给该单元的数据。这种架构将单元作为部署的基本单位，在全站所有机房中部署多个单元，每个机房内的单元数目不固定，但任一单元均部署系统所需的全部应用。数据则是全量数据按照某种维度划分后的一部分。与传统意义上的SOA（服务化）架构不同，单元化架构下，服务仍然是分层的，但每一层中的任意一个节点都属于且仅属于某一个单元，上层调用下层时，仅会选择本单元内的节点。</p>\n</blockquote>\n<p><strong>通俗的理解为</strong>：</p>\n<p>单元化架构，简单来说，就是把系统拆分成若干个独立的单元，每个单元都包含了完成业务操作所需的所有服务和数据。这些单元可以独立部署、管理和监控，就像一个个小房子，每个房子都有自己的客厅、卧室和厨房（服务），也有自己的食物和水（数据）。</p>\n<p>如下图，是一种单元化架构设计。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/6.png\"></p>\n<p>微信红包用户发一个红包时，微信红包系统生成一个 ID 作为这个红包的唯一标识。</p>\n<p>接下来这个红包的所有发红包、抢红包、拆红包、查询红包详情等操作，都根据这个 ID 关联。</p>\n<p>红包系统根据这个红包 ID，按一定的规则（如按 ID 尾号取模等），垂直上下切分。</p>\n<p>切分后，一个垂直链条上的逻辑 Server 服务器、DB 统称为一个 SET。</p>\n<p>各个 SET 之间相互独立，互相解耦。并且同一个红包 ID 的所有请求，包括发红包、抢红包、拆红包、查详情详情等，垂直 stick 到同一个 SET 内处理，高度内聚。</p>\n<p>通过这样的方式，系统将所有红包请求这个巨大的洪流分散为多股小流，互不影响，分而治之，如下图所示。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/7.png\"><br>这个方案解决了同时存在海量事务级操作的问题，将<strong>海量化为小量</strong>。</p>\n<h5 id=\"2-解决DB并发：逻辑Server层将请求排队。-1\"><a href=\"#2-解决DB并发：逻辑Server层将请求排队。-1\" class=\"headerlink\" title=\"2- 解决DB并发：逻辑Server层将请求排队。\"></a>2- 解决DB并发：逻辑Server层将请求排队。</h5><p>红包系统是资金交易系统，DB 操作的事务性无法避免，所以会存在“并发抢锁”问题。但是如果到达 DB 的事务操作（也即拆红包行为）不是并发的，而是串行的，就不会存在“并发抢锁”的问题了。</p>\n<p>按这个思路，为了使拆红包的事务操作串行地进入 DB，只需要将请求在 Server 层以 FIFO（先进先出）的方式排队，就可以达到这个效果。从而问题就集中到 Server 的 FIFO 队列设计上。</p>\n<p>红包系统设计了分布式的、轻巧的、灵活的 FIFO 队列方案。其具体实现如下：</p>\n<p><strong>1）将同一个红包 ID 的所有请求 stick 到同一台 Server。</strong></p>\n<p>上面 SET 化方案已经介绍，同个红包 ID 的所有请求，按红包 ID stick 到同个 SET 中。</p>\n<p>不过在同个 SET 中，会存在多台 Server 服务器同时连接同一台 DB（基于容灾、性能考虑，需要多台 Server 互备、均衡压力）。</p>\n<p>为了使同一个红包 ID 的所有请求，stick 到同一台 Server 服务器上，在 SET 化的设计之外，微信红包系统添加了一层基于红包 ID hash 值的分流，如下图所示。</p>\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<p><strong>2）设计单机请求排队方案。</strong></p>\n<p>将 stick 到同一台 Server 上的所有请求在被接收进程接收后，按红包 ID 进行排队。</p>\n<p>然后串行地进入 worker 进程（执行业务逻辑）进行处理，从而达到排队的效果，如下图所示。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/9.png\"><br><strong>3）增加 Redis缓存 控制并发。</strong></p>\n<p>为了防止 Server 中的请求队列过载导致队列被降级，从而所有请求拥进 DB，系统增加了与 Server 服务器同机部署的 Redis ，用于控制拆同一个红包的请求并发数。</p>\n<p>具体来说，利用 Redis 的 CAS 原子累增操作，控制同时进入 DB 执行拆红包事务的请求数，超过预先设定数值则直接拒绝服务。用于 DB 负载升高时的降级体验。</p>\n<p>通过以上三个措施，系统有效地控制了 DB 的“并发抢锁”情况。</p>\n<h5 id=\"3-系统性能稳定性保障：双维度分库分表设计。-1\"><a href=\"#3-系统性能稳定性保障：双维度分库分表设计。-1\" class=\"headerlink\" title=\"3- 系统性能稳定性保障：双维度分库分表设计。\"></a>3- 系统性能稳定性保障：双维度分库分表设计。</h5><p>红包系统的分库表规则，初期是根据红包 ID 的 hash 值分为多库多表。</p>\n<p>随着红包数据量逐渐增大，单表数据量也逐渐增加。而 DB 的性能与单表数据量有一定相关性。当单表数据量达到一定程度时，DB 性能会有大幅度下降，影响系统性能稳定性。</p>\n<p>采用冷热分离，将历史冷数据与当前热数据分开存储，可以解决这个问题。</p>\n<p>处理微信红包数据的冷热分离时，系统在以红包 ID 维度分库表的基础上，增加了以循环天分表的维度，形成了双维度分库表的特色。</p>\n<p>具体来说，就是分库表规则像 db_xx.t_y_dd 设计，其中，xx&#x2F;y 是红包 ID 的 hash 值后三位，dd 的取值范围在 01~31，代表一个月天数最多 31 天。</p>\n<p>通过这种双维度分库表方式，解决了 DB 单表数据量膨胀导致性能下降的问题，保障了系统性能的稳定性。同时，在热冷分离的问题上，又使得数据搬迁变得简单而优雅。</p>\n<p>综上所述，微信红包系统在解决高并发问题上的设计，主要采用了 <strong>SET 化分治</strong>、<strong>请求排队</strong>、<strong>双维度分库表</strong>等方案，使得单组 DB 的并发性能大幅度提升，取得了很好的效果。</p>\n<h4 id=\"红包分配算法-1\"><a href=\"#红包分配算法-1\" class=\"headerlink\" title=\"红包分配算法\"></a>红包分配算法</h4><p>抢红包后，我们需要进行拆红包，接下来我们讨论一下红包系统的红包分配算法。</p>\n<p>红包金额分配时，由于是随机分配，所以有两种实现方案：<strong>实时拆分和预先生成</strong></p>\n<h5 id=\"1-实时拆分-1\"><a href=\"#1-实时拆分-1\" class=\"headerlink\" title=\"1- 实时拆分\"></a>1- 实时拆分</h5><p>实时拆分，指的是在<strong>抢红包时实时计算</strong>每个红包的金额，以实现红包的拆分过程。</p>\n<p>这个对系统性能和拆分算法要求较高，例如拆分过程要一直保证后续待拆分红包的金额不能为空，不容易做到拆分的红包金额服从<strong>正态分布</strong>规律。</p>\n<h5 id=\"2-预先生成-1\"><a href=\"#2-预先生成-1\" class=\"headerlink\" title=\"2- 预先生成\"></a>2- 预先生成</h5><p>预先生成，指的是在红包<strong>开抢之前</strong>已经完成了红包的<strong>金额拆分</strong>，抢红包时只是依次取出拆分好的红包金额。</p>\n<p>这种方式对拆分算法要求较低，可以拆分出随机性很好的红包金额，但通常需要结合队列使用。</p>\n<h5 id=\"3-二倍均值法-1\"><a href=\"#3-二倍均值法-1\" class=\"headerlink\" title=\"3- 二倍均值法\"></a>3- 二倍均值法</h5><p>综合上述优缺点考虑，以及微信群聊中的人数不多（目前最高 500 人），所以我们采用实时拆分的方式，用<strong>二倍均值法</strong>来生成随机红包，只满足随机即可，不需要正态分布。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">使用二倍均值法生成的随机数，每次随机金额会在  0.01 ~ 剩余平均值\\*2 之间。  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>假设当前红包剩余金额为 10 元，剩余个数为 5，<strong>10&#x2F;5 &#x3D; 2</strong>，则当前用户可以抢到的红包金额为：<strong>0.01 ~ 4</strong> 元之间。</p>\n<p>以下是使用Java实现的二倍均值算法，在红包分配场景中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class RedPacketDistribution &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public static List&lt;BigDecimal&gt; distribute(BigDecimal totalAmount, int totalCount) &#123;  </span><br><span class=\"line\">        // 校验总金额是否为正  </span><br><span class=\"line\">        if (totalAmount.compareTo(BigDecimal.ZERO) &lt;= 0) &#123;  </span><br><span class=\"line\">            throw new IllegalArgumentException(&quot;Invalid parameter, totalAmount must be positive.&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        // 校验红包总数是否至少为1  </span><br><span class=\"line\">        if (totalCount &lt; 1) &#123;  </span><br><span class=\"line\">            throw new IllegalArgumentException(&quot;Invalid parameter, totalCount must be at least 1.&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        List&lt;BigDecimal&gt; redPacketList = new ArrayList&lt;&gt;(totalCount);  </span><br><span class=\"line\">        BigDecimal remainingAmount = totalAmount.multiply(BigDecimal.valueOf(2)); // 初始化为总金额的两倍  </span><br><span class=\"line\">        ThreadLocalRandom random = ThreadLocalRandom.current(); // 使用线程安全的随机数生成器  </span><br><span class=\"line\">  </span><br><span class=\"line\">        for (int i = 0; i &lt; totalCount - 1; i++) &#123;  </span><br><span class=\"line\">            // 随机获取一个幸运值，范围在\\[0, 当前剩余金额)  </span><br><span class=\"line\">            BigDecimal luckValue = BigDecimal.valueOf(random.nextDouble()).multiply(remainingAmount);  </span><br><span class=\"line\">            // 计算并添加实际分配的红包金额（幸运值的一半）  </span><br><span class=\"line\">            BigDecimal amount = luckValue.divide(BigDecimal.valueOf(2), BigDecimal.ROUND\\_HALF\\_DOWN);  </span><br><span class=\"line\">            redPacketList.add(amount);  </span><br><span class=\"line\">            // 更新剩余金额  </span><br><span class=\"line\">            remainingAmount = remainingAmount.subtract(luckValue);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 最后一个红包直接拿走剩余的全部金额，确保总和正确  </span><br><span class=\"line\">        redPacketList.add(remainingAmount.divide(BigDecimal.valueOf(2), BigDecimal.ROUND\\_HALF\\_DOWN));  </span><br><span class=\"line\">  </span><br><span class=\"line\">        return redPacketList;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public static void main(String\\[\\] args) &#123;  </span><br><span class=\"line\">        BigDecimal totalAmount = new BigDecimal(&quot;100.00&quot;); // 红包总金额  </span><br><span class=\"line\">        int totalCount = 10;      // 红包个数  </span><br><span class=\"line\">        List&lt;BigDecimal&gt; redPackets = distribute(totalAmount, totalCount);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        System.out.println(&quot;Red packet distribution:&quot;);  </span><br><span class=\"line\">        for (BigDecimal amount : redPackets) &#123;  </span><br><span class=\"line\">            System.out.printf(&quot;%.2f, &quot;, amount);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h2 id=\"红包系统高可用架构设计\"><a href=\"#红包系统高可用架构设计\" class=\"headerlink\" title=\"红包系统高可用架构设计\"></a>红包系统高可用架构设计</h2><p>红包业务量级的高速发展，对后台系统架构的可用性要求越来越高。在保障微信红包业务体验的前提下，红包后台系统进行了一系列高可用方面的优化设计。</p>\n<p>要保障红包系统架构的高可用性，可以从多个方面进行优化和设计。以下是一些详细说明：</p>\n<ol>\n<li><strong>系统架构设计</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>信息流、业务流、资金流分离</strong>：红包系统由信息流、业务流、资金流三部分组成，这三部分在组织架构上应由不同的后台团队完成，以提高系统的模块化和可维护性。</p>\n</li>\n<li><p><strong>微服务架构</strong>：采用微服务架构，将红包系统拆分成多个独立的服务，每个服务负责特定的功能，这样可以提高系统的可扩展性和容错性。</p>\n</li>\n<li><p><strong>无状态设计</strong>：确保红包系统的服务是无状态的，即服务不需要保存用户的会话信息，这样可以提高系统的并发处理能力和可靠性。</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>高可用性策略</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>冗余部署</strong>：将系统的关键组件部署在多台服务器上，通过搭建主备或者集群的架构来实现冗余。当主服务器出现故障时，备用服务器能够自动接管，保证系统的可用性。</p>\n</li>\n<li><p><strong>负载均衡</strong>：通过将流量分发到多台服务器上，均衡系统的请求负载，提高系统的可用性和扩展性。负载均衡可以通过硬件（如负载均衡器）或者软件（如Nginx、HAProxy）实现。</p>\n</li>\n<li><p><strong>服务容器化</strong>：使用容器技术（如Docker、Kubernetes）将应用程序与其依赖项打包为容器，实现快速部署、弹性扩展和自动化管理。容器化可以提高系统的可移植性、弹性和可伸缩性，从而增加系统的高可用性。</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li><strong>数据保障</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>数据备份与恢复</strong>：定期对关键数据进行备份，并确保备份的数据可用性。这样，在发生数据丢失或损坏时，可以快速恢复数据，减少系统停机时间。</p>\n</li>\n<li><p><strong>分布式缓存</strong>：使用多级缓存技术（如Redis、Memcached等），将数据分别存储在内存缓存、本地缓存和分布式缓存中，以提高访问速度和降低数据库压力。</p>\n</li>\n<li><p><strong>数据一致性</strong>：使用分布式锁技术来保护红包的领取操作，确保每个用户只能领取一次红包。同时，为了保证数据一致性，可以采用消息队列等技术实现请求的异步处理和结果的返回。</p>\n</li>\n</ul>\n<ol start=\"7\">\n<li><strong>监控与告警</strong>：</li>\n</ol>\n<ul>\n<li><p><strong>系统监控</strong>：对红包系统的关键指标（如请求量、响应时间、错误率等）进行实时监控，以便及时发现和解决潜在问题。</p>\n</li>\n<li><p><strong>告警机制</strong>：设置合理的告警阈值，当系统出现异常情况时，及时发送告警通知给相关人员，以便快速响应和处理。</p>\n</li>\n</ul>\n<ol start=\"9\">\n<li><p><strong>安全性保障</strong>：</p>\n<p>通过以上措施的综合应用，可以大大提高红包系统架构的高可用性，确保系统在高峰时段能够稳定、高效地运行。</p>\n</li>\n</ol>\n<ul>\n<li><p><strong>访问控制</strong>：实施严格的访问控制策略，确保只有授权的用户才能访问红包系统。</p>\n</li>\n<li><p><strong>数据加密</strong>：对敏感数据进行加密存储和传输，以防止数据泄露和篡改。</p>\n</li>\n<li><p><strong>安全审计</strong>：定期对红包系统进行安全审计和漏洞扫描，及时修复发现的安全漏洞和隐患。</p>\n</li>\n</ul>\n<h4 id=\"1-系统可用性影响因素-1\"><a href=\"#1-系统可用性影响因素-1\" class=\"headerlink\" title=\"1 - 系统可用性影响因素\"></a>1 - 系统可用性影响因素</h4><p><strong>系统的可用性影响因素可分成两类：</strong></p>\n<ul>\n<li><p>一类计划外；</p>\n<p>计划外包含很多因素，系统用到的所有东西都可能产生故障，都可能成功影响可用性的因素。从这个角度上来讲，可以说故障是无法避免的，系统的运作一定会产生故障，尤其是服务器有成千上万个的时候。</p>\n</li>\n<li><p>一类计划内。</p>\n<p>计划内的影响因素，主要有与升级相关、运维相关的操作，以及日常的备份等。这一类影响因素，通过精细地设计方案，是可以避免对可用性造成影响的。</p>\n</li>\n</ul>\n<h4 id=\"2-红包系统可用性设计方向-1\"><a href=\"#2-红包系统可用性设计方向-1\" class=\"headerlink\" title=\"2 - 红包系统可用性设计方向\"></a>2 - 红包系统可用性设计方向</h4><p>基于上面两个分析结论，可以总结出红包系统的可用性的设计方向。</p>\n<blockquote>\n<p>1.在不能避免意外故障的情况下，尽可能降低出现意外故障时对可用性的影响。</p>\n<p>2.绝大多数计划内的日常维护可以通过方案的设计避免影响可用性，其中平行扩容特指关于存储层的平行扩容。</p>\n</blockquote>\n<p>下面从降低故障影响和微信红包系统的平行扩容两方面进行分析。</p>\n<p>首先是降低意外故障的影响，重点讲解订单存储层在订单 DB 故障的情况下如何降低对红包系统可用性的影响。</p>\n<h4 id=\"3-业务逻辑层-部署方案设计-1\"><a href=\"#3-业务逻辑层-部署方案设计-1\" class=\"headerlink\" title=\"3 - 业务逻辑层 - 部署方案设计\"></a>3 - 业务逻辑层 - 部署方案设计</h4><p>首先是业务逻辑层的部署方案。业务逻辑层是无状态的，微信红包系统的业务逻辑层，部署在两个城市，即两地部署，每一个城市部署至少三个园区，即三个 IDC。并且每个服务需要保证三个 IDC 的部署均衡。另外，三个 IDC 总服务能力需要冗余三分之一，当一个 IDC 出现故障时，服务能力仍然足够。从而达到 IDC 故障不会对可用性产生影响。</p>\n<h4 id=\"4-业务逻辑层-异步化设计-1\"><a href=\"#4-业务逻辑层-异步化设计-1\" class=\"headerlink\" title=\"4 - 业务逻辑层 - 异步化设计\"></a>4 - 业务逻辑层 - 异步化设计</h4><p>如下图所示，微信红包的某些步骤不实时完成也不会影响用户对红包业务可用性的体验。</p>\n<p>比如拆红包，正常的业务流程很长，但关键步骤只有订单相关的几步。</p>\n<p>至于转零钱、写红包记录等操作不需要实时。</p>\n<p>用户抢到红包时，一般不会实时去钱包查看微信零钱，而是在微信群中点开消息查看本次抢到金额和他人抢红包金额。</p>\n<p>所以拆红包时只需要从 cache 查询用户是否拆过红包，然后写入拆红包的订单记录，更新发红包订单，其他的操作都可以异步化。</p>\n<p>当然，不是每个业务都可以进行异步化设计，需要进行业务分析，判断是否存在非关键步骤之外的事情可以将其异步化，并通过异步对账保证最终一致。</p>\n<p>经过上述分析之后，可以采用如下思路与方案：</p>\n<blockquote>\n<p>实现思路：</p>\n<p>1.最简关键路径：简化发红包、拆红包核心流程路径，重点关注与订单相关流程。</p>\n<p>2.快慢分离：将核心流程与其他非关键步骤分离。</p>\n<p>方案：</p>\n<p>1.写用户记录、零钱入账使用MQ异步执行</p>\n<p>2.增加对帐机制保障最终一致。</p>\n</blockquote>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/11.png\"><br>如上图所示，微信红包的某些步骤不实时完成也不会影响用户对红包业务可用性的体验。</p>\n<p>比如拆红包，正常的业务流程很长，但关键步骤只有订单相关的几步。</p>\n<p>至于转零钱、写红包记录等操作不需要实时。</p>\n<p>用户抢到红包时，一般不会实时去钱包查看微信零钱，而是在微信群中点开消息查看本次抢到金额和他人抢红包金额。</p>\n<p>所以拆红包时只需要从 cache 查询用户是否拆过红包，然后写入拆红包的订单记录，更新发红包订单，其他的操作都可以异步化。</p>\n<p>当然，不是每个业务都可以进行异步化设计，需要进行业务分析，判断是否存在非关键步骤之外的事情可以将其异步化，并通过异步对账保证最终一致。</p>\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h4 id=\"5-订单存储层-故障自愈-1\"><a href=\"#5-订单存储层-故障自愈-1\" class=\"headerlink\" title=\"5 - 订单存储层 - 故障自愈\"></a>5 - 订单存储层 - 故障自愈</h4><p>为解决 DB 间的相互影响，需要将 DB 间相互隔离，订单存储层 SET 化。</p>\n<p>SET 化指订单 DB 和订单接入 SERVER 垂直 stick 一起。业务逻辑层访问订单时，根据订单倒数第二、三位数字找到所属订单 SET，一个 SET 的请求不能路由到其他 SET。</p>\n<p>通过 SET 化得到的好处是，控制 DB 连接数、隔离故障影响和分流并发。</p>\n<p><img src=\"/./2024/05/28/%E7%99%BE%E4%BA%BF%E6%B5%81%E9%87%8F%E7%BA%A2%E5%8C%85%E7%B3%BB%E7%BB%9F/10.png\"><br>如上图所示，所设尾号 90-99 的 SET 故障时，如果业务逻辑服务后续不再生成属于这个 SET 的订单，那后续的业务就可以逐渐恢复。</p>\n<p>也就是在发生故障时，业务逻辑层发布一个版本，屏蔽故障号段的单号生成，就可以恢复业务。</p>\n<p>进一步想，除了人为发版本，有没有方法可以让 DB 故障时自动恢复？</p>\n<p>在 DB 故障导致业务失败时，业务逻辑层可获取到故障 DB 的号段，在发红包时，将这些故障的号段，换一个可用的号段就可恢复业务。</p>\n<p>订单号除了最后三位，前面的部分已能保证该红包唯一性，后面的数字只代表着分库表信息，故障时只需要将最后三位换另外一个 SET 便可自动恢复。</p>\n<p>完成这个设计后，即使 DB 出现故障，业务的可用性也不会有影响。</p>\n<p>这里还有一点，新的发红包请求可避免 DB 故障的影响，但那些故障之前已发出未被领取的红包，红包消息已发送到微信群，单号已确定，拆红包时还是失败。</p>\n<p>对这种情况，由于不会有增量，采用正常的主备切换解决即可。</p>\n<h4 id=\"6-订单存储层-平行扩容设计-1\"><a href=\"#6-订单存储层-平行扩容设计-1\" class=\"headerlink\" title=\"6 - 订单存储层 - 平行扩容设计\"></a>6 - 订单存储层 - 平行扩容设计</h4><p>红包系统的高可用架构设计，主要包括了部署设计、SET 化设计、异步化设计、DB 故障自愈能力建设、平行扩容设计。</p>\n<blockquote>\n<p>以上内容比较复杂，架构团队会录制成为架构视频， 帮助大家做架构拿高薪。</p>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>红包系统是一个高并发的资金交易系统，最大的技术挑战是保障并发性能与资金安全。</p>\n<p>这种全新的技术挑战，传统的“秒杀”系统设计方案已不能完全解决。</p>\n<p>在分析了业界“秒杀”系统解决方案的基础上，红包系统采用了 SET 化、请求排队串行化、双维度分库表等设计，形成了独特的高并发、资金安全系统解决方案。</p>\n<h2 id=\"说在最后：有问题找老架构取经\"><a href=\"#说在最后：有问题找老架构取经\" class=\"headerlink\" title=\"说在最后：有问题找老架构取经\"></a>说在最后：有问题找老架构取经</h2><p>超高并发红包架构，一定是一个超级牛掰的简历亮点项目，黄金项目，稍微晚点把全量的架构方案和视频进行发布。</p>\n<p>这个项目写入简历，面试的时候如果大家能对答如流，如数家珍，基本上 面试官会被你 震惊到、吸引到。</p>\n<p>最终，<strong>让面试官爱到 “不能自已、口水直流”</strong>。offer， 也就来了。</p>\n"},{"title":"统计全国重名最多的前100个","date":"2024-06-02T09:16:17.000Z","_content":"\n\n阿里面试：全国14亿个姓名，统计出重名最多的前100个\n===========================\n\n\n> 全国14亿人的数据中，统计出重名人数最多的前100位姓名\n\n最近有小伙伴在面试阿里，遇到这个面试题。小伙伴没有系统的去梳理和总结，所以支支吾吾的说了几句，面试官不满意，面试挂了。\n\n**TOP N面试题是常见的算法题。**\n\nTOP N 统计的面试题，是一道非常常见的题目，大家一定要掌握好。\n\n\n1\\. 问题描述:\n---------\n\n我们需要从全国14亿人的数据中，统计出重名人数最多的前100位姓名\n\n2\\. 问题分析:\n---------\n\n我们的目标：是找到重名人数最多的前100个姓名,\n\n这意味着需要两步：\n\n*   需要有一个高效的数据结构来统计每个名字出现的次数,\n\n*   并快速找到出现次数最多的前100个名字.\n\n\n所以这个问题就转化成了下一个问题： 使用一种低成本、高性能的数据结构，来统计每个名字出现的次数。\n\n3\\. 如何选择一种最低成本、最高性能的数据结构？\n-------------------------\n\n常规的数据结构，选型如下:\n\n*   **数组**:\n\n\n如果姓名的字符集范围很大(支持所有的Unicode字符)，那么，需要极大且稀疏的数组,导致内存浪费严重,也不适合处理动态长度和多样性的字符串集合\n\n*   **链表**:\n\n    链表的插入和查找的操作时间复杂度为O(N), 并且，在大规模数据下性能低下,也不适合快速查找的场景\n\n*   **跳表**:\n\n\n跳表的插入、删除和查找操作的平均事件复杂度都是O(logN)，\n\n跳表式空间换时间的思想，主要是它需要额外的空间来维护多级索引，每个元素在最坏的情况下需要额外的存储空间，导致总的空间复杂度为O(N log N),\n\n在频繁的插入和查询的场景中，效率不高。\n\n来到我们现在这个场景，统计每个名字出现的次数时，不如哈希表在时间和空间的效率高效，哈希表的O(1)时间复杂度更适合大规模的数据频繁的插入和查询。\n\n*   **哈希表:**\n\n\n哈希表的插入和查找的时间复杂度都是O(1),\n\n但是在极端的情况下，哈希冲突会导致时间复杂度退化到O(N)，\n\n在空间效率中，哈希表需要额外的空间来维护键值对，来到这个场景，空间效率和哈希冲突都有潜在风险，\n\n最重要的是哈希表不能共享前缀，在处理大量的具有共同前缀的数据时候，也不适合。\n\n*   **平衡二叉搜索树(如AVL树或红黑树)**:\n\n\n能够维护有序数据,支持快速的插入、删除和查找操作,但在字符串的比较上,性能不如哈希表和Trie高效\n\n*   **前缀树**:\n\n\n前缀树通过共享前缀节点,节省了大量存储空间, 实现了成本的最低化\n\n前缀树对于字符串操作非常高效, 在这个问题中, 有很多名字共享相同前缀, Trie的结构能有效利用这一特点。\n\n经过上面的分析,能够看到Trie更适合统计每个名字出现的次数\n\n4\\. 如何快速筛选出Top 100？\n-------------------\n\n当知道了所有姓名出现的次数之后,、怎么样快速筛选出其中出现次数最多的前100个?\n\n首先想到的是直接排序。\n\n这个问题中,对14亿数据直接排序会有效率的问题，操作非常耗时。\n\n所以直接排序， 这种方法不可取。\n\n我们的目标是找到次数最多的前100个,可以利用堆的性质来完成。\n\n小顶堆总是保持堆顶为当前堆中最小的元素，这样可以确保当新的元素插入时，如果新元素大于堆顶元素，堆顶元素会被替换掉\n\n使用小顶堆的步骤:\n\n1.初始化一个小顶堆:设为100\n\n2.遍历每个姓名及其出现的次数:\n\n*   如果堆的大小小于100，将当前姓名及其出现次数插入堆中。\n\n*   如果当前姓名的出现次数大于堆顶元素的出现次数，则移除堆顶元素，并将当前姓名及其出现次数插入堆中。\n\n\n3.遍历完所有的姓名后,堆中即为重名人数最多的前100个姓名\n\n所以解决这个问题使用了前缀树 + 小顶堆\n\n5\\. 前缀树Trie树介绍\n--------------\n\n在计算机科学中，trie，又称前缀树或字典树，使用一些单词来构建Trie树,如下图所示:\n\n![](./2024/06/02/统计全国重名最多的前100个/1.png)\n\n从图片中可以看到一些有意思的特性:\n\n*   根节点没有数据\n\n*   从根节点到某一个节点,将他们的路径进行连接就组成了对应的字符串\n\n\n定义:\n\n> Trie树，又称为前缀树或字典树, 是一种用于高效存储和检索字符串集合的数据结构, 每个节点代表一个字符, 边表示从一个字符到另一个字符的路径, Trie树通过共享相同前缀的节点来节省存储空间\n\nTrie树是一种有序树，用于保存关联数组，其中的键通常是字符串。\n\n与二叉查找树不同，Trie树 的 键不是直接保存在节点中，而是由节点在树中的位置决定。\n\n一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。\n\n一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。\n\ntrie中的键通常是字符串，但也可以是其它的结构。\n\ntrie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。\n\n比如，bitwise trie中的键是一串位元，可以用于表示整数或者内存地址\n\n**Trie树基本性质**\n\n1，根节点不包含字符，除根节点意外每个节点只包含一个字符。\n\n2，从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。\n\n3，每个节点的所有子节点包含的字符串不相同。\n\n**Trie树优点**：\n\n可以最大限度地减少无谓的字符串比较，故可以用于词频统计和大量字符串排序。\n\n跟哈希表比较：\n\n1，最坏情况时间复杂度比hash表好\n\n2，没有冲突，除非一个key对应多个值（除key外的其他信息）\n\n3，自带排序功能（类似Radix Sort），中序遍历trie可以得到排序。\n\n**Trie树缺点**：\n\n当所有关键字都不具有相同或类似的前缀，空间消耗过大.\n\n6\\. Trie树的基本操作:\n---------------\n\n*   插入:将一个字符串逐字符插入到Trie树中\n\n*   查找:检查Trie树中是否存在某个字符串\n\n*   前缀匹配:查找所有以某个前缀开头的字符串\n\n*   删除:从Trie树中删除一个字符串\n\n\n7\\. Trie树的应用场景:\n---------------\n\n1.字符串检索:\n\n*   应用场景:快速检索字典中的单词\n\n*   使用原因:Trie树通过逐字符匹配,可以在O(L)时间内完成字符串的检索,其中L是字符串的长度,比传统的线性搜索更加高效\n\n\n2.自动补全:\n\n*   应用场景:搜索引擎和输入法中的自动补全功能\n\n*   适用原因:Trie树可以通过前缀查找快速提供所有以给定前缀开头的单词,有效提升用户输入体验\n\n\n3.前缀匹配:\n\n*   应用场景:寻找以特定前缀开头的所有字符串,如电话号码前缀匹配\n\n*   适用原因:Trie树天生适合处理前缀匹配问题,可以在O(L)时间内找到所有以特定前缀开头的字符串\n\n\n4.词频统计:\n\n*   应用场景:文本分析中统计单词出现频率\n\n*   适用原因:Trie树可以在插入过程中记录每个单词的出现次数,通过遍历Trie树可以快速统计所有单词的频率\n\n\n为什么适合这些场景:\n\n5.多模式匹配:\n\n*   应用场景:从文本中同时搜索多个模式(模式匹配算法)\n\n*   适用原因:Trie树可以构建多个模式的结构,通过一次遍历文本同时匹配多个模式,提高匹配效率\n\n\n为什么适用于这些场景:\n\n1.空间效率:\n\n*   共享前缀:Trie树通过共享前缀节点，减少了重复存储相同前缀的空间开销。\n\n*   节省内存:对于大量前缀相同的字符串集合，Trie树显著节省内存使用。\n\n\n2.时间效率:\n\n*   O(L)复杂度:插入、查找和前缀匹配操作的时间复杂度为O(L),其中L是字符串的长度,显著提高了操作效率\n\n*   快速检索:相比于其他线性结构(如数组或链表),Trie树在处理大量字符串时更快\n\n\n8\\. Trie树的代码实现:\n---------------\n\n以下是一个 参考代码：\n\n```\n\n\nimport java.util.HashMap;  \nimport java.util.Map;  \nimport java.util.PriorityQueue;  \n  \nclass TrieNode {  \n    Map<Character, TrieNode> children;  \n    int count;  \n  \n    public TrieNode() {  \n        children = new HashMap<>();  \n        count = 0;  \n    }  \n}  \n  \nclass Trie {  \n    private TrieNode root;  \n  \n    public Trie() {  \n        root = new TrieNode();  \n    }  \n  \n    public void insert(String name) {  \n        TrieNode node = root;  \n        for (char ch : name.toCharArray()) {  \n            node = node.children.computeIfAbsent(ch, k -> new TrieNode());  \n        }  \n        node.count++;  \n    }  \n  \n    public void getAllNames(TrieNode node, StringBuilder prefix, PriorityQueue<NameCount> minHeap, int k) {  \n        if (node == null) return;  \n        if (node.count > 0) {  \n            if (minHeap.size() < k) {  \n                minHeap.offer(new NameCount(prefix.toString(), node.count));  \n            } else if (node.count > minHeap.peek().count) {  \n                minHeap.poll();  \n                minHeap.offer(new NameCount(prefix.toString(), node.count));  \n            }  \n        }  \n        for (Map.Entry<Character, TrieNode> entry : node.children.entrySet()) {  \n            prefix.append(entry.getKey());  \n            getAllNames(entry.getValue(), prefix, minHeap, k);  \n            prefix.deleteCharAt(prefix.length() - 1);  \n        }  \n    }  \n  \n    public PriorityQueue<NameCount> getTopKNames(int k) {  \n        PriorityQueue<NameCount> minHeap = new PriorityQueue<>(k);  \n        getAllNames(root, new StringBuilder(), minHeap, k);  \n        return minHeap;  \n    }  \n}  \n  \nclass NameCount implements Comparable<NameCount\\> {  \n    String name;  \n    int count;  \n  \n    public NameCount(String name, int count) {  \n        this.name = name;  \n        this.count = count;  \n    }  \n  \n    @Override  \n    public int compareTo(NameCount other) {  \n        return Integer.compare(this.count, other.count);  \n    }  \n  \n    @Override  \n    public String toString() {  \n        return name + \": \" + count;  \n    }  \n}  \n  \npublic class Main {  \n    public static void main(String\\[\\] args) {  \n        String\\[\\] names = {\"张伟\", \"王伟伟\", \"王芳\", \"李伟\", \"李娜\"}; // 示例数据  \n        int k = 100; // 找到前100个重名人数最多的姓名  \n  \n        Trie trie = new Trie();  \n        for (String name : names) {  \n            trie.insert(name);  \n        }  \n  \n        PriorityQueue<NameCount> topKNames = trie.getTopKNames(k);  \n        while (!topKNames.isEmpty()) {  \n            System.out.println(topKNames.poll());  \n        }  \n    }  \n}  \n\n\n\n```\n\n9\\. TOP N问题发散:\n--------------\n\n上面的问题进行改进一下, 如果我们对内存有一个限制,比如:要求内存的使用不能超过2G,\n\n注意，这里的内存受限，尽量使用磁盘处理。\n\n> 这里使用hashmap，而不适用 trie树的原因是？\n>\n> trie树是按照字符为粒度组织树的节点的，进行磁盘操作性能不高，而且进行磁盘操作时算法更加复杂。\n>\n> hashmap 是以key为单位操作的， 磁盘操作的效率高。而且 hashmap 统计的时候，代码简洁清晰。\n\n尽管我们hashmap，也不能直接将所有数据加载到内存中处理,\n\n所以可以采取分治的策略,使用外部排序和哈希映射的方法,\n\n以下是详细的步骤:\n\n1.分块读取数据:将14亿条记录分成多个较小的块,每次读取一部分数据到内存中进行处理\n\n2.哈希映射统计词频:对每个块的数据进行哈希映射,统计每个名字出现的次数,将结果写入到磁盘文件\n\n3.合并词频统计结果:读取所有中间文件,合并词频统计结果,得到全局的词频统计\n\n4.使用小顶堆找出前100个重复最多的名字\n\n```\n\n\nimport java.io.\\*;  \nimport java.util.HashMap;  \nimport java.util.Map;  \nimport java.util.PriorityQueue;  \n  \nclass NameCount implements Comparable<NameCount\\> {  \n    String name;  \n    int count;  \n  \n    public NameCount(String name, int count) {  \n        this.name = name;  \n        this.count = count;  \n    }  \n  \n    @Override  \n    public int compareTo(NameCount other) {  \n        return Integer.compare(this.count, other.count);  \n    }  \n  \n    @Override  \n    public String toString() {  \n        return name + \": \" + count;  \n    }  \n}  \n  \npublic class ExternalMemoryTopK {  \n    private static final int CHUNK\\_SIZE = 1000000; // 每个块处理100万条记录  \n  \n    public static void main(String\\[\\] args) throws IOException {  \n        String inputFile = \"names.txt\";  \n        String outputFile = \"top100names.txt\";  \n        int k = 100;  \n  \n        // 第一步：分块读取数据并统计词频  \n        int chunkIndex = 0;  \n        BufferedReader reader = new BufferedReader(new FileReader(inputFile));  \n        String line;  \n        while ((line = reader.readLine()) != null) {  \n            Map<String, Integer> frequencyMap = new HashMap<>();  \n            int lineCount = 0;  \n            while (line != null && lineCount < CHUNK\\_SIZE) {  \n                frequencyMap.put(line, frequencyMap.getOrDefault(line, 0) + 1);  \n                line = reader.readLine();  \n                lineCount++;  \n            }  \n            writeFrequencyMapToFile(frequencyMap, \"chunk\\_\" + chunkIndex + \".txt\");  \n            chunkIndex++;  \n        }  \n        reader.close();  \n  \n        // 第二步：合并所有块的词频统计结果  \n        Map<String, Integer> globalFrequencyMap = new HashMap<>();  \n        for (int i = 0; i < chunkIndex; i++) {  \n            mergeFrequencyMapFromFile(globalFrequencyMap, \"chunk\\_\" + i + \".txt\");  \n        }  \n  \n        // 第三步：使用小顶堆找出前100个重复最多的名字  \n        PriorityQueue<NameCount> minHeap = new PriorityQueue<>(k);  \n        for (Map.Entry<String, Integer> entry : globalFrequencyMap.entrySet()) {  \n            if (minHeap.size() < k) {  \n                minHeap.offer(new NameCount(entry.getKey(), entry.getValue()));  \n            } else if (entry.getValue() > minHeap.peek().count) {  \n                minHeap.poll();  \n                minHeap.offer(new NameCount(entry.getKey(), entry.getValue()));  \n            }  \n        }  \n  \n        // 输出结果  \n        BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));  \n        while (!minHeap.isEmpty()) {  \n            writer.write(minHeap.poll().toString());  \n            writer.newLine();  \n        }  \n        writer.close();  \n    }  \n  \n    private static void writeFrequencyMapToFile(Map<String, Integer> frequencyMap, String filename) throws IOException {  \n        BufferedWriter writer = new BufferedWriter(new FileWriter(filename));  \n        for (Map.Entry<String, Integer> entry : frequencyMap.entrySet()) {  \n            writer.write(entry.getKey() + \" \" + entry.getValue());  \n            writer.newLine();  \n        }  \n        writer.close();  \n    }  \n  \n    private static void mergeFrequencyMapFromFile(Map<String, Integer> globalFrequencyMap, String filename) throws IOException {  \n        BufferedReader reader = new BufferedReader(new FileReader(filename));  \n        String line;  \n        while ((line = reader.readLine()) != null) {  \n            String\\[\\] parts = line.split(\" \");  \n            String name = parts\\[0\\];  \n            int count = Integer.parseInt(parts\\[1\\]);  \n            globalFrequencyMap.put(name, globalFrequencyMap.getOrDefault(name, 0) + count);  \n        }  \n        reader.close();  \n    }  \n}  \n\n\n\n```\n\n10\\. topK问题,典型的解题思路\n-------------------\n\n这是一种典型的topK问题,一般的问法如下：\n\n从一堆数据中选出多少个最大或最小数？\n\n解题思想：\n\n1.  先统计数量, 使用前缀树，hashmap等\n\n2.  再用小顶堆或者 大顶堆\n\n\n取大用小，取小用大。简单来说就是取最大的K个数就用小顶堆，取最小的K个数，就用大顶堆\n\n取海量数据里面最小的K个数？\n\n要找出数组中最小的K个数，就要构造一个有K个元素的大顶堆，因为大顶堆的堆顶值是最大的，其它元素和堆顶的元素比较，大于堆顶的元素，换一个元素继续，小于堆顶的元素，将堆顶元素出堆，将更小的元素插入堆顶，如此反复，堆里面就是最小的数\n\n取海量数据里面最大的K个数？\n\n要找出数组中最大的K个数，就要构造一个有K个元素的小顶堆，因为小顶堆的堆顶值是最小的，其它元素和堆顶的元素比较，大于堆顶的元素，堆顶的元素出堆，将元素插入到小顶堆，将更大的元素换到堆中，如此反复，堆里面就是最大的数\n\n","source":"_posts/统计全国重名最多的前100个.md","raw":"---\ntitle: 统计全国重名最多的前100个\ndate: 2024-06-02 17:16:17\ntags: 算法题\ncategories: 面试\n---\n\n\n阿里面试：全国14亿个姓名，统计出重名最多的前100个\n===========================\n\n\n> 全国14亿人的数据中，统计出重名人数最多的前100位姓名\n\n最近有小伙伴在面试阿里，遇到这个面试题。小伙伴没有系统的去梳理和总结，所以支支吾吾的说了几句，面试官不满意，面试挂了。\n\n**TOP N面试题是常见的算法题。**\n\nTOP N 统计的面试题，是一道非常常见的题目，大家一定要掌握好。\n\n\n1\\. 问题描述:\n---------\n\n我们需要从全国14亿人的数据中，统计出重名人数最多的前100位姓名\n\n2\\. 问题分析:\n---------\n\n我们的目标：是找到重名人数最多的前100个姓名,\n\n这意味着需要两步：\n\n*   需要有一个高效的数据结构来统计每个名字出现的次数,\n\n*   并快速找到出现次数最多的前100个名字.\n\n\n所以这个问题就转化成了下一个问题： 使用一种低成本、高性能的数据结构，来统计每个名字出现的次数。\n\n3\\. 如何选择一种最低成本、最高性能的数据结构？\n-------------------------\n\n常规的数据结构，选型如下:\n\n*   **数组**:\n\n\n如果姓名的字符集范围很大(支持所有的Unicode字符)，那么，需要极大且稀疏的数组,导致内存浪费严重,也不适合处理动态长度和多样性的字符串集合\n\n*   **链表**:\n\n    链表的插入和查找的操作时间复杂度为O(N), 并且，在大规模数据下性能低下,也不适合快速查找的场景\n\n*   **跳表**:\n\n\n跳表的插入、删除和查找操作的平均事件复杂度都是O(logN)，\n\n跳表式空间换时间的思想，主要是它需要额外的空间来维护多级索引，每个元素在最坏的情况下需要额外的存储空间，导致总的空间复杂度为O(N log N),\n\n在频繁的插入和查询的场景中，效率不高。\n\n来到我们现在这个场景，统计每个名字出现的次数时，不如哈希表在时间和空间的效率高效，哈希表的O(1)时间复杂度更适合大规模的数据频繁的插入和查询。\n\n*   **哈希表:**\n\n\n哈希表的插入和查找的时间复杂度都是O(1),\n\n但是在极端的情况下，哈希冲突会导致时间复杂度退化到O(N)，\n\n在空间效率中，哈希表需要额外的空间来维护键值对，来到这个场景，空间效率和哈希冲突都有潜在风险，\n\n最重要的是哈希表不能共享前缀，在处理大量的具有共同前缀的数据时候，也不适合。\n\n*   **平衡二叉搜索树(如AVL树或红黑树)**:\n\n\n能够维护有序数据,支持快速的插入、删除和查找操作,但在字符串的比较上,性能不如哈希表和Trie高效\n\n*   **前缀树**:\n\n\n前缀树通过共享前缀节点,节省了大量存储空间, 实现了成本的最低化\n\n前缀树对于字符串操作非常高效, 在这个问题中, 有很多名字共享相同前缀, Trie的结构能有效利用这一特点。\n\n经过上面的分析,能够看到Trie更适合统计每个名字出现的次数\n\n4\\. 如何快速筛选出Top 100？\n-------------------\n\n当知道了所有姓名出现的次数之后,、怎么样快速筛选出其中出现次数最多的前100个?\n\n首先想到的是直接排序。\n\n这个问题中,对14亿数据直接排序会有效率的问题，操作非常耗时。\n\n所以直接排序， 这种方法不可取。\n\n我们的目标是找到次数最多的前100个,可以利用堆的性质来完成。\n\n小顶堆总是保持堆顶为当前堆中最小的元素，这样可以确保当新的元素插入时，如果新元素大于堆顶元素，堆顶元素会被替换掉\n\n使用小顶堆的步骤:\n\n1.初始化一个小顶堆:设为100\n\n2.遍历每个姓名及其出现的次数:\n\n*   如果堆的大小小于100，将当前姓名及其出现次数插入堆中。\n\n*   如果当前姓名的出现次数大于堆顶元素的出现次数，则移除堆顶元素，并将当前姓名及其出现次数插入堆中。\n\n\n3.遍历完所有的姓名后,堆中即为重名人数最多的前100个姓名\n\n所以解决这个问题使用了前缀树 + 小顶堆\n\n5\\. 前缀树Trie树介绍\n--------------\n\n在计算机科学中，trie，又称前缀树或字典树，使用一些单词来构建Trie树,如下图所示:\n\n![](./2024/06/02/统计全国重名最多的前100个/1.png)\n\n从图片中可以看到一些有意思的特性:\n\n*   根节点没有数据\n\n*   从根节点到某一个节点,将他们的路径进行连接就组成了对应的字符串\n\n\n定义:\n\n> Trie树，又称为前缀树或字典树, 是一种用于高效存储和检索字符串集合的数据结构, 每个节点代表一个字符, 边表示从一个字符到另一个字符的路径, Trie树通过共享相同前缀的节点来节省存储空间\n\nTrie树是一种有序树，用于保存关联数组，其中的键通常是字符串。\n\n与二叉查找树不同，Trie树 的 键不是直接保存在节点中，而是由节点在树中的位置决定。\n\n一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。\n\n一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。\n\ntrie中的键通常是字符串，但也可以是其它的结构。\n\ntrie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。\n\n比如，bitwise trie中的键是一串位元，可以用于表示整数或者内存地址\n\n**Trie树基本性质**\n\n1，根节点不包含字符，除根节点意外每个节点只包含一个字符。\n\n2，从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。\n\n3，每个节点的所有子节点包含的字符串不相同。\n\n**Trie树优点**：\n\n可以最大限度地减少无谓的字符串比较，故可以用于词频统计和大量字符串排序。\n\n跟哈希表比较：\n\n1，最坏情况时间复杂度比hash表好\n\n2，没有冲突，除非一个key对应多个值（除key外的其他信息）\n\n3，自带排序功能（类似Radix Sort），中序遍历trie可以得到排序。\n\n**Trie树缺点**：\n\n当所有关键字都不具有相同或类似的前缀，空间消耗过大.\n\n6\\. Trie树的基本操作:\n---------------\n\n*   插入:将一个字符串逐字符插入到Trie树中\n\n*   查找:检查Trie树中是否存在某个字符串\n\n*   前缀匹配:查找所有以某个前缀开头的字符串\n\n*   删除:从Trie树中删除一个字符串\n\n\n7\\. Trie树的应用场景:\n---------------\n\n1.字符串检索:\n\n*   应用场景:快速检索字典中的单词\n\n*   使用原因:Trie树通过逐字符匹配,可以在O(L)时间内完成字符串的检索,其中L是字符串的长度,比传统的线性搜索更加高效\n\n\n2.自动补全:\n\n*   应用场景:搜索引擎和输入法中的自动补全功能\n\n*   适用原因:Trie树可以通过前缀查找快速提供所有以给定前缀开头的单词,有效提升用户输入体验\n\n\n3.前缀匹配:\n\n*   应用场景:寻找以特定前缀开头的所有字符串,如电话号码前缀匹配\n\n*   适用原因:Trie树天生适合处理前缀匹配问题,可以在O(L)时间内找到所有以特定前缀开头的字符串\n\n\n4.词频统计:\n\n*   应用场景:文本分析中统计单词出现频率\n\n*   适用原因:Trie树可以在插入过程中记录每个单词的出现次数,通过遍历Trie树可以快速统计所有单词的频率\n\n\n为什么适合这些场景:\n\n5.多模式匹配:\n\n*   应用场景:从文本中同时搜索多个模式(模式匹配算法)\n\n*   适用原因:Trie树可以构建多个模式的结构,通过一次遍历文本同时匹配多个模式,提高匹配效率\n\n\n为什么适用于这些场景:\n\n1.空间效率:\n\n*   共享前缀:Trie树通过共享前缀节点，减少了重复存储相同前缀的空间开销。\n\n*   节省内存:对于大量前缀相同的字符串集合，Trie树显著节省内存使用。\n\n\n2.时间效率:\n\n*   O(L)复杂度:插入、查找和前缀匹配操作的时间复杂度为O(L),其中L是字符串的长度,显著提高了操作效率\n\n*   快速检索:相比于其他线性结构(如数组或链表),Trie树在处理大量字符串时更快\n\n\n8\\. Trie树的代码实现:\n---------------\n\n以下是一个 参考代码：\n\n```\n\n\nimport java.util.HashMap;  \nimport java.util.Map;  \nimport java.util.PriorityQueue;  \n  \nclass TrieNode {  \n    Map<Character, TrieNode> children;  \n    int count;  \n  \n    public TrieNode() {  \n        children = new HashMap<>();  \n        count = 0;  \n    }  \n}  \n  \nclass Trie {  \n    private TrieNode root;  \n  \n    public Trie() {  \n        root = new TrieNode();  \n    }  \n  \n    public void insert(String name) {  \n        TrieNode node = root;  \n        for (char ch : name.toCharArray()) {  \n            node = node.children.computeIfAbsent(ch, k -> new TrieNode());  \n        }  \n        node.count++;  \n    }  \n  \n    public void getAllNames(TrieNode node, StringBuilder prefix, PriorityQueue<NameCount> minHeap, int k) {  \n        if (node == null) return;  \n        if (node.count > 0) {  \n            if (minHeap.size() < k) {  \n                minHeap.offer(new NameCount(prefix.toString(), node.count));  \n            } else if (node.count > minHeap.peek().count) {  \n                minHeap.poll();  \n                minHeap.offer(new NameCount(prefix.toString(), node.count));  \n            }  \n        }  \n        for (Map.Entry<Character, TrieNode> entry : node.children.entrySet()) {  \n            prefix.append(entry.getKey());  \n            getAllNames(entry.getValue(), prefix, minHeap, k);  \n            prefix.deleteCharAt(prefix.length() - 1);  \n        }  \n    }  \n  \n    public PriorityQueue<NameCount> getTopKNames(int k) {  \n        PriorityQueue<NameCount> minHeap = new PriorityQueue<>(k);  \n        getAllNames(root, new StringBuilder(), minHeap, k);  \n        return minHeap;  \n    }  \n}  \n  \nclass NameCount implements Comparable<NameCount\\> {  \n    String name;  \n    int count;  \n  \n    public NameCount(String name, int count) {  \n        this.name = name;  \n        this.count = count;  \n    }  \n  \n    @Override  \n    public int compareTo(NameCount other) {  \n        return Integer.compare(this.count, other.count);  \n    }  \n  \n    @Override  \n    public String toString() {  \n        return name + \": \" + count;  \n    }  \n}  \n  \npublic class Main {  \n    public static void main(String\\[\\] args) {  \n        String\\[\\] names = {\"张伟\", \"王伟伟\", \"王芳\", \"李伟\", \"李娜\"}; // 示例数据  \n        int k = 100; // 找到前100个重名人数最多的姓名  \n  \n        Trie trie = new Trie();  \n        for (String name : names) {  \n            trie.insert(name);  \n        }  \n  \n        PriorityQueue<NameCount> topKNames = trie.getTopKNames(k);  \n        while (!topKNames.isEmpty()) {  \n            System.out.println(topKNames.poll());  \n        }  \n    }  \n}  \n\n\n\n```\n\n9\\. TOP N问题发散:\n--------------\n\n上面的问题进行改进一下, 如果我们对内存有一个限制,比如:要求内存的使用不能超过2G,\n\n注意，这里的内存受限，尽量使用磁盘处理。\n\n> 这里使用hashmap，而不适用 trie树的原因是？\n>\n> trie树是按照字符为粒度组织树的节点的，进行磁盘操作性能不高，而且进行磁盘操作时算法更加复杂。\n>\n> hashmap 是以key为单位操作的， 磁盘操作的效率高。而且 hashmap 统计的时候，代码简洁清晰。\n\n尽管我们hashmap，也不能直接将所有数据加载到内存中处理,\n\n所以可以采取分治的策略,使用外部排序和哈希映射的方法,\n\n以下是详细的步骤:\n\n1.分块读取数据:将14亿条记录分成多个较小的块,每次读取一部分数据到内存中进行处理\n\n2.哈希映射统计词频:对每个块的数据进行哈希映射,统计每个名字出现的次数,将结果写入到磁盘文件\n\n3.合并词频统计结果:读取所有中间文件,合并词频统计结果,得到全局的词频统计\n\n4.使用小顶堆找出前100个重复最多的名字\n\n```\n\n\nimport java.io.\\*;  \nimport java.util.HashMap;  \nimport java.util.Map;  \nimport java.util.PriorityQueue;  \n  \nclass NameCount implements Comparable<NameCount\\> {  \n    String name;  \n    int count;  \n  \n    public NameCount(String name, int count) {  \n        this.name = name;  \n        this.count = count;  \n    }  \n  \n    @Override  \n    public int compareTo(NameCount other) {  \n        return Integer.compare(this.count, other.count);  \n    }  \n  \n    @Override  \n    public String toString() {  \n        return name + \": \" + count;  \n    }  \n}  \n  \npublic class ExternalMemoryTopK {  \n    private static final int CHUNK\\_SIZE = 1000000; // 每个块处理100万条记录  \n  \n    public static void main(String\\[\\] args) throws IOException {  \n        String inputFile = \"names.txt\";  \n        String outputFile = \"top100names.txt\";  \n        int k = 100;  \n  \n        // 第一步：分块读取数据并统计词频  \n        int chunkIndex = 0;  \n        BufferedReader reader = new BufferedReader(new FileReader(inputFile));  \n        String line;  \n        while ((line = reader.readLine()) != null) {  \n            Map<String, Integer> frequencyMap = new HashMap<>();  \n            int lineCount = 0;  \n            while (line != null && lineCount < CHUNK\\_SIZE) {  \n                frequencyMap.put(line, frequencyMap.getOrDefault(line, 0) + 1);  \n                line = reader.readLine();  \n                lineCount++;  \n            }  \n            writeFrequencyMapToFile(frequencyMap, \"chunk\\_\" + chunkIndex + \".txt\");  \n            chunkIndex++;  \n        }  \n        reader.close();  \n  \n        // 第二步：合并所有块的词频统计结果  \n        Map<String, Integer> globalFrequencyMap = new HashMap<>();  \n        for (int i = 0; i < chunkIndex; i++) {  \n            mergeFrequencyMapFromFile(globalFrequencyMap, \"chunk\\_\" + i + \".txt\");  \n        }  \n  \n        // 第三步：使用小顶堆找出前100个重复最多的名字  \n        PriorityQueue<NameCount> minHeap = new PriorityQueue<>(k);  \n        for (Map.Entry<String, Integer> entry : globalFrequencyMap.entrySet()) {  \n            if (minHeap.size() < k) {  \n                minHeap.offer(new NameCount(entry.getKey(), entry.getValue()));  \n            } else if (entry.getValue() > minHeap.peek().count) {  \n                minHeap.poll();  \n                minHeap.offer(new NameCount(entry.getKey(), entry.getValue()));  \n            }  \n        }  \n  \n        // 输出结果  \n        BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));  \n        while (!minHeap.isEmpty()) {  \n            writer.write(minHeap.poll().toString());  \n            writer.newLine();  \n        }  \n        writer.close();  \n    }  \n  \n    private static void writeFrequencyMapToFile(Map<String, Integer> frequencyMap, String filename) throws IOException {  \n        BufferedWriter writer = new BufferedWriter(new FileWriter(filename));  \n        for (Map.Entry<String, Integer> entry : frequencyMap.entrySet()) {  \n            writer.write(entry.getKey() + \" \" + entry.getValue());  \n            writer.newLine();  \n        }  \n        writer.close();  \n    }  \n  \n    private static void mergeFrequencyMapFromFile(Map<String, Integer> globalFrequencyMap, String filename) throws IOException {  \n        BufferedReader reader = new BufferedReader(new FileReader(filename));  \n        String line;  \n        while ((line = reader.readLine()) != null) {  \n            String\\[\\] parts = line.split(\" \");  \n            String name = parts\\[0\\];  \n            int count = Integer.parseInt(parts\\[1\\]);  \n            globalFrequencyMap.put(name, globalFrequencyMap.getOrDefault(name, 0) + count);  \n        }  \n        reader.close();  \n    }  \n}  \n\n\n\n```\n\n10\\. topK问题,典型的解题思路\n-------------------\n\n这是一种典型的topK问题,一般的问法如下：\n\n从一堆数据中选出多少个最大或最小数？\n\n解题思想：\n\n1.  先统计数量, 使用前缀树，hashmap等\n\n2.  再用小顶堆或者 大顶堆\n\n\n取大用小，取小用大。简单来说就是取最大的K个数就用小顶堆，取最小的K个数，就用大顶堆\n\n取海量数据里面最小的K个数？\n\n要找出数组中最小的K个数，就要构造一个有K个元素的大顶堆，因为大顶堆的堆顶值是最大的，其它元素和堆顶的元素比较，大于堆顶的元素，换一个元素继续，小于堆顶的元素，将堆顶元素出堆，将更小的元素插入堆顶，如此反复，堆里面就是最小的数\n\n取海量数据里面最大的K个数？\n\n要找出数组中最大的K个数，就要构造一个有K个元素的小顶堆，因为小顶堆的堆顶值是最小的，其它元素和堆顶的元素比较，大于堆顶的元素，堆顶的元素出堆，将元素插入到小顶堆，将更大的元素换到堆中，如此反复，堆里面就是最大的数\n\n","slug":"统计全国重名最多的前100个","published":1,"updated":"2024-06-02T09:23:46.849Z","comments":1,"layout":"post","photos":[],"_id":"clwxc4ra30013b4uh8luafqeq","content":"<h1 id=\"阿里面试：全国14亿个姓名，统计出重名最多的前100个\"><a href=\"#阿里面试：全国14亿个姓名，统计出重名最多的前100个\" class=\"headerlink\" title=\"阿里面试：全国14亿个姓名，统计出重名最多的前100个\"></a>阿里面试：全国14亿个姓名，统计出重名最多的前100个</h1><blockquote>\n<p>全国14亿人的数据中，统计出重名人数最多的前100位姓名</p>\n</blockquote>\n<p>最近有小伙伴在面试阿里，遇到这个面试题。小伙伴没有系统的去梳理和总结，所以支支吾吾的说了几句，面试官不满意，面试挂了。</p>\n<p><strong>TOP N面试题是常见的算法题。</strong></p>\n<p>TOP N 统计的面试题，是一道非常常见的题目，大家一定要掌握好。</p>\n<h2 id=\"1-问题描述\"><a href=\"#1-问题描述\" class=\"headerlink\" title=\"1. 问题描述:\"></a>1. 问题描述:</h2><p>我们需要从全国14亿人的数据中，统计出重名人数最多的前100位姓名</p>\n<h2 id=\"2-问题分析\"><a href=\"#2-问题分析\" class=\"headerlink\" title=\"2. 问题分析:\"></a>2. 问题分析:</h2><p>我们的目标：是找到重名人数最多的前100个姓名,</p>\n<p>这意味着需要两步：</p>\n<ul>\n<li><p>需要有一个高效的数据结构来统计每个名字出现的次数,</p>\n</li>\n<li><p>并快速找到出现次数最多的前100个名字.</p>\n</li>\n</ul>\n<p>所以这个问题就转化成了下一个问题： 使用一种低成本、高性能的数据结构，来统计每个名字出现的次数。</p>\n<h2 id=\"3-如何选择一种最低成本、最高性能的数据结构？\"><a href=\"#3-如何选择一种最低成本、最高性能的数据结构？\" class=\"headerlink\" title=\"3. 如何选择一种最低成本、最高性能的数据结构？\"></a>3. 如何选择一种最低成本、最高性能的数据结构？</h2><p>常规的数据结构，选型如下:</p>\n<ul>\n<li><strong>数组</strong>:</li>\n</ul>\n<p>如果姓名的字符集范围很大(支持所有的Unicode字符)，那么，需要极大且稀疏的数组,导致内存浪费严重,也不适合处理动态长度和多样性的字符串集合</p>\n<ul>\n<li><p><strong>链表</strong>:</p>\n<p>链表的插入和查找的操作时间复杂度为O(N), 并且，在大规模数据下性能低下,也不适合快速查找的场景</p>\n</li>\n<li><p><strong>跳表</strong>:</p>\n</li>\n</ul>\n<p>跳表的插入、删除和查找操作的平均事件复杂度都是O(logN)，</p>\n<p>跳表式空间换时间的思想，主要是它需要额外的空间来维护多级索引，每个元素在最坏的情况下需要额外的存储空间，导致总的空间复杂度为O(N log N),</p>\n<p>在频繁的插入和查询的场景中，效率不高。</p>\n<p>来到我们现在这个场景，统计每个名字出现的次数时，不如哈希表在时间和空间的效率高效，哈希表的O(1)时间复杂度更适合大规模的数据频繁的插入和查询。</p>\n<ul>\n<li><strong>哈希表:</strong></li>\n</ul>\n<p>哈希表的插入和查找的时间复杂度都是O(1),</p>\n<p>但是在极端的情况下，哈希冲突会导致时间复杂度退化到O(N)，</p>\n<p>在空间效率中，哈希表需要额外的空间来维护键值对，来到这个场景，空间效率和哈希冲突都有潜在风险，</p>\n<p>最重要的是哈希表不能共享前缀，在处理大量的具有共同前缀的数据时候，也不适合。</p>\n<ul>\n<li><strong>平衡二叉搜索树(如AVL树或红黑树)</strong>:</li>\n</ul>\n<p>能够维护有序数据,支持快速的插入、删除和查找操作,但在字符串的比较上,性能不如哈希表和Trie高效</p>\n<ul>\n<li><strong>前缀树</strong>:</li>\n</ul>\n<p>前缀树通过共享前缀节点,节省了大量存储空间, 实现了成本的最低化</p>\n<p>前缀树对于字符串操作非常高效, 在这个问题中, 有很多名字共享相同前缀, Trie的结构能有效利用这一特点。</p>\n<p>经过上面的分析,能够看到Trie更适合统计每个名字出现的次数</p>\n<h2 id=\"4-如何快速筛选出Top-100？\"><a href=\"#4-如何快速筛选出Top-100？\" class=\"headerlink\" title=\"4. 如何快速筛选出Top 100？\"></a>4. 如何快速筛选出Top 100？</h2><p>当知道了所有姓名出现的次数之后,、怎么样快速筛选出其中出现次数最多的前100个?</p>\n<p>首先想到的是直接排序。</p>\n<p>这个问题中,对14亿数据直接排序会有效率的问题，操作非常耗时。</p>\n<p>所以直接排序， 这种方法不可取。</p>\n<p>我们的目标是找到次数最多的前100个,可以利用堆的性质来完成。</p>\n<p>小顶堆总是保持堆顶为当前堆中最小的元素，这样可以确保当新的元素插入时，如果新元素大于堆顶元素，堆顶元素会被替换掉</p>\n<p>使用小顶堆的步骤:</p>\n<p>1.初始化一个小顶堆:设为100</p>\n<p>2.遍历每个姓名及其出现的次数:</p>\n<ul>\n<li><p>如果堆的大小小于100，将当前姓名及其出现次数插入堆中。</p>\n</li>\n<li><p>如果当前姓名的出现次数大于堆顶元素的出现次数，则移除堆顶元素，并将当前姓名及其出现次数插入堆中。</p>\n</li>\n</ul>\n<p>3.遍历完所有的姓名后,堆中即为重名人数最多的前100个姓名</p>\n<p>所以解决这个问题使用了前缀树 + 小顶堆</p>\n<h2 id=\"5-前缀树Trie树介绍\"><a href=\"#5-前缀树Trie树介绍\" class=\"headerlink\" title=\"5. 前缀树Trie树介绍\"></a>5. 前缀树Trie树介绍</h2><p>在计算机科学中，trie，又称前缀树或字典树，使用一些单词来构建Trie树,如下图所示:</p>\n<p><img src=\"/./2024/06/02/%E7%BB%9F%E8%AE%A1%E5%85%A8%E5%9B%BD%E9%87%8D%E5%90%8D%E6%9C%80%E5%A4%9A%E7%9A%84%E5%89%8D100%E4%B8%AA/1.png\"></p>\n<p>从图片中可以看到一些有意思的特性:</p>\n<ul>\n<li><p>根节点没有数据</p>\n</li>\n<li><p>从根节点到某一个节点,将他们的路径进行连接就组成了对应的字符串</p>\n</li>\n</ul>\n<p>定义:</p>\n<blockquote>\n<p>Trie树，又称为前缀树或字典树, 是一种用于高效存储和检索字符串集合的数据结构, 每个节点代表一个字符, 边表示从一个字符到另一个字符的路径, Trie树通过共享相同前缀的节点来节省存储空间</p>\n</blockquote>\n<p>Trie树是一种有序树，用于保存关联数组，其中的键通常是字符串。</p>\n<p>与二叉查找树不同，Trie树 的 键不是直接保存在节点中，而是由节点在树中的位置决定。</p>\n<p>一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。</p>\n<p>一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>\n<p>trie中的键通常是字符串，但也可以是其它的结构。</p>\n<p>trie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。</p>\n<p>比如，bitwise trie中的键是一串位元，可以用于表示整数或者内存地址</p>\n<p><strong>Trie树基本性质</strong></p>\n<p>1，根节点不包含字符，除根节点意外每个节点只包含一个字符。</p>\n<p>2，从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。</p>\n<p>3，每个节点的所有子节点包含的字符串不相同。</p>\n<p><strong>Trie树优点</strong>：</p>\n<p>可以最大限度地减少无谓的字符串比较，故可以用于词频统计和大量字符串排序。</p>\n<p>跟哈希表比较：</p>\n<p>1，最坏情况时间复杂度比hash表好</p>\n<p>2，没有冲突，除非一个key对应多个值（除key外的其他信息）</p>\n<p>3，自带排序功能（类似Radix Sort），中序遍历trie可以得到排序。</p>\n<p><strong>Trie树缺点</strong>：</p>\n<p>当所有关键字都不具有相同或类似的前缀，空间消耗过大.</p>\n<h2 id=\"6-Trie树的基本操作\"><a href=\"#6-Trie树的基本操作\" class=\"headerlink\" title=\"6. Trie树的基本操作:\"></a>6. Trie树的基本操作:</h2><ul>\n<li><p>插入:将一个字符串逐字符插入到Trie树中</p>\n</li>\n<li><p>查找:检查Trie树中是否存在某个字符串</p>\n</li>\n<li><p>前缀匹配:查找所有以某个前缀开头的字符串</p>\n</li>\n<li><p>删除:从Trie树中删除一个字符串</p>\n</li>\n</ul>\n<h2 id=\"7-Trie树的应用场景\"><a href=\"#7-Trie树的应用场景\" class=\"headerlink\" title=\"7. Trie树的应用场景:\"></a>7. Trie树的应用场景:</h2><p>1.字符串检索:</p>\n<ul>\n<li><p>应用场景:快速检索字典中的单词</p>\n</li>\n<li><p>使用原因:Trie树通过逐字符匹配,可以在O(L)时间内完成字符串的检索,其中L是字符串的长度,比传统的线性搜索更加高效</p>\n</li>\n</ul>\n<p>2.自动补全:</p>\n<ul>\n<li><p>应用场景:搜索引擎和输入法中的自动补全功能</p>\n</li>\n<li><p>适用原因:Trie树可以通过前缀查找快速提供所有以给定前缀开头的单词,有效提升用户输入体验</p>\n</li>\n</ul>\n<p>3.前缀匹配:</p>\n<ul>\n<li><p>应用场景:寻找以特定前缀开头的所有字符串,如电话号码前缀匹配</p>\n</li>\n<li><p>适用原因:Trie树天生适合处理前缀匹配问题,可以在O(L)时间内找到所有以特定前缀开头的字符串</p>\n</li>\n</ul>\n<p>4.词频统计:</p>\n<ul>\n<li><p>应用场景:文本分析中统计单词出现频率</p>\n</li>\n<li><p>适用原因:Trie树可以在插入过程中记录每个单词的出现次数,通过遍历Trie树可以快速统计所有单词的频率</p>\n</li>\n</ul>\n<p>为什么适合这些场景:</p>\n<p>5.多模式匹配:</p>\n<ul>\n<li><p>应用场景:从文本中同时搜索多个模式(模式匹配算法)</p>\n</li>\n<li><p>适用原因:Trie树可以构建多个模式的结构,通过一次遍历文本同时匹配多个模式,提高匹配效率</p>\n</li>\n</ul>\n<p>为什么适用于这些场景:</p>\n<p>1.空间效率:</p>\n<ul>\n<li><p>共享前缀:Trie树通过共享前缀节点，减少了重复存储相同前缀的空间开销。</p>\n</li>\n<li><p>节省内存:对于大量前缀相同的字符串集合，Trie树显著节省内存使用。</p>\n</li>\n</ul>\n<p>2.时间效率:</p>\n<ul>\n<li><p>O(L)复杂度:插入、查找和前缀匹配操作的时间复杂度为O(L),其中L是字符串的长度,显著提高了操作效率</p>\n</li>\n<li><p>快速检索:相比于其他线性结构(如数组或链表),Trie树在处理大量字符串时更快</p>\n</li>\n</ul>\n<h2 id=\"8-Trie树的代码实现\"><a href=\"#8-Trie树的代码实现\" class=\"headerlink\" title=\"8. Trie树的代码实现:\"></a>8. Trie树的代码实现:</h2><p>以下是一个 参考代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.HashMap;  </span><br><span class=\"line\">import java.util.Map;  </span><br><span class=\"line\">import java.util.PriorityQueue;  </span><br><span class=\"line\">  </span><br><span class=\"line\">class TrieNode &#123;  </span><br><span class=\"line\">    Map&lt;Character, TrieNode&gt; children;  </span><br><span class=\"line\">    int count;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public TrieNode() &#123;  </span><br><span class=\"line\">        children = new HashMap&lt;&gt;();  </span><br><span class=\"line\">        count = 0;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">class Trie &#123;  </span><br><span class=\"line\">    private TrieNode root;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public Trie() &#123;  </span><br><span class=\"line\">        root = new TrieNode();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public void insert(String name) &#123;  </span><br><span class=\"line\">        TrieNode node = root;  </span><br><span class=\"line\">        for (char ch : name.toCharArray()) &#123;  </span><br><span class=\"line\">            node = node.children.computeIfAbsent(ch, k -&gt; new TrieNode());  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        node.count++;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public void getAllNames(TrieNode node, StringBuilder prefix, PriorityQueue&lt;NameCount&gt; minHeap, int k) &#123;  </span><br><span class=\"line\">        if (node == null) return;  </span><br><span class=\"line\">        if (node.count &gt; 0) &#123;  </span><br><span class=\"line\">            if (minHeap.size() &lt; k) &#123;  </span><br><span class=\"line\">                minHeap.offer(new NameCount(prefix.toString(), node.count));  </span><br><span class=\"line\">            &#125; else if (node.count &gt; minHeap.peek().count) &#123;  </span><br><span class=\"line\">                minHeap.poll();  </span><br><span class=\"line\">                minHeap.offer(new NameCount(prefix.toString(), node.count));  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        for (Map.Entry&lt;Character, TrieNode&gt; entry : node.children.entrySet()) &#123;  </span><br><span class=\"line\">            prefix.append(entry.getKey());  </span><br><span class=\"line\">            getAllNames(entry.getValue(), prefix, minHeap, k);  </span><br><span class=\"line\">            prefix.deleteCharAt(prefix.length() - 1);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public PriorityQueue&lt;NameCount&gt; getTopKNames(int k) &#123;  </span><br><span class=\"line\">        PriorityQueue&lt;NameCount&gt; minHeap = new PriorityQueue&lt;&gt;(k);  </span><br><span class=\"line\">        getAllNames(root, new StringBuilder(), minHeap, k);  </span><br><span class=\"line\">        return minHeap;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">class NameCount implements Comparable&lt;NameCount\\&gt; &#123;  </span><br><span class=\"line\">    String name;  </span><br><span class=\"line\">    int count;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public NameCount(String name, int count) &#123;  </span><br><span class=\"line\">        this.name = name;  </span><br><span class=\"line\">        this.count = count;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public int compareTo(NameCount other) &#123;  </span><br><span class=\"line\">        return Integer.compare(this.count, other.count);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public String toString() &#123;  </span><br><span class=\"line\">        return name + &quot;: &quot; + count;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">public class Main &#123;  </span><br><span class=\"line\">    public static void main(String\\[\\] args) &#123;  </span><br><span class=\"line\">        String\\[\\] names = &#123;&quot;张伟&quot;, &quot;王伟伟&quot;, &quot;王芳&quot;, &quot;李伟&quot;, &quot;李娜&quot;&#125;; // 示例数据  </span><br><span class=\"line\">        int k = 100; // 找到前100个重名人数最多的姓名  </span><br><span class=\"line\">  </span><br><span class=\"line\">        Trie trie = new Trie();  </span><br><span class=\"line\">        for (String name : names) &#123;  </span><br><span class=\"line\">            trie.insert(name);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        PriorityQueue&lt;NameCount&gt; topKNames = trie.getTopKNames(k);  </span><br><span class=\"line\">        while (!topKNames.isEmpty()) &#123;  </span><br><span class=\"line\">            System.out.println(topKNames.poll());  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-TOP-N问题发散\"><a href=\"#9-TOP-N问题发散\" class=\"headerlink\" title=\"9. TOP N问题发散:\"></a>9. TOP N问题发散:</h2><p>上面的问题进行改进一下, 如果我们对内存有一个限制,比如:要求内存的使用不能超过2G,</p>\n<p>注意，这里的内存受限，尽量使用磁盘处理。</p>\n<blockquote>\n<p>这里使用hashmap，而不适用 trie树的原因是？</p>\n<p>trie树是按照字符为粒度组织树的节点的，进行磁盘操作性能不高，而且进行磁盘操作时算法更加复杂。</p>\n<p>hashmap 是以key为单位操作的， 磁盘操作的效率高。而且 hashmap 统计的时候，代码简洁清晰。</p>\n</blockquote>\n<p>尽管我们hashmap，也不能直接将所有数据加载到内存中处理,</p>\n<p>所以可以采取分治的策略,使用外部排序和哈希映射的方法,</p>\n<p>以下是详细的步骤:</p>\n<p>1.分块读取数据:将14亿条记录分成多个较小的块,每次读取一部分数据到内存中进行处理</p>\n<p>2.哈希映射统计词频:对每个块的数据进行哈希映射,统计每个名字出现的次数,将结果写入到磁盘文件</p>\n<p>3.合并词频统计结果:读取所有中间文件,合并词频统计结果,得到全局的词频统计</p>\n<p>4.使用小顶堆找出前100个重复最多的名字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.\\*;  </span><br><span class=\"line\">import java.util.HashMap;  </span><br><span class=\"line\">import java.util.Map;  </span><br><span class=\"line\">import java.util.PriorityQueue;  </span><br><span class=\"line\">  </span><br><span class=\"line\">class NameCount implements Comparable&lt;NameCount\\&gt; &#123;  </span><br><span class=\"line\">    String name;  </span><br><span class=\"line\">    int count;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public NameCount(String name, int count) &#123;  </span><br><span class=\"line\">        this.name = name;  </span><br><span class=\"line\">        this.count = count;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public int compareTo(NameCount other) &#123;  </span><br><span class=\"line\">        return Integer.compare(this.count, other.count);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public String toString() &#123;  </span><br><span class=\"line\">        return name + &quot;: &quot; + count;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">public class ExternalMemoryTopK &#123;  </span><br><span class=\"line\">    private static final int CHUNK\\_SIZE = 1000000; // 每个块处理100万条记录  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public static void main(String\\[\\] args) throws IOException &#123;  </span><br><span class=\"line\">        String inputFile = &quot;names.txt&quot;;  </span><br><span class=\"line\">        String outputFile = &quot;top100names.txt&quot;;  </span><br><span class=\"line\">        int k = 100;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 第一步：分块读取数据并统计词频  </span><br><span class=\"line\">        int chunkIndex = 0;  </span><br><span class=\"line\">        BufferedReader reader = new BufferedReader(new FileReader(inputFile));  </span><br><span class=\"line\">        String line;  </span><br><span class=\"line\">        while ((line = reader.readLine()) != null) &#123;  </span><br><span class=\"line\">            Map&lt;String, Integer&gt; frequencyMap = new HashMap&lt;&gt;();  </span><br><span class=\"line\">            int lineCount = 0;  </span><br><span class=\"line\">            while (line != null &amp;&amp; lineCount &lt; CHUNK\\_SIZE) &#123;  </span><br><span class=\"line\">                frequencyMap.put(line, frequencyMap.getOrDefault(line, 0) + 1);  </span><br><span class=\"line\">                line = reader.readLine();  </span><br><span class=\"line\">                lineCount++;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            writeFrequencyMapToFile(frequencyMap, &quot;chunk\\_&quot; + chunkIndex + &quot;.txt&quot;);  </span><br><span class=\"line\">            chunkIndex++;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        reader.close();  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 第二步：合并所有块的词频统计结果  </span><br><span class=\"line\">        Map&lt;String, Integer&gt; globalFrequencyMap = new HashMap&lt;&gt;();  </span><br><span class=\"line\">        for (int i = 0; i &lt; chunkIndex; i++) &#123;  </span><br><span class=\"line\">            mergeFrequencyMapFromFile(globalFrequencyMap, &quot;chunk\\_&quot; + i + &quot;.txt&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 第三步：使用小顶堆找出前100个重复最多的名字  </span><br><span class=\"line\">        PriorityQueue&lt;NameCount&gt; minHeap = new PriorityQueue&lt;&gt;(k);  </span><br><span class=\"line\">        for (Map.Entry&lt;String, Integer&gt; entry : globalFrequencyMap.entrySet()) &#123;  </span><br><span class=\"line\">            if (minHeap.size() &lt; k) &#123;  </span><br><span class=\"line\">                minHeap.offer(new NameCount(entry.getKey(), entry.getValue()));  </span><br><span class=\"line\">            &#125; else if (entry.getValue() &gt; minHeap.peek().count) &#123;  </span><br><span class=\"line\">                minHeap.poll();  </span><br><span class=\"line\">                minHeap.offer(new NameCount(entry.getKey(), entry.getValue()));  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 输出结果  </span><br><span class=\"line\">        BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));  </span><br><span class=\"line\">        while (!minHeap.isEmpty()) &#123;  </span><br><span class=\"line\">            writer.write(minHeap.poll().toString());  </span><br><span class=\"line\">            writer.newLine();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        writer.close();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    private static void writeFrequencyMapToFile(Map&lt;String, Integer&gt; frequencyMap, String filename) throws IOException &#123;  </span><br><span class=\"line\">        BufferedWriter writer = new BufferedWriter(new FileWriter(filename));  </span><br><span class=\"line\">        for (Map.Entry&lt;String, Integer&gt; entry : frequencyMap.entrySet()) &#123;  </span><br><span class=\"line\">            writer.write(entry.getKey() + &quot; &quot; + entry.getValue());  </span><br><span class=\"line\">            writer.newLine();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        writer.close();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    private static void mergeFrequencyMapFromFile(Map&lt;String, Integer&gt; globalFrequencyMap, String filename) throws IOException &#123;  </span><br><span class=\"line\">        BufferedReader reader = new BufferedReader(new FileReader(filename));  </span><br><span class=\"line\">        String line;  </span><br><span class=\"line\">        while ((line = reader.readLine()) != null) &#123;  </span><br><span class=\"line\">            String\\[\\] parts = line.split(&quot; &quot;);  </span><br><span class=\"line\">            String name = parts\\[0\\];  </span><br><span class=\"line\">            int count = Integer.parseInt(parts\\[1\\]);  </span><br><span class=\"line\">            globalFrequencyMap.put(name, globalFrequencyMap.getOrDefault(name, 0) + count);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        reader.close();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-topK问题-典型的解题思路\"><a href=\"#10-topK问题-典型的解题思路\" class=\"headerlink\" title=\"10. topK问题,典型的解题思路\"></a>10. topK问题,典型的解题思路</h2><p>这是一种典型的topK问题,一般的问法如下：</p>\n<p>从一堆数据中选出多少个最大或最小数？</p>\n<p>解题思想：</p>\n<ol>\n<li><p>先统计数量, 使用前缀树，hashmap等</p>\n</li>\n<li><p>再用小顶堆或者 大顶堆</p>\n</li>\n</ol>\n<p>取大用小，取小用大。简单来说就是取最大的K个数就用小顶堆，取最小的K个数，就用大顶堆</p>\n<p>取海量数据里面最小的K个数？</p>\n<p>要找出数组中最小的K个数，就要构造一个有K个元素的大顶堆，因为大顶堆的堆顶值是最大的，其它元素和堆顶的元素比较，大于堆顶的元素，换一个元素继续，小于堆顶的元素，将堆顶元素出堆，将更小的元素插入堆顶，如此反复，堆里面就是最小的数</p>\n<p>取海量数据里面最大的K个数？</p>\n<p>要找出数组中最大的K个数，就要构造一个有K个元素的小顶堆，因为小顶堆的堆顶值是最小的，其它元素和堆顶的元素比较，大于堆顶的元素，堆顶的元素出堆，将元素插入到小顶堆，将更大的元素换到堆中，如此反复，堆里面就是最大的数</p>\n","cover":"/img/liushui.png","cover_type":"img","excerpt":"","more":"<h1 id=\"阿里面试：全国14亿个姓名，统计出重名最多的前100个\"><a href=\"#阿里面试：全国14亿个姓名，统计出重名最多的前100个\" class=\"headerlink\" title=\"阿里面试：全国14亿个姓名，统计出重名最多的前100个\"></a>阿里面试：全国14亿个姓名，统计出重名最多的前100个</h1><blockquote>\n<p>全国14亿人的数据中，统计出重名人数最多的前100位姓名</p>\n</blockquote>\n<p>最近有小伙伴在面试阿里，遇到这个面试题。小伙伴没有系统的去梳理和总结，所以支支吾吾的说了几句，面试官不满意，面试挂了。</p>\n<p><strong>TOP N面试题是常见的算法题。</strong></p>\n<p>TOP N 统计的面试题，是一道非常常见的题目，大家一定要掌握好。</p>\n<h2 id=\"1-问题描述\"><a href=\"#1-问题描述\" class=\"headerlink\" title=\"1. 问题描述:\"></a>1. 问题描述:</h2><p>我们需要从全国14亿人的数据中，统计出重名人数最多的前100位姓名</p>\n<h2 id=\"2-问题分析\"><a href=\"#2-问题分析\" class=\"headerlink\" title=\"2. 问题分析:\"></a>2. 问题分析:</h2><p>我们的目标：是找到重名人数最多的前100个姓名,</p>\n<p>这意味着需要两步：</p>\n<ul>\n<li><p>需要有一个高效的数据结构来统计每个名字出现的次数,</p>\n</li>\n<li><p>并快速找到出现次数最多的前100个名字.</p>\n</li>\n</ul>\n<p>所以这个问题就转化成了下一个问题： 使用一种低成本、高性能的数据结构，来统计每个名字出现的次数。</p>\n<h2 id=\"3-如何选择一种最低成本、最高性能的数据结构？\"><a href=\"#3-如何选择一种最低成本、最高性能的数据结构？\" class=\"headerlink\" title=\"3. 如何选择一种最低成本、最高性能的数据结构？\"></a>3. 如何选择一种最低成本、最高性能的数据结构？</h2><p>常规的数据结构，选型如下:</p>\n<ul>\n<li><strong>数组</strong>:</li>\n</ul>\n<p>如果姓名的字符集范围很大(支持所有的Unicode字符)，那么，需要极大且稀疏的数组,导致内存浪费严重,也不适合处理动态长度和多样性的字符串集合</p>\n<ul>\n<li><p><strong>链表</strong>:</p>\n<p>链表的插入和查找的操作时间复杂度为O(N), 并且，在大规模数据下性能低下,也不适合快速查找的场景</p>\n</li>\n<li><p><strong>跳表</strong>:</p>\n</li>\n</ul>\n<p>跳表的插入、删除和查找操作的平均事件复杂度都是O(logN)，</p>\n<p>跳表式空间换时间的思想，主要是它需要额外的空间来维护多级索引，每个元素在最坏的情况下需要额外的存储空间，导致总的空间复杂度为O(N log N),</p>\n<p>在频繁的插入和查询的场景中，效率不高。</p>\n<p>来到我们现在这个场景，统计每个名字出现的次数时，不如哈希表在时间和空间的效率高效，哈希表的O(1)时间复杂度更适合大规模的数据频繁的插入和查询。</p>\n<ul>\n<li><strong>哈希表:</strong></li>\n</ul>\n<p>哈希表的插入和查找的时间复杂度都是O(1),</p>\n<p>但是在极端的情况下，哈希冲突会导致时间复杂度退化到O(N)，</p>\n<p>在空间效率中，哈希表需要额外的空间来维护键值对，来到这个场景，空间效率和哈希冲突都有潜在风险，</p>\n<p>最重要的是哈希表不能共享前缀，在处理大量的具有共同前缀的数据时候，也不适合。</p>\n<ul>\n<li><strong>平衡二叉搜索树(如AVL树或红黑树)</strong>:</li>\n</ul>\n<p>能够维护有序数据,支持快速的插入、删除和查找操作,但在字符串的比较上,性能不如哈希表和Trie高效</p>\n<ul>\n<li><strong>前缀树</strong>:</li>\n</ul>\n<p>前缀树通过共享前缀节点,节省了大量存储空间, 实现了成本的最低化</p>\n<p>前缀树对于字符串操作非常高效, 在这个问题中, 有很多名字共享相同前缀, Trie的结构能有效利用这一特点。</p>\n<p>经过上面的分析,能够看到Trie更适合统计每个名字出现的次数</p>\n<h2 id=\"4-如何快速筛选出Top-100？\"><a href=\"#4-如何快速筛选出Top-100？\" class=\"headerlink\" title=\"4. 如何快速筛选出Top 100？\"></a>4. 如何快速筛选出Top 100？</h2><p>当知道了所有姓名出现的次数之后,、怎么样快速筛选出其中出现次数最多的前100个?</p>\n<p>首先想到的是直接排序。</p>\n<p>这个问题中,对14亿数据直接排序会有效率的问题，操作非常耗时。</p>\n<p>所以直接排序， 这种方法不可取。</p>\n<p>我们的目标是找到次数最多的前100个,可以利用堆的性质来完成。</p>\n<p>小顶堆总是保持堆顶为当前堆中最小的元素，这样可以确保当新的元素插入时，如果新元素大于堆顶元素，堆顶元素会被替换掉</p>\n<p>使用小顶堆的步骤:</p>\n<p>1.初始化一个小顶堆:设为100</p>\n<p>2.遍历每个姓名及其出现的次数:</p>\n<ul>\n<li><p>如果堆的大小小于100，将当前姓名及其出现次数插入堆中。</p>\n</li>\n<li><p>如果当前姓名的出现次数大于堆顶元素的出现次数，则移除堆顶元素，并将当前姓名及其出现次数插入堆中。</p>\n</li>\n</ul>\n<p>3.遍历完所有的姓名后,堆中即为重名人数最多的前100个姓名</p>\n<p>所以解决这个问题使用了前缀树 + 小顶堆</p>\n<h2 id=\"5-前缀树Trie树介绍\"><a href=\"#5-前缀树Trie树介绍\" class=\"headerlink\" title=\"5. 前缀树Trie树介绍\"></a>5. 前缀树Trie树介绍</h2><p>在计算机科学中，trie，又称前缀树或字典树，使用一些单词来构建Trie树,如下图所示:</p>\n<p><img src=\"/./2024/06/02/%E7%BB%9F%E8%AE%A1%E5%85%A8%E5%9B%BD%E9%87%8D%E5%90%8D%E6%9C%80%E5%A4%9A%E7%9A%84%E5%89%8D100%E4%B8%AA/1.png\"></p>\n<p>从图片中可以看到一些有意思的特性:</p>\n<ul>\n<li><p>根节点没有数据</p>\n</li>\n<li><p>从根节点到某一个节点,将他们的路径进行连接就组成了对应的字符串</p>\n</li>\n</ul>\n<p>定义:</p>\n<blockquote>\n<p>Trie树，又称为前缀树或字典树, 是一种用于高效存储和检索字符串集合的数据结构, 每个节点代表一个字符, 边表示从一个字符到另一个字符的路径, Trie树通过共享相同前缀的节点来节省存储空间</p>\n</blockquote>\n<p>Trie树是一种有序树，用于保存关联数组，其中的键通常是字符串。</p>\n<p>与二叉查找树不同，Trie树 的 键不是直接保存在节点中，而是由节点在树中的位置决定。</p>\n<p>一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。</p>\n<p>一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>\n<p>trie中的键通常是字符串，但也可以是其它的结构。</p>\n<p>trie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。</p>\n<p>比如，bitwise trie中的键是一串位元，可以用于表示整数或者内存地址</p>\n<p><strong>Trie树基本性质</strong></p>\n<p>1，根节点不包含字符，除根节点意外每个节点只包含一个字符。</p>\n<p>2，从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。</p>\n<p>3，每个节点的所有子节点包含的字符串不相同。</p>\n<p><strong>Trie树优点</strong>：</p>\n<p>可以最大限度地减少无谓的字符串比较，故可以用于词频统计和大量字符串排序。</p>\n<p>跟哈希表比较：</p>\n<p>1，最坏情况时间复杂度比hash表好</p>\n<p>2，没有冲突，除非一个key对应多个值（除key外的其他信息）</p>\n<p>3，自带排序功能（类似Radix Sort），中序遍历trie可以得到排序。</p>\n<p><strong>Trie树缺点</strong>：</p>\n<p>当所有关键字都不具有相同或类似的前缀，空间消耗过大.</p>\n<h2 id=\"6-Trie树的基本操作\"><a href=\"#6-Trie树的基本操作\" class=\"headerlink\" title=\"6. Trie树的基本操作:\"></a>6. Trie树的基本操作:</h2><ul>\n<li><p>插入:将一个字符串逐字符插入到Trie树中</p>\n</li>\n<li><p>查找:检查Trie树中是否存在某个字符串</p>\n</li>\n<li><p>前缀匹配:查找所有以某个前缀开头的字符串</p>\n</li>\n<li><p>删除:从Trie树中删除一个字符串</p>\n</li>\n</ul>\n<h2 id=\"7-Trie树的应用场景\"><a href=\"#7-Trie树的应用场景\" class=\"headerlink\" title=\"7. Trie树的应用场景:\"></a>7. Trie树的应用场景:</h2><p>1.字符串检索:</p>\n<ul>\n<li><p>应用场景:快速检索字典中的单词</p>\n</li>\n<li><p>使用原因:Trie树通过逐字符匹配,可以在O(L)时间内完成字符串的检索,其中L是字符串的长度,比传统的线性搜索更加高效</p>\n</li>\n</ul>\n<p>2.自动补全:</p>\n<ul>\n<li><p>应用场景:搜索引擎和输入法中的自动补全功能</p>\n</li>\n<li><p>适用原因:Trie树可以通过前缀查找快速提供所有以给定前缀开头的单词,有效提升用户输入体验</p>\n</li>\n</ul>\n<p>3.前缀匹配:</p>\n<ul>\n<li><p>应用场景:寻找以特定前缀开头的所有字符串,如电话号码前缀匹配</p>\n</li>\n<li><p>适用原因:Trie树天生适合处理前缀匹配问题,可以在O(L)时间内找到所有以特定前缀开头的字符串</p>\n</li>\n</ul>\n<p>4.词频统计:</p>\n<ul>\n<li><p>应用场景:文本分析中统计单词出现频率</p>\n</li>\n<li><p>适用原因:Trie树可以在插入过程中记录每个单词的出现次数,通过遍历Trie树可以快速统计所有单词的频率</p>\n</li>\n</ul>\n<p>为什么适合这些场景:</p>\n<p>5.多模式匹配:</p>\n<ul>\n<li><p>应用场景:从文本中同时搜索多个模式(模式匹配算法)</p>\n</li>\n<li><p>适用原因:Trie树可以构建多个模式的结构,通过一次遍历文本同时匹配多个模式,提高匹配效率</p>\n</li>\n</ul>\n<p>为什么适用于这些场景:</p>\n<p>1.空间效率:</p>\n<ul>\n<li><p>共享前缀:Trie树通过共享前缀节点，减少了重复存储相同前缀的空间开销。</p>\n</li>\n<li><p>节省内存:对于大量前缀相同的字符串集合，Trie树显著节省内存使用。</p>\n</li>\n</ul>\n<p>2.时间效率:</p>\n<ul>\n<li><p>O(L)复杂度:插入、查找和前缀匹配操作的时间复杂度为O(L),其中L是字符串的长度,显著提高了操作效率</p>\n</li>\n<li><p>快速检索:相比于其他线性结构(如数组或链表),Trie树在处理大量字符串时更快</p>\n</li>\n</ul>\n<h2 id=\"8-Trie树的代码实现\"><a href=\"#8-Trie树的代码实现\" class=\"headerlink\" title=\"8. Trie树的代码实现:\"></a>8. Trie树的代码实现:</h2><p>以下是一个 参考代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.HashMap;  </span><br><span class=\"line\">import java.util.Map;  </span><br><span class=\"line\">import java.util.PriorityQueue;  </span><br><span class=\"line\">  </span><br><span class=\"line\">class TrieNode &#123;  </span><br><span class=\"line\">    Map&lt;Character, TrieNode&gt; children;  </span><br><span class=\"line\">    int count;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public TrieNode() &#123;  </span><br><span class=\"line\">        children = new HashMap&lt;&gt;();  </span><br><span class=\"line\">        count = 0;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">class Trie &#123;  </span><br><span class=\"line\">    private TrieNode root;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public Trie() &#123;  </span><br><span class=\"line\">        root = new TrieNode();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public void insert(String name) &#123;  </span><br><span class=\"line\">        TrieNode node = root;  </span><br><span class=\"line\">        for (char ch : name.toCharArray()) &#123;  </span><br><span class=\"line\">            node = node.children.computeIfAbsent(ch, k -&gt; new TrieNode());  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        node.count++;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public void getAllNames(TrieNode node, StringBuilder prefix, PriorityQueue&lt;NameCount&gt; minHeap, int k) &#123;  </span><br><span class=\"line\">        if (node == null) return;  </span><br><span class=\"line\">        if (node.count &gt; 0) &#123;  </span><br><span class=\"line\">            if (minHeap.size() &lt; k) &#123;  </span><br><span class=\"line\">                minHeap.offer(new NameCount(prefix.toString(), node.count));  </span><br><span class=\"line\">            &#125; else if (node.count &gt; minHeap.peek().count) &#123;  </span><br><span class=\"line\">                minHeap.poll();  </span><br><span class=\"line\">                minHeap.offer(new NameCount(prefix.toString(), node.count));  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        for (Map.Entry&lt;Character, TrieNode&gt; entry : node.children.entrySet()) &#123;  </span><br><span class=\"line\">            prefix.append(entry.getKey());  </span><br><span class=\"line\">            getAllNames(entry.getValue(), prefix, minHeap, k);  </span><br><span class=\"line\">            prefix.deleteCharAt(prefix.length() - 1);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public PriorityQueue&lt;NameCount&gt; getTopKNames(int k) &#123;  </span><br><span class=\"line\">        PriorityQueue&lt;NameCount&gt; minHeap = new PriorityQueue&lt;&gt;(k);  </span><br><span class=\"line\">        getAllNames(root, new StringBuilder(), minHeap, k);  </span><br><span class=\"line\">        return minHeap;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">class NameCount implements Comparable&lt;NameCount\\&gt; &#123;  </span><br><span class=\"line\">    String name;  </span><br><span class=\"line\">    int count;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public NameCount(String name, int count) &#123;  </span><br><span class=\"line\">        this.name = name;  </span><br><span class=\"line\">        this.count = count;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public int compareTo(NameCount other) &#123;  </span><br><span class=\"line\">        return Integer.compare(this.count, other.count);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public String toString() &#123;  </span><br><span class=\"line\">        return name + &quot;: &quot; + count;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">public class Main &#123;  </span><br><span class=\"line\">    public static void main(String\\[\\] args) &#123;  </span><br><span class=\"line\">        String\\[\\] names = &#123;&quot;张伟&quot;, &quot;王伟伟&quot;, &quot;王芳&quot;, &quot;李伟&quot;, &quot;李娜&quot;&#125;; // 示例数据  </span><br><span class=\"line\">        int k = 100; // 找到前100个重名人数最多的姓名  </span><br><span class=\"line\">  </span><br><span class=\"line\">        Trie trie = new Trie();  </span><br><span class=\"line\">        for (String name : names) &#123;  </span><br><span class=\"line\">            trie.insert(name);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        PriorityQueue&lt;NameCount&gt; topKNames = trie.getTopKNames(k);  </span><br><span class=\"line\">        while (!topKNames.isEmpty()) &#123;  </span><br><span class=\"line\">            System.out.println(topKNames.poll());  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-TOP-N问题发散\"><a href=\"#9-TOP-N问题发散\" class=\"headerlink\" title=\"9. TOP N问题发散:\"></a>9. TOP N问题发散:</h2><p>上面的问题进行改进一下, 如果我们对内存有一个限制,比如:要求内存的使用不能超过2G,</p>\n<p>注意，这里的内存受限，尽量使用磁盘处理。</p>\n<blockquote>\n<p>这里使用hashmap，而不适用 trie树的原因是？</p>\n<p>trie树是按照字符为粒度组织树的节点的，进行磁盘操作性能不高，而且进行磁盘操作时算法更加复杂。</p>\n<p>hashmap 是以key为单位操作的， 磁盘操作的效率高。而且 hashmap 统计的时候，代码简洁清晰。</p>\n</blockquote>\n<p>尽管我们hashmap，也不能直接将所有数据加载到内存中处理,</p>\n<p>所以可以采取分治的策略,使用外部排序和哈希映射的方法,</p>\n<p>以下是详细的步骤:</p>\n<p>1.分块读取数据:将14亿条记录分成多个较小的块,每次读取一部分数据到内存中进行处理</p>\n<p>2.哈希映射统计词频:对每个块的数据进行哈希映射,统计每个名字出现的次数,将结果写入到磁盘文件</p>\n<p>3.合并词频统计结果:读取所有中间文件,合并词频统计结果,得到全局的词频统计</p>\n<p>4.使用小顶堆找出前100个重复最多的名字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.\\*;  </span><br><span class=\"line\">import java.util.HashMap;  </span><br><span class=\"line\">import java.util.Map;  </span><br><span class=\"line\">import java.util.PriorityQueue;  </span><br><span class=\"line\">  </span><br><span class=\"line\">class NameCount implements Comparable&lt;NameCount\\&gt; &#123;  </span><br><span class=\"line\">    String name;  </span><br><span class=\"line\">    int count;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public NameCount(String name, int count) &#123;  </span><br><span class=\"line\">        this.name = name;  </span><br><span class=\"line\">        this.count = count;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public int compareTo(NameCount other) &#123;  </span><br><span class=\"line\">        return Integer.compare(this.count, other.count);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public String toString() &#123;  </span><br><span class=\"line\">        return name + &quot;: &quot; + count;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">public class ExternalMemoryTopK &#123;  </span><br><span class=\"line\">    private static final int CHUNK\\_SIZE = 1000000; // 每个块处理100万条记录  </span><br><span class=\"line\">  </span><br><span class=\"line\">    public static void main(String\\[\\] args) throws IOException &#123;  </span><br><span class=\"line\">        String inputFile = &quot;names.txt&quot;;  </span><br><span class=\"line\">        String outputFile = &quot;top100names.txt&quot;;  </span><br><span class=\"line\">        int k = 100;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 第一步：分块读取数据并统计词频  </span><br><span class=\"line\">        int chunkIndex = 0;  </span><br><span class=\"line\">        BufferedReader reader = new BufferedReader(new FileReader(inputFile));  </span><br><span class=\"line\">        String line;  </span><br><span class=\"line\">        while ((line = reader.readLine()) != null) &#123;  </span><br><span class=\"line\">            Map&lt;String, Integer&gt; frequencyMap = new HashMap&lt;&gt;();  </span><br><span class=\"line\">            int lineCount = 0;  </span><br><span class=\"line\">            while (line != null &amp;&amp; lineCount &lt; CHUNK\\_SIZE) &#123;  </span><br><span class=\"line\">                frequencyMap.put(line, frequencyMap.getOrDefault(line, 0) + 1);  </span><br><span class=\"line\">                line = reader.readLine();  </span><br><span class=\"line\">                lineCount++;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            writeFrequencyMapToFile(frequencyMap, &quot;chunk\\_&quot; + chunkIndex + &quot;.txt&quot;);  </span><br><span class=\"line\">            chunkIndex++;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        reader.close();  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 第二步：合并所有块的词频统计结果  </span><br><span class=\"line\">        Map&lt;String, Integer&gt; globalFrequencyMap = new HashMap&lt;&gt;();  </span><br><span class=\"line\">        for (int i = 0; i &lt; chunkIndex; i++) &#123;  </span><br><span class=\"line\">            mergeFrequencyMapFromFile(globalFrequencyMap, &quot;chunk\\_&quot; + i + &quot;.txt&quot;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 第三步：使用小顶堆找出前100个重复最多的名字  </span><br><span class=\"line\">        PriorityQueue&lt;NameCount&gt; minHeap = new PriorityQueue&lt;&gt;(k);  </span><br><span class=\"line\">        for (Map.Entry&lt;String, Integer&gt; entry : globalFrequencyMap.entrySet()) &#123;  </span><br><span class=\"line\">            if (minHeap.size() &lt; k) &#123;  </span><br><span class=\"line\">                minHeap.offer(new NameCount(entry.getKey(), entry.getValue()));  </span><br><span class=\"line\">            &#125; else if (entry.getValue() &gt; minHeap.peek().count) &#123;  </span><br><span class=\"line\">                minHeap.poll();  </span><br><span class=\"line\">                minHeap.offer(new NameCount(entry.getKey(), entry.getValue()));  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        // 输出结果  </span><br><span class=\"line\">        BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));  </span><br><span class=\"line\">        while (!minHeap.isEmpty()) &#123;  </span><br><span class=\"line\">            writer.write(minHeap.poll().toString());  </span><br><span class=\"line\">            writer.newLine();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        writer.close();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    private static void writeFrequencyMapToFile(Map&lt;String, Integer&gt; frequencyMap, String filename) throws IOException &#123;  </span><br><span class=\"line\">        BufferedWriter writer = new BufferedWriter(new FileWriter(filename));  </span><br><span class=\"line\">        for (Map.Entry&lt;String, Integer&gt; entry : frequencyMap.entrySet()) &#123;  </span><br><span class=\"line\">            writer.write(entry.getKey() + &quot; &quot; + entry.getValue());  </span><br><span class=\"line\">            writer.newLine();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        writer.close();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    private static void mergeFrequencyMapFromFile(Map&lt;String, Integer&gt; globalFrequencyMap, String filename) throws IOException &#123;  </span><br><span class=\"line\">        BufferedReader reader = new BufferedReader(new FileReader(filename));  </span><br><span class=\"line\">        String line;  </span><br><span class=\"line\">        while ((line = reader.readLine()) != null) &#123;  </span><br><span class=\"line\">            String\\[\\] parts = line.split(&quot; &quot;);  </span><br><span class=\"line\">            String name = parts\\[0\\];  </span><br><span class=\"line\">            int count = Integer.parseInt(parts\\[1\\]);  </span><br><span class=\"line\">            globalFrequencyMap.put(name, globalFrequencyMap.getOrDefault(name, 0) + count);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        reader.close();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-topK问题-典型的解题思路\"><a href=\"#10-topK问题-典型的解题思路\" class=\"headerlink\" title=\"10. topK问题,典型的解题思路\"></a>10. topK问题,典型的解题思路</h2><p>这是一种典型的topK问题,一般的问法如下：</p>\n<p>从一堆数据中选出多少个最大或最小数？</p>\n<p>解题思想：</p>\n<ol>\n<li><p>先统计数量, 使用前缀树，hashmap等</p>\n</li>\n<li><p>再用小顶堆或者 大顶堆</p>\n</li>\n</ol>\n<p>取大用小，取小用大。简单来说就是取最大的K个数就用小顶堆，取最小的K个数，就用大顶堆</p>\n<p>取海量数据里面最小的K个数？</p>\n<p>要找出数组中最小的K个数，就要构造一个有K个元素的大顶堆，因为大顶堆的堆顶值是最大的，其它元素和堆顶的元素比较，大于堆顶的元素，换一个元素继续，小于堆顶的元素，将堆顶元素出堆，将更小的元素插入堆顶，如此反复，堆里面就是最小的数</p>\n<p>取海量数据里面最大的K个数？</p>\n<p>要找出数组中最大的K个数，就要构造一个有K个元素的小顶堆，因为小顶堆的堆顶值是最小的，其它元素和堆顶的元素比较，大于堆顶的元素，堆顶的元素出堆，将元素插入到小顶堆，将更大的元素换到堆中，如此反复，堆里面就是最大的数</p>\n"}],"PostAsset":[{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\1.png","slug":"1.png","post":"clwxc4r9n0001b4uheged3dyu","modified":0,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\10.png","slug":"10.png","post":"clwxc4r9n0001b4uheged3dyu","modified":0,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\11.png","slug":"11.png","post":"clwxc4r9n0001b4uheged3dyu","modified":0,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\2.png","slug":"2.png","post":"clwxc4r9n0001b4uheged3dyu","modified":0,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\3.png","slug":"3.png","post":"clwxc4r9n0001b4uheged3dyu","modified":0,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\4.png","slug":"4.png","post":"clwxc4r9n0001b4uheged3dyu","modified":0,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\5.png","slug":"5.png","post":"clwxc4r9n0001b4uheged3dyu","modified":0,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\6.png","slug":"6.png","post":"clwxc4r9n0001b4uheged3dyu","modified":0,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\7.png","slug":"7.png","post":"clwxc4r9n0001b4uheged3dyu","modified":0,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\8.png","slug":"8.png","post":"clwxc4r9n0001b4uheged3dyu","modified":0,"renderable":0},{"_id":"source\\_posts\\Edge浏览器中使用免费的ChatGPT\\9.png","slug":"9.png","post":"clwxc4r9n0001b4uheged3dyu","modified":0,"renderable":0},{"_id":"source\\_posts\\Springmvc最热点面试题\\1.png","slug":"1.png","post":"clwxc4r9t0007b4uh4vrvcr3g","modified":0,"renderable":0},{"_id":"source\\_posts\\Springcloud最热点面试题\\1.png","slug":"1.png","post":"clwxc4r9t0008b4uh4hkbejn1","modified":0,"renderable":0},{"_id":"source\\_posts\\Springcloud最热点面试题\\2.png","slug":"2.png","post":"clwxc4r9t0008b4uh4hkbejn1","modified":0,"renderable":0},{"_id":"source\\_posts\\Springcloud最热点面试题\\3.png","slug":"3.png","post":"clwxc4r9t0008b4uh4hkbejn1","modified":0,"renderable":0},{"_id":"source\\_posts\\Springcloud最热点面试题\\4.png","slug":"4.png","post":"clwxc4r9t0008b4uh4hkbejn1","modified":0,"renderable":0},{"_id":"source\\_posts\\Springcloud最热点面试题\\5.png","slug":"5.png","post":"clwxc4r9t0008b4uh4hkbejn1","modified":0,"renderable":0},{"_id":"source\\_posts\\Springcloud最热点面试题\\6.png","slug":"6.png","post":"clwxc4r9t0008b4uh4hkbejn1","modified":0,"renderable":0},{"_id":"source\\_posts\\Springcloud最热点面试题\\7.png","slug":"7.png","post":"clwxc4r9t0008b4uh4hkbejn1","modified":0,"renderable":0},{"_id":"source\\_posts\\Springcloud最热点面试题\\8.png","slug":"8.png","post":"clwxc4r9t0008b4uh4hkbejn1","modified":0,"renderable":0},{"_id":"source\\_posts\\Springcloud最热点面试题\\9.png","slug":"9.png","post":"clwxc4r9t0008b4uh4hkbejn1","modified":0,"renderable":0},{"_id":"source\\_posts\\Spring最热点面试题\\1.png","slug":"1.png","post":"clwxc4r9u0009b4uh3q5fc1k2","modified":0,"renderable":0},{"_id":"source\\_posts\\写代码神器\\1.png","slug":"1.png","post":"clwxc4r9w000eb4uhhe7m2l6c","modified":0,"renderable":0},{"_id":"source\\_posts\\写代码神器\\2.png","slug":"2.png","post":"clwxc4r9w000eb4uhhe7m2l6c","modified":0,"renderable":0},{"_id":"source\\_posts\\写代码神器\\3.png","slug":"3.png","post":"clwxc4r9w000eb4uhhe7m2l6c","modified":0,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\1.png","slug":"1.png","post":"clwxc4r9y000ib4uh2hod2ysy","modified":0,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\10.png","slug":"10.png","post":"clwxc4r9y000ib4uh2hod2ysy","modified":0,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\11.png","slug":"11.png","post":"clwxc4r9y000ib4uh2hod2ysy","modified":0,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\12.png","slug":"12.png","post":"clwxc4r9y000ib4uh2hod2ysy","modified":0,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\2.png","slug":"2.png","post":"clwxc4r9y000ib4uh2hod2ysy","modified":0,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\3.png","slug":"3.png","post":"clwxc4r9y000ib4uh2hod2ysy","modified":0,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\4.png","slug":"4.png","post":"clwxc4r9y000ib4uh2hod2ysy","modified":0,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\5.png","slug":"5.png","post":"clwxc4r9y000ib4uh2hod2ysy","modified":0,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\6.png","slug":"6.png","post":"clwxc4r9y000ib4uh2hod2ysy","modified":0,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\7.png","slug":"7.png","post":"clwxc4r9y000ib4uh2hod2ysy","modified":0,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\8.png","slug":"8.png","post":"clwxc4r9y000ib4uh2hod2ysy","modified":0,"renderable":0},{"_id":"source\\_posts\\场景设计面试题\\9.png","slug":"9.png","post":"clwxc4r9y000ib4uh2hod2ysy","modified":0,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\1.png","slug":"1.png","post":"clwxc4ra30012b4uhc8l152if","modified":0,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\10.png","slug":"10.png","post":"clwxc4ra30012b4uhc8l152if","modified":0,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\11.png","slug":"11.png","post":"clwxc4ra30012b4uhc8l152if","modified":0,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\2.png","slug":"2.png","post":"clwxc4ra30012b4uhc8l152if","modified":0,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\3.png","slug":"3.png","post":"clwxc4ra30012b4uhc8l152if","modified":0,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\4.png","slug":"4.png","post":"clwxc4ra30012b4uhc8l152if","modified":0,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\5.png","slug":"5.png","post":"clwxc4ra30012b4uhc8l152if","modified":0,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\6.png","slug":"6.png","post":"clwxc4ra30012b4uhc8l152if","modified":0,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\7.png","slug":"7.png","post":"clwxc4ra30012b4uhc8l152if","modified":0,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\8.png","slug":"8.png","post":"clwxc4ra30012b4uhc8l152if","modified":0,"renderable":0},{"_id":"source\\_posts\\百亿流量红包系统\\9.png","slug":"9.png","post":"clwxc4ra30012b4uhc8l152if","modified":0,"renderable":0},{"_id":"source\\_posts\\统计全国重名最多的前100个\\1.png","slug":"1.png","post":"clwxc4ra30013b4uh8luafqeq","modified":0,"renderable":0}],"PostCategory":[{"post_id":"clwxc4r9n0001b4uheged3dyu","category_id":"clwxc4r9r0004b4uhco12cdyi","_id":"clwxc4r9w000fb4uh6uxm4yg5"},{"post_id":"clwxc4r9q0003b4uhdfude5p9","category_id":"clwxc4r9u000ab4uhgdi136p6","_id":"clwxc4r9z000lb4uhf9460x1q"},{"post_id":"clwxc4r9y000ib4uh2hod2ysy","category_id":"clwxc4r9u000ab4uhgdi136p6","_id":"clwxc4ra0000ob4uh6mcn0vec"},{"post_id":"clwxc4r9t0007b4uh4vrvcr3g","category_id":"clwxc4r9u000ab4uhgdi136p6","_id":"clwxc4ra0000rb4uh3djg9y8k"},{"post_id":"clwxc4r9t0008b4uh4hkbejn1","category_id":"clwxc4r9u000ab4uhgdi136p6","_id":"clwxc4ra0000ub4uhhlbqgzj3"},{"post_id":"clwxc4r9u0009b4uh3q5fc1k2","category_id":"clwxc4r9u000ab4uhgdi136p6","_id":"clwxc4ra1000xb4uhhpfp2ri0"},{"post_id":"clwxc4r9w000eb4uhhe7m2l6c","category_id":"clwxc4ra0000tb4uhbt6f3v5d","_id":"clwxc4ra10010b4uh0f8dbvp8"},{"post_id":"clwxc4ra30012b4uhc8l152if","category_id":"clwxc4r9u000ab4uhgdi136p6","_id":"clwxc4ra40015b4uha1nfgvrl"},{"post_id":"clwxc4ra30013b4uh8luafqeq","category_id":"clwxc4r9u000ab4uhgdi136p6","_id":"clwxc4ra40016b4uh3li35m66"}],"PostTag":[{"post_id":"clwxc4r9n0001b4uheged3dyu","tag_id":"clwxc4r9s0005b4uh6xtx79he","_id":"clwxc4r9v000cb4uhfvy041ts"},{"post_id":"clwxc4r9q0003b4uhdfude5p9","tag_id":"clwxc4r9u000bb4uhcny93e8j","_id":"clwxc4r9z000jb4uh1sh78yjb"},{"post_id":"clwxc4r9t0007b4uh4vrvcr3g","tag_id":"clwxc4r9w000hb4uh9v3v9sxm","_id":"clwxc4ra0000nb4uhgqct3d0f"},{"post_id":"clwxc4r9t0008b4uh4hkbejn1","tag_id":"clwxc4r9z000mb4uh8vk4cxay","_id":"clwxc4ra0000sb4uheycmfs5c"},{"post_id":"clwxc4r9u0009b4uh3q5fc1k2","tag_id":"clwxc4ra0000qb4uhczqg0kyh","_id":"clwxc4ra1000wb4uh8d5mhrl5"},{"post_id":"clwxc4r9w000eb4uhhe7m2l6c","tag_id":"clwxc4ra0000vb4uh252xgn88","_id":"clwxc4ra1000zb4uh8bxg5u3x"},{"post_id":"clwxc4r9y000ib4uh2hod2ysy","tag_id":"clwxc4ra1000yb4uhby968jwn","_id":"clwxc4ra10011b4uh04zr5qwx"},{"post_id":"clwxc4ra30012b4uhc8l152if","tag_id":"clwxc4ra40014b4uhgxyf6erx","_id":"clwxc4ra50018b4uh3stw7e0n"},{"post_id":"clwxc4ra30013b4uh8luafqeq","tag_id":"clwxc4ra40017b4uh2xlgcm80","_id":"clwxc4ra50019b4uhczb0dp7a"}],"Tag":[{"name":"ChatGpt","_id":"clwxc4r9s0005b4uh6xtx79he"},{"name":"springboot","_id":"clwxc4r9u000bb4uhcny93e8j"},{"name":"springmvc","_id":"clwxc4r9w000hb4uh9v3v9sxm"},{"name":"springcloud","_id":"clwxc4r9z000mb4uh8vk4cxay"},{"name":"spring","_id":"clwxc4ra0000qb4uhczqg0kyh"},{"name":"开发神器","_id":"clwxc4ra0000vb4uh252xgn88"},{"name":"场景设计","_id":"clwxc4ra1000yb4uhby968jwn"},{"name":"架构","_id":"clwxc4ra40014b4uhgxyf6erx"},{"name":"算法题","_id":"clwxc4ra40017b4uh2xlgcm80"}]}}